
// INLINED /Users/robin/Development/lively-next/lively.lang/dist/lively.lang.js

(function() {
  var GLOBAL = typeof window !== "undefined" ? window :
      typeof global!=="undefined" ? global :
        typeof self!=="undefined" ? self : this;
  if (typeof GLOBAL.lively === "undefined") GLOBAL.lively = {};
  (function() {
    this.lively = this.lively || {};
(function (exports) {
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var get$1 = function get$1(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get$1(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

















var set$1 = function set$1(object, property, value, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent !== null) {
      set$1(parent, property, value, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    desc.value = value;
  } else {
    var setter = desc.set;

    if (setter !== undefined) {
      setter.call(receiver, value);
    }
  }

  return value;
};

// A `Closure` is a representation of a JavaScript function that controls what
// values are bound to out-of-scope variables. By default JavaScript has no
// reflection capabilities over closed values in functions. When needing to
// serialize execution or when behavior should become part of the state of a
// system it is often necessary to have first-class control over this language
// aspect.
//
// Typically closures aren't created directly but with the help of [`asScriptOf`](#)
//
// Example:
// function func(a) { return a + b; }
// var closureFunc = Closure.fromFunction(func, {b: 3}).recreateFunc();
// closureFunc(4) // => 7
// var closure = closureFunc.livelyClosure // => {
// //   varMapping: { b: 3 },
// //   originalFunc: function func(a) {/*...*/}
// // }
// closure.lookup("b") // => 3
// closure.getFuncSource() // => "function func(a) { return a + b; }"

var parameterRegex = /function[^\(]*\(([^\)]*)\)|\(?([^\)=]*)\)?\s*=>/;

var Closure = function () {
  createClass(Closure, null, [{
    key: "fromFunction",
    value: function fromFunction(func, varMapping) {
      /*show-in-doc*/
      return new this(func, varMapping || {});
    }
  }, {
    key: "fromSource",
    value: function fromSource(source, varMapping) {
      /*show-in-doc*/
      return new this(null, varMapping || {}, source);
    }
  }]);

  function Closure(func, varMapping, source, funcProperties) {
    classCallCheck(this, Closure);

    this.originalFunc = func;
    this.varMapping = varMapping || {};
    this.setFuncSource(source || func);
    this.setFuncProperties(func || funcProperties);
  }

  createClass(Closure, [{
    key: "setFuncSource",


    // accessing
    value: function setFuncSource(src) {
      /*show-in-doc*/
      src = typeof lively !== "undefined" && lively.sourceTransform && typeof lively.sourceTransform.stringifyFunctionWithoutToplevelRecorder === "function" ? lively.sourceTransform.stringifyFunctionWithoutToplevelRecorder(src) : String(src);
      return this.source = src;
    }
  }, {
    key: "getFuncSource",
    value: function getFuncSource() {
      /*show-in-doc*/
      return this.source || this.setFuncSource(this.originalFunc);
    }
  }, {
    key: "hasFuncSource",
    value: function hasFuncSource() {
      /*show-in-doc*/
      return this.source && true;
    }
  }, {
    key: "getFunc",
    value: function getFunc() {
      /*show-in-doc*/
      return this.originalFunc || this.recreateFunc();
    }
  }, {
    key: "getFuncProperties",
    value: function getFuncProperties() {
      // ignore-in-doc
      // a function may have state attached
      return this.funcProperties || (this.funcProperties = {});
    }
  }, {
    key: "setFuncProperties",
    value: function setFuncProperties(obj) {
      // ignore-in-doc
      var props = this.getFuncProperties();
      for (var name in obj) {
        // The AST implementation assumes that Function objects are some
        // kind of value object. When their identity changes cached state
        // should not be carried over to new function instances. This is a
        // pretty intransparent way to invalidate attributes that are used
        // for caches.
        // @cschuster, can you please fix this by making invalidation more
        // explicit?
        if (obj.hasOwnProperty(name)) props[name] = obj[name];
      }
    }
  }, {
    key: "lookup",
    value: function lookup(name) {
      /*show-in-doc*/
      return this.varMapping[name];
    }
  }, {
    key: "parameterNames",
    value: function parameterNames(methodString) {
      // ignore-in-doc

      if (typeof lively !== "undefined" && lively.ast) {
        return (lively.ast.parseFunction(methodString).params || []).map(function (ea) {
          if (ea.type === "Identifier") return ea.name;
          if (ea.left && ea.left.type === "Identifier") return ea.left.name;
          return null;
        }).filter(Boolean);
      }

      var paramsMatch = parameterRegex.exec(methodString);
      if (!paramsMatch) return [];
      var paramsString = paramsMatch[1] || paramsMatch[2] || "";
      return paramsString.split(",").map(function (ea) {
        return ea.trim();
      });
    }
  }, {
    key: "firstParameter",
    value: function firstParameter(src) {
      // ignore-in-doc
      return this.parameterNames(src)[0] || null;
    }

    // -=-=-=-=-=-=-=-=-=-
    // function creation
    // -=-=-=-=-=-=-=-=-=-

  }, {
    key: "recreateFunc",
    value: function recreateFunc() {
      // Creates a real function object
      return this.recreateFuncFromSource(this.getFuncSource(), this.originalFunc);
    }
  }, {
    key: "recreateFuncFromSource",
    value: function recreateFuncFromSource(funcSource, optFunc) {
      // ignore-in-doc
      // what about objects that are copied by value, e.g. numbers?
      // when those are modified after the originalFunc we captured
      // varMapping then we will have divergent state
      var closureVars = [],
          thisFound = false,
          specificSuperHandling = this.firstParameter(funcSource) === '$super';
      for (var name in this.varMapping) {
        if (!this.varMapping.hasOwnProperty(name)) continue;
        if (name == 'this') {
          thisFound = true;continue;
        }
        // closureVars.push(`var ${name} = this.varMapping.${name};\n`);
        closureVars.push("var " + name + " = this.varMapping." + name + ";\n");
      }

      var src = "";
      if (closureVars.length > 0) src += closureVars.join("\n");
      if (specificSuperHandling) src += '(function superWrapperForClosure() { return ';
      src += "(" + funcSource + ")";
      if (specificSuperHandling) src += '.apply(this, [$super.bind(this)]' + '.concat(Array.from(arguments))) })';
      try {
        var func = evalJS.call(this, src) || this.couldNotCreateFunc(src);
        this.addFuncProperties(func);
        this.originalFunc = func;
        return func;
      } catch (e) {
        // var msg = `Cannot create function ${e} src: ${src}`;
        var msg = "Cannot create function " + e + " src: " + src;
        console.error(msg);
        throw new Error(msg);
      }
    }
  }, {
    key: "addFuncProperties",
    value: function addFuncProperties(func) {
      // ignore-in-doc
      var props = this.getFuncProperties();
      for (var name in props) {
        if (props.hasOwnProperty(name)) func[name] = props[name];
      }this.addClosureInformation(func);
    }
  }, {
    key: "couldNotCreateFunc",
    value: function couldNotCreateFunc(src) {
      // ignore-in-doc
      var msg = 'Could not recreate closure from source: \n' + src;
      console.error(msg);
      return function () {
        throw new Error(msg);
      };
    }

    // -=-=-=-=-=-
    // conversion
    // -=-=-=-=-=-

  }, {
    key: "asFunction",
    value: function asFunction() {
      /*ignore-in-doc*/
      return this.recreateFunc();
    }

    // -=-=-=-=-=-=-=-=-=-=-=-
    // function modification
    // -=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "addClosureInformation",
    value: function addClosureInformation(f) {
      /*ignore-in-doc-in-doc*/
      f.hasLivelyClosure = true;
      f.livelyClosure = this;
      return f;
    }
  }, {
    key: "isLivelyClosure",
    get: function get() {
      return true;
    }

    // serialization

  }, {
    key: "doNotSerialize",
    get: function get() {
      return ['originalFunc'];
    }
  }]);
  return Closure;
}();

/*global clearTimeout, setTimeout*/

/*
 * Abstractions around first class functions like augmenting and inspecting
 * functions as well as to control function calls like dealing with asynchronous
 * control flows.
 */

// -=-=-=-=-=-=-=-=-
// static functions
// -=-=-=-=-=-=-=-=-

function Empty() {
  /*`function() {}`*/return function () {};
}
function K() {
  /*`function(arg) { return arg; }`*/return function (arg) {
    return arg;
  };
}
function Null() {
  /*`function() { return null; }`*/return function () {
    return null;
  };
}
function False() {
  /*`function() { return false; }`*/return function () {
    return false;
  };
}
function True() {
  /*`function() { return true; }`*/return function () {
    return true;
  };
}
function notYetImplemented() {
  return function () {
    throw new Error('Not yet implemented');
  };
}

// -=-=-=-=-=-
// accessing
// -=-=-=-=-=-
function all(object) {
  // Returns all property names of `object` that reference a function.
  // Example:
  // var obj = {foo: 23, bar: function() { return 42; }};
  // all(obj) // => ["bar"]
  var a = [];
  for (var name in object) {
    if (!object.__lookupGetter__(name) && typeof object[name] === 'function') a.push(name);
  }
  return a;
}

function own(object) {
  // Returns all local (non-prototype) property names of `object` that
  // reference a function.
  // Example:
  // var obj1 = {foo: 23, bar: function() { return 42; }};
  // var obj2 = {baz: function() { return 43; }};
  // obj2.__proto__ = obj1
  // own(obj2) // => ["baz"]
  // /*vs.*/ all(obj2) // => ["baz","bar"]
  var a = [];
  for (var name in object) {
    if (!object.__lookupGetter__(name) && object.hasOwnProperty(name) && typeof object[name] === 'function') a.push(name);
  }
  return a;
}

// -=-=-=-=-=-
// inspection
// -=-=-=-=-=-

function argumentNames(f) {
  // Example:
  // argumentNames(function(arg1, arg2) {}) // => ["arg1","arg2"]
  // argumentNames(function(/*var args*/) {}) // => []
  if (f.superclass) return []; // it's a class...
  var src = f.toString(),
      names = "",
      arrowMatch = src.match(/(?:\(([^\)]*)\)|([^\(\)-+!]+))\s*=>/);
  if (arrowMatch) names = arrowMatch[1] || arrowMatch[2] || "";else {
    var headerMatch = src.match(/^[\s\(]*function[^(]*\(([^)]*)\)/);
    if (headerMatch && headerMatch[1]) names = headerMatch[1];
  }
  return names.replace(/\/\/.*?[\r\n]|\/\*(?:.|[\r\n])*?\*\//g, '').replace(/\s+/g, '').split(',').map(function (ea) {
    return ea.trim();
  }).filter(function (name) {
    return !!name;
  });
}

function qualifiedMethodName(f) {
  // ignore-in-doc
  var objString = "";
  if (f.declaredClass) {
    objString += f.declaredClass + '>>';
  } else if (f.declaredObject) {
    objString += f.declaredObject + '.';
  }
  return objString + (f.methodName || f.displayName || f.name || "anonymous");
}

function extractBody(func) {

  // superflous indent. Useful when you have to stringify code but not want
  // to construct strings by hand.
  // Example:
  // extractBody(function(arg) {
  //   var x = 34;
  //   alert(2 + arg);
  // }) => "var x = 34;\nalert(2 + arg);"
  var codeString = String(func).replace(/^function[^\{]+\{\s*/, '').replace(/\}$/, '').trim(),
      lines = codeString.split(/\n|\r/),
      indent = undefined;
  for (var i = 0; i < lines.length; i++) {
    var m = lines[i].match(/^(\s+)[^\s]/);
    if (m && (indent === undefined || m[1].length < indent.length)) indent = m[1];
  }
  return indent ? codeString.replace(new RegExp("^" + indent, 'gm'), '') : codeString;
}

// -=-=-=-
// timing
// -=-=-=-

function timeToRun(func) {
  // returns synchronous runtime of calling `func` in ms
  // Example:
  // timeToRun(function() { new WebResource("http://google.de").beSync().get() });
  // // => 278 (or something else...)
  var startTime = Date.now();
  func();
  return Date.now() - startTime;
}

function timeToRunN$1(func, n) {
  // Like `timeToRun` but calls function `n` times instead of once. Returns
  // the average runtime of a call in ms.
  var startTime = Date.now();
  for (var i = 0; i < n; i++) {
    func();
  }return (Date.now() - startTime) / n;
}

function delay(func, timeout /*, arg1...argN*/) {
  // Delays calling `func` for `timeout` seconds(!).
  // Example:
  // (function() { alert("Run in the future!"); }).delay(1);
  var args = Array.prototype.slice.call(arguments),
      __method = args.shift(),
      timeout = args.shift() * 1000;
  return setTimeout(function delayed() {
    return __method.apply(__method, args);
  }, timeout);
}

// these last two methods are Underscore.js 1.3.3 and are slightly adapted
// Underscore.js license:
// (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.
// Underscore is distributed under the MIT license.

function throttle(func, wait) {
  // Exec func at most once every wait ms even when called more often
  // useful to calm down eagerly running updaters and such.
  // Example:
  // var i = 0;
  // var throttled = throttle(function() { alert(++i + '-' + Date.now()) }, 500);
  // Array.range(0,100).forEach(function(n) { throttled() });
  var context,
      args,
      timeout,
      throttling,
      more,
      result,
      whenDone = debounce(wait, function () {
    more = throttling = false;
  });
  return function () {
    context = this;args = arguments;
    var later = function later() {
      timeout = null;
      if (more) func.apply(context, args);
      whenDone();
    };
    if (!timeout) timeout = setTimeout(later, wait);
    if (throttling) {
      more = true;
    } else {
      result = func.apply(context, args);
    }
    whenDone();
    throttling = true;
    return result;
  };
}

function debounce(wait, func, immediate) {
  // Call `func` after `wait` milliseconds elapsed since the last invocation.
  // Unlike `throttle` an invocation will restart the wait period. This is
  // useful if you have a stream of events that you want to wait for to finish
  // and run a subsequent function afterwards. When you pass arguments to the
  // debounced functions then the arguments from the last call will be use for
  // the invocation.
  //
  // With `immediate` set to true, immediately call `func` but when called again during `wait` before
  // wait ms are done nothing happens. E.g. to not exec a user invoked
  // action twice accidentally.
  // Example:
  // var start = Date.now();
  // var f = debounce(200, function(arg1) {
  //   alert("running after " + (Date.now()-start) + "ms with arg " + arg1);
  // });
  // f("call1");
  // delay(f.curry("call2"), 0.1);
  // delay(f.curry("call3"), 0.15);
  // // => Will eventually output: "running after 352ms with arg call3"
  var timeout;
  return function () {
    var context = this,
        args = arguments;
    var later = function later() {
      timeout = null;
      if (!immediate) func.apply(context, args);
    };
    if (immediate && !timeout) func.apply(context, args);
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

var _throttledByName = {};
function throttleNamed(name, wait, func) {
  // Like `throttle` but remembers the throttled function once created and
  // repeated calls to `throttleNamed` with the identical name will use the same
  // throttled function. This allows to throttle functions in a central place
  // that might be called various times in different contexts without having to
  // manually store the throttled function.
  var store = _throttledByName;
  if (store[name]) return store[name];
  function throttleNamedWrapper() {
    // ignore-in-doc, cleaning up
    debounceNamed(name, wait, function () {
      delete store[name];
    })();
    func.apply(this, arguments);
  }
  return store[name] = throttle(throttleNamedWrapper, wait);
}

var _debouncedByName = {};
function debounceNamed(name, wait, func, immediate) {
  // Like `debounce` but remembers the debounced function once created and
  // repeated calls to `debounceNamed` with the identical name will use the same
  // debounced function. This allows to debounce functions in a central place
  // that might be called various times in different contexts without having to
  // manually store the debounced function.
  var store = _debouncedByName;
  if (store[name]) return store[name];
  function debounceNamedWrapper() {
    // ignore-in-doc, cleaning up
    delete store[name];
    func.apply(this, arguments);
  }
  return store[name] = debounce(wait, debounceNamedWrapper, immediate);
}

var _queues = {};
function createQueue(id, workerFunc) {
  // A simple queue with an attached asynchronous `workerFunc` to process
  // queued tasks. Calling `createQueue` will return an object with the
  // following interface:
  // ```js
  // {
  //   push: function(task) {/**/},
  //   pushAll: function(tasks) {/**/},
  //   handleError: function(err) {}, // Overwrite to handle errors
  //   dran: function() {}, // Overwrite to react when the queue empties
  // }
  // Example:
  // var sum = 0;
  // var q = createQueue("example-queue", function(arg, thenDo) { sum += arg; thenDo(); });
  // q.pushAll([1,2,3]);
  // queues will be remembered by their name
  // createQueue("example-queue").push(4);
  // sum // => 6

  var store = _queues;

  var queue = store[id] || (store[id] = {
    _workerActive: false,
    worker: workerFunc, tasks: [],
    drain: null, // can be overwritten by a function
    push: function push(task) {
      queue.tasks.push(task);
      queue.activateWorker();
    },
    pushAll: function pushAll(tasks) {
      tasks.forEach(function (ea) {
        queue.tasks.push(ea);
      });
      queue.activateWorker();
    },
    pushNoActivate: function pushNoActivate(task) {
      queue.tasks.push(task);
    },
    handleError: function handleError(err) {
      // can be overwritten
      err && console.error('Error in queue: ' + err);
    },
    activateWorker: function activateWorker() {
      function callback(err) {
        queue.handleError(err);queue.activateWorker();
      }
      var tasks = queue.tasks,
          active = queue._workerActive;
      if (tasks.length === 0) {
        if (active) {
          queue._workerActive = false;
          if (typeof queue.drain === 'function') queue.drain();
        }
        delete store[id];
      } else {
        if (!active) queue._workerActive = true;
        try {
          queue.worker(tasks.shift(), callback);
        } catch (err) {
          callback(err);
        }
      }
    }
  });

  return queue;
}

var _queueUntilCallbacks = {};
function workerWithCallbackQueue(id, workerFunc, optTimeout) {
  // This functions helps when you have a long running computation that
  // multiple call sites (independent from each other) depend on. This
  // function does the housekeeping to start the long running computation
  // just once and returns an object that allows to schedule callbacks
  // once the workerFunc is done.
  // Example:
  // var worker = workerWithCallbackQueue("example",
  //   function slowFunction(thenDo) {
  //     var theAnswer = 42;
  //     setTimeout(function() { thenDo(null, theAnswer); });
  //   });
  // // all "call sites" depend on `slowFunction` but don't have to know about
  // // each other
  // worker.whenDone(function callsite1(err, theAnswer) { alert("callback1: " + theAnswer); })
  // worker.whenDone(function callsite2(err, theAnswer) { alert("callback2: " + theAnswer); })
  // workerWithCallbackQueue("example").whenDone(function callsite3(err, theAnswer) { alert("callback3: " + theAnswer); })
  // // => Will eventually show: callback1: 42, callback2: 42 and callback3: 42


  // ignore-in-doc
  // This is how it works:
  // If `id` does not exist, workerFunc is called, otherwise ignored.
  // workerFunc is expected to call thenDoFunc with arguments: error, arg1, ..., argN
  // if called subsequently before workerFunc is done, the other thenDoFunc
  // will "pile up" and called with the same arguments as the first
  // thenDoFunc once workerFunc is done
  var store = _queueUntilCallbacks,
      queueCallbacks = store[id],
      isRunning = !!queueCallbacks;

  if (isRunning) return queueCallbacks;

  var callbacksRun = false,
      canceled = false;

  function cleanup() {
    if (timeoutProc) clearTimeout(timeoutProc);
    callbacksRun = true;
    delete store[id];
  }

  function runCallbacks(args) {
    if (callbacksRun) return;
    cleanup();
    queueCallbacks.callbacks.forEach(function (cb) {
      try {
        cb.apply(null, args);
      } catch (e) {
        console.error("Error when invoking callbacks in queueUntil [" + id + "]:\n" + String(e.stack || e));
      }
    });
  }

  // timeout
  if (optTimeout) {
    var timeoutProc = setTimeout(function () {
      if (callbacksRun) return;
      runCallbacks([new Error("timeout")]);
    }, optTimeout);
  }

  // init the store
  queueCallbacks = store[id] = {
    callbacks: [],
    cancel: function cancel() {
      canceled = true;
      cleanup();
    },
    whenDone: function whenDone(cb) {
      queueCallbacks.callbacks.push(cb);
      return queueCallbacks;
    }
  };

  // call worker, but delay so we can immediately return
  setTimeout(function () {
    if (canceled) return;
    try {
      workerFunc(function () /*args*/{
        runCallbacks(arguments);
      });
    } catch (e) {
      runCallbacks([e]);
    }
  }, 0);

  return queueCallbacks;
}

function _composeAsyncDefaultEndCallback(err, arg1 /*err + args*/) {
  if (err) console.error("lively.lang.composeAsync error", err);
}

function composeAsync() /*functions*/{
  // Composes functions that are asynchronous and expecting continuations to
  // be called in node.js callback style (error is first argument, real
  // arguments follow).
  // A call like `composeAsync(f,g,h)(arg1, arg2)` has a flow of control like:
  //  `f(arg1, arg2, thenDo1)` -> `thenDo1(err, fResult)`
  // -> `g(fResult, thenDo2)` -> `thenDo2(err, gResult)` ->
  // -> `h(fResult, thenDo3)` -> `thenDo2(err, hResult)`
  // Example:
  // composeAsync(
  //   function(a,b, thenDo) { thenDo(null, a+b); },
  //   function(x, thenDo) { thenDo(x*4); }
  //  )(3,2, function(err, result) { alert(result); });

  var toArray$$1 = Array.prototype.slice,
      functions = toArray$$1.call(arguments),
      defaultEndCb = _composeAsyncDefaultEndCallback,
      endCallback = defaultEndCb,
      endSuccess,
      endFailure,
      endPromise = new Promise(function (resolve, reject) {
    endSuccess = resolve;endFailure = reject;
  });

  return functions.reverse().reduce(function (prevFunc, funcOrPromise, i) {

    var nextActivated = false;
    return function () {
      var args = toArray$$1.call(arguments);

      // ignore-in-doc
      // the last arg needs to be function, discard all non-args
      // following it. This allows to have an optional callback func that can
      // even be `undefined`, e.g. when calling this func from a callsite
      // using var args;
      if (endCallback === defaultEndCb && i === functions.length - 1 /*first function*/) {
          while (args.length && typeof args[args.length - 1] !== 'function') {
            args.pop();
          }if (typeof args[args.length - 1] === 'function') endCallback = args.pop();
        }

      function next() /*err and args*/{
        nextActivated = true;
        var args = toArray$$1.call(arguments),
            err = args.shift();
        if (err) {
          endCallback(err);endFailure(err);
        } else prevFunc.apply(null, args);
      }

      if (typeof funcOrPromise === "function") {
        try {
          var result = funcOrPromise.apply(this, args.concat([next]));
          if (result && typeof result.then === "function" && typeof result.catch === "function") {
            result.then(function (value) {
              return next(null, value);
            }).catch(function (err) {
              return next(err);
            });
          }
        } catch (e) {
          console.error('composeAsync: ', e.stack || e);
          if (!nextActivated) {
            endCallback(e);endFailure(e);
          }
        }
      } else if (funcOrPromise && typeof funcOrPromise.then === "function" && typeof funcOrPromise.catch === "function") {
        funcOrPromise.then(function (value) {
          next(null, value);
        }).catch(function (err) {
          next(err);
        });
      } else {
        var err = new Error("Invalid argument to composeAsync: " + funcOrPromise);
        endCallback(err);
        endFailure(err);
      }

      return endPromise;
    };
  }, function () {
    var args = toArray$$1.call(arguments);
    endCallback.apply(null, [null].concat(args));
    endSuccess(args[0]);
  });
}

function compose() /*functions*/{
  // Composes synchronousefunctions:
  // `compose(f,g,h)(arg1, arg2)` = `h(g(f(arg1, arg2)))`
  // Example:
  // compose(
  //   function(a,b) { return a+b; },
  //   function(x) {return x*4}
  // )(3,2) // => 20

  var functions = Array.prototype.slice.call(arguments);
  return functions.reverse().reduce(function (prevFunc, func) {
    return function () {
      return prevFunc(func.apply(this, arguments));
    };
  }, function (x) {
    return x;
  });
}

function flip(f) {
  // Swaps the first two args
  // Example:
  // flip(function(a, b, c) {
  //   return a + b + c; })(' World', 'Hello', '!') // => "Hello World!"
  return function flipped() /*args*/{
    var args = Array.prototype.slice.call(arguments),
        flippedArgs = [args[1], args[0]].concat(args.slice(2));
    return f.apply(null, flippedArgs);
  };
}

function withNull(func) {
  // returns a modified version of func that will have `null` always curried
  // as first arg. Usful e.g. to make a nodejs-style callback work with a
  // then-able:
  // Example:
  // promise.then(withNull(cb)).catch(cb);
  func = func || function () {};
  return function () /*args*/{
    var args = lively.lang.arr.from(arguments);
    func.apply(null, [null].concat(args));
  };
}

function waitFor(timeoutMs, waitTesterFunc, thenDo) {
  // Wait for waitTesterFunc to return true, then run thenDo, passing
  // failure/timout err as first parameter. A timout occurs after
  // timeoutMs. During the wait period waitTesterFunc might be called
  // multiple times.
  var start = Date.now();
  var timeStep = 50;
  if (!thenDo) {
    thenDo = waitTesterFunc;
    waitTesterFunc = timeoutMs;
    timeoutMs = undefined;
  }
  (function test() {
    if (waitTesterFunc()) return thenDo();
    if (timeoutMs) {
      var duration = Date.now() - start,
          timeLeft = timeoutMs - duration;
      if (timeLeft <= 0) return thenDo(new Error('timeout'));
      if (timeLeft < timeStep) timeStep = timeLeft;
    }
    setTimeout(test, timeStep);
  })();
}

function waitForAll(options, funcs, thenDo) {
  // Wait for multiple asynchronous functions. Once all have called the
  // continuation, call `thenDo`.
  // options can be: `{timeout: NUMBER}` (how long to wait in milliseconds).

  if (!thenDo) {
    thenDo = funcs;funcs = options;options = null;
  }
  options = options || {};

  var results = funcs.map(function () {
    return null;
  });
  if (!funcs.length) {
    thenDo(null, results);return;
  }

  var leftFuncs = Array.prototype.slice.call(funcs);

  funcs.forEach(function (f, i) {
    try {
      f(function () /*err and args*/{
        var args = Array.prototype.slice.call(arguments);
        var err = args.shift();
        markAsDone(f, i, err, args);
      });
    } catch (e) {
      markAsDone(f, i, e, null);
    }
  });

  if (options.timeout) {
    setTimeout(function () {
      if (!leftFuncs.length) return;
      var missing = results.map(function (ea, i) {
        return ea === null && i;
      }).filter(function (ea) {
        return typeof ea === 'number';
      }).join(', ');
      var err = new Error("waitForAll timed out, functions at " + missing + " not done");
      markAsDone(null, null, err, null);
    }, options.timeout);
  }

  function markAsDone(f, i, err, result) {
    if (!leftFuncs.length) return;

    var waitForAllErr = null;
    var fidx = leftFuncs.indexOf(f);
    fidx > -1 && leftFuncs.splice(fidx, 1);
    if (err) {
      leftFuncs.length = 0;
      waitForAllErr = new Error("in waitForAll at" + (typeof i === 'number' ? " " + i : "") + ": \n" + (err.stack || String(err)));
    } else if (result) results[i] = result;
    if (!leftFuncs.length) setTimeout(function () {
      thenDo(waitForAllErr, results);
    }, 0);
  }
}

// -=-=-=-=-
// wrapping
// -=-=-=-=-

function curry(func, arg1, arg2, argN /*func and curry args*/) {
  // Return a version of `func` with args applied.
  // Example:
  // var add1 = (function(a, b) { return a + b; }).curry(1);
  // add1(3) // => 4

  if (arguments.length <= 1) return arguments[0];
  var args = Array.prototype.slice.call(arguments),
      func = args.shift();
  function wrappedFunc() {
    return func.apply(this, args.concat(Array.prototype.slice.call(arguments)));
  }
  wrappedFunc.isWrapper = true;
  wrappedFunc.originalFunction = func;
  return wrappedFunc;
}

function wrap(func, wrapper) {
  // A `wrapper` is another function that is being called with the arguments
  // of `func` and a proceed function that, when called, runs the originally
  // wrapped function.
  // Example:
  // function original(a, b) { return a+b }
  // var wrapped = wrap(original, function logWrapper(proceed, a, b) {
  //   alert("original called with " + a + "and " + b);
  //   return proceed(a, b);
  // })
  // wrapped(3,4) // => 7 and a message will pop up
  var __method = func;
  var wrappedFunc = function wrapped() {
    var args = Array.prototype.slice.call(arguments);
    var wrapperArgs = wrapper.isWrapper ? args : [__method.bind(this)].concat(args);
    return wrapper.apply(this, wrapperArgs);
  };
  wrappedFunc.isWrapper = true;
  wrappedFunc.originalFunction = __method;
  return wrappedFunc;
}

function getOriginal(func) {
  // Get the original function that was augmented by `wrap`. `getOriginal`
  // will traversed as many wrappers as necessary.
  while (func.originalFunction) {
    func = func.originalFunction;
  }return func;
}

function wrapperChain(method) {
  // Function wrappers used for wrapping, cop, and other method
  // manipulations attach a property "originalFunction" to the wrapper. By
  // convention this property references the wrapped method like wrapper
  // -> cop wrapper -> real method.
  // tThis method gives access to the linked list starting with the outmost
  // wrapper.
  var result = [];
  do {
    result.push(method);
    method = method.originalFunction;
  } while (method);
  return result;
}

function replaceMethodForOneCall(obj, methodName, replacement) {
  // Change an objects method for a single invocation.
  // Example:
  // var obj = {foo: function() { return "foo"}};
  // lively.lang.replaceMethodForOneCall(obj, "foo", function() { return "bar"; });
  // obj.foo(); // => "bar"
  // obj.foo(); // => "foo"
  replacement.originalFunction = obj[methodName];
  var reinstall = obj.hasOwnProperty(methodName);
  obj[methodName] = function () {
    if (reinstall) obj[methodName] = replacement.originalFunction;else delete obj[methodName];
    return replacement.apply(this, arguments);
  };
  return obj;
}

function once(func) {
  // Ensure that `func` is only executed once. Multiple calls will not call
  // `func` again but will return the original result.
  if (!func) return undefined;
  if (typeof func !== 'function') throw new Error("once() expecting a function");
  var invoked = false,
      result;
  return function () {
    if (invoked) return result;
    invoked = true;
    return result = func.apply(this, arguments);
  };
}

function either() /*funcs*/{
  // Accepts multiple functions and returns an array of wrapped
  // functions. Those wrapped functions ensure that only one of the original
  // function is run (the first on to be invoked).
  //
  // This is useful if you have multiple asynchronous choices of how the
  // control flow might continue but want to ensure that a continuation
  // is  only triggered once, like in a timeout situation:
  //
  // ```js
  // function outerFunction(callback) {
  //   function timeoutAction() { callback(new Error('timeout!')); }
  //   function otherAction() { callback(null, "All OK"); }
  //   setTimeout(timeoutAction, 200);
  //   doSomethingAsync(otherAction);
  // }
  // ```
  //
  // To ensure that `callback` only runs once you would normally have to write boilerplate like this:
  //
  // ```js
  // var ran = false;
  // function timeoutAction() { if (ran) return; ran = true; callback(new Error('timeout!')); }
  // function otherAction() { if (ran) return; ran = true; callback(null, "All OK"); }
  // ```
  //
  // Since this can get tedious an error prone, especially if more than two choices are involved, `either` can be used like this:
  // Example:
  // function outerFunction(callback) {
  //   var actions = either(
  //     function() { callback(new Error('timeout!')); },
  //     function() { callback(null, "All OK"); });
  //   setTimeout(actions[0], 200);
  //   doSomethingAsync(actions[1]);
  // }
  var funcs = Array.prototype.slice.call(arguments),
      wasCalled = false;
  return funcs.map(function (func) {
    return function () {
      if (wasCalled) return undefined;
      wasCalled = true;
      return func.apply(this, arguments);
    };
  });
}

var _eitherNameRegistry = {};
function eitherNamed(name, func) {
  // Works like [`either`](#) but usage does not require to wrap all
  // functions at once:
  // Example:
  // var log = "", name = "either-example-" + Date.now();
  // function a() { log += "aRun"; };
  // function b() { log += "bRun"; };
  // function c() { log += "cRun"; };
  // setTimeout(eitherNamed(name, a), 100);
  // setTimeout(eitherNamed(name, b), 40);
  // setTimeout(eitherNamed(name, c), 80);
  // setTimeout(function() { alert(log); /* => "bRun" */ }, 150);
  var funcs = Array.prototype.slice.call(arguments);
  var registry = _eitherNameRegistry;
  var name = funcs.shift();
  var eitherCall = registry[name] || (registry[name] = { wasCalled: false, callsLeft: 0 });
  eitherCall.callsLeft++;
  return function () {
    eitherCall.callsLeft--;
    // cleanup the storage if all registered functions fired
    if (eitherCall.callsLeft <= 0) delete registry[name];
    if (eitherCall.wasCalled) return undefined;
    eitherCall.wasCalled = true;
    return func.apply(this, arguments);
  };
}

// -=-=-=-=-
// creation
// -=-=-=-=-
function evalJS(src) {
  return eval(src);
}

function fromString(funcOrString) {
  // Example:
  // fromString("function() { return 3; }")() // => 3
  return evalJS('(' + funcOrString.toString() + ');');
}

function asScript(func, optVarMapping) {
  // Lifts `func` to become a `Closure`, that is that free variables referenced
  // in `func` will be bound to the values of an object that can be passed in as
  // the second parameter. Keys of this object are mapped to the free variables.
  //
  // Please see [`Closure`](#) for a more detailed explanation and examples.
  return Closure.fromFunction(func, optVarMapping).recreateFunc();
}

function asScriptOf(f, obj, optName, optMapping) {
  // Like `asScript` but makes `f` a method of `obj` as `optName` or the name
  // of the function.
  var name = optName || f.name;
  if (!name) {
    throw Error("Function that wants to be a script needs a name: " + this);
  }
  var proto = Object.getPrototypeOf(obj),
      mapping = { "this": obj };
  if (optMapping) mapping = merge([mapping, optMapping]);
  if (proto && proto[name]) {
    var superFunc = function superFunc() {
      try {
        // FIXME super is supposed to be static
        return Object.getPrototypeOf(obj)[name].apply(obj, arguments);
      } catch (e) {
        if ((typeof $world === "undefined" ? "undefined" : _typeof($world)) !== undefined) $world.logError(e, 'Error in $super call');else console.error('Error in $super call: ' + e + '\n' + e.stack);
        return null;
      }
    };
    mapping["$super"] = Closure.fromFunction(superFunc, { obj: obj, name: name }).recreateFunc();
  }
  return addToObject(asScript(f, mapping), obj, name);
}

// -=-=-=-=-=-=-=-=-
// closure related
// -=-=-=-=-=-=-=-=-
function addToObject(f, obj, name) {
  // ignore-in-doc
  f.displayName = name;

  var methodConnections = obj.attributeConnections ? obj.attributeConnections.filter(function (con) {
    return con.getSourceAttrName() === 'update';
  }) : [];

  if (methodConnections) methodConnections.forEach(function (ea) {
    ea.disconnect();
  });

  obj[name] = f;

  if (typeof obj === "undefined" ? "undefined" : _typeof(obj)) f.declaredObject = safeToString(obj);

  // suppport for tracing
  if (typeof lively !== "undefined" && obj && lively.Tracing && lively.Tracing.stackTracingEnabled) {
    lively.Tracing.instrumentMethod(obj, name, {
      declaredObject: safeToString(obj)
    });
  }

  if (methodConnections) methodConnections.forEach(function (ea) {
    ea.connect();
  });

  return f;
}

function binds(f, varMapping) {
  // ignore-in-doc
  // convenience function
  return Closure.fromFunction(f, varMapping || {}).recreateFunc();
}

function setLocalVarValue(f, name, value) {
  // ignore-in-doc
  if (f.hasLivelyClosure) f.livelyClosure.funcProperties[name] = value;
}

function getVarMapping(f) {
  // ignore-in-doc
  if (f.hasLivelyClosure) return f.livelyClosure.varMapping;
  if (f.isWrapper) return f.originalFunction.varMapping;
  if (f.varMapping) return f.varMapping;
  return {};
}

function setProperty(func, name, value) {
  func[name] = value;
  if (func.hasLivelyClosure) func.livelyClosure.funcProperties[name] = value;
}

// -=-=-=-=-=-=-=-=-=-=-=-=-
// class-related functions
// -=-=-=-=-=-=-=-=-=-=-=-=-
function functionNames(klass) {
  // Treats passed function as class (constructor).
  // Example:
  // var Klass1 = function() {}
  // Klass1.prototype.foo = function(a, b) { return a + b; };
  // Klass1.prototype.bar = function(a) { return this.foo(a, 3); };
  // Klass1.prototype.baz = 23;
  // functionNames(Klass1); // => ["bar","foo"]

  var result = [],
      lookupObj = klass.prototype;
  while (lookupObj) {
    result = Object.keys(lookupObj).reduce(function (result, name) {
      if (typeof lookupObj[name] === 'function' && result.indexOf(name) === -1) result.push(name);
      return result;
    }, result);
    lookupObj = Object.getPrototypeOf(lookupObj);
  }
  return result;
}

function localFunctionNames(func) {
  return Object.keys(func.prototype).filter(function (name) {
    return typeof func.prototype[name] === 'function';
  });
}

// -=-=-=-=-=-=-=-=-=-=-
// tracing and logging
// -=-=-=-=-=-=-=-=-=-=-

function logErrors(func, prefix) {
  var advice = function logErrorsAdvice(proceed /*,args*/) {
    var args = Array.prototype.slice.call(arguments);
    args.shift();
    try {
      return proceed.apply(func, args);
    } catch (er) {
      if (typeof lively !== "undefined" && lively.morphic && lively.morphic.World && lively.morphic.World.current()) {
        lively.morphic.World.current().logError(er);
        throw er;
      }

      if (prefix) console.warn("ERROR: %s.%s(%s): err: %s %s", func, prefix, args, er, er.stack || "");else console.warn("ERROR: %s %s", er, er.stack || "");
      throw er;
    }
  };

  advice.methodName = "$logErrorsAdvice";
  var result = wrap(func, advice);
  result.originalFunction = func;
  result.methodName = "$logErrorsWrapper";
  return result;
}

function logCompletion(func, module) {
  var advice = function logCompletionAdvice(proceed) {
    var args = Array.prototype.slice.call(arguments);
    args.shift();
    try {
      var result = proceed.apply(func, args);
    } catch (er) {
      console.warn('failed to load ' + module + ': ' + er);
      if (typeof lively !== 'undefined' && lively.lang.Execution) lively.lang.Execution.showStack();
      throw er;
    }
    console.log('completed ' + module);
    return result;
  };

  advice.methodName = "$logCompletionAdvice::" + module;

  var result = wrap(func, advice);
  result.methodName = "$logCompletionWrapper::" + module;
  result.originalFunction = func;
  return result;
}

function logCalls(func, isUrgent) {
  var original = func,
      advice = function logCallsAdvice(proceed) {
    var args = Array.prototype.slice.call(arguments);
    args.shift(), result = proceed.apply(func, args);
    if (isUrgent) {
      console.warn('%s(%s) -> %s', qualifiedMethodName(original), args, result);
    } else {
      console.log('%s(%s) -> %s', qualifiedMethodName(original), args, result);
    }
    return result;
  };

  advice.methodName = "$logCallsAdvice::" + qualifiedMethodName(func);

  var result = wrap(func, advice);
  result.originalFunction = func;
  result.methodName = "$logCallsWrapper::" + qualifiedMethodName(func);
  return result;
}

function traceCalls(func, stack) {
  var advice = function traceCallsAdvice(proceed) {
    var args = Array.prototype.slice.call(arguments);
    args.shift();
    stack.push(args);
    var result = proceed.apply(func, args);
    stack.pop();
    return result;
  };
  return wrap(func, advice);
}

function webkitStack() {
  // this won't work in every browser
  try {
    throw new Error();
  } catch (e) {
    // remove "Error" and this function from stack, rewrite it nicely
    return String(e.stack).split(/\n/).slice(2).map(function (line) {
      return line.replace(/^\s*at\s*([^\s]+).*/, '$1');
    }).join('\n');
  }
}



var fun = Object.freeze({
	Empty: Empty,
	K: K,
	Null: Null,
	False: False,
	True: True,
	notYetImplemented: notYetImplemented,
	withNull: withNull,
	all: all,
	own: own,
	argumentNames: argumentNames,
	qualifiedMethodName: qualifiedMethodName,
	extractBody: extractBody,
	timeToRun: timeToRun,
	timeToRunN: timeToRunN$1,
	delay: delay,
	throttle: throttle,
	debounce: debounce,
	throttleNamed: throttleNamed,
	debounceNamed: debounceNamed,
	createQueue: createQueue,
	workerWithCallbackQueue: workerWithCallbackQueue,
	composeAsync: composeAsync,
	compose: compose,
	waitFor: waitFor,
	waitForAll: waitForAll,
	flip: flip,
	curry: curry,
	wrap: wrap,
	binds: binds,
	getOriginal: getOriginal,
	wrapperChain: wrapperChain,
	replaceMethodForOneCall: replaceMethodForOneCall,
	once: once,
	either: either,
	eitherNamed: eitherNamed,
	evalJS: evalJS,
	fromString: fromString,
	asScript: asScript,
	asScriptOf: asScriptOf,
	addToObject: addToObject,
	setLocalVarValue: setLocalVarValue,
	getVarMapping: getVarMapping,
	setProperty: setProperty,
	functionNames: functionNames,
	localFunctionNames: localFunctionNames,
	logErrors: logErrors,
	logCompletion: logCompletion,
	logCalls: logCalls,
	traceCalls: traceCalls,
	webkitStack: webkitStack
});

// show-in-doc
// A Grouping is created by arr.groupBy and maps keys to Arrays.

var Group = function () {
  function Group() {
    classCallCheck(this, Group);
  }

  createClass(Group, [{
    key: "toArray",
    value: function toArray() {
      // Example:
      // var group = arr.groupBy([1,2,3,4,5], function(n) { return n % 2; })
      // group.toArray(); // => [[2,4],[1,3,5]]
      return this.reduceGroups(function (all$$1, _, group) {
        return all$$1.concat([group]);
      }, []);
    }
  }, {
    key: "forEach",
    value: function forEach(iterator, context) {
      // Iteration for each item in each group, called like `iterator(groupKey, groupItem)`
      var groups = this;
      Object.keys(groups).forEach(function (groupName) {
        groups[groupName].forEach(iterator.bind(context, groupName));
      });
      return groups;
    }
  }, {
    key: "forEachGroup",
    value: function forEachGroup(iterator, context) {
      // Iteration for each group, called like `iterator(groupKey, group)`
      var groups = this;
      Object.keys(groups).forEach(function (groupName) {
        iterator.call(context, groupName, groups[groupName]);
      });
      return groups;
    }
  }, {
    key: "map",
    value: function map(iterator, context) {
      // Map for each item in each group, called like `iterator(groupKey, group)`
      var result = new Group();
      this.forEachGroup(function (groupName, group) {
        result[groupName] = group.map(iterator.bind(context, groupName));
      });
      return result;
    }
  }, {
    key: "mapGroups",
    value: function mapGroups(iterator, context) {
      // Map for each group, called like `iterator(groupKey, group)`
      var result = new Group();
      this.forEachGroup(function (groupName, group) {
        result[groupName] = iterator.call(context, groupName, group);
      });
      return result;
    }
  }, {
    key: "keys",
    value: function keys() {
      // show-in-docs
      return Object.keys(this);
    }
  }, {
    key: "reduceGroups",
    value: function reduceGroups(iterator, carryOver, context) {
      // Reduce/fold for each group, called like `iterator(carryOver, groupKey, group)`
      this.forEachGroup(function (groupName, group) {
        carryOver = iterator.call(context, carryOver, groupName, group);
      });
      return carryOver;
    }
  }, {
    key: "count",
    value: function count() {
      // counts the elements of each group
      return this.reduceGroups(function (groupCount, groupName, group) {
        groupCount[groupName] = group.length;
        return groupCount;
      }, {});
    }
  }], [{
    key: "fromArray",
    value: function fromArray(array, hashFunc, context) {
      // Example:
      // Group.fromArray([1,2,3,4,5,6], function(n) { return n % 2; })
      // // => {"0": [2,4,6], "1": [1,3,5]}
      var grouping = new Group();
      for (var i = 0, len = array.length; i < len; i++) {
        var hash = hashFunc.call(context, array[i], i);
        if (!grouping[hash]) grouping[hash] = [];
        grouping[hash].push(array[i]);
      }
      return grouping;
    }
  }, {
    key: "by",
    get: function get() {
      return groupBy;
    }
  }]);
  return Group;
}();

/*global System, global*/

/*
 * Methods to make working with arrays more convenient and collection-like
 * abstractions for groups, intervals, grids.
 */

var GLOBAL$1 = typeof System !== "undefined" ? System.global : typeof window !== 'undefined' ? window : global;

var features$1 = {
  from: !!Array.from,
  filter: !!Array.prototype.filter,
  find: !!Array.prototype.find,
  findIndex: !!Array.prototype.findIndex,
  includes: !!Array.prototype.includes
};

// variety of functions for Arrays


// -=-=-=-=-=-=-=-
// array creations
// -=-=-=-=-=-=-=-

function range(begin, end, step) {
  // Examples:
  //   arr.range(0,5) // => [0,1,2,3,4,5]
  //   arr.range(0,10,2) // => [0,2,4,6,8,10]
  step = step || 0;
  var result = [];
  if (begin <= end) {
    if (step <= 0) step = -step || 1;
    for (var i = begin; i <= end; i += step) {
      result.push(i);
    }
  } else {
    if (step >= 0) step = -step || -1;
    for (var i = begin; i >= end; i += step) {
      result.push(i);
    }
  }
  return result;
}

var from = features$1.from ? Array.from : function (iterable) {
  // Makes JS arrays out of array like objects like `arguments` or DOM `childNodes`
  if (!iterable) return [];
  if (Array.isArray(iterable)) return iterable;
  if (iterable.toArray) return iterable.toArray();
  var length = iterable.length,
      results = new Array(length);
  while (length--) {
    results[length] = iterable[length];
  }return results;
};

function withN(n, obj) {
  // Example:
  //   arr.withN(3, "Hello") // => ["Hello","Hello","Hello"]
  var result = new Array(n);
  while (n > 0) {
    result[--n] = obj;
  }return result;
}

function genN(n, generator) {
  // Number -> Function -> Array
  // Takes a generator function that is called for each `n`.
  // Example:
  //   arr.genN(3, num.random) // => [46,77,95]
  var result = new Array(n);
  while (n > 0) {
    result[--n] = generator(n);
  }return result;
}

// -=-=-=-=-
// filtering
// -=-=-=-=-

function filter(array, iterator, context) {
  // [a] -> (a -> Boolean) -> c? -> [a]
  // Calls `iterator` for each element in `array` and returns a subset of it
  // including the elements for which `iterator` returned a truthy value.
  // Like `Array.prototype.filter`.
  return array.filter(iterator, context);
}

var detect = features$1.find ? function (arr, iterator, context) {
  return arr.find(iterator, context);
} : function (arr, iterator, context) {
  // [a] -> (a -> Boolean) -> c? -> a
  // returns the first occurrence of an element in `arr` for which iterator
  // returns a truthy value
  for (var value, i = 0, len = arr.length; i < len; i++) {
    value = arr[i];
    if (iterator.call(context, value, i)) return value;
  }
  return undefined;
};

var findIndex = features$1.findIndex ? function (arr, iterator, context) {
  return arr.findIndex(iterator, context);
} : function (arr, iterator, context) {
  var i = -1;
  return arr.find(function (ea, j) {
    i = j;return iterator.call(ea, context);
  }) ? i : -1;
};

function findAndGet(arr, iterator) {
  // find the first occurence for which `iterator` returns a truthy value and
  // return *this* value, i.e. unlike find the iterator result and not the
  // element of the list is returned
  var result;
  arr.find(function (ea, i) {
    return result = iterator(ea, i);
  });
  return result;
}

function filterByKey(arr, key) {
  // [a] -> String -> [a]
  // Example:
  //   var objects = [{x: 3}, {y: 4}, {x:5}]
  //   arr.filterByKey(objects, "x") // => [{x: 3},{x: 5}]
  return arr.filter(function (ea) {
    return !!ea[key];
  });
}

function grep(arr, filter, context) {
  // [a] -> String|RegExp -> [a]
  // `filter` can be a String or RegExp. Will stringify each element in
  // Example:
  // ["Hello", "World", "Lively", "User"].grep("l") // => ["Hello","World","Lively"]
  if (typeof filter === 'string') filter = new RegExp(filter, 'i');
  return arr.filter(filter.test.bind(filter));
}

function mask(array, mask) {
  // select every element in array for which array's element is truthy
  // Example: [1,2,3].mask([false, true, false]) => [2]
  return array.filter(function (_, i) {
    return !!mask[i];
  });
}

function reject(array, func, context) {
  // show-in-doc
  function iterator(val, i) {
    return !func.call(context, val, i);
  }
  return array.filter(iterator);
}

function rejectByKey(array, key) {
  // show-in-doc
  return array.filter(function (ea) {
    return !ea[key];
  });
}

function without(array, elem) {
  // non-mutating
  // Example:
  // arr.without([1,2,3,4,5,6], 3) // => [1,2,4,5,6]
  return array.filter(function (value) {
    return value !== elem;
  });
}

function withoutAll(array, otherArr) {
  // non-mutating
  // Example:
  // arr.withoutAll([1,2,3,4,5,6], [3,4]) // => [1,2,5,6]
  return array.filter(function (value) {
    return otherArr.indexOf(value) === -1;
  });
}

function uniq(array, sorted) {
  // non-mutating
  // Removes duplicates from array.
  return array.reduce(function (a, value, index) {
    if (0 === index || (sorted ? last(a) != value : a.indexOf(value) === -1)) a.push(value);
    return a;
  }, []);
}

function uniqBy(array, comparator, context) {
  // like `arr.uniq` but with custom equality: `comparator(a,b)` returns
  // BOOL. True if a and be should be regarded equal, false otherwise.
  var result = array.slice();
  for (var i = 0; i < result.length; i++) {
    var item = array[i];
    for (var j = i + 1; j < result.length; j++) {
      if (comparator.call(context, item, result[j])) {
        removeAt(result, j);j--;
      }
    }
  }
  return result;
}

function compact(array) {
  // removes falsy values
  // Example:
  // arr.compact([1,2,undefined,4,0]) // => [1,2,4]
  return array.filter(function (ea) {
    return !!ea;
  });
}

function mutableCompact(array) {
  // fix gaps that were created with 'delete'
  var i = 0,
      j = 0,
      len = array.length;
  while (i < len) {
    if (array.hasOwnProperty(i)) array[j++] = array[i];
    i++;
  }
  while (j++ < len) {
    array.pop();
  }return array;
}

// -=-=-=-=-
// iteration
// -=-=-=-=-

function forEach$1(array, iterator, context) {
  // [a] -> (a -> Undefined) -> c? -> Undefined
  // `iterator` is called on each element in `array` for side effects. Like
  // `Array.prototype.forEach`.
  return array.forEach(iterator, context);
}

function zip() /*arr, arr2, arr3*/{
  // Takes any number of lists as arguments. Combines them elment-wise.
  // Example:
  // arr.zip([1,2,3], ["a", "b", "c"], ["A", "B"])
  // // => [[1,"a","A"],[2,"b","B"],[3,"c",undefined]]
  var args = Array.from(arguments),
      array = args.shift(),
      iterator = typeof last(args) === 'function' ? args.pop() : function (x) {
    return x;
  },
      collections = [array].concat(args).map(function (ea) {
    return Array.from(ea);
  });
  return array.map(function (value, index) {
    return iterator(pluck(collections, index), index);
  });
}

function flatten(array, optDepth) {
  // Turns a nested collection into a flat one.
  // Example:
  // arr.flatten([1, [2, [3,4,5], [6]], 7,8])
  // // => [1,2,3,4,5,6,7,8]
  if (typeof optDepth === "number") {
    if (optDepth <= 0) return array;
    optDepth--;
  }
  return array.reduce(function (flattened, value) {
    return flattened.concat(Array.isArray(value) ? flatten(value, optDepth) : [value]);
  }, []);
}

function flatmap(array, it, ctx) {
  // the simple version
  // Array.prototype.concat.apply([], array.map(it, ctx));
  // causes stack overflows with really big arrays
  var results = [];
  for (var i = 0; i < array.length; i++) {
    results.push.apply(results, it.call(ctx, array[i], i));
  }
  return results;
}

function interpose(array, delim) {
  // Injects delim between elements of array
  // Example:
  // lively.lang.arr.interpose(["test", "abc", 444], "aha"));
  // // => ["test","aha","abc","aha",444]
  return array.reduce(function (xs, x) {
    if (xs.length > 0) xs.push(delim);
    xs.push(x);return xs;
  }, []);
}

function delimWith(array, delim) {
  // ignore-in-doc
  return interpose(array, delim);
}

// -=-=-=-=-
// mapping
// -=-=-=-=-

function map$1(array, iterator, context) {
  // [a] -> (a -> b) -> c? -> [b]
  // Applies `iterator` to each element of `array` and returns a new Array
  // with the results of those calls. Like `Array.prototype.some`.
  return array.map(iterator, context);
}

function invoke(array, method, arg1, arg2, arg3, arg4, arg5, arg6) {
  // Calls `method` on each element in `array`, passing all arguments. Often
  // a handy way to avoid verbose `map` calls.
  // Example: arr.invoke(["hello", "world"], "toUpperCase") // => ["HELLO","WORLD"]
  return array.map(function (ea) {
    return ea[method](arg1, arg2, arg3, arg4, arg5, arg6);
  });
}

function pluck(array, property) {
  // Returns `property` or undefined from each element of array. For quick
  // `map`s and similar to `invoke`.
  // Example: arr.pluck(["hello", "world"], 0) // => ["h","w"]
  return array.map(function (ea) {
    return ea[property];
  });
}

// -=-=-=-=-
// folding
// -=-=-=-=-

function reduce(array, iterator, memo, context) {
  // Array -> Function -> Object? -> Object? -> Object?
  // Applies `iterator` to each element of `array` and returns a new Array
  // with the results of those calls. Like `Array.prototype.some`.
  return array.reduce(iterator, memo, context);
}

function reduceRight(array, iterator, memo, context) {
  // show-in-doc
  return array.reduceRight(iterator, memo, context);
}

// -=-=-=-=-
// testing
// -=-=-=-=-

var isArray$1 = Array.isArray;

var includes$1 = features$1.includes ? function (array, object) {
  return array.includes(object);
} : function (array, object) {
  // Example: arr.include([1,2,3], 2) // => true
  return array.indexOf(object) !== -1;
};

var include$1 = includes$1;

function some(array, iterator, context) {
  // [a] -> (a -> Boolean) -> c? -> Boolean
  // Returns true if there is at least one abject in `array` for which
  // `iterator` returns a truthy result. Like `Array.prototype.some`.
  return array.some(iterator, context);
}

function every(array, iterator, context) {
  // [a] -> (a -> Boolean) -> c? -> Boolean
  // Returns true if for all abjects in `array` `iterator` returns a truthy
  // result. Like `Array.prototype.every`.
  return array.every(iterator, context);
}

function equals$2(array, otherArray) {
  // Returns true iff each element in `array` is equal (`==`) to its
  // corresponding element in `otherArray`
  var len = array.length;
  if (!otherArray || len !== otherArray.length) return false;
  for (var i = 0; i < len; i++) {
    if (array[i] && otherArray[i] && array[i].equals && otherArray[i].equals) {
      if (!array[i].equals(otherArray[i])) {
        return false;
      } else {
        continue;
      }
    }
    if (array[i] != otherArray[i]) return false;
  }
  return true;
}

function deepEquals(array, otherArray) {
  // Returns true iff each element in `array` is structurally equal
  // (`lang.obj.equals`) to its corresponding element in `otherArray`
  var len = array.length;
  if (!otherArray || len !== otherArray.length) return false;
  for (var i = 0; i < len; i++) {
    if (!equals$1(array[i], otherArray[i])) return false;
  }
  return true;
}

// -=-=-=-=-
// sorting
// -=-=-=-=-

function isSorted(array, descending) {
  if (descending) {
    for (var i = 1; i < array.length; i++) {
      if (array[i - 1] < array[i]) return false;
    }
  } else {
    for (var i = 1; i < array.length; i++) {
      if (array[i - 1] > array[i]) return false;
    }
  }
  return true;
}

function sort(array, sortFunc) {
  // [a] -> (a -> Number)? -> [a]
  // Just `Array.prototype.sort`
  return array.sort(sortFunc);
}

function sortBy(array, iterator, context) {
  // Example:
  // arr.sortBy(["Hello", "Lively", "User"], function(ea) {
  //   return ea.charCodeAt(ea.length-1); }) // => ["Hello","User","Lively"]
  return pluck(array.map(function (value, index) {
    return { value: value, criteria: iterator.call(context, value, index) };
  }).sort(function (left, right) {
    var a = left.criteria,
        b = right.criteria;
    return a < b ? -1 : a > b ? 1 : 0;
  }), 'value');
}

function sortByKey(array, key) {
  // Example:
  // lively.lang.arr.sortByKey([{x: 3}, {x: 2}, {x: 8}], "x")
  // // => [{x: 2},{x: 3},{x: 8}]
  return sortBy(array, function (ea) {
    return ea[key];
  });
}

function reverse(array) {
  return array.reverse();
}

function reversed(array) {
  return array.slice().reverse();
}

// -=-=-=-=-=-=-=-=-=-=-=-=-
// RegExp / String matching
// -=-=-=-=-=-=-=-=-=-=-=-=-

function reMatches$1(arr, re, stringifier) {
  // result might include null items if re did not match (usful for masking)
  // Example:
  //   var morphs = $world.withAllSubmorphsDo(function(x) { return x; ;
  //   morphs.mask(morphs.reMatches(/code/i))
  stringifier = stringifier || String;
  return arr.map(function (ea) {
    return stringifier(ea).match(re);
  });
}

// -=-=-=-=-=-
// accessors
// -=-=-=-=-=-

function first(array) {
  return array[0];
}

function last(array) {
  return array[array.length - 1];
}

// -=-=-=-=-=-=-=-
// Set operations
// -=-=-=-=-=-=-=-

function intersect(array1, array2) {
  // set-like intersection
  return uniq(array1).filter(function (item) {
    return array2.indexOf(item) > -1;
  });
}

function union(array1, array2) {
  // set-like union
  var result = array1.slice();
  for (var i = 0; i < array2.length; i++) {
    var item = array2[i];
    if (result.indexOf(item) === -1) result.push(item);
  }
  return result;
}

function pushAt(array, item, index) {
  // inserts `item` at `index`, mutating
  array.splice(index, 0, item);
}

function removeAt(array, index) {
  // inserts item at `index`, mutating
  array.splice(index, 1);
}

function remove(array, item) {
  // removes first occurrence of item in `array`, mutating
  var index = array.indexOf(item);
  if (index >= 0) removeAt(array, index);
  return item;
}

function pushAll$1(array, items) {
  // appends all `items`, mutating
  array.push.apply(array, items);
  return array;
}

function pushAllAt(array, items, idx) {
  // inserts all `items` at `idx`, mutating
  array.splice.apply(array, [idx, 0].concat(items));
}

function pushIfNotIncluded(array, item) {
  // only appends `item` if its not already in `array`, mutating
  if (!array.includes(item)) array.push(item);
}

function replaceAt(array, item, index) {
  // mutating
  array.splice(index, 1, item);
}

function clear(array) {
  // removes all items, mutating
  array.length = 0;return array;
}

function isSubset(list1, list2) {
  // are all elements in list1 in list2?
  for (var i = 0; i < list1.length; i++) {
    if (!list2.includes(list1[i])) return false;
  }return true;
}

// -=-=-=-=-=-=-=-=-=-=-=-
// asynchronous iteration
// -=-=-=-=-=-=-=-=-=-=-=-
function doAndContinue(array, iterator, endFunc, context) {
  // Iterates over array but instead of consecutively calling iterator,
  // iterator gets passed in the invocation for the next iteration step
  // as a function as first parameter. This allows to wait arbitrarily
  // between operation steps, great for managing dependencies between tasks.
  // Related is [`fun.composeAsync`]().
  // Example:
  // arr.doAndContinue([1,2,3,4], function(next, n) {
  //   alert("At " + n);
  //   setTimeout(next, 100);
  // }, function() { alert("Done"); })
  // // If the elements are functions you can leave out the iterator:
  // arr.doAndContinue([
  //   function(next) { alert("At " + 1); next(); },
  //   function(next) { alert("At " + 2); next(); }
  // ], null, function() { alert("Done"); });
  endFunc = endFunc || Null;
  context = context || GLOBAL$1;
  iterator = iterator || function (next, ea, idx) {
    ea.call(context, next, idx);
  };
  return array.reduceRight(function (nextFunc, ea, idx) {
    return function () {
      iterator.call(context, nextFunc, ea, idx);
    };
  }, endFunc)();
}

function nestedDelay(array, iterator, waitSecs, endFunc, context, optSynchronChunks) {
  // Calls `iterator` for every element in `array` and waits between iterator
  // calls `waitSecs`. Eventually `endFunc` is called. When passing a number n
  // as `optSynchronChunks`, only every nth iteration is delayed.
  endFunc = endFunc || function () {};
  return array.clone().reverse().reduce(function (nextFunc, ea, idx) {
    return function () {
      iterator.call(context || GLOBAL$1, ea, idx);
      // only really delay every n'th call optionally
      if (optSynchronChunks && idx % optSynchronChunks !== 0) {
        nextFunc();
      } else {
        nextFunc.delay(waitSecs);
      }
    };
  }, endFunc)();
}

function forEachShowingProgress() /*array, progressBar, iterator, labelFunc, whenDoneFunc, context or spec*/{
  // ignore-in-doc
  var args = Array.from(arguments),
      array = args.shift(),
      steps = array.length,
      progressBar,
      iterator,
      labelFunc,
      whenDoneFunc,
      context,
      progressBarAdded = false;

  // init args
  if (args.length === 1) {
    progressBar = args[0].progressBar;
    iterator = args[0].iterator;
    labelFunc = args[0].labelFunction;
    whenDoneFunc = args[0].whenDone;
    context = args[0].context;
  } else {
    progressBar = args[0];
    iterator = args[1];
    labelFunc = args[2];
    whenDoneFunc = args[3];
    context = args[4];
  }
  if (!context) context = typeof window !== 'undefined' ? window : global;
  if (!labelFunc) labelFunc = function labelFunc(x) {
    return x;
  };

  // init progressbar
  if (!progressBar) {
    progressBarAdded = true;
    var Global = typeof window !== 'undefined' ? window : global;
    var world = Global.lively && lively.morphic && lively.morphic.World.current();
    progressBar = world ? world.addProgressBar() : {
      setValue: function setValue(val) {},
      setLabel: function setLabel() {},
      remove: function remove() {}
    };
  }
  progressBar.setValue(0);

  // nest functions so that the iterator calls the next after a delay
  array.reduceRight(function (nextFunc, item, idx) {
    return function () {
      try {
        progressBar.setValue(idx / steps);
        if (labelFunc) progressBar.setLabel(labelFunc.call(context, item, idx));
        iterator.call(context, item, idx);
      } catch (e) {
        console.error('Error in forEachShowingProgress at %s (%s)\n%s\n%s', idx, item, e, e.stack);
      }
      nextFunc.delay(0);
    };
  }, function () {
    progressBar.setValue(1);
    if (progressBarAdded) (function () {
      progressBar.remove();
    }).delay(0);
    if (whenDoneFunc) whenDoneFunc.call(context);
  })();

  return array;
}

function swap(array, index1, index2) {
  // mutating
  // Example:
  // var a = [1,2,3,4];
  // arr.swap(a, 3, 1);
  // a // => [1,4,3,2]
  if (index1 < 0) index1 = array.length + index1;
  if (index2 < 0) index2 = array.length + index2;
  var temp = array[index1];
  array[index1] = array[index2];
  array[index2] = temp;
  return array;
}

function rotate(array, times) {
  // non-mutating
  // Example:
  // arr.rotate([1,2,3]) // => [2,3,1]
  times = times || 1;
  return array.slice(times).concat(array.slice(0, times));
}

// -=-=-=-=-
// grouping
// -=-=-=-=-

function groupBy(array, iterator, context) {
  // Applies `iterator` to each element in `array`, and puts the return value
  // into a collection (the group) associated to it's stringified representation
  // (the "hash").
  // See [`Group.prototype`] for available operations on groups.
  // Example:
  // Example 1: Groups characters by how often they occur in a string:
  // var chars = arr.from("Hello World");
  // arr.groupBy(arr.uniq(chars), function(c) {
  //   return arr.count(chars, c); })
  // // => {
  // //   "1": ["H","e"," ","W","r","d"],
  // //   "2": ["o"],
  // //   "3": ["l"]
  // // }
  // // Example 2: Group numbers by a custom qualifier:
  // arr.groupBy([3,4,1,7,4,3,8,4], function(n) {
  //   if (n <= 3) return "small";
  //   if (n <= 7) return "medium";
  //   return "large";
  // });
  // // => {
  // //   large: [8],
  // //   medium: [4,7,4,4],
  // //   small: [3,1,3]
  // // }
  return Group.fromArray(array, iterator, context);
}

function groupByKey(array, key) {
  // var objects = [{x: }]
  // arr.groupBy(arr.uniq(chars), function(c) {
  //   return arr.count(chars, c); })
  // // => {
  // //   "1": ["H","e"," ","W","r","d"],
  // //   "2": ["o"],
  // //   "3": ["l"]
  // // }
  return groupBy(array, function (ea) {
    return ea[key];
  });
}

function partition(array, iterator, context) {
  // Example:
  // var array = [1,2,3,4,5,6];
  // arr.partition(array, function(ea) { return ea > 3; })
  // // => [[1,2,3,4],[5,6]]
  iterator = iterator || function (x) {
    return x;
  };
  var trues = [],
      falses = [];
  array.forEach(function (value, index) {
    (iterator.call(context, value, index) ? trues : falses).push(value);
  });
  return [trues, falses];
}

function batchify(array, constrainedFunc, context) {
  // Takes elements and fits them into subarrays (= batches) so that for
  // each batch constrainedFunc returns true. Note that contrained func
  // should at least produce 1-length batches, otherwise an error is raised
  // Example:
  // // Assume you have list of things that have different sizes and you want to
  // // create sub-arrays of these things, with each sub-array having if possible
  // // less than a `batchMaxSize` of combined things in it:
  // var sizes = [
  //   Math.pow(2, 15), // 32KB
  //   Math.pow(2, 29), // 512MB
  //   Math.pow(2, 29), // 512MB
  //   Math.pow(2, 27), // 128MB
  //   Math.pow(2, 26), // 64MB
  //   Math.pow(2, 26), // 64MB
  //   Math.pow(2, 24), // 16MB
  //   Math.pow(2, 26)] // 64MB
  // var batchMaxSize = Math.pow(2, 28)/*256MB*/;
  // function batchConstrained(batch) {
  //   return batch.length == 1 || batch.sum() < batchMaxSize;
  // }
  // var batches = sizes.batchify(batchConstrained);
  // batches.pluck('length') // => [4,1,1,2]
  // batches.map(arr.sum).map(num.humanReadableByteSize) // => ["208.03MB","512MB","512MB","128MB"]

  return findBatches([], array);

  // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  function extractBatch(batch, sizes) {
    // ignore-in-doc
    // Array -> Array -> Array[Array,Array]
    // case 1: no sizes to distribute, we are done
    if (!sizes.length) return [batch, []];
    var first = sizes[0],
        rest = sizes.slice(1);
    // if batch is empty we have to take at least one
    // if batch and first still fits, add first
    var candidate = batch.concat([first]);
    if (constrainedFunc.call(context, candidate)) return extractBatch(candidate, rest);
    // otherwise leave first out for now
    var batchAndSizes = extractBatch(batch, rest);
    return [batchAndSizes[0], [first].concat(batchAndSizes[1])];
  }

  function findBatches(batches, sizes) {
    if (!sizes.length) return batches;
    var extracted = extractBatch([], sizes);
    if (!extracted[0].length) throw new Error('Batchify constrained does not ensure consumption ' + 'of at least one item per batch!');
    return findBatches(batches.concat([extracted[0]]), extracted[1]);
  }
}

function toTuples(array, tupleLength) {
  // Creates sub-arrays with length `tupleLength`
  // Example:
  // arr.toTuples(["H","e","l","l","o"," ","W","o","r","l","d"], 4)
  // // => [["H","e","l","l"],["o"," ","W","o"],["r","l","d"]]
  tupleLength = tupleLength || 1;
  return range(0, Math.ceil(array.length / tupleLength) - 1).map(function (n) {
    return array.slice(n * tupleLength, n * tupleLength + tupleLength);
  }, array);
}

var permutations = function () {
  function computePermutations(restArray, values$$1) {
    return !restArray.length ? [values$$1] : flatmap(restArray, function (ea, i) {
      return computePermutations(restArray.slice(0, i).concat(restArray.slice(i + 1)), values$$1.concat([ea]));
    });
  }
  return function (array) {
    return computePermutations(array, []);
  };
}();

function combinationsPick(listOfListsOfValues, pickIndices) {
  // Given a "listOfListsOfValues" in the form of an array of arrays and
  // `pickIndices` list with the size of the number of arrays which indicates what
  // values to pick from each of the arrays, return a list with two values:
  // 1. values picked from each of the arrays, 2. the next pickIndices or null if at end
  // Example:
  //  var searchSpace = [["a", "b", "c"], [1,2]];
  //  arr.combinationsPick(searchSpace, [0,1]);
  //    // => [["a",2], [1,0]]
  //  arr.combinationsPick(searchSpace, [1,0]);
  //    // => [["b",1], [1,1]]
  var values$$1 = listOfListsOfValues.map(function (subspace, i) {
    return subspace[pickIndices[i]];
  }),
      nextState = pickIndices.slice();
  for (var i = listOfListsOfValues.length; i--; i >= 0) {
    var subspace = listOfListsOfValues[i],
        nextIndex = nextState[i] + 1;
    if (subspace[nextIndex]) {
      nextState[i] = nextIndex;break;
    } else if (i === 0) {
      nextState = undefined;break;
    } else {
      nextState[i] = 0;
    }
  }
  return [values$$1, nextState];
}

function combinations(listOfListsOfValues) {
  // Given a "listOfListsOfValues" in the form of an array of arrays,
  // retrieve all the combinations by picking one item from each array.
  // This basically creates a search tree, traverses it and gathers all node
  // values whenever a leaf node is reached.
  // Example:
  //   lively.lang.arr.combinations([['a', 'b', 'c'], [1, 2]])
  //    // => [["a", 1], ["a", 2], ["b", 1], ["b", 2], ["c", 1], ["c", 2]]
  var size = listOfListsOfValues.reduce(function (prod, space) {
    return prod * space.length;
  }, 1),
      searchState = listOfListsOfValues.map(function (_) {
    return 0;
  }),
      results = new Array(size);
  for (var i = 0; i < size; i++) {
    var result = combinationsPick(listOfListsOfValues, searchState);
    results[i] = result[0];
    searchState = result[1];
  }
  return results;
}

function take(arr, n) {
  return arr.slice(0, n);
}

function drop(arr, n) {
  return arr.slice(n);
}

function takeWhile(arr, fun, context) {
  var i = 0;
  for (; i < arr.length; i++) {
    if (!fun.call(context, arr[i], i)) break;
  }return arr.slice(0, i);
}

function dropWhile(arr, fun, context) {
  var i = 0;
  for (; i < arr.length; i++) {
    if (!fun.call(context, arr[i], i)) break;
  }return arr.slice(i);
}

// -=-=-=-=-=-
// randomness
// -=-=-=-=-=-

function shuffle(array) {
  // Ramdomize the order of elements of array. Does not mutate array.
  // Example:
  // arr.shuffle([1,2,3,4,5]) // => [3,1,2,5,4]
  var unusedIndexes = range(0, array.length - 1);
  return array.reduce(function (shuffled, ea, i) {
    var shuffledIndex = unusedIndexes.splice(Math.round(Math.random() * (unusedIndexes.length - 1)), 1);
    shuffled[shuffledIndex] = ea;
    return shuffled;
  }, Array(array.length));
}

// -=-=-=-=-=-=-=-
// Number related
// -=-=-=-=-=-=-=-

function max(array, iterator, context) {
  // Example:
  //   var array = [{x:3,y:2}, {x:5,y:1}, {x:1,y:5}];
  //   arr.max(array, function(ea) { return ea.x; }) // => {x: 5, y: 1}
  iterator = iterator || function (x) {
    return x;
  };
  var result;
  array.reduce(function (max, ea, i) {
    var val = iterator.call(context, ea, i);
    if (typeof val !== "number" || val <= max) return max;
    result = ea;return val;
  }, -Infinity);
  return result;
}

function min(array, iterator, context) {
  // Similar to `arr.max`.
  iterator = iterator || function (x) {
    return x;
  };
  return max(array, function (ea, i) {
    return -iterator.call(context, ea, i);
  });
}

function sum(array) {
  // show-in-doc
  var sum = 0;
  for (var i = 0; i < array.length; i++) {
    sum += array[i];
  }return sum;
}

function count$1(array, item) {
  return array.reduce(function (count, ea) {
    return ea === item ? count + 1 : count;
  }, 0);
}

function size$1(array) {
  return array.length;
}

function histogram(data, binSpec) {
  // ignore-in-doc
  // Without a `binSpec` argument partition the data
  // var numbers = arr.genN(10, num.random);
  // var numbers = arr.withN(10, "a");
  // => [65,73,34,94,92,31,27,55,95,48]
  // => [[65,73],[34,94],[92,31],[27,55],[95,48]]
  // => [[82,50,16],[25,43,77],[40,64,31],[51,39,13],[17,34,87],[51,33,30]]
  if (typeof binSpec === 'undefined' || typeof binSpec === 'number') {
    var binNumber = binSpec || function sturge() {
      return Math.ceil(Math.log(data.length) / Math.log(2) + 1);
    }(data);
    var binSize = Math.ceil(Math.round(data.length / binNumber));
    return range(0, binNumber - 1).map(function (i) {
      return data.slice(i * binSize, (i + 1) * binSize);
    });
  } else if (binSpec instanceof Array) {
    // ignore-in-doc
    // bins specifies n threshold values that will create n-1 bins.
    // Each data value d is placed inside a bin i if:
    // threshold[i] >= d && threshold[i+1] < d
    var thresholds = binSpec;
    return data.reduce(function (bins, d) {
      if (d < thresholds[1]) {
        bins[0].push(d);return bins;
      }
      for (var i = 1; i < thresholds.length; i++) {
        if (d >= thresholds[i] && (!thresholds[i + 1] || d <= thresholds[i + 1])) {
          bins[i].push(d);return bins;
        }
      }
      throw new Error("Histogram creation: Cannot group data " + d + " into thresholds " + thresholds);
    }, range(1, thresholds.length).map(function () {
      return [];
    }));
  }
}

// -=-=-=-=-
// Copying
// -=-=-=-=-

function clone$1(array) {
  // shallow copy
  return [].concat(array);
}

// -=-=-=-=-=-
// conversion
// -=-=-=-=-=-

function toArray$3(array) {
  return from(array);
}

// -=-=-=-=-=-
// DEPRECATED
// -=-=-=-=-=-

function each(arr, iterator, context) {
  return arr.forEach(iterator, context);
}

function all$1(arr, iterator, context) {
  return arr.every(iterator, context);
}

function any(arr, iterator, context) {
  return arr.some(iterator, context);
}

function collect(arr, iterator, context) {
  return arr.map(iterator, context);
}

function findAll(arr, iterator, context) {
  return arr.filter(iterator, context);
}

function inject(array, memo, iterator, context) {
  if (context) iterator = iterator.bind(context);
  return array.reduce(iterator, memo);
}

// asynch methods
function mapAsyncSeries(array, iterator, callback) {
  // Apply `iterator` over `array`. Unlike `mapAsync` the invocation of
  // the iterator happens step by step in the order of the items of the array
  // and not concurrently.

  // ignore-in-doc
  // Could simply be:
  // return exports.arr.mapAsync(array, {parallel: 1}, iterator, callback);
  // but the version below is 2x faster

  var result = [],
      callbackTriggered = false;
  return array.reduceRight(function (nextFunc, ea, idx) {
    if (callbackTriggered) return;
    return function (err, eaResult) {
      if (err) return maybeDone(err);
      if (idx > 0) result.push(eaResult);
      try {
        iterator(ea, idx, once(nextFunc));
      } catch (e) {
        maybeDone(e);
      }
    };
  }, function (err, eaResult) {
    result.push(eaResult);
    maybeDone(err, true);
  })();

  function maybeDone(err, finalCall) {
    if (callbackTriggered || !err && !finalCall) return;
    callbackTriggered = true;
    try {
      callback(err, result);
    } catch (e) {
      console.error("Error in mapAsyncSeries - callback invocation error:\n" + (e.stack || e));
    }
  }
}

function mapAsync(array, options, iterator, callback) {
  // Apply `iterator` over `array`. In each iterator gets a callback as third
  // argument that should be called when the iteration is done. After all
  // iterators have called their callbacks, the main `callback` function is
  // invoked with the result array.
  // Example:
  // lively.lang.arr.mapAsync([1,2,3,4],
  //   function(n, i, next) { setTimeout(function() { next(null, n + i); }, 20); },
  //   function(err, result) { /* result => [1,3,5,7] */ });

  if (typeof options === "function") {
    callback = iterator;
    iterator = options;
    options = null;
  }
  options = options || {};

  if (!array.length) return callback && callback(null, []);

  if (!options.parallel) options.parallel = Infinity;

  var results = [],
      completed = [],
      callbackTriggered = false,
      lastIteratorIndex = 0,
      nActive = 0;

  var iterators = array.map(function (item, i) {
    return function () {
      nActive++;
      try {
        iterator(item, i, once(function (err, result) {
          results[i] = err || result;
          maybeDone(i, err);
        }));
      } catch (e) {
        maybeDone(i, e);
      }
    };
  });

  return activate();

  // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  function activate() {
    while (nActive < options.parallel && lastIteratorIndex < array.length) {
      iterators[lastIteratorIndex++]();
    }
  }

  function maybeDone(idx, err) {
    if (completed.indexOf(idx) > -1) return;
    completed.push(idx);
    nActive--;
    if (callbackTriggered) return;
    if (!err && completed.length < array.length) {
      activate();return;
    }
    callbackTriggered = true;
    try {
      callback && callback(err, results);
    } catch (e) {
      console.error("Error in mapAsync - main callback invocation error:\n" + (e.stack || e));
    }
  }
}

// poly-filling...
if (!features$1.from) Array.from = from;
if (!features$1.filter) Array.prototype.filter = function (it, ctx) {
  return filter(this, it, ctx);
};
if (!features$1.find) Array.prototype.find = function (it, ctx) {
  return detect(this, it, ctx);
};
if (!features$1.findIndex) Array.prototype.findIndex = function (it, ctx) {
  return findIndex(this, it, ctx);
};
if (!features$1.includes) Array.prototype.includes = function (x) {
  return includes$1(this, x);
};



var arr = Object.freeze({
	range: range,
	from: from,
	withN: withN,
	genN: genN,
	filter: filter,
	detect: detect,
	findIndex: findIndex,
	findAndGet: findAndGet,
	filterByKey: filterByKey,
	grep: grep,
	mask: mask,
	reject: reject,
	rejectByKey: rejectByKey,
	without: without,
	withoutAll: withoutAll,
	uniq: uniq,
	uniqBy: uniqBy,
	compact: compact,
	mutableCompact: mutableCompact,
	forEach: forEach$1,
	zip: zip,
	flatten: flatten,
	flatmap: flatmap,
	interpose: interpose,
	delimWith: delimWith,
	map: map$1,
	invoke: invoke,
	pluck: pluck,
	reduce: reduce,
	reduceRight: reduceRight,
	isArray: isArray$1,
	includes: includes$1,
	include: include$1,
	some: some,
	every: every,
	equals: equals$2,
	deepEquals: deepEquals,
	isSorted: isSorted,
	sort: sort,
	sortBy: sortBy,
	sortByKey: sortByKey,
	reverse: reverse,
	reversed: reversed,
	reMatches: reMatches$1,
	first: first,
	last: last,
	intersect: intersect,
	union: union,
	pushAt: pushAt,
	removeAt: removeAt,
	remove: remove,
	pushAll: pushAll$1,
	pushAllAt: pushAllAt,
	pushIfNotIncluded: pushIfNotIncluded,
	replaceAt: replaceAt,
	clear: clear,
	isSubset: isSubset,
	doAndContinue: doAndContinue,
	nestedDelay: nestedDelay,
	forEachShowingProgress: forEachShowingProgress,
	swap: swap,
	rotate: rotate,
	groupBy: groupBy,
	groupByKey: groupByKey,
	partition: partition,
	batchify: batchify,
	toTuples: toTuples,
	permutations: permutations,
	combinationsPick: combinationsPick,
	combinations: combinations,
	take: take,
	drop: drop,
	takeWhile: takeWhile,
	dropWhile: dropWhile,
	shuffle: shuffle,
	max: max,
	min: min,
	sum: sum,
	count: count$1,
	size: size$1,
	histogram: histogram,
	clone: clone$1,
	toArray: toArray$3,
	each: each,
	all: all$1,
	any: any,
	collect: collect,
	findAll: findAll,
	inject: inject,
	mapAsyncSeries: mapAsyncSeries,
	mapAsync: mapAsync
});

/*
 * Utility functions that help to inspect, enumerate, and create JS objects
 */

// -=-=-=-=-=-=-=-=-
// internal helper
// -=-=-=-=-=-=-=-=-

// serveral methods in lib/object.js are inspired or derived from
// Prototype JavaScript framework, version 1.6.0_rc1
// (c) 2005-2007 Sam Stephenson
// Prototype is freely distributable under the terms of an MIT-style license.
// For details, see the Prototype web site: http://www.prototypejs.org/

function print$1(object) {
  if (object && Array.isArray(object)) {
    return '[' + object.map(print$1) + ']';
  }
  if (typeof object !== "string") {
    return String(object);
  }
  var result = String(object);
  result = result.replace(/\n/g, '\\n\\\n');
  result = result.replace(/(")/g, '\\$1');
  result = '\"' + result + '\"';
  return result;
}

function indent$1(str, indentString, depth) {
  if (!depth || depth <= 0) return str;
  while (depth > 0) {
    depth--;str = indentString + str;
  }
  return str;
}

// show-in-doc

// -=-=-=-=-
// testing
// -=-=-=-=-

function isArray$$1(obj) {
  /*show-in-doc*/return Array.isArray(obj);
}

function isElement(object) {
  /*show-in-doc*/return object && object.nodeType == 1;
}

function isFunction(object) {
  /*show-in-doc*/return object instanceof Function;
}

function isBoolean(object) {
  /*show-in-doc*/return typeof object == "boolean";
}

function isString(object) {
  /*show-in-doc*/return typeof object == "string";
}

function isNumber(object) {
  /*show-in-doc*/return typeof object == "number";
}

function isUndefined(object) {
  /*show-in-doc*/return typeof object == "undefined";
}

function isRegExp(object) {
  /*show-in-doc*/return object instanceof RegExp;
}

function isObject(object) {
  /*show-in-doc*/return (typeof object === "undefined" ? "undefined" : _typeof(object)) == "object";
}

function isPrimitive(obj) {
  // show-in-doc
  if (!obj) return true;
  switch (typeof obj === "undefined" ? "undefined" : _typeof(obj)) {
    case "string":
    case "number":
    case "boolean":
      return true;
  }
  return false;
}

function isEmpty(object) {
  /*show-in-doc*/
  for (var key in object) {
    if (object.hasOwnProperty(key)) return false;
  }return true;
}

function equals$1(a, b) {
  // Is object `a` structurally equivalent to object `b`? Deep comparison.
  if (a === b) return true;
  if (!a && !b) return true;
  if (!a || !b) return false;
  if (Array.isArray(a)) return deepEquals(a, b);
  switch (a.constructor) {
    case String:
    case Date:
    case Boolean:
    case Number:
      return a == b;
  }
  if (typeof a.isEqualNode === "function") return a.isEqualNode(b);
  if (typeof a.equals === "function") return a.equals(b);
  var seenInA = [];
  for (var name in a) {
    seenInA.push(name);
    if (typeof a[name] === "function") continue;
    if (!equals$1(a[name], b[name])) return false;
  }
  for (var name in b) {
    if (seenInA.indexOf(name) !== -1) continue;
    if (typeof b[name] === "function") continue;
    if (!equals$1(b[name], a[name])) return false;
  }
  return true;
}

// -=-=-=-=-=-
// accessing
// -=-=-=-=-=-

var keys$1 = Object.keys;

function values(object) {
  // Example:
  // var obj1 = {x: 22}, obj2 = {x: 23, y: {z: 3}};
  // obj2.__proto__ = obj1;
  // obj.values(obj1) // => [22]
  // obj.values(obj2) // => [23,{z: 3}]
  return object ? Object.keys(object).map(function (k) {
    return object[k];
  }) : [];
}

function select(obj, keys) {
  // return a new object that copies all properties with `keys` from `obj`
  var selected = {};
  for (var i = 0; i < keys.length; i++) {
    selected[keys[i]] = obj[keys[i]];
  }return selected;
}

function dissoc(object, keys) {
  var result = {};
  for (var name in object) {
    if (object.hasOwnProperty(name) && keys.indexOf(name) === -1) result[name] = object[name];
  }return result;
}

function addScript(object, funcOrString, optName, optMapping) {
  var func = fromString(funcOrString);
  return asScriptOf(func, object, optName, optMapping);
}

// -=-=-=-=-
// mutation
// -=-=-=-=-
function extend(destination, source) {
  // Add all properties of `source` to `destination`.
  // Example:
  // var dest = {x: 22}, src = {x: 23, y: 24}
  // obj.extend(dest, src);
  // dest // => {x: 23,y: 24}

  var currentCategoryNames = null;
  for (var i = 1; i < arguments.length; i++) {
    if (typeof arguments[i] == "string") {
      var catName = arguments[i];
      if (!destination.categories) destination.categories = {};
      if (!destination.categories[catName]) destination.categories[catName] = [];
      currentCategoryNames = destination.categories[catName];
      continue;
    }

    var source = arguments[i];
    for (var property in source) {
      var getter = source.__lookupGetter__(property),
          setter = source.__lookupSetter__(property);
      if (getter) destination.__defineGetter__(property, getter);
      if (setter) destination.__defineSetter__(property, setter);
      if (getter || setter) continue;
      var sourceObj = source[property];
      destination[property] = sourceObj;
      if (currentCategoryNames) currentCategoryNames.push(property);
      if (typeof sourceObj === "function") {
        if (!sourceObj.displayName) sourceObj.displayName = property;
        // remember the module that contains the definition
        if (typeof lively !== "undefined" && lively.Module && lively.Module.current) sourceObj.sourceModule = lively.Module.current();
      }
    }
  }

  return destination;
}

// -=-=-=-=-
// clone
// -=-=-=-=-

function clone$$1(object) {
  // Shallow copy
  if (isPrimitive(object)) return object;
  if (Array.isArray(object)) return Array.prototype.slice.call(object);
  var clone$$1 = {};
  for (var key in object) {
    if (object.hasOwnProperty(key)) clone$$1[key] = object[key];
  }
  return clone$$1;
}

function extract(object, properties, mapFunc) {
  // Takes a list of properties and returns a new object with those
  // properties shallow-copied from object
  var copied = {};
  for (var i = 0; i < properties.length; i++) {
    if (properties[i] in object) copied[properties[i]] = mapFunc ? mapFunc(properties[i], object[properties[i]]) : object[properties[i]];
  }
  return copied;
}

// -=-=-=-=-=-
// inspection
// -=-=-=-=-=-
function inspect(object, options, depth) {
  // Prints a human-readable representation of `obj`. The printed
  // representation will be syntactically correct JavaScript but will not
  // necessarily evaluate to a structurally identical object. `inspect` is
  // meant to be used while interactivively exploring JavaScript programs and
  // state.
  //
  // `options` can be {
  //   printFunctionSource: BOOLEAN,
  //   escapeKeys: BOOLEAN,
  //   maxDepth: NUMBER,
  //   customPrinter: FUNCTION
  // }
  options = options || {};
  depth = depth || 0;

  if (options.customPrinter) {
    var ignoreSignal = options._ignoreSignal || (options._ignoreSignal = {});
    var customInspected = options.customPrinter(object, ignoreSignal);
    if (customInspected !== ignoreSignal) return customInspected;
  }
  if (!object) return print$1(object);

  // print function
  if (typeof object === 'function') {
    return options.printFunctionSource ? String(object) : 'function' + (object.name ? ' ' + object.name : '') + '(' + argumentNames(object).join(',') + ') {/*...*/}';
  }

  // print "primitive"
  switch (object.constructor) {
    case String:
    case Boolean:
    case RegExp:
    case Number:
      return print$1(object);
  }

  if (typeof object.serializeExpr === 'function') return object.serializeExpr();

  var isArray$$1 = object && Array.isArray(object),
      openBr = isArray$$1 ? '[' : '{',
      closeBr = isArray$$1 ? ']' : '}';
  if (options.maxDepth && depth >= options.maxDepth) return openBr + '/*...*/' + closeBr;

  var printedProps = [];
  if (isArray$$1) {
    printedProps = object.map(function (ea) {
      return inspect(ea, options, depth + 1);
    });
  } else {
    printedProps = Object.keys(object).sort(function (a, b) {
      var aIsFunc = typeof object[a] === 'function',
          bIsFunc = typeof object[b] === 'function';
      if (aIsFunc === bIsFunc) {
        if (a < b) return -1;
        if (a > b) return 1;
        return 0;
      }
      return aIsFunc ? 1 : -1;
    }).map(function (key, i) {
      if (isArray$$1) inspect(object[key], options, depth + 1);
      var printedVal = inspect(object[key], options, depth + 1);
      return options.escapeKeys ? JSON.stringify(key) : key + ": " + printedVal;
    });
  }

  if (printedProps.length === 0) {
    return openBr + closeBr;
  }

  var printedPropsJoined = printedProps.join(', '),
      useNewLines = (!isArray$$1 || options.newLineInArrays) && (!options.minLengthForNewLine || printedPropsJoined.length >= options.minLengthForNewLine),
      ind = indent$1('', options.indent || '  ', depth),
      propIndent = indent$1('', options.indent || '  ', depth + 1),
      startBreak = useNewLines && !isArray$$1 ? '\n' + propIndent : '',
      eachBreak = useNewLines ? '\n' + propIndent : '',
      endBreak = useNewLines && !isArray$$1 ? '\n' + ind : '';
  if (useNewLines) printedPropsJoined = printedProps.join(',' + eachBreak);
  return openBr + startBreak + printedPropsJoined + endBreak + closeBr;
}

// -=-=-=-=-
// merging
// -=-=-=-=-
function merge(objs) {
  // `objs` can be a list of objects. The return value will be a new object,
  // containing all properties of all objects. If the same property exist in
  // multiple objects, the right-most property takes precedence.
  //
  // Like `extend` but will not mutate objects in `objs`.

  // if objs are arrays just concat them
  // if objs are real objs then merge propertdies
  if (arguments.length > 1) {
    return merge(Array.prototype.slice.call(arguments));
  }

  if (Array.isArray(objs[0])) {
    // test for all?
    return Array.prototype.concat.apply([], objs);
  }

  return objs.reduce(function (merged, ea) {
    for (var name in ea) {
      if (ea.hasOwnProperty(name)) merged[name] = ea[name];
    }return merged;
  }, {});
}

function deepMerge(objA, objB) {
  // `objs` can be a list of objects. The return value will be a new object,
  // containing all properties of all objects. If the same property exist in
  // multiple objects, the right-most property takes precedence.
  //
  // Like `extend` but will not mutate objects in `objs`.

  // if objs are arrays just concat them
  // if objs are real objs then merge propertdies

  if (!objA) return objB;
  if (!objB) return objA;

  if (Array.isArray(objA)) {
    if (!Array.isArray(objB)) return objB;
    var merged = objA.map(function (ea, i) {
      return deepMerge(ea, objB[i]);
    });
    if (objB.length > objA.length) merged = merged.concat(objB.slice(objA.length));
    return merged;
  }

  if ((typeof objA === "undefined" ? "undefined" : _typeof(objA)) !== "object" || (typeof objB === "undefined" ? "undefined" : _typeof(objB)) !== "object") return objB;

  return Object.keys(objA).concat(Object.keys(objB)).reduce(function (merged, name) {
    if (!objA[name]) merged[name] = objB[name];else if (!objB[name]) merged[name] = objA[name];else if (_typeof(objA[name]) !== "object" || _typeof(objB[name]) !== "object") merged[name] = objB[name];else merged[name] = deepMerge(objA[name], objB[name]);
    return merged;
  }, {});
}

function sortKeysWithBeforeAndAfterConstraints(properties) {
  var throwErrorOnMissing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  // Expects `properties` to be a map of keys to objects having optional
  // before/after attributes that, if present, should be lists of other property
  // keys. `sortProperties` will return an ordered list of property keys so
  // that the before / after requirements are fullfilled. If a cyclic
  // dependency is encountered an error will be thrown.
  // Example:
  // ```
  // sortProperties({foo: {}, bar: {after: ["foo"], before: ["baz"]}, "baz": {after: ["foo"]}})
  // // => ["foo","bar","baz"]
  // ```

  // ignore-in-doc
  // 1. convert "before" requirement into "after" and check if all properties
  // mentioned in after/before are actually there
  var keys = [],
      props = [],
      remaining = [];
  for (var key in properties) {
    var prop = properties[key],
        before = prop.hasOwnProperty("before") ? prop.before : prop.before = [],
        after = prop.hasOwnProperty("after") ? prop.after : prop.after = [];

    keys.push(key);
    props.push(prop);

    for (var i = before.length; i--;) {
      var beforePropName = before[i];
      var beforeProp = properties[beforePropName];
      if (!beforeProp) {
        console.warn("[initializeProperties] " + this + " sortProperties: " + ("Property " + key + " requires to be initialized before " + beforePropName + " ") + "but that property cannot be found.");
        before.splice(i, 1);
        continue;
      }
      if (!beforeProp.hasOwnProperty("after")) beforeProp.after = [];
      beforeProp.after.push(key);
    }

    for (var _i = after.length; _i--;) {
      var afterPropName = after[_i];
      var afterProp = properties[afterPropName];
      if (!afterProp) {
        console.warn("[initializeProperties] " + this + " sortProperties: " + ("Property " + key + " requires to be initialized after " + afterPropName + " ") + "but that property cannot be found.");
        after.splice(_i, 1);
      }
    }

    remaining.push(key);
  }

  // ignore-in-doc
  // compute order
  var resolvedGroups = [],
      resolvedKeys = [],
      lastLength = remaining.length + 1;

  while (remaining.length) {
    if (lastLength === remaining.length) throw new Error("Circular dependencies in handler order, could not resolve properties " + remaining.map(function (key) {
      var before = properties[key].before,
          after = properties[key].after;
      if ((!before || !before.length) && (!after || !after.length)) return "";
      var report = key + "\n";
      if (before && before.length) report += "  - before " + before.join(",") + "\n";
      if (after && after.length) report += "  - after " + after.join(",") + "\n";
      return report;
    }).join(""));
    lastLength = remaining.length;
    var resolvedGroup = [];
    for (var _i2 = remaining.length; _i2--;) {
      var _key = remaining[_i2];
      if (isSubset(properties[_key].after, resolvedKeys)) {
        remaining.splice(_i2, 1);
        resolvedKeys.push(_key);
        resolvedGroup.push(_key);
      }
    }
    resolvedGroups.push(resolvedGroup);
  }

  return flatten(resolvedGroups, 1);
}

// -=-=-=-=-=-=-
// inheritance
// -=-=-=-=-=-=-
function inherit(obj) {
  return Object.create(obj);
}

function valuesInPropertyHierarchy(obj, name) {
  // Lookup all properties named name in the proto hierarchy of obj.
  // Example:
  // var a = {foo: 3}, b = Object.create(a), c = Object.create(b);
  // c.foo = 4;
  // obj.valuesInPropertyHierarchy(c, "foo") // => [3,4]
  var result = [],
      lookupObj = obj;
  while (lookupObj) {
    if (lookupObj.hasOwnProperty(name)) result.unshift(lookupObj[name]);
    lookupObj = Object.getPrototypeOf(lookupObj);
  }
  return result;
}

function mergePropertyInHierarchy(obj, propName) {
  // like `merge` but automatically gets all definitions of the value in the
  // prototype chain and merges those.
  // Example:
  // var o1 = {x: {foo: 23}}, o2 = {x: {foo: 24, bar: 15}}, o3 = {x: {baz: "zork"}};
  // o2.__proto__ = o1; o3.__proto__ = o2;
  // obj.mergePropertyInHierarchy(o3, "x");
  // // => {bar: 15, baz: "zork",foo: 24}
  return merge(valuesInPropertyHierarchy(obj, propName));
}

function deepCopy(object) {
  // Recursively traverses `object` and its properties to create a copy.
  if (!object || (typeof object === "undefined" ? "undefined" : _typeof(object)) !== "object" || object instanceof RegExp) return object;
  var result = Array.isArray(object) ? Array(object.length) : {};
  for (var key in object) {
    if (object.hasOwnProperty(key)) result[key] = deepCopy(object[key]);
  }
  return result;
}

// -=-=-=-=-=-=-=-=-
// stringification
// -=-=-=-=-=-=-=-=-
function typeStringOf(obj) {
  // ignore-in-doc
  if (obj === null) return "null";
  if (typeof obj === "undefined") return "undefined";
  return obj.constructor.name;
}

function shortPrintStringOf(obj) {
  // ignore-in-doc
  // primitive values
  if (!isMutableType(obj)) return safeToString(obj);

  // constructed objects
  if (obj.constructor.name !== 'Object' && !Array.isArray(obj)) {
    if (obj.constructor.name) return obj.constructor.name ? obj.constructor.name : Object.prototype.toString.call(obj).split(" ")[1].split("]")[0];
  }

  // arrays or plain objects
  var typeString = "";

  function displayTypeAndLength(obj, collectionType, firstBracket, secondBracket) {
    if (obj.constructor.name === collectionType) {
      typeString += firstBracket;
      if (obj.length || Object.keys(obj).length) typeString += "...";
      typeString += secondBracket;
    }
  }
  displayTypeAndLength(obj, "Object", "{", "}");
  displayTypeAndLength(obj, "Array", "[", "]");
  return typeString;
}

function isMutableType(obj) {
  // Is `obj` a value or mutable type?
  var immutableTypes = ["null", "undefined", "Boolean", "Number", "String"];
  return immutableTypes.indexOf(typeStringOf(obj)) === -1;
}

function safeToString(obj) {
  // Like `toString` but catches errors.
  try {
    return (obj ? obj.toString() : String(obj)).replace('\n', '');
  } catch (e) {
    return '<error printing object>';
  }
}

function asObject(obj) {
  switch (typeof obj === "undefined" ? "undefined" : _typeof(obj)) {
    case 'string':
      return new String(obj);
    case 'boolean':
      return new Boolean(obj);
    case 'number':
      return new Number(obj);
    default:
      return obj;
  }
}

function newKeyIn(obj) {
  var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "_";

  var i = 1,
      key;
  do {
    key = base + "-" + i++;
  } while (key in obj);
  return key;
}



var obj = Object.freeze({
	isArray: isArray$$1,
	isElement: isElement,
	isFunction: isFunction,
	isBoolean: isBoolean,
	isString: isString,
	isNumber: isNumber,
	isUndefined: isUndefined,
	isRegExp: isRegExp,
	isObject: isObject,
	isPrimitive: isPrimitive,
	isEmpty: isEmpty,
	equals: equals$1,
	keys: keys$1,
	values: values,
	select: select,
	dissoc: dissoc,
	addScript: addScript,
	extend: extend,
	clone: clone$$1,
	extract: extract,
	inspect: inspect,
	merge: merge,
	deepMerge: deepMerge,
	inherit: inherit,
	valuesInPropertyHierarchy: valuesInPropertyHierarchy,
	mergePropertyInHierarchy: mergePropertyInHierarchy,
	sortKeysWithBeforeAndAfterConstraints: sortKeysWithBeforeAndAfterConstraints,
	deepCopy: deepCopy,
	typeStringOf: typeStringOf,
	shortPrintStringOf: shortPrintStringOf,
	isMutableType: isMutableType,
	safeToString: safeToString,
	asObject: asObject,
	newKeyIn: newKeyIn
});

/*global btoa*/

// String utility methods for printing, parsing, and converting strings.

var features = {
  repeat: !!String.prototype.repeat,
  includes: !!String.prototype.includes,
  startsWith: !!String.prototype.startsWith,
  endsWith: !!String.prototype.endsWith
};

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// printing and formatting strings
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

function format() {
  // String+ -> String
  // Takes a variable number of arguments. The first argument is the format
  // string. Placeholders in the format string are marked with `"%s"`.
  // Example:
  //   lively.lang.string.format("Hello %s!", "Lively User"); // => "Hello Lively User!"
  return formatFromArray(Array.prototype.slice.call(arguments));
}

function formatFromArray(objects) {
  var self = objects.shift();
  if (!self) {
    console.log("Error in Strings>>formatFromArray, first arg is undefined");
  }

  function appendText(object, string) {
    return "" + object;
  }

  function appendInteger(value, string) {
    return value.toString();
  }

  function appendFloat(value, string, precision) {
    if (precision > -1) return value.toFixed(precision);else return value.toString();
  }

  function appendObject(value, string) {
    return inspect(value);
  }

  var appenderMap = { s: appendText, d: appendInteger, i: appendInteger, f: appendFloat, o: appendObject };
  var reg = /((^%|[^\\]%)(\d+)?(\.)([a-zA-Z]))|((^%|[^\\]%)([a-zA-Z]))/;

  function parseFormat(fmt) {
    var oldFmt = fmt;
    var parts = [];

    for (var m = reg.exec(fmt); m; m = reg.exec(fmt)) {
      var type = m[8] || m[5],
          appender = type in appenderMap ? appenderMap[type] : appendObject,
          precision = m[3] ? parseInt(m[3]) : m[4] == "." ? -1 : 0;
      parts.push(fmt.substr(0, m[0][0] == "%" ? m.index : m.index + 1));
      parts.push({ appender: appender, precision: precision });

      fmt = fmt.substr(m.index + m[0].length);
    }
    if (fmt) parts.push(fmt.toString());

    return parts;
  }

  var parts = parseFormat(self),
      str = "",
      objIndex = 0;

  for (var i = 0; i < parts.length; ++i) {
    var part = parts[i];
    if (part && (typeof part === "undefined" ? "undefined" : _typeof(part)) == "object") {
      var object = objects[objIndex++];
      str += (part.appender || appendText)(object, str, part.precision);
    } else {
      str += appendText(part, str);
    }
  }
  return str;
}

function indent(str, indentString, depth) {
  // String -> String -> String? -> String
  // Example:
  //   string.indent("Hello", "  ", 2) // => "    Hello"
  if (!depth || depth <= 0) return str;
  var indent = "";while (depth > 0) {
    depth--;indent += indentString;
  }
  return lines(str).map(function (line) {
    return indent + line;
  }).join("\n");
}

function minIndent(str, indentString) {
  // Find out what the minum indentation of the text in str is
  // Example:
  //   minIndent("    Hello", "  ") // => 2
  if (!indentString) indentString = "  ";
  var indentRe = new RegExp("^(" + indentString + ")*", "gm");
  return min(str.match(indentRe).map(function (ea) {
    return Math.floor(ea.length / indentString.length);
  }));
}

function changeIndent(str, indentString, depth) {
  // Add or remove indent from lines in str to match depth
  // Example:
  //   string.changeIndent("    Hello", "  ", 1) // => "  Hello"
  if (!indentString) indentString = "  ";
  if (!depth) depth = 0;
  var existingIndent = minIndent(str, indentString);
  if (existingIndent === depth) return str;
  if (existingIndent < depth) return indent(str, indentString, depth - existingIndent);
  var prefixToRemove = indentString.repeat(existingIndent - depth);
  return lines(str).map(function (line) {
    return line.slice(prefixToRemove.length);
  }).join("\n");
}

function quote(str) {
  // Example:
  //   string.print("fo\"o") // => "\"fo\\\"o\""
  return '"' + str.replace(/"/g, '\\"') + '"';
}

function print(obj) {
  // Prints Arrays and escapes quotations. See `obj.inspect` for how to
  // completely print / inspect JavaScript data strcutures
  // Example:
  //   string.print([[1,2,3], "string", {foo: 23}])
  //      // => [[1,2,3],"string",[object Object]]
  if (obj && Array.isArray(obj)) return '[' + obj.map(print) + ']';
  if (typeof obj !== "string") return String(obj);
  var result = String(obj);
  result = result.replace(/\n/g, '\\n\\\n');
  result = result.replace(/(")/g, '\\$1');
  result = '\"' + result + '\"';
  return result;
}

function printNested(list, depth) {
  // Example:
  //   string.printNested([1,2,[3,4,5]]) // => "1\n2\n  3\n  4\n  5\n"
  depth = depth || 0;
  return list.reduce(function (s, ea) {
    return s += Array.isArray(ea) ? printNested(ea, depth + 1) : indent(ea + "\n", '  ', depth);
  }, "");
}

function pad(string, n, left) {
  // Examples:
  // pad("Foo", 2) // => "Foo  "
  // pad("Foo", 2, true) // => "  Foo"
  return left ? ' '.repeat(n) + string : string + ' '.repeat(n);
}

function printTable(tableArray, options) {
  // Array -> Object? -> String
  // Takes a 2D Array and prints a table string. Kind of the reverse
  // operation to `tableize`
  // Example:
  //   string.printTable([["aaa", "b", "c"], ["d", "e","f"]])
  //    // =>
  //    // aaa b c
  //    // d   e f
  var columnWidths = [],
      separator = options && options.separator || ' ',
      alignLeftAll = !options || !options.align || options.align === 'left',
      alignRightAll = options && options.align === 'right';
  function alignRight(columnIndex) {
    if (alignLeftAll) return false;
    if (alignRightAll) return true;
    return options && Array.isArray(options.align) && options.align[columnIndex] === 'right';
  }
  tableArray.forEach(function (row) {
    row.forEach(function (cellVal, i) {
      if (columnWidths[i] === undefined) columnWidths[i] = 0;
      columnWidths[i] = Math.max(columnWidths[i], String(cellVal).length);
    });
  });
  return tableArray.map(function (row) {
    return row.map(function (cellVal, i) {
      var cellString = String(cellVal);
      return pad(cellString, columnWidths[i] - cellString.length, alignRight(i));
    }).join(separator);
  }).join('\n');
}

function printTree(rootNode, nodePrinter, childGetter, indent) {
  // Object -> Function -> Function -> Number? -> String
  // A generic function to print a tree representation from a nested data structure.
  // Receives three arguments:
  // - `rootNode` an object representing the root node of the tree
  // - `nodePrinter` is a function that gets a tree node and should return stringified version of it
  // - `childGetter` is a function that gets a tree node and should return a list of child nodes
  // Example:
  // var root = {name: "a", subs: [{name: "b", subs: [{name: "c"}]}, {name: "d"}]};
  // string.printTree(root, function(n) { return n.name; }, function(n) { return n.subs; });
  // // =>
  // // a
  // // |-b
  // // | \-c
  // // \-d

  var nodeList = [];
  indent = indent || '  ';
  iterator(0, 0, rootNode);
  return nodeList.join('\n');
  // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  function iterator(depth, index, node) {
    // ignore-in-doc
    // 1. Create stringified representation of node
    nodeList[index] = indent.repeat(depth) + nodePrinter(node, depth);
    var children = childGetter(node, depth),
        childIndex = index + 1;
    if (!children || !children.length) return childIndex;
    // 2. If there are children then assemble those linear inside nodeList
    // The childIndex is the pointer of the current items of childList into
    // nodeList.
    var lastIndex = childIndex,
        lastI = children.length - 1;
    children.forEach(function (ea, i) {
      childIndex = iterator(depth + 1, childIndex, ea);
      // 3. When we have printed the recursive version then augment the
      // printed version of the direct children with horizontal slashes
      // directly in front of the represented representation
      var isLast = lastI === i,
          cs = nodeList[lastIndex].split(''),
          fromSlash = depth * indent.length + 1,
          toSlash = depth * indent.length + indent.length;
      for (var i = fromSlash; i < toSlash; i++) {
        cs[i] = '-';
      }if (isLast) cs[depth * indent.length] = '\\';
      nodeList[lastIndex] = cs.join('');
      // 4. For all children (direct and indirect) except for the
      // last one (itself and all its children) add vertical bars in
      // front of each at position of the current nodes depth. This
      // makes is much easier to see which child node belongs to which
      // parent
      if (!isLast) nodeList.slice(lastIndex, childIndex).forEach(function (ea, i) {
        var cs2 = ea.split('');
        cs2[depth * indent.length] = '|';
        nodeList[lastIndex + i] = cs2.join('');
      });
      lastIndex = childIndex;
    });
    return childIndex;
  }
}

function toArray$1(s) {
  // Example:
  // string.toArray("fooo") // => ["f","o","o","o"]
  return s.split('');
}

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// parsing strings into other entities
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

function lines(str) {
  // Example: string.lines("foo\nbar\n\rbaz") // => ["foo","bar","baz"]
  return str.split(/\n\r?/);
}

function paragraphs(string, options) {
  // Examples:
  // var text = "Hello, this is a pretty long sentence\nthat even includes new lines."
  //         + "\n\n\nThis is a sentence in  a new paragraph.";
  // string.paragraphs(text) // => [
  //   // "Hello, this is a pretty long sentence\nthat even includes new lines.",
  //   // "This is a sentence in  a new paragraph."]
  // string.paragraphs(text, {keepEmptyLines: true}) // => [
  //   // "Hello, this is a pretty long sentence\n that even includes new lines.",
  //   // "\n ",
  //   // "This is a sentence in  a new paragraph."]
  var sep = options ? options.sep : '\n\n';
  if (!options || !options.keepEmptyLines) return string.split(new RegExp(sep + '+'));
  function isWhiteSpace(s) {
    return (/^\s*$/.test(s)
    );
  }
  return string.split('\n').concat('').reduce(function (parasAndLast, line) {
    var paras = parasAndLast[0],
        last$$1 = parasAndLast[1];
    if (isWhiteSpace(last$$1) === isWhiteSpace(line)) {
      last$$1 += '\n' + line;
    } else {
      last$$1.length && paras.push(last$$1);last$$1 = line;
    }
    return [paras, last$$1];
  }, [[], ''])[0];
}

function nonEmptyLines(str) {
  // Example: string.nonEmptyLines("foo\n\nbar\n") // => ["foo","bar"]
  return lines(str).compact();
}

function tokens(str, regex) {
  // Example:
  // string.tokens(' a b c') => ['a', 'b', 'c']
  return str.split(regex || /\s+/).filter(function (tok) {
    return !/^\s*$/.test(tok);
  });
}

function tableize(s, options) {
  // String -> Object? -> Array
  // Takes a String representing a "table" and parses it into a 2D-Array (as
  // accepted by the `collection.Grid` methods or `string.printTable`)
  // ```js
  // options = {
  //     convertTypes: BOOLEAN, // automatically convert to Numbers, Dates, ...?
  //     cellSplitter: REGEXP // how to recognize "cells", by default just spaces
  // }
  // ```
  // Examples:
  // string.tableize('a b c\nd e f')
  // // => [["a","b","c"],["d","e","f"]]
  // // can also parse csv like
  // var csv = '"Symbol","Name","LastSale",\n'
  //         + '"FLWS","1-800 FLOWERS.COM, Inc.","5.65",\n'
  //         + '"FCTY","1st Century Bancshares, Inc","5.65",'
  // string.tableize(csv, {cellSplitter: /^\s*"|","|",?\s*$/g})
  // // => [["Symbol","Name","LastSale"],
  // //     ["FLWS","1-800 FLOWERS.COM, Inc.",5.65],
  // //     ["FCTY","1st Century Bancshares, Inc",5.65]]

  options = options || {};
  var splitter = options.cellSplitter || /\s+/,
      emptyStringRe = /^\s*$/,
      convertTypes = options.hasOwnProperty('convertTypes') ? !!options.convertTypes : true,
      _lines = lines(s),
      table = [];
  for (var i = 0; i < _lines.length; i++) {
    var _tokens = tokens(_lines[i], splitter);
    if (convertTypes) {
      _tokens = _tokens.map(function (tok) {
        if (tok.match(emptyStringRe)) return tok;
        var num = Number(tok);
        if (!isNaN(num)) return num;
        var date = new Date(tok);
        if (!isNaN(+date)) return date;
        return tok.trim();
      });
    }
    if (_tokens.length > 0) table.push(_tokens);
  }
  return table;
}

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// (un)escape / encoding / decoding
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

function unescapeCharacterEntities(s) {
  // Converts [character entities](http://dev.w3.org/html5/html-author/charref)
  // into utf-8 strings
  // Example:
  //   string.unescapeCharacterEntities("foo &amp;&amp; bar") // => "foo && bar"
  if (typeof document === 'undefined') throw new Error("Cannot unescapeCharacterEntities");
  var div = document.createElement('div');
  div.innerHTML = s;
  return div.textContent;
}

function toQueryParams(s, separator) {
  // Example:
  // string.toQueryParams("http://example.com?foo=23&bar=test")
  //   // => {bar: "test", foo: "23"}
  var match = s.trim().match(/([^?#]*)(#.*)?$/);
  if (!match) return {};

  var hash = match[1].split(separator || '&').inject({}, function (hash, pair) {
    if ((pair = pair.split('='))[0]) {
      var key = decodeURIComponent(pair.shift());
      var value = pair.length > 1 ? pair.join('=') : pair[0];
      if (value != undefined) value = decodeURIComponent(value);

      if (key in hash) {
        if (!Array.isArray(hash[key])) hash[key] = [hash[key]];
        hash[key].push(value);
      } else hash[key] = value;
    }
    return hash;
  });
  return hash;
}

// -=-=-=-=-=-=-=-=-=-=-=-=-
// file system path support
// -=-=-=-=-=-=-=-=-=-=-=-=-
function joinPath() /*paths*/{
  // Joins the strings passed as paramters together so that ea string is
  // connected via a single "/".
  // Example:
  // string.joinPath("foo", "bar") // => "foo/bar";
  var args = Array.prototype.slice.call(arguments);
  return args.reduce(function (path, ea) {
    return typeof ea === "string" ? path.replace(/\/*$/, "") + "/" + ea.replace(/^\/*/, "") : path;
  });
}

// -=-=-=-=-=-=-=-=-
// ids and hashing
// -=-=-=-=-=-=-=-=-

function newUUID() {
  // Example:
  //   string.newUUID() // => "3B3E74D0-85EA-45F2-901C-23ECF3EAB9FB"
  var id = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0,
        v = c == 'x' ? r : r & 0x3 | 0x8;
    return v.toString(16);
  }).toUpperCase();
  return id;
}

function createDataURI(content, mimeType) {
  // String -> String -> String
  // Takes some string representing content and a mime type.
  // For a list of mime types see: [http://www.iana.org/assignments/media-types/media-types.xhtml]()
  // More about data URIs: [https://developer.mozilla.org/en-US/docs/Web/HTTP/data_URIs]()
  // Example:
  //   window.open(string.createDataURI('<h1>test</h1>', 'text/html'));
  mimeType = mimeType || "text/plain";
  return "data:" + mimeType + ";base64," + btoa(content);
}

function hashCode(s) {
  // [http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/]()
  // Example: string.hashCode("foo") // => 101574
  var hash = 0,
      len = s.length;
  if (len == 0) return hash;
  for (var i = 0; i < len; i++) {
    var c = s.charCodeAt(i);
    hash = (hash << 5) - hash + c;
    hash = hash & hash; // Convert to 32bit integer
  }
  return hash;
}

function md5(string) {
  // © Joseph Myers [http://www.myersdaily.org/joseph/javascript/md5-text.html]()
  // Example:
  //   string.md5("foo") // => "acbd18db4cc2f85cedef654fccc4a4d8"

  /* ignore-in-doc
  this function is much faster,
  so if possible we use it. Some IEs
  are the only ones I know of that
  need the idiotic second function,
  generated by an if clause.  */
  // var add32 = hex(md51("hello")) === "5d41402abc4b2a76b9719d911017c592" ?
  //   function add32(a, b) { return (a + b) & 0xFFFFFFFF; } :
  var add32 = function add32(x, y) {
    var lsw = (x & 0xFFFF) + (y & 0xFFFF),
        msw = (x >> 16) + (y >> 16) + (lsw >> 16);
    return msw << 16 | lsw & 0xFFFF;
  };

  function cmn(q, a, b, x, s, t) {
    a = add32(add32(a, q), add32(x, t));
    return add32(a << s | a >>> 32 - s, b);
  }

  function ff(a, b, c, d, x, s, t) {
    return cmn(b & c | ~b & d, a, b, x, s, t);
  }

  function gg(a, b, c, d, x, s, t) {
    return cmn(b & d | c & ~d, a, b, x, s, t);
  }

  function hh(a, b, c, d, x, s, t) {
    return cmn(b ^ c ^ d, a, b, x, s, t);
  }

  function ii(a, b, c, d, x, s, t) {
    return cmn(c ^ (b | ~d), a, b, x, s, t);
  }

  function md5cycle(x, k) {
    var a = x[0],
        b = x[1],
        c = x[2],
        d = x[3];

    a = ff(a, b, c, d, k[0], 7, -680876936);
    d = ff(d, a, b, c, k[1], 12, -389564586);
    c = ff(c, d, a, b, k[2], 17, 606105819);
    b = ff(b, c, d, a, k[3], 22, -1044525330);
    a = ff(a, b, c, d, k[4], 7, -176418897);
    d = ff(d, a, b, c, k[5], 12, 1200080426);
    c = ff(c, d, a, b, k[6], 17, -1473231341);
    b = ff(b, c, d, a, k[7], 22, -45705983);
    a = ff(a, b, c, d, k[8], 7, 1770035416);
    d = ff(d, a, b, c, k[9], 12, -1958414417);
    c = ff(c, d, a, b, k[10], 17, -42063);
    b = ff(b, c, d, a, k[11], 22, -1990404162);
    a = ff(a, b, c, d, k[12], 7, 1804603682);
    d = ff(d, a, b, c, k[13], 12, -40341101);
    c = ff(c, d, a, b, k[14], 17, -1502002290);
    b = ff(b, c, d, a, k[15], 22, 1236535329);

    a = gg(a, b, c, d, k[1], 5, -165796510);
    d = gg(d, a, b, c, k[6], 9, -1069501632);
    c = gg(c, d, a, b, k[11], 14, 643717713);
    b = gg(b, c, d, a, k[0], 20, -373897302);
    a = gg(a, b, c, d, k[5], 5, -701558691);
    d = gg(d, a, b, c, k[10], 9, 38016083);
    c = gg(c, d, a, b, k[15], 14, -660478335);
    b = gg(b, c, d, a, k[4], 20, -405537848);
    a = gg(a, b, c, d, k[9], 5, 568446438);
    d = gg(d, a, b, c, k[14], 9, -1019803690);
    c = gg(c, d, a, b, k[3], 14, -187363961);
    b = gg(b, c, d, a, k[8], 20, 1163531501);
    a = gg(a, b, c, d, k[13], 5, -1444681467);
    d = gg(d, a, b, c, k[2], 9, -51403784);
    c = gg(c, d, a, b, k[7], 14, 1735328473);
    b = gg(b, c, d, a, k[12], 20, -1926607734);

    a = hh(a, b, c, d, k[5], 4, -378558);
    d = hh(d, a, b, c, k[8], 11, -2022574463);
    c = hh(c, d, a, b, k[11], 16, 1839030562);
    b = hh(b, c, d, a, k[14], 23, -35309556);
    a = hh(a, b, c, d, k[1], 4, -1530992060);
    d = hh(d, a, b, c, k[4], 11, 1272893353);
    c = hh(c, d, a, b, k[7], 16, -155497632);
    b = hh(b, c, d, a, k[10], 23, -1094730640);
    a = hh(a, b, c, d, k[13], 4, 681279174);
    d = hh(d, a, b, c, k[0], 11, -358537222);
    c = hh(c, d, a, b, k[3], 16, -722521979);
    b = hh(b, c, d, a, k[6], 23, 76029189);
    a = hh(a, b, c, d, k[9], 4, -640364487);
    d = hh(d, a, b, c, k[12], 11, -421815835);
    c = hh(c, d, a, b, k[15], 16, 530742520);
    b = hh(b, c, d, a, k[2], 23, -995338651);

    a = ii(a, b, c, d, k[0], 6, -198630844);
    d = ii(d, a, b, c, k[7], 10, 1126891415);
    c = ii(c, d, a, b, k[14], 15, -1416354905);
    b = ii(b, c, d, a, k[5], 21, -57434055);
    a = ii(a, b, c, d, k[12], 6, 1700485571);
    d = ii(d, a, b, c, k[3], 10, -1894986606);
    c = ii(c, d, a, b, k[10], 15, -1051523);
    b = ii(b, c, d, a, k[1], 21, -2054922799);
    a = ii(a, b, c, d, k[8], 6, 1873313359);
    d = ii(d, a, b, c, k[15], 10, -30611744);
    c = ii(c, d, a, b, k[6], 15, -1560198380);
    b = ii(b, c, d, a, k[13], 21, 1309151649);
    a = ii(a, b, c, d, k[4], 6, -145523070);
    d = ii(d, a, b, c, k[11], 10, -1120210379);
    c = ii(c, d, a, b, k[2], 15, 718787259);
    b = ii(b, c, d, a, k[9], 21, -343485551);

    x[0] = add32(a, x[0]);
    x[1] = add32(b, x[1]);
    x[2] = add32(c, x[2]);
    x[3] = add32(d, x[3]);
  }

  function md51(s) {
    var n = s.length,
        state = [1732584193, -271733879, -1732584194, 271733878],
        i;
    for (i = 64; i <= n; i += 64) {
      md5cycle(state, md5blk(s.substring(i - 64, i)));
    }
    s = s.substring(i - 64);
    var tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        sl = s.length;
    for (i = 0; i < sl; i++) {
      tail[i >> 2] |= s.charCodeAt(i) << (i % 4 << 3);
    }tail[i >> 2] |= 0x80 << (i % 4 << 3);
    if (i > 55) {
      md5cycle(state, tail);
      i = 16;
      while (i--) {
        tail[i] = 0;
      }
      //			for (i=0; i<16; i++) tail[i] = 0;
    }
    tail[14] = n * 8;
    md5cycle(state, tail);
    return state;
  }

  /* ignore-in-doc
   * there needs to be support for Unicode here,
   * unless we pretend that we can redefine the MD-5
   * algorithm for multi-byte characters (perhaps
   * by adding every four 16-bit characters and
   * shortening the sum to 32 bits). Otherwise
   * I suggest performing MD-5 as if every character
   * was two bytes--e.g., 0040 0025 = @%--but then
   * how will an ordinary MD-5 sum be matched?
   * There is no way to standardize text to something
   * like UTF-8 before transformation; speed cost is
   * utterly prohibitive. The JavaScript standard
   * itself needs to look at this: it should start
   * providing access to strings as preformed UTF-8
   * 8-bit unsigned value arrays.
   */
  function md5blk(s) {
    // ignore-in-doc
    /* I figured global was faster.   */
    var md5blks = [],
        i; /* Andy King said do it this way. */
    for (i = 0; i < 64; i += 4) {
      md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
    }
    return md5blks;
  }

  var hex_chr = '0123456789abcdef'.split('');

  function rhex(n) {
    var s = '',
        j = 0;
    for (; j < 4; j++) {
      s += hex_chr[n >> j * 8 + 4 & 0x0F] + hex_chr[n >> j * 8 & 0x0F];
    }return s;
  }

  function hex(x) {
    var l = x.length;
    for (var i = 0; i < l; i++) {
      x[i] = rhex(x[i]);
    }return x.join('');
  }

  return hex(md51(string));
}

// -=-=-=-=-=-=-=-=-=-=-=-=-=-
// matching strings / regexps
// -=-=-=-=-=-=-=-=-=-=-=-=-=-

function reMatches$$1(string, re) {
  // Different to the native `match` function this method returns an object
  // with `start`, `end`, and `match` fields
  // Example:
  //   string.reMatches("Hello World", /o/g)
  //   // => [{start: 4, end: 5, match: "o"},{start: 7, end: 8, match: "o"}]
  var matches = [];
  string.replace(re, function (match, idx) {
    matches.push({ match: match, start: idx, end: idx + match.length });
  });
  return matches;
}

function stringMatch(s, patternString, options) {
  // returns `{matched: true}` if success otherwise
  // `{matched: false, error: EXPLANATION, pattern: STRING|RE, pos: NUMBER}`
  // Example:
  //   string.stringMatch("foo 123 bar", "foo __/[0-9]+/__ bar") // => {matched: true}
  //   string.stringMatch("foo aaa bar", "foo __/[0-9]+/__ bar")
  //     // => {
  //     //   error: "foo <--UNMATCHED-->aaa bar",
  //     //   matched: false,
  //     //   pattern: /[0-9]+/,
  //     //   pos: 4
  //     // }
  options = options || {};
  if (!!options.normalizeWhiteSpace) s = s.replace(/\s+/g, ' ');
  if (!!options.ignoreIndent) {
    s = s.replace(/^\s+/gm, '');
    patternString = patternString.replace(/^\s+/gm, '');
  }
  return s == patternString ? { matched: true } : embeddedReMatch(s, patternString);

  // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  function splitInThree(string, start, end, startGap, endGap) {
    // ignore-in-doc
    // split string at start and end
    // return (0, start), (start, end), (end, ...)
    startGap = startGap || 0;endGap = endGap || 0;
    return [string.slice(0, start), string.slice(start + startGap, end - endGap), string.slice(end)];
  }

  function matchStringForward(s, pattern) {
    // ignore-in-doc
    // try to match pattern at beginning of string. if matched, return
    // result object with {
    //   match: STRING,
    //   REST: STRING -- remaining string after pattern was consumed
    // }
    if (pattern.constructor !== RegExp) {
      var idx = s.indexOf(pattern);
      if (idx === 0) return { match: pattern, rest: s.slice(pattern.length) };
      // no match
      for (var i = 0; i < pattern.length; i++) {
        // figure out where we failed
        if (pattern[i] != s[i]) return { match: null, pos: i };
      }return { match: null };
    }
    var matches = reMatches$$1(s, pattern);
    // show(matches)
    // show(string.slice(matches[0].end));
    return !matches || !matches.length || matches[0].start !== 0 ? { match: null } : { match: matches[0].match, rest: s.slice(matches[0].end) };
  }

  function matchStringForwardWithAllPatterns(s, patterns) {
    // ignore-in-doc
    // like matchStringForward, just apply list of patterns
    var pos = 0;
    for (var i = 0; i < patterns.length; i++) {
      var p = patterns[i],
          result = matchStringForward(s, p);
      if (!result.match) return { matched: false, pos: pos + (result.pos || 0), pattern: p };
      pos += result.match.length;
      s = result.rest;
    }
    return s.length ? { matched: false, pos: pos } : { matched: true };
  }

  function splitIntoPatterns(matcher) {
    var starts = reMatches$$1(matcher, /__\//g),
        ends = reMatches$$1(matcher, /\/__/g);
    if (starts.length !== ends.length) {
      throw new Error("pattern invalid: " + matcher + " cannot be split into __/.../__ embedded RegExps" + "\nstarts: " + JSON.stringify(starts) + '\nvs ends:\n' + JSON.stringify(ends));
    }
    var consumed = 0;
    return starts.reduce(function (patterns, start, i) {
      var end = ends[i];
      var matcher = patterns.pop();
      var splitted = splitInThree(matcher, start.start - consumed, end.end - consumed, 3, 3);
      if (splitted[0].length) {
        patterns.push(splitted[0]);
        consumed += splitted[0].length;
      }
      try {
        if (splitted[1].length) {
          patterns.push(new RegExp(splitted[1]));
          consumed += splitted[1].length + 3 + 3;
        }
      } catch (e) {
        throw new Error("Cannot create pattern re from: " + inspect(splitted));
      }
      if (splitted[2].length) {
        patterns.push(splitted[2]);
      }
      return patterns;
    }, [matcher]);
  }

  function embeddedReMatch(s, patternString) {
    // ignore-in-doc
    // the main match func
    var patterns = splitIntoPatterns(patternString);
    var result = matchStringForwardWithAllPatterns(s, patterns);
    if (result.matched) return result;
    result.error = s.slice(0, result.pos) + '<--UNMATCHED-->' + s.slice(result.pos);
    return result;
  }
}

function peekRight(s, start, needle) {
  // Finds the next occurence of `needle` (String or RegExp). Returns delta
  // index.
  // Example:
  // peekRight("Hello World", 0, /o/g) // => 4
  // peekRight("Hello World", 5, /o/) // => 2
  s = s.slice(start);
  if (typeof needle === 'string') {
    var idx = s.indexOf(needle);
    return idx === -1 ? null : idx + start;
  } else if (needle.constructor === RegExp) {
    var matches = reMatches$$1(s, needle);
    return matches[0] ? matches[0].start : null;
  }
  return null;
}

function peekLeft(s, start, needle) {
  // Similar to `peekRight`
  s = s.slice(0, start);
  if (typeof needle === 'string') {
    var idx = s.lastIndexOf(needle);
    return idx === -1 ? null : idx;
  } else if (needle.constructor === RegExp) {
    var matches = reMatches$$1(s, needle);
    return last(matches) ? last(matches).start : null;
  }
  return null;
}

function lineIndexComputer(s) {
  // String -> Function
  // For converting character positions to line numbers.
  // Returns a function accepting char positions. If the char pos is outside
  // of the line ranges -1 is returned.
  // Example:
  // var idxComp = lineIndexComputer("Hello\nWorld\n\nfoo");
  // idxComp(3) // => 0 (index 3 is "l")
  // idxComp(6) // => 1 (index 6 is "W")
  // idxComp(12) // => 2 (index 12 is "\n")

  // ignore-in-doc
  // line ranges: list of numbers, each line has two entries:
  // i -> start of line, i+1 -> end of line
  var _lineRanges = lineRanges(s);
  // ignore-in-doc
  // FIXME, this is O(n). Make cumputation more efficient, binary lookup?
  return function (pos) {
    for (var line = 0; line < _lineRanges.length; line++) {
      var lineRange = _lineRanges[line];
      if (pos >= lineRange[0] && pos < lineRange[1]) return line;
    }
    return -1;
  };
}

function lineNumberToIndexesComputer(s) {
  // String -> Function
  // For converting line numbers to [startIndex, endIndex]
  // Example:
  // var idxComp = lineNumberToIndexesComputer("Hello\nWorld\n\nfoo");
  // idxComp(1) // => [6,12]
  return function (lineNo) {
    return lineRanges(s)[lineNo];
  };
}

function lineRanges(s) {
  return lines(s).reduce(function (akk, line) {
    var start = akk.indexCount,
        end = akk.indexCount + line.length + 1;
    akk.lineRanges.push([start, end]);
    akk.indexCount = end;
    return akk;
  }, { lineRanges: [], indexCount: 0 }).lineRanges;
}

// -=-=-=-=-
// diffing
// -=-=-=-=-

function diff(s1, s2) {
  if (typeof JsDiff === "undefined") return 'diff not supported';
  return JsDiff.convertChangesToXML(JsDiff.diffWordsWithSpace(s1, s2));
}

// -=-=-=-=-
// testing
// -=-=-=-=-

function empty(s) {
  // show-in-doc
  return s == '';
}

var includes$$1 = features.includes ? function (s, pattern) {
  return s.includes(pattern);
} : function (s, pattern) {
  // Example:
  // include("fooo!", "oo") // => true
  return s.indexOf(pattern) > -1;
};

var include$$1 = includes$$1;

var startsWith = features.startsWith ? function (s, pattern) {
  return s.startsWith(pattern);
} : function (s, pattern) {
  // Example:
  // startsWith("fooo!", "foo") // => true
  return s.indexOf(pattern) === 0;
};

function startsWithVowel(s) {
  // show-in-doc
  var c = s[0];
  return c === 'A' || c === 'E' || c === 'I' || c === 'O' || c === 'U' || c === 'a' || c === 'e' || c === 'i' || c === 'o' || c === 'u' || false;
}

var endsWith = features.endsWith ? function (s, pattern) {
  return s.endsWith(pattern);
} : function (s, pattern) {
  // Example:
  // endsWith("fooo!", "o!") // => true
  var d = s.length - pattern.length;
  return d >= 0 && s.lastIndexOf(pattern) === d;
};

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// string conversion and manipulation
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

function withDecimalPrecision(str, precision) {
  // String -> Number -> String
  // Example: withDecimalPrecision("1.12345678", 3) // => "1.123"
  var floatValue = parseFloat(str);
  return isNaN(floatValue) ? str : floatValue.toFixed(precision);
}

function capitalize(s) {
  // Example:
  // capitalize("foo bar") // => "Foo bar"
  return s.length ? s.charAt(0).toUpperCase() + s.slice(1) : s;
}

function camelCaseString(s) {
  // Spaces to camels, including first char
  // Example: camelCaseString("foo bar baz") // => "FooBarBaz"
  return s.split(" ").invoke('capitalize').join("");
}

function camelize(s) {
  // Dashes to camels, excluding first char
  // Example: camelize("foo-bar-baz") // => "fooBarBaz"
  var parts = s.split('-'),
      len = parts.length;
  if (len == 1) return parts[0];

  var camelized = s.charAt(0) == '-' ? parts[0].charAt(0).toUpperCase() + parts[0].substring(1) : parts[0];
  for (var i = 1; i < len; i++) {
    camelized += parts[i].charAt(0).toUpperCase() + parts[i].substring(1);
  }return camelized;
}

function truncate(s, length, truncation) {
  // Enforces that s is not more then `length` characters long.
  // Example:
  // truncate("123456789", 5) // => "12..."
  length = length || 30;
  truncation = truncation === undefined ? '...' : truncation;
  return s.length > length ? s.slice(0, length - truncation.length) + truncation : String(s);
}

function truncateLeft(s, length, truncation) {
  // Enforces that s is not more then `length` characters long.
  // Example:
  // truncate("123456789", 5) // => "12..."
  length = length || 30;
  truncation = truncation === undefined ? '...' : truncation;
  return s.length > length ? truncation + s.slice(-length) : String(s);
}

function regExpEscape(s) {
  // For creating RegExps from strings and not worrying about proper escaping
  // of RegExp special characters to literally match those.
  // Example:
  // var re = new RegExp(regExpEscape("fooo{20}"));
  // re.test("fooo") // => false
  // re.test("fooo{20}") // => true
  return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
}

function succ(s) {
  // Uses char code.
  // Example:
  // succ("a") // => "b"
  // succ("Z") // => "["
  return s.slice(0, s.length - 1) + String.fromCharCode(s.charCodeAt(s.length - 1) + 1);
}

function digitValue(s) {
  // ignore-in-doc
  return s.charCodeAt(0) - "0".charCodeAt(0);
}

var times = features.repeat ? function (s, count$$1) {
  return s.repeat(count$$1);
} : function (s, count$$1) {
  // Example:
  // string.times("test", 3) // => "testtesttest"
  return count$$1 < 1 ? '' : new Array(count$$1 + 1).join(s);
};

function applyChange(string, change) {
  // change is of the form
  // `{start: Number, end: Number, lines: [String], action: "insert"|"remove"}`
  if (change.action === "insert") {
    return string.slice(0, change.start) + change.lines.join("\n") + string.slice(change.start);
  } else if (change.action === "remove") {
    return string.slice(0, change.start) + string.slice(change.end);
  }
  return string;
}

function applyChanges(s, changes) {
  return changes.reduce(function (result, change) {
    return applyChange(s, change);
  }, s);
}

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// diffing / comparing

function levenshtein(a, b) {
  // How many edit operations separate string a from b?
  // MIT licensed, https://gist.github.com/andrei-
  // Copyright (c) 2011 Andrei Mackenzie and https://github.com/kigiri
  if (a.length === 0) return b.length;
  if (b.length === 0) return a.length;
  var tmp, i, j, prev, val, row;
  // swap to save some memory O(min(a,b)) instead of O(a)
  if (a.length > b.length) {
    tmp = a;a = b;b = tmp;
  }

  row = Array(a.length + 1);
  // init the row
  for (i = 0; i <= a.length; i++) {
    row[i] = i;
  } // fill in the rest
  for (i = 1; i <= b.length; i++) {
    prev = i;
    for (j = 1; j <= a.length; j++) {
      if (b[i - 1] === a[j - 1]) {
        val = row[j - 1]; // match
      } else {
        val = Math.min(row[j - 1] + 1, // substitution
        Math.min(prev + 1, // insertion
        row[j] + 1)); // deletion
      }
      row[j - 1] = prev;
      prev = val;
    }
    row[a.length] = prev;
  }
  return row[a.length];
}



var string = Object.freeze({
	format: format,
	formatFromArray: formatFromArray,
	indent: indent,
	minIndent: minIndent,
	changeIndent: changeIndent,
	quote: quote,
	print: print,
	printNested: printNested,
	pad: pad,
	printTable: printTable,
	printTree: printTree,
	toArray: toArray$1,
	lines: lines,
	paragraphs: paragraphs,
	nonEmptyLines: nonEmptyLines,
	tokens: tokens,
	tableize: tableize,
	unescapeCharacterEntities: unescapeCharacterEntities,
	toQueryParams: toQueryParams,
	joinPath: joinPath,
	newUUID: newUUID,
	createDataURI: createDataURI,
	hashCode: hashCode,
	md5: md5,
	reMatches: reMatches$$1,
	stringMatch: stringMatch,
	peekRight: peekRight,
	peekLeft: peekLeft,
	lineIndexComputer: lineIndexComputer,
	lineNumberToIndexesComputer: lineNumberToIndexesComputer,
	lineRanges: lineRanges,
	diff: diff,
	empty: empty,
	includes: includes$$1,
	include: include$$1,
	startsWith: startsWith,
	startsWithVowel: startsWithVowel,
	endsWith: endsWith,
	withDecimalPrecision: withDecimalPrecision,
	capitalize: capitalize,
	camelCaseString: camelCaseString,
	camelize: camelize,
	truncate: truncate,
	truncateLeft: truncateLeft,
	regExpEscape: regExpEscape,
	succ: succ,
	digitValue: digitValue,
	times: times,
	applyChange: applyChange,
	applyChanges: applyChanges,
	levenshtein: levenshtein
});

/*
 * Utility functions for JS Numbers.
 */

function random(min, max) {
  // random number between (and including) `min` and `max`
  min = min || 0;
  max = max || 100;
  return Math.round(Math.random() * (max - min) + min);
}

var normalRandom = function (mean, stdDev) {
  // returns randomized numbers in a normal distribution that can be
  // controlled ising the `mean` and `stdDev` parameters
  var spare,
      isSpareReady = false;
  return function (mean, stdDev) {
    if (isSpareReady) {
      isSpareReady = false;
      return spare * stdDev + mean;
    } else {
      var u, v, s;
      do {
        u = Math.random() * 2 - 1;
        v = Math.random() * 2 - 1;
        s = u * u + v * v;
      } while (s >= 1 || s == 0);
      var mul = Math.sqrt(-2.0 * Math.log(s) / s);
      spare = v * mul;
      isSpareReady = true;
      return mean + stdDev * u * mul;
    }
  };
}();

function randomSmallerInteger(n) {
  return Math.floor(Math.random() * n);
}

function humanReadableByteSize(n) {
  // interpret `n` as byte size and print a more readable version
  // Example:
  //   num.humanReadableByteSize(Math.pow(2,32)) // => "4096MB"
  function round(n) {
    return Math.round(n * 100) / 100;
  }
  if (n < 1000) return String(round(n)) + 'B';
  n = n / 1024;
  if (n < 1000) return String(round(n)) + 'KB';
  n = n / 1024;
  return String(round(n)) + 'MB';
}

function average(numbers) {
  // show-in-doc
  return numbers.reduce(function (sum, n) {
    return sum + n;
  }, 0) / numbers.length;
}

function median(numbers) {
  // show-in-doc
  var sorted = numbers.sort(function (a, b) {
    return b - a;
  }),
      len = numbers.length;
  return len % 2 === 0 ? 0.5 * (sorted[len / 2 - 1] + sorted[len / 2]) : sorted[(len - 1) / 2];
}

function between(x, a, b, eps) {
  // is `a` <= `x` <= `y`?
  eps = eps || 0;
  var min, max;
  if (a < b) {
    min = a, max = b;
  } else {
    max = a, min = b;
  }
  return max - x + eps >= 0 && min - x - eps <= 0;
}

function sort$1(arr) {
  // numerical sort, JavaScript native `sort` function is lexical by default.
  return arr.sort(function (a, b) {
    return a - b;
  });
}

function parseLength(string, toUnit) {
  // This converts the length value to pixels or the specified `toUnit`.
  // length converstion, supported units are: mm, cm, in, px, pt, pc
  // Examples:
  // num.parseLength('3cm') // => 113.38582677165354
  // num.parseLength('3cm', "in") // => 1.1811023622047243
  toUnit = toUnit || 'px';
  var match = string.match(/([0-9\.]+)\s*(.*)/);
  if (!match || !match[1]) return undefined;
  var length = parseFloat(match[1]),
      fromUnit = match[2];
  return convertLength(length, fromUnit, toUnit);
}

var convertLength = function () {
  // ignore-in-doc
  // num.convertLength(20, 'px', 'pt').roundTo(0.01)
  function toCm(n, unit) {
    // as defined in http://www.w3.org/TR/css3-values/#absolute-lengths
    if (unit === 'cm') return n;else if (unit === 'mm') return n * 0.1;else if (unit === 'in') return n * 2.54;else if (unit === 'px') return n * toCm(1 / 96, 'in');else if (unit === 'pt') return n * toCm(1 / 72, 'in');else if (unit === 'pc') return n * toCm(12, 'pt');
  }
  return function to(length, fromUnit, toUnit) {
    if (fromUnit === toUnit) return length;else if (toUnit === "cm") return toCm(length, fromUnit);else if (fromUnit === "cm") return length / toCm(1, toUnit);else return to(to(length, fromUnit, 'cm'), 'cm', toUnit);
  };
}();

function roundTo(n, quantum) {
  // `quantum` is something like 0.01,

  // for JS rounding to work we need the reciprocal
  quantum = 1 / quantum;
  return Math.round(n * quantum) / quantum;
}

function detent(n, detent, grid, snap) {
  // This function is useful to implement smooth transitions and snapping.
  // Map all values that are within detent/2 of any multiple of grid to
  // that multiple. Otherwise, if snap is true, return self, meaning that
  // the values in the dead zone will never be returned. If snap is
  // false, then expand the range between dead zone so that it covers the
  // range between multiples of the grid, and scale the value by that
  // factor.
  // Examples:
  // // With snapping:
  // num.detent(0.11, 0.2, 0.5, true) // => 0.11
  // num.detent(0.39, 0.2, 0.5, true) // => 0.39
  // num.detent(0.55, 0.2, 0.5, true)  // => 0.5
  // num.detent(0.61, 0.2, 0.5, true)   // => 0.61
  // // Smooth transitions without snapping:
  // num.detent(0.1,  0.2, 0.5) // => 0
  // num.detent(0.11,  0.2, 0.5) // => 0.0166666
  // num.detent(0.34,  0.2, 0.5)  // => 0.4
  // num.detent(0.39,  0.2, 0.5) // => 0.4833334
  // num.detent(0.4,  0.2, 0.5) // => 0.5
  // num.detent(0.6,  0.2, 0.5) // => 0.5
  var r1 = roundTo(n, grid); // Nearest multiple of grid
  if (Math.abs(n - r1) < detent / 2) return r1; // Snap to that multiple...
  if (snap) return n; // ...and return n
  // or compute nearest end of dead zone
  var r2 = n < r1 ? r1 - detent / 2 : r1 + detent / 2;
  // and scale values between dead zones to fill range between multiples
  return r1 + (n - r2) * grid / (grid - detent);
}

function toDegrees(n) {
  // Example:
  // num.toDegrees(Math.PI/2) // => 90
  return n * 180 / Math.PI % 360;
}

function toRadians(n) {
  // Example:
  // num.toRadians(180) // => 3.141592653589793
  return n / 180 * Math.PI;
}



var num = Object.freeze({
	random: random,
	normalRandom: normalRandom,
	randomSmallerInteger: randomSmallerInteger,
	humanReadableByteSize: humanReadableByteSize,
	average: average,
	median: median,
	between: between,
	sort: sort$1,
	parseLength: parseLength,
	convertLength: convertLength,
	roundTo: roundTo,
	detent: detent,
	toDegrees: toDegrees,
	toRadians: toRadians
});

function all$2(object, predicate) {
  // ignore-in-doc
  var a = [];
  for (var name in object) {
    if ((object.__lookupGetter__(name) || typeof object[name] !== 'function') && (predicate ? predicate(name, object) : true)) a.push(name);
  }
  return a;
}

function allOwnPropertiesOrFunctions(obj, predicate) {
  // ignore-in-doc
  return Object.getOwnPropertyNames(obj).reduce(function (result, name) {
    if (predicate ? predicate(obj, name) : true) result.push(name);
    return result;
  }, []);
}

function own$1(object) {
  // ignore-in-doc
  var a = [];
  for (var name in object) {
    if (object.hasOwnProperty(name) && (object.__lookupGetter__(name) || object[name] !== 'function')) a.push(name);
  }
  return a;
}

function forEachOwn(object, func, context) {
  // ignore-in-doc
  var result = [];
  for (var name in object) {
    if (!object.hasOwnProperty(name)) continue;
    var value = object[name];
    if (value !== 'function') {
      result.push(func.call(context || this, name, value));
    }
  }
  return result;
}

function nameFor(object, value) {
  // ignore-in-doc
  for (var name in object) {
    if (object[name] === value) return name;
  }return undefined;
}

function values$1(obj) {
  // ignore-in-doc
  var values = [];
  for (var name in obj) {
    values.push(obj[name]);
  }return values;
}

function ownValues(obj) {
  // ignore-in-doc
  var values = [];
  for (var name in obj) {
    if (obj.hasOwnProperty(name)) values.push(obj[name]);
  }return values;
}

function any$1(obj, predicate) {
  // ignore-in-doc
  for (var name in obj) {
    if (predicate(obj, name)) return true;
  }return false;
}

function allProperties(obj, predicate) {
  // ignore-in-doc
  var result = [];
  for (var name in obj) {
    if (predicate ? predicate(obj, name) : true) result.push(name);
  }return result;
}

function hash(obj) {
  // ignore-in-doc
  // Using the property names of `obj` to generate a hash value.
  return Object.keys(obj).sort().join('').hashCode();
}



var properties = Object.freeze({
	all: all$2,
	allOwnPropertiesOrFunctions: allOwnPropertiesOrFunctions,
	own: own$1,
	forEachOwn: forEachOwn,
	nameFor: nameFor,
	values: values$1,
	ownValues: ownValues,
	any: any$1,
	allProperties: allProperties,
	hash: hash
});

/*
 * Util functions to print and work with JS date objects.
 */

var dateFormat = function setupDateFormat() {

    /*
     * Date Format 1.2.3
     * (c) 2007-2009 Steven Levithan <stevenlevithan.com>
     * MIT license
     *
     * Includes enhancements by Scott Trenda <scott.trenda.net>
     * and Kris Kowal <cixar.com/~kris.kowal/>
     *
     * Accepts a date, a mask, or a date and a mask.
     * Returns a formatted version of the given date.
     * The date defaults to the current date/time.
     * The mask defaults to dateFormat.masks.default.
     */

    // http://blog.stevenlevithan.com/archives/date-time-format

    var dateFormat = function () {
        var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g,
            timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
            timezoneClip = /[^-+\dA-Z]/g,
            pad = function pad(val, len) {
            val = String(val);
            len = len || 2;
            while (val.length < len) {
                val = "0" + val;
            }return val;
        };

        // Regexes and supporting functions are cached through closure
        return function (date, mask, utc) {
            var dF = dateFormat;

            // You can't provide utc if you skip other args (use the "UTC:" mask prefix)
            if (arguments.length == 1 && Object.prototype.toString.call(date) == "[object String]" && !/\d/.test(date)) {
                mask = date;
                date = undefined;
            }

            // Passing date through Date applies Date.parse, if necessary
            date = date ? new Date(date) : new Date();
            if (isNaN(date)) throw SyntaxError("invalid date");

            mask = String(dF.masks[mask] || mask || dF.masks["default"]);

            // Allow setting the utc argument via the mask
            if (mask.slice(0, 4) == "UTC:") {
                mask = mask.slice(4);
                utc = true;
            }

            var _ = utc ? "getUTC" : "get",
                d = date[_ + "Date"](),
                D = date[_ + "Day"](),
                m = date[_ + "Month"](),
                y = date[_ + "FullYear"](),
                H = date[_ + "Hours"](),
                M = date[_ + "Minutes"](),
                s = date[_ + "Seconds"](),
                L = date[_ + "Milliseconds"](),
                o = utc ? 0 : date.getTimezoneOffset(),
                flags = {
                d: d,
                dd: pad(d),
                ddd: dF.i18n.dayNames[D],
                dddd: dF.i18n.dayNames[D + 7],
                m: m + 1,
                mm: pad(m + 1),
                mmm: dF.i18n.monthNames[m],
                mmmm: dF.i18n.monthNames[m + 12],
                yy: String(y).slice(2),
                yyyy: y,
                h: H % 12 || 12,
                hh: pad(H % 12 || 12),
                H: H,
                HH: pad(H),
                M: M,
                MM: pad(M),
                s: s,
                ss: pad(s),
                l: pad(L, 3),
                L: pad(L > 99 ? Math.round(L / 10) : L),
                t: H < 12 ? "a" : "p",
                tt: H < 12 ? "am" : "pm",
                T: H < 12 ? "A" : "P",
                TT: H < 12 ? "AM" : "PM",
                Z: utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, ""),
                o: (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
                S: ["th", "st", "nd", "rd"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]
            };

            return mask.replace(token, function ($0) {
                return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1);
            });
        };
    }();

    // Some common format strings
    dateFormat.masks = {
        "default": "ddd mmm dd yyyy HH:MM:ss",
        shortDate: "m/d/yy",
        mediumDate: "mmm d, yyyy",
        longDate: "mmmm d, yyyy",
        fullDate: "dddd, mmmm d, yyyy",
        shortTime: "h:MM TT",
        mediumTime: "h:MM:ss TT",
        longTime: "h:MM:ss TT Z",
        isoDate: "yyyy-mm-dd",
        isoTime: "HH:MM:ss",
        isoDateTime: "yyyy-mm-dd'T'HH:MM:ss",
        isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
    };

    // Internationalization strings
    dateFormat.i18n = {
        dayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        monthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
    };

    return dateFormat;
}(); // end of setupDateFormat


function format$1(date, mask, utc) {
    // Custom date / time stringifier. Provides default masks:
    //
    // Mask           | Pattern
    // ---------------|--------------------------------
    // default        | `"ddd mmm dd yyyy HH:MM:ss"`
    // shortDate      | `"m/d/yy"`
    // mediumDate     | `"mmm d, yyyy"`
    // longDate       | `"mmmm d, yyyy"`
    // fullDate       | `"dddd, mmmm d, yyyy"`
    // shortTime      | `"h:MM TT"`
    // mediumTime     | `"h:MM:ss TT"`
    // longTime       | `"h:MM:ss TT Z"`
    // isoDate        | `"yyyy-mm-dd"`
    // isoTime        | `"HH:MM:ss"`
    // isoDateTime    | `"yyyy-mm-dd'T'HH:MM:ss"`
    // isoUtcDateTime | `"UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"`
    //
    // and internationalized strings via `date.format.i18n.dayNames`
    // and `date.format.i18n.dayNames`
    // Examples:
    //   date.format(new Date(), date.format.masks.longTime) // => "7:13:31 PM PDT"
    //   date.format(new Date(), "yyyy/mm/dd") // => "2014/10/09"
    return dateFormat(date, mask, utc);
}

function equals$3(date, otherDate) {
    // show-in-doc
    return otherDate && otherDate instanceof Date && otherDate.getTime() === date.getTime();
}

function relativeTo(date, otherDate) {
    // Prints a human readable difference of two Date objects. The older date
    // goes first.
    // Examples:
    //   var now = new Date();
    //   date.relativeTo(new Date(now-2000), now) // => "2 secs"
    //   date.relativeTo(new Date("10/11/2014"), new Date("10/12/2014")) // => "1 day"
    if (!(otherDate instanceof Date)) return '';
    if (otherDate < date) return '';
    if (otherDate === date) return 'now';
    var minuteString = 'min',
        secondString = 'sec',
        hourString = 'hour',
        dayString = 'day',
        diff = otherDate - date,
        totalSecs = Math.round(diff / 1000),
        secs = totalSecs % 60,
        mins = Math.floor(totalSecs / 60) % 60,
        hours = Math.floor(totalSecs / 60 / 60) % 24,
        days = Math.floor(totalSecs / 60 / 60 / 24),
        parts = [];
    if (days > 0) {
        parts.push(days);
        if (days > 1) dayString += 's';
        parts.push(dayString);
    }
    if (hours > 0 && days < 2) {
        parts.push(hours);
        if (hours > 1) hourString += 's';
        parts.push(hourString);
    }
    if (mins > 0 && hours < 3 && days === 0) {
        parts.push(mins);
        if (mins > 1) minuteString += 's';
        parts.push(minuteString);
    }
    if (secs > 0 && mins < 3 && hours === 0 && days === 0) {
        parts.push(secs);
        if (secs > 1) secondString += 's';
        parts.push(secondString);
    }
    return parts.join(' ');
}



var date = Object.freeze({
	format: format$1,
	equals: equals$3,
	relativeTo: relativeTo
});

/*global require, process, Promise*/

/*
 * Methods helping with promises (Promise/A+ model). Not a promise shim.
 */

function promise(obj) {
  // Promise object / function converter
  // Example:
  // promise("foo");
  //   // => Promise({state: "fullfilled", value: "foo"})
  // lively.lang.promise({then: (resolve, reject) => resolve(23)})
  //   // => Promise({state: "fullfilled", value: 23})
  // lively.lang.promise(function(val, thenDo) { thenDo(null, val + 1) })(3)
  //   // => Promise({state: "fullfilled", value: 4})
  return typeof obj === "function" ? promise.convertCallbackFun(obj) : Promise.resolve(obj);
}

function delay$1(ms, resolveVal) {
  // Like `Promise.resolve(resolveVal)` but waits for `ms` milliseconds
  // before resolving
  return new Promise(function (resolve) {
    return setTimeout(resolve, ms, resolveVal);
  });
}

function delayReject(ms, rejectVal) {
  // like `promise.delay` but rejects
  return new Promise(function (_, reject) {
    return setTimeout(reject, ms, rejectVal);
  });
}

function timeout(ms, promise) {
  // Takes a promise and either resolves to the value of the original promise
  // when it succeeds before `ms` milliseconds passed or fails with a timeout
  // error
  return new Promise(function (resolve, reject) {
    var done = false;
    setTimeout(function () {
      return !done && (done = true) && reject(new Error('Promise timed out'));
    }, ms);
    promise.then(function (val) {
      return !done && (done = true) && resolve(val);
    }, function (err) {
      return !done && (done = true) && reject(err);
    });
  });
}

function waitFor$1(ms, tester) {
  // Tests for a condition calling function `tester` until the result is
  // truthy. Resolves with last return value of `tester`. If `ms` is defined
  // and `ms` milliseconds passed, reject with timeout error

  return new Promise(function (resolve, reject) {
    if (typeof ms === "function") {
      tester = ms;ms = undefined;
    }
    var stopped = false,
        error = null,
        value = undefined,
        i = setInterval(function () {
      if (stopped) {
        clearInterval(i);return;
      }
      try {
        value = tester();
      } catch (e) {
        error = e;
      }
      if (value || error) {
        stopped = true;
        clearInterval(i);
        error ? reject(error) : resolve(value);
      }
    }, 10);
    if (typeof ms === "number") {
      setTimeout(function () {
        error = new Error('timeout');
      }, ms);
    }
  });
}

function deferred() {
  // returns an object
  // `{resolve: FUNCTION, reject: FUNCTION, promise: PROMISE}`
  // that separates the resolve/reject handling from the promise itself
  // Similar to the deprecated `Promise.defer()`
  var resolve,
      reject,
      promise = new Promise(function (_resolve, _reject) {
    resolve = _resolve;reject = _reject;
  });
  return { resolve: resolve, reject: reject, promise: promise };
}

function convertCallbackFun(func) {
  // Takes a function that accepts a nodejs-style callback function as a last
  // parameter and converts it to a function *not* taking the callback but
  // producing a promise instead. The promise will be resolved with the
  // *first* non-error argument.
  // nodejs callback convention: a function that takes as first parameter an
  // error arg and second+ parameters are the result(s).
  // Example:
  // var fs = require("fs"),
  //     readFile = promise.convertCallbackFun(fs.readFile);
  // readFile("./some-file.txt")
  //   .then(content => console.log(String(content)))
  //   .catch(err => console.error("Could not read file!", err));
  return function promiseGenerator() /*args*/{
    var args = Array.from(arguments),
        self = this;
    return new Promise(function (resolve, reject) {
      args.push(function (err, result) {
        return err ? reject(err) : resolve(result);
      });
      func.apply(self, args);
    });
  };
}

function convertCallbackFunWithManyArgs(func) {
  // like convertCallbackFun but the promise will be resolved with the
  // all non-error arguments wrapped in an array.
  return function promiseGenerator() /*args*/{
    var args = Array.from(arguments),
        self = this;
    return new Promise(function (resolve, reject) {
      args.push(function () /*err + args*/{
        var args = Array.from(arguments),
            err = args.shift();
        return err ? reject(err) : resolve(args);
      });
      func.apply(self, args);
    });
  };
}

function _chainResolveNext(promiseFuncs, prevResult, akku, resolve, reject) {
  var next = promiseFuncs.shift();
  if (!next) resolve(prevResult);else {
    try {
      Promise.resolve(next(prevResult, akku)).then(function (result) {
        return _chainResolveNext(promiseFuncs, result, akku, resolve, reject);
      }).catch(function (err) {
        reject(err);
      });
    } catch (err) {
      reject(err);
    }
  }
}

function chain$1(promiseFuncs) {
  // Similar to Promise.all but takes a list of promise-producing functions
  // (instead of Promises directly) that are run sequentially. Each function
  // gets the result of the previous promise and a shared "state" object passed
  // in. The function should return either a value or a promise. The result of
  // the entire chain call is a promise itself that either resolves to the last
  // returned value or rejects with an error that appeared somewhere in the
  // promise chain. In case of an error the chain stops at that point.
  // Example:
  // lively.lang.promise.chain([
  //   () => Promise.resolve(23),
  //   (prevVal, state) => { state.first = prevVal; return prevVal + 2 },
  //   (prevVal, state) => { state.second = prevVal; return state }
  // ]).then(result => console.log(result));
  // // => prints {first: 23,second: 25}
  return new Promise(function (resolve, reject) {
    return _chainResolveNext(promiseFuncs.slice(), undefined, {}, resolve, reject);
  });
}

function promise_finally(promise, finallyFn) {
  return Promise.resolve(promise).then(function (result) {
    try {
      finallyFn();
    } catch (err) {
      console.error("Error in promise finally: " + err.stack || err);
    }return result;
  }).catch(function (err) {
    try {
      finallyFn();
    } catch (err) {
      console.error("Error in promise finally: " + err.stack || err);
    }throw err;
  });
}

// FIXME!
Object.assign(promise, {
  delay: delay$1,
  delayReject: delayReject,
  timeout: timeout,
  waitFor: waitFor$1,
  deferred: deferred,
  convertCallbackFun: convertCallbackFun,
  convertCallbackFunWithManyArgs: convertCallbackFunWithManyArgs,
  chain: chain$1,
  "finally": promise_finally
});

// -=-=-=-=-=-=-=-=-=-=-=-=-=-
// js object path accessor
// -=-=-=-=-=-=-=-=-=-=-=-=-=-

// show-in-doc
// A `Path` is an objectified chain of property names (kind of a "complex"
// getter and setter). Path objects can make access and writes into deeply nested
// structures more convenient. `Path` provide "safe" get and set operations and
// can be used for debugging by providing a hook that allows users to find out
// when get/set operations happen.

function Path(p, splitter) {
  if (p instanceof Path) return p;
  if (!(this instanceof Path)) return new Path(p, splitter);
  this.setSplitter(splitter || '.');
  this.fromPath(p);
}

Object.assign(Path.prototype, {

  get isPathAccessor() {
    return true;
  },

  fromPath: function fromPath(path) {
    // ignore-in-doc
    if (typeof path === "string" && path !== '' && path !== this.splitter) {
      this._parts = path.split(this.splitter);
      this._path = path;
    } else if (Array.isArray(path)) {
      this._parts = [].concat(path);
      this._path = path.join(this.splitter);
    } else {
      this._parts = [];
      this._path = '';
    }
    return this;
  },
  setSplitter: function setSplitter(splitter) {
    // ignore-in-doc
    if (splitter) this.splitter = splitter;
    return this;
  },
  parts: function parts() {
    /*key names as array*/return this._parts;
  },
  size: function size() {
    /*show-in-doc*/return this._parts.length;
  },
  slice: function slice(n, m) {
    /*show-in-doc*/return Path(this.parts().slice(n, m));
  },
  normalizePath: function normalizePath() {
    // ignore-in-doc
    // FIXME: define normalization
    return this._path;
  },
  isRoot: function isRoot(obj) {
    return this._parts.length === 0;
  },
  isIn: function isIn(obj) {
    // Does the Path resolve to a value when applied to `obj`?
    if (this.isRoot()) return true;
    var parent = this.get(obj, -1);
    return parent && parent.hasOwnProperty(this._parts[this._parts.length - 1]);
  },
  equals: function equals(obj) {
    // Example:
    // var p1 = Path("foo.1.bar.baz"), p2 = Path(["foo", 1, "bar", "baz"]);
    // // Path's can be both created via strings or pre-parsed with keys in a list.
    // p1.equals(p2) // => true
    return obj && obj.isPathAccessor && this.parts().equals(obj.parts());
  },
  isParentPathOf: function isParentPathOf(otherPath) {
    // Example:
    // var p1 = Path("foo.1.bar.baz"), p2 = Path("foo.1.bar");
    // p2.isParentPathOf(p1) // => true
    // p1.isParentPathOf(p2) // => false
    otherPath = otherPath && otherPath.isPathAccessor ? otherPath : Path(otherPath);
    var parts = this.parts(),
        otherParts = otherPath.parts();
    for (var i = 0; i < parts.length; i++) {
      if (parts[i] != otherParts[i]) return false;
    }
    return true;
  },
  relativePathTo: function relativePathTo(otherPath) {
    // Example:
    // var p1 = Path("foo.1.bar.baz"), p2 = Path("foo.1");
    // p2.relativePathTo(p1) // => Path(["bar","baz"])
    // p1.relativePathTo(p2) // => undefined
    otherPath = Path(otherPath);
    return this.isParentPathOf(otherPath) ? otherPath.slice(this.size(), otherPath.size()) : undefined;
  },
  del: function del(obj) {
    if (this.isRoot()) return false;
    var parent = obj;
    for (var i = 0; i < this._parts.length - 1; i++) {
      var part = this._parts[i];
      if (parent.hasOwnProperty(part)) {
        parent = parent[part];
      } else return false;
    }
    return delete parent[this._parts[this._parts.length - 1]];
  },
  withParentAndKeyDo: function withParentAndKeyDo(obj, ensure, doFunc) {
    // Deeply resolve path in `obj`, not fully, however, only to the parent
    // element of the last part of path. Take the parent, the key (the last
    // part of path) and pass it to `doFunc`. When `ensure` is true, create
    // objects along path it path does not resolve
    if (this.isRoot()) return doFunc(null, null);
    var parent = obj;
    for (var i = 0; i < this._parts.length - 1; i++) {
      var part = this._parts[i];
      if (parent.hasOwnProperty(part) && (_typeof(parent[part]) === "object" || typeof parent[part] === "function")) {
        parent = parent[part];
      } else if (ensure) {
        parent = parent[part] = {};
      } else {
        return doFunc(null, part);
      }
    }
    return doFunc(parent, this._parts[this._parts.length - 1]);
  },
  set: function set(obj, val, ensure) {
    // Deeply resolve path in `obj` and set the resulting property to `val`. If
    // `ensure` is true, create nested structure in between as necessary.
    // Example:
    // var o1 = {foo: {bar: {baz: 42}}};
    // var path = Path("foo.bar.baz");
    // path.set(o1, 43)
    // o1 // => {foo: {bar: {baz: 43}}}
    // var o2 = {foo: {}};
    // path.set(o2, 43, true)
    // o2 // => {foo: {bar: {baz: 43}}}
    return this.withParentAndKeyDo(obj, ensure, function (parent, key) {
      return parent ? parent[key] = val : undefined;
    });
  },
  defineProperty: function defineProperty(obj, propertySpec, ensure) {
    // like `Path>>set`, however uses Objeect.defineProperty
    return this.withParentAndKeyDo(obj, ensure, function (parent, key) {
      return parent ? Object.defineProperty(parent, key, propertySpec) : undefined;
    });
  },
  get: function get(obj, n) {
    // show-in-doc
    var parts = n ? this._parts.slice(0, n) : this._parts;
    return parts.reduce(function (current, pathPart) {
      return current ? current[pathPart] : current;
    }, obj);
  },
  concat: function concat(p, splitter) {
    // show-in-doc
    return Path(this.parts().concat(Path(p, splitter).parts()));
  },
  toString: function toString() {
    return this.normalizePath();
  },
  serializeExpr: function serializeExpr() {
    // ignore-in-doc
    return 'lively.lang.Path(' + inspect(this.parts()) + ')';
  },
  watch: function watch(options) {
    // React or be notified on reads or writes to a path in a `target`. Options:
    // ```js
    // {
    //   target: OBJECT,
    //   uninstall: BOOLEAN,
    //   onGet: FUNCTION,
    //   onSet: FUNCTION,
    //   haltWhenChanged: BOOLEAN,
    //   verbose: BOOLEAN
    // }
    // ```
    // Example:
    // // Quite useful for debugging to find out what call-sites change an object.
    // var o = {foo: {bar: 23}};
    // Path("foo.bar").watch({target: o, verbose: true});
    // o.foo.bar = 24; // => You should see: "[object Object].bar changed: 23 -> 24"
    if (!options || this.isRoot()) return;
    var target = options.target,
        parent = this.get(target, -1),
        propName = this.parts().slice(-1)[0],
        newPropName = 'propertyWatcher$' + propName,
        watcherIsInstalled = parent && parent.hasOwnProperty(newPropName),
        uninstall = options.uninstall,
        haltWhenChanged = options.haltWhenChanged,
        showStack = options.showStack,
        getter = parent.__lookupGetter__(propName),
        setter = parent.__lookupSetter__(propName);
    if (!target || !propName || !parent) return;
    if (uninstall) {
      if (!watcherIsInstalled) return;
      delete parent[propName];
      parent[propName] = parent[newPropName];
      delete parent[newPropName];
      var msg = 'Watcher for ' + parent + '.' + propName + ' uninstalled';
      show(msg);
      return;
    }
    if (watcherIsInstalled) {
      var msg = 'Watcher for ' + parent + '.' + propName + ' already installed';
      show(msg);
      return;
    }
    if (getter || setter) {
      var msg = parent + '["' + propName + '"] is a getter/setter, watching not support';
      console.log(msg);
      if (typeof show === "undefined") show(msg);
      return;
    }
    // observe slots, for debugging
    parent[newPropName] = parent[propName];
    parent.__defineSetter__(propName, function (v) {
      var oldValue = parent[newPropName];
      if (options.onSet) options.onSet(v, oldValue);
      var msg = parent + "." + propName + " changed: " + oldValue + " -> " + v;
      if (showStack) msg += '\n' + (typeof lively !== "undefined" ? lively.printStack() : console.trace());
      if (options.verbose) {
        console.log(msg);
        if (typeof show !== 'undefined') show(msg);
      }
      if (haltWhenChanged) debugger;
      return parent[newPropName] = v;
    });
    parent.__defineGetter__(propName, function () {
      if (options.onGet) options.onGet(parent[newPropName]);
      return parent[newPropName];
    });
    var msg = 'Watcher for ' + parent + '.' + propName + ' installed';
    console.log(msg);
    if (typeof show !== 'undefined') show(msg);
  },
  debugFunctionWrapper: function debugFunctionWrapper(options) {
    // ignore-in-doc
    // options = {target, [haltWhenChanged, showStack, verbose, uninstall]}
    var target = options.target,
        parent = this.get(target, -1),
        funcName = this.parts().slice(-1)[0],
        uninstall = options.uninstall,
        haltWhenChanged = options.haltWhenChanged === undefined ? true : options.haltWhenChanged,
        showStack = options.showStack,
        func = parent && funcName && parent[funcName],
        debuggerInstalled = func && func.isDebugFunctionWrapper;
    if (!target || !funcName || !func || !parent) return;
    if (uninstall) {
      if (!debuggerInstalled) return;
      parent[funcName] = parent[funcName].debugTargetFunction;
      var msg = 'Uninstalled debugFunctionWrapper for ' + parent + '.' + funcName;
      console.log(msg);
      if (typeof show !== 'undefined') show(msg);
      show(msg);
      return;
    }
    if (debuggerInstalled) {
      var msg = 'debugFunctionWrapper for ' + parent + '.' + funcName + ' already installed';
      console.log(msg);
      if (typeof show !== 'undefined') show(msg);
      return;
    }
    var debugFunc = parent[funcName] = func.wrap(function (proceed) {
      var args = Array.from(arguments);
      if (haltWhenChanged) debugger;
      if (showStack) show(lively.printStack());
      if (options.verbose) show(funcName + ' called');
      return args.shift().apply(parent, args);
    });
    debugFunc.isDebugFunctionWrapper = true;
    debugFunc.debugTargetFunction = func;
    var msg = 'debugFunctionWrapper for ' + parent + '.' + funcName + ' installed';
    console.log(msg);
    if (typeof show !== 'undefined') show(msg);
  }
});

/*
Computation over graphs. Unless otherwise specified a graph is a simple JS
object whose properties are interpreted as nodes that refer to arrays whose
elements describe edges. Example:

```js
var testGraph = {
  "a": ["b", "c"],
  "b": ["c", "d", "e", "f"],
  "d": ["c", "f"],
  "e": ["a", "f"],
  "f": []
}
```
*/

// show-in-doc
function clone$2(graph) {
  // return a copy of graph map
  var cloned = {};
  for (var id in graph) {
    cloned[id] = graph[id].slice();
  }return cloned;
}

function without$1(graph, ids) {
  // return a copy of graph map with ids removed
  var cloned = {};
  for (var id in graph) {
    if (ids.indexOf(id) > -1) continue;
    cloned[id] = graph[id].filter(function (id) {
      return ids.indexOf(id) === -1;
    });
  }
  return cloned;
}

function hull(graphMap, id, ignore, maxDepth) {
  // Takes a graph in object format and a start id and then traverses the
  // graph and gathers all nodes that can be reached from that start id.
  // Returns a list of those nodes.
  // Optionally use `ignore` list to filter out certain nodes that shouldn't
  // be considered and maxDepth to stop early. By default a maxDepth of 20 is
  // used.
  // Example:
  // var testGraph = {
  // "a": ["b", "c"],
  // "b": ["c", "d", "e", "f"],
  // "d": ["c", "f"],
  // "e": ["a", "f"],
  // "f": []
  // }
  // hull(testGraph, "d") // => ["c", "f"]
  // hull(testGraph, "e") // => ['a', 'f', 'b', 'c', 'd', 'e']
  // hull(testGraph, "e", ["b"]) // =? ["a", "f", "c"]
  return uniq(flatten(values(subgraphReachableBy(graphMap, id, ignore, maxDepth))));
}

function subgraphReachableBy(graphMap, id, ignore, maxDepth) {
  // show-in-doc
  // Like hull but returns subgraph map of `graphMap`
  // Example:
  // subgraphReachableBy(testGraph, "e", [], 2);
  // // => {e: [ 'a', 'f' ], a: [ 'b', 'c' ], f: []}
  maxDepth = maxDepth || 10;
  if (ignore) graphMap = without$1(graphMap, ignore);
  var ids = [id],
      step = 0,
      subgraph = {};
  while (ids.length && step++ < maxDepth) {
    ids = ids.reduce(function (ids, id) {
      return subgraph[id] ? ids : ids.concat(subgraph[id] = graphMap[id] || []);
    }, []);
  }
  return subgraph;
}

function invert(g) {
  // inverts the references of graph object `g`.
  // Example:
  // invert({a: ["b"], b: ["a", "c"]})
  //   // => {a: ["b"], b: ["a"], c: ["b"]}
  return Object.keys(g).reduce(function (inverted, k) {
    g[k].forEach(function (k2) {
      if (!inverted[k2]) inverted[k2] = [k];else inverted[k2].push(k);
    });
    return inverted;
  }, {});
}

function sortByReference(depGraph, startNode) {
  // Sorts graph into an array of arrays. Each "bucket" contains the graph
  // nodes that have no other incoming nodes than those already visited. This
  // means, we start with the leaf nodes and then walk our way up.
  // This is useful for computing how to traverse a dependency graph: You get
  // a sorted list of dependencies that also allows circular references.
  // Example:
  // var depGraph = {a: ["b", "c"], b: ["c"], c: ["b"]};
  // sortByReference(depGraph, "a");
  // // => [["c"], ["b"], ["a"]]

  var all$$1 = [startNode].concat(hull(depGraph, startNode)),
      seen = [],
      groups = [];

  while (seen.length !== all$$1.length) {
    var depsRemaining = withoutAll(all$$1, seen).reduce(function (depsRemaining, node) {
      depsRemaining[node] = withoutAll(depGraph[node] || [], seen).length;
      return depsRemaining;
    }, {}),
        min$$1 = withoutAll(all$$1, seen).reduce(function (minNode, node) {
      return depsRemaining[node] <= depsRemaining[minNode] ? node : minNode;
    });

    if (depsRemaining[min$$1] === 0) {
      groups.push(Object.keys(depsRemaining).filter(function (key) {
        return depsRemaining[key] === 0;
      }));
    } else {
      groups.push([min$$1]);
    }

    seen = flatten(groups);
  }

  return groups;
}

function reduce$1(doFunc, graph, rootNode, carryOver, ignore, context) {
  // Starts with `rootNode` and visits all (in)directly related nodes, calling
  // `doFunc` at each node. The result of `doFunc` is passed as first
  // argument to the next iterator call. For the first call the value
  // `carryOver` is used.
  // Example:
  // var depGraph = {a: ["b", "c"],b: ["c"]}
  // graphReduce((_, ea, i) => console.log("%s %s", ea, i), depGraph, "a")

  var visitedNodes = ignore || [],
      index = 0;
  iterator(rootNode);
  return carryOver;

  function iterator(currentNode) {
    if (visitedNodes.indexOf(currentNode) > -1) return;
    carryOver = doFunc.call(context, carryOver, currentNode, index++);
    visitedNodes = visitedNodes.concat([currentNode]);
    var next = withoutAll(graph[currentNode] || [], visitedNodes);
    next.forEach(function (ea) {
      return iterator(ea);
    });
  }
}



var graph = Object.freeze({
	clone: clone$2,
	without: without$1,
	hull: hull,
	subgraphReachableBy: subgraphReachableBy,
	invert: invert,
	sortByReference: sortByReference,
	reduce: reduce$1
});

/*global System, global*/

// show-in-doc
// Intervals are arrays whose first two elements are numbers and the
// first element should be less or equal the second element, see
// [`interval.isInterval`](). This abstraction is useful when working with text
// ranges in rich text, for example.

var GLOBAL$2 = typeof System !== "undefined" ? System.global : typeof window !== 'undefined' ? window : global;

function isInterval(object) {
  // Example:
  // interval.isInterval([1,12]) // => true
  // interval.isInterval([1,12, {property: 23}]) // => true
  // interval.isInterval([1]) // => false
  // interval.isInterval([12, 1]) // => false
  return Array.isArray(object) && object.length >= 2 && object[0] <= object[1];
}

function sort$2(intervals) {
  // Sorts intervals according to rules defined in [`interval.compare`]().
  return intervals.sort(compare);
}

function compare(a, b) {
  // How [`interval.sort`]() compares.
  // We assume that `a[0] <= a[1] and b[0] <= b[1]` according to `isInterval`
  // ```
  // -3: a < b and non-overlapping, e.g [1,2] and [3,4]
  // -2: a < b and intervals border at each other, e.g [1,3] and [3,4]
  // -1: a < b and overlapping, e.g, [1,3] and [2,4] or [1,3] and [1,4]
  //  0: a = b, e.g. [1,2] and [1,2]
  //  1: a > b and overlapping, e.g. [2,4] and [1,3]
  //  2: a > b and share border, e.g [1,4] and [0,1]
  //  3: a > b and non-overlapping, e.g [2,4] and [0,1]
  // ```
  if (a[0] < b[0]) {
    // -3 || -2 || -1
    if (a[1] < b[0]) return -3;
    if (a[1] === b[0]) return -2;
    return -1;
  }
  if (a[0] === b[0]) {
    // -1 || 0 || 1
    if (a[1] === b[1]) return 0;
    return a[1] < b[1] ? -1 : 1;
  }
  // we know a[0] > b[0], 1 || 2 || 3
  return -1 * compare(b, a);
}

function coalesce(interval1, interval2, optMergeCallback) {
  // Turns two interval into one iff compare(interval1, interval2) ∈ [-2,
  // -1,0,1, 2] (see [`inerval.compare`]()).
  // Otherwise returns null. Optionally uses merge function.
  // Examples:
  //   interval.coalesce([1,4], [5,7]) // => null
  //   interval.coalesce([1,2], [1,2]) // => [1,2]
  //   interval.coalesce([1,4], [3,6]) // => [1,6]
  //   interval.coalesce([3,6], [4,5]) // => [3,6]
  var cmpResult = this.compare(interval1, interval2);
  switch (cmpResult) {
    case -3:
    case 3:
      return null;
    case 0:
      optMergeCallback && optMergeCallback(interval1, interval2, interval1);
      return interval1;
    case 2:
    case 1:
      var temp = interval1;interval1 = interval2;interval2 = temp; // swap
    case -2:
    case -1:
      var coalesced = [interval1[0], Math.max(interval1[1], interval2[1])];
      optMergeCallback && optMergeCallback(interval1, interval2, coalesced);
      return coalesced;
    default:
      throw new Error("Interval compare failed");
  }
}

function coalesceOverlapping(intervals, mergeFunc) {
  // Like `coalesce` but accepts an array of intervals.
  // Example:
  //   interval.coalesceOverlapping([[9,10], [1,8], [3, 7], [15, 20], [14, 21]])
  //   // => [[1,8],[9,10],[14,21]]
  var condensed = [],
      len = intervals.length;
  while (len > 0) {
    var ival = intervals.shift();len--;
    for (var i = 0; i < len; i++) {
      var otherInterval = intervals[i],
          coalesced = coalesce(ival, otherInterval, mergeFunc);
      if (coalesced) {
        ival = coalesced;
        intervals.splice(i, 1);
        len--;i--;
      }
    }
    condensed.push(ival);
  }
  return this.sort(condensed);
}

function mergeOverlapping(intervalsA, intervalsB, mergeFunc) {
  var result = [];
  while (intervalsA.length > 0) {
    var intervalA = intervalsA.shift();

    var toMerge = intervalsB.map(function (intervalB) {
      var cmp = compare(intervalA, intervalB);
      return cmp === -1 || cmp === 0 || cmp === 1;
    });

    result.push(mergeFunc(intervalA, toMerge[0]));

    result.push(intervalA);
  }
  return result;
}

function intervalsInRangeDo(start, end, intervals, iterator, mergeFunc, context) {
  // Merges and iterates through sorted intervals. Will "fill up"
  // intervals. This is currently used for computing text chunks in
  // lively.morphic.TextCore.
  // Example:
  // interval.intervalsInRangeDo(
  //   2, 10, [[0, 1], [5,8], [2,4]],
  //   function(i, isNew) { i.push(isNew); return i; })
  // // => [[2,4,false],[4,5,true],[5,8,false],[8,10,true]]

  context = context || GLOBAL$2;
  // need to be sorted for the algorithm below
  intervals = this.sort(intervals);
  var free = [],
      nextInterval,
      collected = [];
  // merged intervals are already sorted, simply "negate" the interval array;
  while (nextInterval = intervals.shift()) {
    if (nextInterval[1] < start) continue;
    if (nextInterval[0] < start) {
      nextInterval = Array.prototype.slice.call(nextInterval);
      nextInterval[0] = start;
    }
    var nextStart = end < nextInterval[0] ? end : nextInterval[0];
    if (start < nextStart) {
      collected.push(iterator.call(context, [start, nextStart], true));
    }
    if (end < nextInterval[1]) {
      nextInterval = Array.prototype.slice.call(nextInterval);
      nextInterval[1] = end;
    }
    // special case, the newly constructed interval has length 0,
    // happens when intervals contains doubles at the start
    if (nextInterval[0] === nextInterval[1]) {
      var prevInterval;
      if (mergeFunc && (prevInterval = collected.slice(-1)[0])) {
        // arguments: a, b, merged, like in the callback of #merge
        mergeFunc.call(context, prevInterval, nextInterval, prevInterval);
      }
    } else {
      collected.push(iterator.call(context, nextInterval, false));
    }
    start = nextInterval[1];
    if (start >= end) break;
  }
  if (start < end) collected.push(iterator.call(context, [start, end], true));
  return collected;
}

function intervalsInbetween(start, end, intervals) {
  // Computes "free" intervals between the intervals given in range start - end
  // currently used for computing text chunks in lively.morphic.TextCore
  // Example:
  // interval.intervalsInbetween(0, 10,[[1,4], [5,8]])
  // // => [[0,1],[4,5],[8,10]]
  return intervalsInRangeDo(start, end, coalesceOverlapping(Array.prototype.slice.call(intervals)), function (interval, isNew) {
    return isNew ? interval : null;
  }).filter(Boolean);
}

function mapToMatchingIndexes(intervals, intervalsToFind) {
  // Returns an array of indexes of the items in intervals that match
  // items in `intervalsToFind`.
  // Note: We expect intervals and intervals to be sorted according to [`interval.compare`]()!
  // This is the optimized version of:
  // ```
  // return intervalsToFind.collect(function findOne(toFind) {
  //    var startIdx, endIdx;
  //    var start = intervals.detect(function(ea, i) {
  //       startIdx = i; return ea[0] === toFind[0]; });
  //    if (start === undefined) return [];
  //    var end = intervals.detect(function(ea, i) {
  //       endIdx = i; return ea[1] === toFind[1]; });
  //    if (end === undefined) return [];
  //    return Array.range(startIdx, endIdx);
  // });
  // ```

  var startIntervalIndex = 0,
      endIntervalIndex,
      currentInterval;
  return intervalsToFind.map(function (toFind) {
    while (currentInterval = intervals[startIntervalIndex]) {
      if (currentInterval[0] < toFind[0]) {
        startIntervalIndex++;continue;
      }
      break;
    }
    if (currentInterval && currentInterval[0] === toFind[0]) {
      endIntervalIndex = startIntervalIndex;
      while (currentInterval = intervals[endIntervalIndex]) {
        if (currentInterval[1] < toFind[1]) {
          endIntervalIndex++;continue;
        }
        break;
      }
      if (currentInterval && currentInterval[1] === toFind[1]) {
        return range(startIntervalIndex, endIntervalIndex);
      }
    }
    return [];
  });
}



var interval = Object.freeze({
	isInterval: isInterval,
	sort: sort$2,
	compare: compare,
	coalesce: coalesce,
	coalesceOverlapping: coalesceOverlapping,
	mergeOverlapping: mergeOverlapping,
	intervalsInRangeDo: intervalsInRangeDo,
	intervalsInbetween: intervalsInbetween,
	mapToMatchingIndexes: mapToMatchingIndexes
});

// show-in-doc
// Accessor to sub-ranges of arrays. This is used, for example, for rendering
// large lists or tables in which only a part of the items should be used for
// processing or rendering. An array projection provides convenient access and
// can apply operations to sub-ranges.

function create(array, length, optStartIndex) {
  // Example:
  // arrayProjection.create([1,2,3,4,5,6,7,8,9], 4, 1)
  // // => { array: [/*...*/], from: 1, to: 5 }
  var startIndex = optStartIndex || 0;
  if (startIndex + length > array.length) startIndex -= startIndex + length - array.length;
  return { array: array, from: startIndex, to: startIndex + length };
}

function toArray$4(projection) {
  // show-in-doc
  return projection.array.slice(projection.from, projection.to);
}

function originalToProjectedIndex(projection, index) {
  // Maps index from original Array to projection.
  // Example:
  //   var proj = arrayProjection.create([1,2,3,4,5,6,7,8,9], 4, 3);
  //   arrayProjection.originalToProjectedIndex(proj, 1) // => null
  //   arrayProjection.originalToProjectedIndex(proj, 3) // => 0
  //   arrayProjection.originalToProjectedIndex(proj, 5) // => 2
  return index < projection.from || index >= projection.to ? null : index - projection.from;
}

function projectedToOriginalIndex(projection, index) {
  // Inverse to `originalToProjectedIndex`.
  // Example:
  //   var proj = arrayProjection.create([1,2,3,4,5,6,7,8,9], 4, 3);
  //   arrayProjection.projectedToOriginalIndex(proj, 1) // => 4
  if (index < 0 || index > projection.to - projection.from) return null;
  return projection.from + index;
}

function transformToIncludeIndex(projection, index) {
  // Computes how the projection needs to shift minimally (think "scroll"
  // down or up) so that index becomes "visible" in projection.
  // Example:
  // var proj = arrayProjection.create([1,2,3,4,5,6,7,8,9], 4, 3);
  // arrayProjection.transformToIncludeIndex(proj, 1)
  // // => { array: [/*...*/], from: 1, to: 5 }
  if (!(index in projection.array)) return null;
  var delta = 0;
  if (index < projection.from) delta = -projection.from + index;
  if (index >= projection.to) delta = index - projection.to + 1;
  if (delta === 0) return projection;
  return create(projection.array, projection.to - projection.from, projection.from + delta);
}



var arrayProjection = Object.freeze({
	create: create,
	toArray: toArray$4,
	originalToProjectedIndex: originalToProjectedIndex,
	projectedToOriginalIndex: projectedToOriginalIndex,
	transformToIncludeIndex: transformToIncludeIndex
});

// show-in-doc
// A grid is a two-dimaensional array, representing a table-like data

function get$2(grid, nRow, nCol) {
  var row = grid[nRow];
  return row ? row[nCol] : undefined;
}

function set$2(grid, nRow, nCol, obj) {
  var row = grid[nRow];
  if (row) row[nCol] = obj;
  return obj;
}

function getRow(grid, nRow) {
  return grid[nRow];
}

function setRow(grid, nRow, newRow) {
  return grid[nRow] = newRow;
}

function getCol(grid, nCol) {
  return grid.reduce(function (col, row) {
    col.push(row[nCol]);return col;
  }, []);
}

function setCol(grid, nCol, newCol) {
  return grid.map(function (row, i) {
    return row[nCol] ? row[nCol] = newCol[i] : undefined;
  });
}

function create$1(rows, columns, initialObj) {
  // Example:
  // grid.create(3, 2, "empty")
  // // => [["empty","empty"],
  // //     ["empty","empty"],
  // //     ["empty","empty"]]
  var result = new Array(rows);
  while (rows > 0) {
    result[--rows] = withN(columns, initialObj);
  }return result;
}

function mapCreate(rows, cols, func, context) {
  // like `grid.create` but takes generator function for cells
  var result = new Array(rows);
  for (var i = 0; i < rows; i++) {
    result[i] = new Array(cols);
    for (var j = 0; j < cols; j++) {
      result[i][j] = func.call(context || this, i, j);
    }
  }
  return result;
}

function forEach$2(grid, func, context) {
  // iterate, `func` is called as `func(cellValue, i, j)`
  grid.forEach(function (row, i) {
    row.forEach(function (val, j) {
      func.call(context || this, val, i, j);
    });
  });
}

function map$2(grid, func, context) {
  // map, `func` is called as `func(cellValue, i, j)`
  var result = new Array(grid.length);
  grid.forEach(function (row, i) {
    result[i] = new Array(row.length);
    row.forEach(function (val, j) {
      result[i][j] = func.call(context || this, val, i, j);
    });
  });
  return result;
}

function toObjects(grid) {
  // The first row of the grid defines the propNames
  // for each following row create a new object with those porperties
  // mapped to the cells of the row as values
  // Example:
  // grid.toObjects([['a', 'b'],[1,2],[3,4]])
  // // => [{a:1,b:2},{a:3,b:4}]
  var props = grid[0],
      objects = new Array(grid.length - 1);
  for (var i = 1; i < grid.length; i++) {
    var obj = objects[i - 1] = {};
    for (var j = 0; j < props.length; j++) {
      obj[props[j]] = grid[i][j];
    }
  }
  return objects;
}

function tableFromObjects(objects, valueForUndefined) {
  // Reverse operation to `grid.toObjects`. Useful for example to convert objectified
  // SQL result sets into tables that can be printed via Strings.printTable.
  // Objects are key/values like [{x:1,y:2},{x:3},{z:4}]. Keys are interpreted as
  // column names and objects as rows.
  // Example:
  // grid.tableFromObjects([{x:1,y:2},{x:3},{z:4}])
  // // => [["x","y","z"],
  // //    [1,2,null],
  // //    [3,null,null],
  // //    [null,null,4]]

  if (!Array.isArray(objects)) objects = [objects];
  var table = [[]],
      columns = table[0],
      rows = objects.reduce(function (rows, ea) {
    return rows.concat([Object.keys(ea).reduce(function (row, col) {
      var colIdx = columns.indexOf(col);
      if (colIdx === -1) {
        colIdx = columns.length;columns.push(col);
      }
      row[colIdx] = ea[col];
      return row;
    }, [])]);
  }, []);
  valueForUndefined = arguments.length === 1 ? null : valueForUndefined;
  rows.forEach(function (row) {
    // fill cells with no value with null
    for (var i = 0; i < columns.length; i++) {
      if (!row[i]) row[i] = valueForUndefined;
    }
  });
  return table.concat(rows);
}



var grid = Object.freeze({
	get: get$2,
	set: set$2,
	getRow: getRow,
	setRow: setRow,
	getCol: getCol,
	setCol: setCol,
	create: create$1,
	mapCreate: mapCreate,
	forEach: forEach$2,
	map: map$2,
	toObjects: toObjects,
	tableFromObjects: tableFromObjects
});

/*
 * Methods for traversing and transforming tree structures.
 */

function prewalk(treeNode, iterator, childGetter) {
  var counter = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : { i: 0 };
  var depth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

  var i = counter.i++;
  iterator(treeNode, i, depth);
  (childGetter(treeNode, i, depth) || []).forEach(function (ea) {
    return prewalk(ea, iterator, childGetter, counter, depth + 1);
  });
}

function postwalk(treeNode, iterator, childGetter) {
  var counter = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : { i: 0 };
  var depth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

  var i = counter.i++;
  (childGetter(treeNode, i, depth) || []).forEach(function (ea) {
    return postwalk(ea, iterator, childGetter);
  });
  iterator(treeNode, i, depth);
}

function find(treeNode, testFunc, childGetter) {
  // Traverses a `treeNode` recursively and returns the first node for which
  // `testFunc` returns true. `childGetter` is a function to retrieve the
  // children from a node.
  if (testFunc(treeNode)) return treeNode;
  var children = childGetter(treeNode);
  if (!children || !children.length) return undefined;
  for (var i = 0; i < children.length; i++) {
    var found = find(children[i], testFunc, childGetter);
    if (found) return found;
  }
  return undefined;
}
var detect$1 = find;

function filter$1(treeNode, testFunc, childGetter) {
  // Traverses a `treeNode` recursively and returns all nodes for which
  // `testFunc` returns true. `childGetter` is a function to retrieve the
  // children from a node.
  var result = [];
  if (testFunc(treeNode)) result.push(treeNode);
  return result.concat(flatten((childGetter(treeNode) || []).map(function (n) {
    return filter$1(n, testFunc, childGetter);
  })));
}

function map$3(treeNode, mapFunc, childGetter) {
  var depth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

  // Traverses a `treeNode` recursively and call `mapFunc` on each node. The
  // return values of all mapFunc calls is the result. `childGetter` is a
  // function to retrieve the children from a node.
  return [mapFunc(treeNode, depth)].concat(flatten((childGetter(treeNode) || []).map(function (n) {
    return map$3(n, mapFunc, childGetter, depth);
  })));
}

function mapTree(treeNode, mapFunc, childGetter) {
  var depth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

  // Traverses the tree and creates a structurally identical tree but with
  // mapped nodes
  var mappedNodes = (childGetter(treeNode) || []).map(function (n) {
    return mapTree(n, mapFunc, childGetter, depth);
  });
  return mapFunc(treeNode, mappedNodes, depth);
}



var tree = Object.freeze({
	prewalk: prewalk,
	postwalk: postwalk,
	find: find,
	detect: detect$1,
	filter: filter$1,
	map: map$3,
	mapTree: mapTree
});

/*global process, require*/

/*
 * A simple node.js-like cross-platform event emitter implementation that can
 * be used as a mixin. Emitters support the methods: `on(eventName, handlerFunc)`,
 * `once(eventName, handlerFunc)`, `emit(eventName, eventData)`,
 * `removeListener(eventName, handlerFunc)`, `removeAllListeners(eventName)`
 * Example:
 * var emitter = events.makeEmitter({});
 * var log = [];
 * emitter.on("test", function() { log.push("listener1"); });
 * emitter.once("test", function() { log.push("listener2"); });
 * emitter.emit("test");
 * emitter.emit("test");
 * log // => ["listener1","listener2","listener1"]
 * emitter.removeAllListeners("test");
 * emitter.emit("test");
 * log // => is still ["listener1","listener2","listener1"]
 */

var isNode$1 = typeof process !== 'undefined' && process.versions && process.versions.node;

var makeEmitter = isNode$1 ? function (obj, options) {
  if (obj.on && obj.removeListener) return obj;
  var events = typeof System !== "undefined" ? System._nodeRequire("events") : require("events");
  Object.assign(obj, events.EventEmitter.prototype);
  events.EventEmitter.call(obj);
  if (options && options.maxListenerLimit) obj.setMaxListeners(options.maxListenerLimit);

  return obj;
} : function (obj) {
  if (obj.on && obj.removeListener) return obj;

  obj.listeners = {};

  obj.on = function (type, handler) {
    if (!handler) return;
    if (!obj.listeners[type]) obj.listeners[type] = [];
    obj.listeners[type].push(handler);
  };

  obj.once = function (type, handler) {
    if (!handler) return;
    function onceHandler /*ignore-in-docs args*/() {
      obj.removeListener(type, onceHandler);
      handler.apply(this, arguments);
    }
    obj.on(type, onceHandler);
  };

  obj.removeListener = function (type, handler) {
    if (!obj.listeners[type]) return;
    obj.listeners[type] = obj.listeners[type].filter(function (h) {
      return h !== handler;
    });
  };

  obj.removeAllListeners = function (type) {
    if (!obj.listeners[type]) return;
    obj.listeners[type] = [];
  };

  obj.emit = function () /*type and args*/{
    var args = Array.prototype.slice.call(arguments),
        type = args.shift(),
        handlers = obj.listeners[type];
    if (!handlers || !handlers.length) return;
    handlers.forEach(function (handler) {
      try {
        handler.apply(null, args);
      } catch (e) {
        console.error("Error in event handler: %s", e.stack || String(e));
      }
    });
  };

  return obj;
};



var events = Object.freeze({
	makeEmitter: makeEmitter
});

/*global clearTimeout, setTimeout, clearInterval, setInterval*/

/*
 * A pluggable interface to provide asynchronous, actor-like message
 * communication between JavaScript systems. Provides a unified message protocol
 * and send / receive methods.
 */

var OFFLINE = 'offline';
var ONLINE = 'online';
/*

TODO: move to promises! include broadcast API

renames:
listen() => open()
id() => id

*/

/*

A messenger is an object that provides a common, message-based interface. Messengers expect you to provide an implementation of a small number of methods: `send`, `listen`, `close`, and `isOnline`. A messenger will then provide a unified interface for sending and receiving messages. Common boilerplate functionality such as queuing messages, error handling, dealing with instable connections, heartbeats, etc. is handled by the messenger object automatically (and can be parameterized).

This allows to use a single interface across a range of heterogeneous objects without having to implement every detail of the abstraction repeatedly. This is especially valuable when dealing with asynchronous or remote communication (web workers, XHR requests, WebSockets, node.js processes, ...).

To see a minimal example of how to use messengers for the local communication between JavaScript objects [see this example](#messenger-example).

A more sophisticated example of messengers is [the worker implementation](worker.js) which provides an actor-like worker interface that uses web workers in web browsers and child_process.fork in node.js.

```js
var msger = lively.lang.messenger.create({
  send: function(msg, onSendDone) { console.log(msg); onSendDone(); },
  listen: function(thenDo) { thenDo(); },
  close: function(thenDo) { thenDo(); },
  isOnline: function() { return true }
});
```

#### Messenger interface

The interface methods are build to enable an user to send and receive
messages. Each messenger provides the following methods:

##### msger.id()

Each msger has an id that can either be defined by the user when the
msger is created or is automatically assigned. The id should be unique for each
messenger in a messenger network. It is used as the `target` attribute to
address messages and internally in the messaging implementation for routing.
See the [message protocol](#messenger-message-protocol) description for more info.

##### msger.isOnline()

Can the msger send and receive messages right now?

##### msger.heartbeatEnabled()

Does the msger send automated heartbeat messages?

##### msger.listen(optionalCallback)

Brings the messenger "online": Starts listening for messages and brings it
into a state to send messages. `optionalCallback` is a function that is called
when listening begins. It should accept one argument `error` that is null if no
error occured when listening was started, an Error object otherwise.

##### msger.send(msg, onReceiveFunc)

Sends a message. The message should be structured according to the [message
protocol](#messenger-message-protocol). `onReceiveFunc` is triggered when the `msg` is being
answered. `onReceiveFunc` should take two arguments: `error` and `answer`.
`answer` is itself a message object.

##### msger.sendTo(target, action, data, onReceiveFunc)

A simpler `send`, the `msg` object is automatically assembled. `target`
should be an id of the receiver and `action` a string naming the service that
should be triggered on the receiver.

##### msger.answer(msg, data, expectMore, whenSend)

Assembles an answer message for `msg` that includes `data`. `expectMore`
should be truthy when multiple answers should be send (a streaming response,
see the [messaging protocol](#messenger-message-protocol)).

##### msger.close(thenDo)

Stops listening.

##### msger.whenOnline(thenDo)

Registers a callback that is triggered as soon as a listen attempt succeeds
(or when the messenger is listening already then it succeeds immediately).

##### msger.outgoingMessages()

Returns the messages that are currently inflight or not yet send.

##### msger.addServices(serviceSpec)

Add services to the messenger. `serviceSpec` should be  JS object whose keys
correspond to message actions:

```js
msg.addServices({
  helloWorld: function(msg, messenger) {
    messenger.answer(msg, "received a message!");
  }
});
```

See the examples below for more information.

##### *[event]* msger.on("message")

To allow users to receive messages that were not initiated by a send,
messengers are [event emitters](events.js) that emit `"message"` events
whenever they receive a new message.

The messenger object is used to create new messenger interfaces and ties
them to a specific implementation. Please see [worker.js]() for examples of
how web workers and node.js processes are wrapped to provide a cross-platform
interface to a worker abstraction.


#### <a name="messenger-message-protocol"></a>Message protocol

A message is a JSON object with the following fields:

```js
var messageSchema = {

    // REQUIRED selector for service lookup. By convention action gets
    // postfixed with "Result" for response messages
    action: STRING,

    // REQUIRED target of the message, the id of the receiver
    target: UUID,

    // OPTIONAL arguments
    data: OBJECT,

    // OPTIONAL identifier of the message, will be provided if not set by user
    messageId: UUID,

    // OPTIONAL sender of the message, will be provided if not set by user
    sender: UUID,

    // OPTIONAL identifier of a message that this message answers, will be provided
    inResponseTo: UUID,

    // OPTIONAL if message is an answer. Can be interpreted by the receiver as
    // a streaming response. Lively participants (tracker and clients) will
    // trigger data bindings and fire callbacks for a message for every streaming
    // response
    expectMoreResponses: BOOL,

    // EXPERIMENTAL UUIDs of trackers/sessions handlers that forwarded this
    // message
    route: ARRAY
}
```

The `sendTo` and `answer` methods of messengers will automatically create these
messages. If the user invokes the `send` method then a JS object according to
the schema above should be passed as the first argument.

#### <a name="messenger-example"></a>Messenger examples

The following code implements what is needed to use a messenger to communicate
between any number of local JavaScript objects. Instead of dispatching methods using
a local list of messengers you will most likely use an existing networking /
messaging mechanism.

See the [worker](#) and [its implementation](worker.js) for a real use case in
which forking processes in the browser using Web Workers and in node.js using
child_process.fork is unified.

```js
// spec that defines message sending in terms of receivers in the messengers list
var messengers = [];
var messengerSpec = {
  send: function(msg, onSendDone) {
    var err = null, recv = arr.detect(messengers, function(ea) {
          return ea.id() === msg.target; });
    if (recv) recv.onMessage(msg);
    else err = new Error("Could not find receiver " + msg.target);
    onSendDone(err);
  },
  listen: function(thenDo) { arr.pushIfNotIncluded(messengers, this); },
  close: function(thenDo) { arr.remove(messengers, this); },
  isOnline: function() { return arr.include(messengers, this); }
};

// Create the messengers and add a simple "service"
var msger1 = messenger.create(messengerSpec);
var msger2 = messenger.create(messengerSpec);
msger2.addServices({
  add: function(msg, msger) { msger.answer(msg, {result: msg.data.a + msg.data.b}); }
});

// turn'em on...
msger1.listen();
msger2.listen();

// ...and action!
msger1.sendTo(msger2.id(), 'add', {a: 3, b: 4},
  function(err, answer) { alert(answer.data.result); });
```

*/

function create$2(spec) {

  var expectedMethods = [{ name: "send", args: ['msg', 'callback'] }, { name: "listen", args: ['messenger', 'callback'] }, { name: "close", args: ['messenger', 'callback'] }, { name: "isOnline", args: [] }];

  var ignoredAttributes = expectedMethods.map(function (ea) {
    return ea.name;
  }).concat(["id", "sendHeartbeat", "heartbeatInterval", "ignoreUnknownMessages", "allowConcurrentSends", "sendTimeout", "services"]);

  expectedMethods.forEach(function (exp) {
    if (spec[exp.name]) return;
    var msg = "message implementation needs function " + exp.name + "(" + exp.args.join(',') + ")";
    throw new Error(msg);
  });

  var heartbeatInterval = spec.sendHeartbeat && (spec.heartbeatInterval || 1000);
  var ignoreUnknownMessages = spec.hasOwnProperty("ignoreUnknownMessages") ? spec.ignoreUnknownMessages : false;

  var messenger = {

    _outgoing: [],
    _inflight: [],
    _id: spec.id || newUUID(),
    _ignoreUnknownMessages: ignoreUnknownMessages,
    _services: {},
    _messageCounter: 0,
    _messageResponseCallbacks: {},
    _whenOnlineCallbacks: [],
    _statusWatcherProc: null,
    _startHeartbeatProcessProc: null,
    _listenInProgress: null,
    _heartbeatInterval: heartbeatInterval,
    _status: OFFLINE,

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    _runWhenOnlineCallbacks: function _runWhenOnlineCallbacks() {
      var cbs = messenger._whenOnlineCallbacks.slice();
      messenger._whenOnlineCallbacks = [];
      cbs.forEach(function (ea) {
        try {
          ea.call(null, null, messenger);
        } catch (e) {
          console.error("error in _runWhenOnlineCallbacks: %s", e);
        }
      });
    },

    _ensureStatusWatcher: function _ensureStatusWatcher() {
      if (messenger._statusWatcherProc) return;
      messenger._statusWatcherProc = setInterval(function () {
        if (messenger.isOnline() && messenger._whenOnlineCallbacks.length) messenger._runWhenOnlineCallbacks();
        var prevStatus = messenger._status;
        messenger._status = messenger.isOnline() ? ONLINE : OFFLINE;
        if (messenger._status !== ONLINE && messenger._statusWatcherProc) {
          messenger.reconnect();
        }
        if (messenger._status !== prevStatus && messenger.onStatusChange) {
          messenger.onStatusChange();
        }
      }, 20);
    },

    _addMissingData: function _addMissingData(msg) {
      if (!msg.target) throw new Error("Message needs target!");
      if (!msg.action) throw new Error("Message needs action!");
      if (!msg.data) msg.data = null;
      if (!msg.messageId) msg.messageId = newUUID();
      msg.sender = messenger.id();
      msg.messageIndex = messenger._messageCounter++;
      return msg;
    },

    _queueSend: function _queueSend(msg, onReceiveFunc) {
      if (onReceiveFunc && typeof onReceiveFunc !== 'function') throw new Error("Expecing a when send callback, got: " + onReceiveFunc);
      messenger._outgoing.push([msg, onReceiveFunc]);
    },

    _deliverMessageQueue: function _deliverMessageQueue() {
      if (!spec.allowConcurrentSends && messenger._inflight.length) return;

      var queued = messenger._outgoing.shift();
      if (!queued) return;

      messenger._inflight.push(queued);
      if (messenger.isOnline()) deliver(queued);else messenger.whenOnline(function () {
        deliver(queued);
      });
      startTimeoutProc(queued);

      if (spec.allowConcurrentSends && messenger._outgoing.length) messenger._deliverMessageQueue();

      // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

      function deliver(queued) {
        // ignore-in-doc
        if (messenger._inflight.indexOf(queued) === -1) return; // timed out
        var msg = queued[0],
            callback = queued[1];
        if (callback) messenger._messageResponseCallbacks[msg.messageId] = callback;

        spec.send.call(messenger, msg, function (err) {
          remove(messenger._inflight, queued);
          if (err) onSendError(err, queued);
          messenger._deliverMessageQueue();
        });
      }

      function startTimeoutProc(queued) {
        if (typeof spec.sendTimeout !== 'number') return;
        setTimeout(function () {
          if (messenger._inflight.indexOf(queued) === -1) return; // delivered
          remove(messenger._inflight, queued);
          onSendError(new Error('Timeout sending message'), queued);
          messenger._deliverMessageQueue();
        }, spec.sendTimeout);
      }

      function onSendError(err, queued) {
        var msg = queued[0],
            callback = queued[1];
        delete messenger._messageResponseCallbacks[msg.messageId];
        console.error(err);
        callback && callback(err);
      }
    },

    _startHeartbeatProcess: function _startHeartbeatProcess() {
      if (messenger._startHeartbeatProcessProc) return;
      messenger._startHeartbeatProcessProc = setTimeout(function () {
        spec.sendHeartbeat.call(messenger, function (err, result) {
          messenger._startHeartbeatProcessProc = null;
          messenger._startHeartbeatProcess();
        });
      }, messenger._heartbeatInterval);
    },

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

    id: function id() {
      return messenger._id;
    },

    isOnline: function isOnline() {
      return spec.isOnline.call(messenger);
    },

    heartbeatEnabled: function heartbeatEnabled() {
      return typeof messenger._heartbeatInterval === 'number';
    },

    listen: function listen(thenDo) {
      if (messenger._listenInProgress) return;
      messenger._listenInProgress = true;
      messenger._ensureStatusWatcher();
      return spec.listen.call(messenger, function (err) {
        messenger._listenInProgress = null;
        thenDo && thenDo(err);
        if (messenger.heartbeatEnabled()) messenger._startHeartbeatProcess();
      });
      return messenger;
    },

    reconnect: function reconnect() {
      if (messenger._status === ONLINE) return;
      messenger.listen();
      return messenger;
    },

    send: function send(msg, onReceiveFunc) {
      messenger._addMissingData(msg);
      messenger._queueSend(msg, onReceiveFunc);
      messenger._deliverMessageQueue();
      return msg;
    },

    sendTo: function sendTo(target, action, data, onReceiveFunc) {
      var msg = { target: target, action: action, data: data };
      return messenger.send(msg, onReceiveFunc);
    },

    onMessage: function onMessage(msg) {
      messenger.emit("message", msg);
      if (msg.inResponseTo) {
        var cb = messenger._messageResponseCallbacks[msg.inResponseTo];
        if (cb && !msg.expectMoreResponses) delete messenger._messageResponseCallbacks[msg.inResponseTo];
        if (cb) cb(null, msg);
      } else {
        var action = messenger._services[msg.action];
        if (action) {
          try {
            action.call(null, msg, messenger);
          } catch (e) {
            var errmMsg = String(e.stack || e);
            console.error("Error invoking service: " + errmMsg);
            messenger.answer(msg, { error: errmMsg });
          }
        } else if (!messenger._ignoreUnknownMessages) {
          var err = new Error("messageNotUnderstood: " + msg.action);
          messenger.answer(msg, { error: String(err) });
        }
      }
    },

    answer: function answer(msg, data, expectMore, whenSend) {
      if (typeof expectMore === 'function') {
        whenSend = expectMore;expectMore = false;
      }
      var answer = {
        target: msg.sender,
        action: msg.action + 'Result',
        inResponseTo: msg.messageId,
        data: data };
      if (expectMore) answer.expectMoreResponses = true;
      return messenger.send(answer, whenSend);
    },

    close: function close(thenDo) {
      clearInterval(messenger._statusWatcherProc);
      messenger._statusWatcherProc = null;
      spec.close.call(messenger, function (err) {
        messenger._status = OFFLINE;
        thenDo && thenDo(err);
      });
      return messenger;
    },

    whenOnline: function whenOnline(thenDo) {
      messenger._whenOnlineCallbacks.push(thenDo);
      if (messenger.isOnline()) messenger._runWhenOnlineCallbacks();
      return messenger;
    },

    outgoingMessages: function outgoingMessages() {
      return pluck(messenger._inflight.concat(messenger._outgoing), 0);
    },

    addServices: function addServices(serviceSpec) {
      Object.assign(messenger._services, serviceSpec);
      return messenger;
    }
  };

  if (spec.services) messenger.addServices(spec.services);
  makeEmitter(messenger);

  for (var name in spec) {
    if (ignoredAttributes.indexOf(name) === -1 && spec.hasOwnProperty(name)) {
      messenger[name] = spec[name];
    }
  }

  return messenger;
}



var messenger = Object.freeze({
	create: create$2
});

/*global require, Worker, URL, webkitURL, Blob, BlobBuilder, process, require*/

/*
 * A platform-independent worker interface that will spawn new processes per
 * worker (if the platform you use it on supports it).
 */

var isNodejs = typeof require !== 'undefined' && typeof process !== 'undefined';

// ignore-in-doc
// Code in worker setup is evaluated in the context of workers, it will get to
// workers in a stringified form(!).
var WorkerSetup = {

  loadDependenciesBrowser: function loadDependenciesBrowser(options) {
    var me = typeof self !== "undefined" ? self : this;
    importScripts.apply(me, options.scriptsToLoad || []);
  },

  loadDependenciesNodejs: function loadDependenciesNodejs(options) {
    var lv = global.lively || (global.lively = {});
    lv.lang = require(require("path").join(options.libLocation, "index"));
  },

  // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  // yoshiki and robert, 05/08/13: Inserted code that sets up the lively context
  // and globals of Lively and other required objects:
  initBrowserGlobals: function initBrowserGlobals(options) {
    remoteWorker.send = function (msg) {
      postMessage(msg);
    };
    var me = typeof self !== "undefined" ? self : this;
    var Global = me.Global = me;
    Global.window = Global;
    Global.console = Global.console || function () {
      var c = {};
      ['log', 'error', 'warn'].forEach(function (name) {
        c[name] = function () /*args*/{
          var string = arguments[0];
          for (var i = 1; i < arguments.length; i++) {
            string = string.replace('%s', arguments[i]);
          }remoteWorker.send({
            type: name,
            message: ['[', name.toUpperCase(), '] ', string].join('')
          });
        };
      });
      return c;
    }();
  },

  initOnMessageHandler: function initOnMessageHandler(options) {
    if (remoteWorker.on) remoteWorker.on('message', onMessage);else remoteWorker.onmessage = onMessage;

    function onMessage(msg) {
      msg = msg.data.data ? msg.data : msg;
      if (remoteWorker.messenger) remoteWorker.messenger.onMessage(msg);else if (msg.action == "close") {
        remoteWorker.send({ type: "closed", workerReady: false });
        remoteWorker.close();
        return;
      }
    }
  },

  initWorkerInterface: function initWorkerInterface(options) {
    remoteWorker.callStringifiedFunction = function (stringifiedFunc, args, thenDo) {
      // ignore-in-doc
      // runs stringified function and passing args. stringifiedFunc might
      // be asynchronous if it takes an addaitional argument. In this case a
      // callback to call when the work is done is passed, otherwise thenDo
      // will be called immediatelly after creating and calling the function

      var func;
      try {
        func = eval('(' + stringifiedFunc + ')');
      } catch (e) {
        thenDo(new Error("Cannot create function from string: " + e.stack || e));
        return;
      }

      // ignore-in-doc
      // when it takes one more arg then we assume that this is the callback
      // to be called by the run func when it considers to be done
      var usesCallback = func.length === args.length + 1;
      var whenDone = lively.lang.fun.once(function (err, result) {
        remoteWorker.isBusy = false;thenDo(err, result);
      });
      remoteWorker.isBusy = true;

      if (usesCallback) args.push(whenDone);

      try {
        var result = func.apply(remoteWorker, args.concat([whenDone]));
      } catch (e) {
        whenDone(e, null);return;
      }

      if (!usesCallback) whenDone(null, result);
    };

    remoteWorker.httpRequest = function (options) {
      if (!options.url) {
        console.log("Error, httpRequest needs url");
        return;
      }
      var req = new XMLHttpRequest(),
          method = options.method || 'GET';
      function handleStateChange() {
        if (req.readyState === 4) {
          // req.status
          options.done && options.done(req);
        }
      }
      req.onreadystatechange = handleStateChange;
      req.open(method, options.url);
      req.send();
    };

    remoteWorker.terminateIfNotBusyIn = function (ms) {
      setTimeout(function () {
        if (remoteWorker.isBusy) {
          remoteWorker.terminateIfNotBusyIn(ms);return;
        }
        remoteWorker.send({ type: "closed", workerReady: false });
        remoteWorker.close();
      }, ms);
    };
  },

  // ignore-in-doc
  // setting up the worker messenger interface, this is how the worker
  // should be communicated with
  initWorkerMessenger: function initWorkerMessenger(options) {
    if (!options.useMessenger) return null;
    if (!lively.lang.messenger) throw new Error("worker.create requires messenger.js to be loaded!");
    if (!lively.lang.events) throw new Error("worker.create requires events.js to be loaded!");

    return remoteWorker.messenger = lively.lang.messenger.create({
      services: {

        remoteEval: function remoteEval(msg, messenger) {
          var result;
          try {
            result = eval(msg.data.expr);
          } catch (e) {
            result = e.stack || e;
          }
          messenger.answer(msg, { result: String(result) });
        },

        run: function run(msg, messenger) {
          var funcString = msg.data.func,
              args = msg.data.args;
          if (!funcString) {
            messenger.answer(msg, { error: 'no funcString' });return;
          }
          remoteWorker.callStringifiedFunction(funcString, args, function (err, result) {
            messenger.answer(msg, { error: err ? String(err) : null, result: result });
          });
        },

        close: function close(msg, messenger) {
          messenger.answer(msg, { status: "OK" });
          remoteWorker.send({ type: "closed", workerReady: false });
          remoteWorker.close();
        }
      },

      isOnline: function isOnline() {
        return true;
      },
      send: function send(msg, whenSend) {
        remoteWorker.send(msg);whenSend();
      },
      listen: function listen(whenListening) {
        whenListening();
      },
      close: function close(whenClosed) {
        remoteWorker.send({ type: "closed", workerReady: false });remoteWorker.close();
      }

    });
  }

};

var BrowserWorker = {

  create: function create$3(options) {
    // ignore-in-doc
    // this function instantiates a browser worker object. We provide a
    // messenger-based interface to the pure Worker. Please use create to get an
    // improved interface to a worker

    options = options || {};

    // ignore-in-doc
    // figure out where the other lang libs can be loaded from
    if (!options.libLocation && !options.scriptsToLoad) {
      var workerScript = document.querySelector("script[src$=\"worker.js\"]");
      if (!workerScript) throw new Error("Cannot find library path to start worker. Use worker.create({libLocation: \"...\"}) to explicitly define the path!");
      options.libLocation = workerScript.src.replace(/worker.js$/, '');
    }

    var workerSetupCode = String(workerSetupFunction).replace("__FUNCTIONDECLARATIONS__", [WorkerSetup.initBrowserGlobals, WorkerSetup.loadDependenciesBrowser, WorkerSetup.initOnMessageHandler, WorkerSetup.initWorkerInterface, WorkerSetup.initWorkerMessenger].join('\n'));
    var workerCode = '(' + workerSetupCode + ')();';
    var worker = new Worker(makeDataURI(workerCode));
    init(options, worker);
    return worker;

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

    // ignore-in-doc
    // This code is triggered in the UI process directly after the
    // creation of the worker and sends the setup message to the worker
    // for initializing it.
    function init(options, worker) {
      makeEmitter(worker);

      if (!options.scriptsToLoad) {
        options.scriptsToLoad = ['base.js', 'events.js', 'object.js', 'collection.js', 'function.js', 'string.js', 'number.js', 'date.js', 'messenger.js', 'worker.js'].map(function (ea) {
          return options.libLocation + ea;
        });
      }

      var workerOptions = Object.keys(options).reduce(function (opts, key) {
        if (typeof options[key] !== 'function') opts[key] = options[key];
        return opts;
      }, {});

      worker.onmessage = function (evt) {
        if (evt.data.workerReady !== undefined) {
          worker.ready = !!evt.data.workerReady;
          if (worker.ready) worker.emit("ready");else worker.emit("close");
        } else worker.emit('message', evt.data);
      };

      worker.errors = [];
      worker.onerror = function (evt) {
        console.error(evt);
        worker.errors.push(evt);
        worker.emit("error", evt);
      };

      worker.postMessage({ action: 'setup', options: workerOptions });
    }

    // ignore-in-doc
    // This code is run inside the worker and bootstraps the messenger
    // interface. It also installs a console.log method since since this is not
    // available by default.
    function workerSetupFunction() {
      var remoteWorker = self;
      remoteWorker.onmessage = function (evt) {
        if (evt.data.action !== "setup") {
          throw new Error("expected setup to be first message but got " + JSON.stringify(evt.data));
        }
        var options = evt.data.options || {};
        initBrowserGlobals(options);
        loadDependenciesBrowser(options);
        initOnMessageHandler(options);
        initWorkerInterface(options);
        initWorkerMessenger(options);
        postMessage({ workerReady: true });
      };
      __FUNCTIONDECLARATIONS__;
    }

    function makeDataURI(codeToInclude) {
      // ignore-in-doc
      // see http://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string
      var blob;
      try {
        blob = new Blob([codeToInclude], { type: "text/javascript" });
      } catch (e) {
        /* ignore-in-doc Backwards-compatibility*/
        window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
        blob = new BlobBuilder();
        blob.append(codeToInclude);
        blob = blob.getBlob();
      }
      var urlInterface = typeof webkitURL !== 'undefined' ? webkitURL : URL;
      return urlInterface.createObjectURL(blob);
    }
  }

};

var NodejsWorker = {

  debug: false,
  initCodeFileCreated: false,

  create: function create$3(options) {
    options = options || {};

    // ignore-in-doc
    // figure out where the other lang libs can be loaded from
    // if (!options.libLocation && !options.scriptsToLoad) {
    //   var workerScript = document.querySelector("script[src$=\"worker.js\"]");
    //   if (!workerScript) throw new Error("Cannot find library path to start worker. Use worker.create({libLocation: \"...\"}) to explicitly define the path!");
    //   options.libLocation = workerScript.src.replace(/worker.js$/, '');
    // }

    var workerProc;
    var worker = makeEmitter({
      ready: false,
      errors: [],

      postMessage: function postMessage(msg) {
        if (!workerProc) {
          worker.emit("error", new Error('nodejs worker process not yet created'));
          return;
        }
        if (!worker.ready) {
          worker.emit("error", new Error('nodejs worker process not ready or already closed'));
          return;
        }
        workerProc.send(msg);
      }
    });

    NodejsWorker.startWorker(options, function (err, _workerProc) {
      if (err) {
        worker.ready = false;worker.emit("error", err);return;
      }

      workerProc = _workerProc;

      workerProc.on('message', function (m) {
        NodejsWorker.debug && console.log('[WORKER PARENT] got message:', m);
        worker.emit("message", m);
      });

      workerProc.on('close', function () {
        console.log("[WORKER PARENT] worker closed");
        worker.emit("close");
      });

      workerProc.on('error', function (err) {
        console.log("[WORKER PARENT] error ", err);
        worker.errors.push(err);
        worker.emit("error", err);
      });

      worker.ready = true;
      worker.emit("ready");
    });

    return worker;
  },

  // this code is run in the context of the worker process
  workerSetupFunction: function workerSetupFunction() {
    var remoteWorker = process;
    var debug = true;
    var close = false;

    debug && console.log("[WORKER] Starting init");
    // ignore-in-doc
    // process.on('message', function(m) {
    //   debug && console.log('[WORKER] got message:', m);
    //   if (m.action === 'ping') process.send({action: 'pong', data: m});
    //   else if (m.action === 'close') close = true;
    //   else if (m.action === 'setup') setup(m.data);
    //   else console.error('[WORKER] unknown message: ', m);
    // });

    remoteWorker.on("message", function (msg) {
      if (msg.action !== "setup") {
        throw new Error("expected setup to be first message but got " + JSON.stringify(msg.data));
      }
      remoteWorker.removeAllListeners("message");
      var options = msg.data.options || {};
      debug && console.log("[WORKER] running setup with options", options);
      loadDependenciesNodejs(options);
      initOnMessageHandler(options);
      initWorkerInterface(options);
      initWorkerMessenger(options);
      remoteWorker.send({ workerReady: true });
    });
    __FUNCTIONDECLARATIONS__;
  },

  ensureInitCodeFile: function ensureInitCodeFile(options, initCode, thenDo) {
    var path = require("path");
    var os = require("os");
    var fs = require("fs");

    var workerTmpDir = path.join(os.tmpDir(), 'lively-nodejs-workers/');
    var fn = path.join(workerTmpDir, 'nodejs-worker-init.js');

    if (!NodejsWorker.initCodeFileCreated) NodejsWorker.createWorkerCodeFile(options, fn, initCode, thenDo);else fs.exists(fn, function (exists) {
      if (exists) thenDo(null, fn);else NodejsWorker.createWorkerCodeFile(options, fn, initCode, thenDo);
    });
  },

  createWorkerCodeFile: function createWorkerCodeFile(options, fileName, initCode, thenDo) {
    var path = require("path");
    var fs = require("fs");
    var exec = require("child_process").exec;

    exec("mkdir -p " + path.dirname(fileName), function (code, out, err) {
      if (code) {
        thenDo(new Error(["[WORKER PARENT] Could not create worker temp dir:", out, err].join('\n')));
        return;
      }
      fs.writeFile(fileName, initCode, function (err) {
        NodejsWorker.debug && console.log('worker code file %s created', fileName);
        NodejsWorker.initCodeFileCreated = true;
        thenDo(err, fileName);
      });
    });
  },

  startWorker: function startWorker(options, thenDo) {
    var util = require("util");
    var fork = require("child_process").fork;

    var workerSetupCode = String(NodejsWorker.workerSetupFunction).replace("__FUNCTIONDECLARATIONS__", [WorkerSetup.loadDependenciesNodejs, WorkerSetup.initOnMessageHandler, WorkerSetup.initWorkerInterface, WorkerSetup.initWorkerMessenger].join('\n'));

    var initCode = util.format("(%s)();\n", workerSetupCode);
    NodejsWorker.ensureInitCodeFile(options, initCode, function (err, codeFileName) {
      if (err) return thenDo(err);
      var worker = fork(codeFileName, {});
      NodejsWorker.debug && console.log('worker forked');
      worker.on('message', function (m) {
        if (m.action === 'pong') console.log("[WORKER pong] ", m);else if (m.action === 'log') console.log("[Message from WORKER] ", m.data);
      });
      worker.once('message', function (m) {
        NodejsWorker.debug && console.log('worker setup done');
        thenDo(null, worker, m);
      });
      worker.on('close', function () {
        NodejsWorker.debug && console.log("[WORKER PARENT] worker closed");
      });
      worker.send({ action: "setup", data: { options: options } });
      global.WORKER = worker;
    });
  }

};

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// the worker interface, usable both in browser and node.js contexts
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

/*
Worker objects allow to fork processes in both Web and node.js JavaScript
environments. They provide this mechanism using web workers in the browser and
node.js child processes in node.js. The interface is unified for all platforms.
 */

function fork(options, workerFunc, thenDo) {
  // Fork automatically starts a worker and calls `workerFunc`. `workerFunc`
  // gets as a last paramter a callback, that, when invoked with an error and
  // result object, ends the worker execution.
  //
  // Options are the same as in `create` except for an `args` property that
  // can be an array of objects. These objects will be passed to `workerFunc`
  // as arguments.
  //
  // Note: `workerFunc` will not be able to capture outside variables (create a
  // closure).
  //
  // Example:
  // // When running this inside a browser: Note how the UI does not block.
  // worker.fork({args: [40]},
  //   function(n, thenDo) {
  //     function fib(n) { return n <= 1 ? n : fib(n-1) + fib(n-2); }
  //     thenDo(null, fib(n));
  //   },
  //   function(err, result) { show(err ? err.stack : result); })

  if (!thenDo) {
    thenDo = workerFunc;workerFunc = options;options = null;
  }
  options = options || {};
  var args = options.args || [];
  var w = create$3(options);
  w.run.apply(w, [workerFunc].concat(args).concat(thenDo));
  return w;
}

function create$3(options) {
  // Explicitly creates a first-class worker. Options:
  // ```js
  // {
  //   workerId: STRING, // optional, id for worker, will be auto assigned if not provided
  //   libLocation: STRING, // optional, path to where the lively.lang lib is located. Worker will try to find it automatically if not provided.
  //   scriptsToLoad: ARRAY // optional, list of path/urls to load. Overwrites `libLocation`
  // }
  // ```
  //
  // Example:
  // // this is just a helper function
  // function resultHandler(err, result) { alert(err ? String(err) : result); }
  //
  // // 1. Create the worker
  // var worker = lively.lang.worker.create({libLocation: baseURL});
  //
  // // 2. You can evaluate arbitrary JS code
  // worker.eval("1+2", function(err, result) { show(err ? String(err) : result); });
  //
  // // 3. Arbitrary functions can be called inside the worker context.
  // //    Note: functions shouldn't be closures / capture local state!) and passing
  // //    in arguments!
  // worker.run(
  //   function(a, b, thenDo) { setTimeout(function() { thenDo(null, a+b); }, 300); },
  //   19, 4, resultHandler);
  //
  // // 4. You can also install your own messenger services...
  // worker.run(
  //   function(thenDo) {
  //     self.messenger.addServices({
  //       foo: function(msg, messenger) { messenger.answer(msg, "bar!"); }
  //     });
  //     thenDo(null, "Service installed!");
  //   }, resultHandler);
  //
  // // ... and call them via the messenger interface
  // worker.sendTo("worker", "foo", {}, resultHandler);
  //
  // // 5. afterwards: shut it down
  // worker.close(function(err) { err && show(String(err)); alertOK("worker shutdown"); })

  options = options || {};
  options.useMessenger = true;

  // if (!exports.messenger)
  //   throw new Error("worker.create requires messenger.js to be loaded!")
  // if (!exports.events)
  //   throw new Error("worker.create requires events.js to be loaded!")
  // if (!exports.obj)
  //   throw new Error("worker.create requires object.js to be loaded!")

  var workerId = options.workerId || newUUID();

  var messenger = create$2({
    sendTimeout: 5000,

    send: function send(msg, whenSend) {
      messenger.worker.postMessage(msg);
      whenSend();
    },

    listen: function listen(whenListening) {
      var w = messenger.worker = isNodejs ? NodejsWorker.create(options) : BrowserWorker.create(options);
      w.on("message", function (msg) {
        messenger.onMessage(msg);
      });
      w.on('ready', function () {
        NodejsWorker.debug && console.log("WORKER READY!!!");
      });
      w.on('close', function () {
        NodejsWorker.debug && console.log("WORKER CLOSED...!!!");
      });
      w.once('ready', whenListening);
    },

    close: function close(whenClosed) {
      if (!messenger.worker.ready) return whenClosed(null);
      return messenger.sendTo(workerId, 'close', {}, function (err, answer) {
        err = err || answer.data.error;
        err && console.error("Error in worker messenger close: " + err.stack || err);
        if (err) whenClosed(err);else {
          var closed = false;
          messenger.worker.once('close', function () {
            closed = true;
          });
          waitFor(1000, function () {
            return !!closed;
          }, whenClosed);
        }
      });
    },

    isOnline: function isOnline() {
      return messenger.worker && messenger.worker.ready;
    }

  });

  Object.assign(messenger, {
    eval: function _eval(code, thenDo) {
      messenger.sendTo(workerId, "remoteEval", { expr: code }, function (err, answer) {
        thenDo(err, answer ? answer.data.result : null);
      });
    },
    run: function run() /*runFunc, arg1, ... argN, thenDo*/{
      var args = Array.prototype.slice.call(arguments),
          workerFunc = args.shift(),
          thenDo = args.pop();
      if (typeof workerFunc !== "function") throw new Error("run: no function that should run in worker passed");
      if (typeof thenDo !== "function") throw new Error("run: no callback passed");

      return messenger.sendTo(workerId, 'run', { func: String(workerFunc), args: args }, function (err, answer) {
        thenDo(err || answer.data.error, answer ? answer.data.result : null);
      });
    }
  });

  messenger.listen();

  return messenger;
}



var worker = Object.freeze({
	fork: fork,
	create: create$3
});

var GLOBAL = typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : undefined;

var isNode = typeof process !== "undefined" && process.env && typeof process.exit === "function";

var globalInterfaceSpec = [{ action: "installMethods", target: "Array", sources: ["arr"], methods: ["from", "genN", "range", "withN"] }, { action: "installMethods", target: "Array.prototype", sources: ["arr"], methods: ["all", "any", "batchify", "clear", "clone", "collect", "compact", "delimWith", "detect", "doAndContinue", "each", "equals", "filterByKey", "findAll", "first", "flatten", "forEachShowingProgress", "grep", "groupBy", "groupByKey", "histogram", "include", "inject", "intersect", "invoke", "last", "mapAsync", "mapAsyncSeries", "mask", "max", "min", "mutableCompact", "nestedDelay", "partition", "pluck", "pushAll", "pushAllAt", "pushAt", "pushIfNotIncluded", "reMatches", "reject", "rejectByKey", "remove", "removeAt", "replaceAt", "rotate", "shuffle", "size", "sortBy", "sortByKey", "sum", "swap", "toArray", "toTuples", "union", "uniq", "uniqBy", "without", "withoutAll", "zip"], alias: [["select", "filter"]] }, { action: "installMethods", target: "Date", sources: ["date"], methods: [/*"parse"*/] }, { action: "installMethods", target: "Date.prototype", sources: ["date"], methods: ["equals", "format", "relativeTo"] }, { action: "installMethods", target: "Function", sources: ["fun"], methods: ["fromString"] }, { action: "installMethods", target: "Function.prototype", sources: ["fun"], methods: [/*"addProperties",*/"addToObject", "argumentNames", "asScript", "asScriptOf", "binds", "curry", "delay", "functionNames", "localFunctionNames", "getOriginal", "getVarMapping", "logCalls", "logCompletion", "logErrors", "qualifiedMethodName", "setProperty", "traceCalls", "wrap"] }, { action: "installMethods", target: "Number", sources: ["num"], methods: [] }, { action: "installMethods", target: "Number.prototype", sources: ["num"], methods: ["detent", "randomSmallerInteger", "roundTo", "toDegrees", "toRadians"] }, { action: "installMethods", target: "Object", sources: ["obj"], methods: ["addScript", "clone", "deepCopy", "extend", "inherit", "isArray", "isBoolean", "isElement", "isEmpty", "isFunction", "isNumber", "isObject", "isRegExp", "isString", "isUndefined", "merge", "mergePropertyInHierarchy", "values", "valuesInPropertyHierarchy"] }, { action: "installMethods", target: "Object.prototype", sources: ["obj"], methods: [] }, { action: "installMethods", target: "String.prototype", sources: ["string"], methods: ["camelize", "capitalize", "digitValue", "empty", "hashCode", "include", "pad", "regExpEscape", "startsWithVowel", "succ", "times", "toArray", "toQueryParams", "truncate"] }, { action: "installMethods", target: "Function.prototype", sources: ["klass"], methods: ["create", "addMethods", "isSubclassOf", "superclasses", "categoryNameFor", "remove"], alias: [["subclass", "create"]] }, { action: "installObject", target: "Numbers", source: "num", methods: ["average", "between", "convertLength", "humanReadableByteSize", "median", "normalRandom", "parseLength", "random", "sort"] }, { action: "installObject", target: "Properties", source: "properties", methods: ["all", "allOwnPropertiesOrFunctions", "allProperties", "any", "forEachOwn", "hash", "nameFor", "own", "ownValues", "values"] }, { action: "installObject", target: "Strings", source: "string", methods: ["camelCaseString", "createDataURI", "diff", "format", "formatFromArray", "indent", "lineIndexComputer", "lines", "md5", "newUUID", "nonEmptyLines", "pad", "paragraphs", "peekLeft", "peekRight", "print", "printNested", "printTable", "printTree", "quote", "reMatches", "stringMatch", "tableize", "tokens", "unescapeCharacterEntities", "withDecimalPrecision"] }, { action: "installObject", target: "Objects", source: "obj", methods: ["asObject", "equals", "inspect", "isMutableType", "safeToString", "shortPrintStringOf", "typeStringOf"] }, { action: "installObject", target: "Functions", source: "fun", methods: ["all", "compose", "composeAsync", "createQueue", "debounce", "debounceNamed", "either", "extractBody", "flip", "notYetImplemented", "once", "own", "throttle", "throttleNamed", "timeToRun", "timeToRunN", "waitFor", "workerWithCallbackQueue", "wrapperChain"] }, { action: "installObject", target: "Grid", source: "grid" }, { action: "installObject", target: "Interval", source: "interval" }, { action: "installObject", target: "lively.ArrayProjection", source: "arrayProjection" }, { action: "installObject", target: "lively.Closure", source: "Closure" }, { action: "installObject", target: "lively.Grouping", source: "Group" }, { action: "installObject", target: "lively.PropertyPath", source: "Path" }, { action: "installObject", target: "lively.Worker", source: "worker" }, { action: "installObject", target: "lively.Class", source: "classHelper" }];

function createLivelyLangObject() {
  return {
    chain: chain$$1,
    noConflict: noConflict,
    installGlobals: installGlobals,
    uninstallGlobals: uninstallGlobals,
    globalInterfaceSpec: globalInterfaceSpec,
    toString: function toString() {
      return "[object lively.lang]";
    }
  };
}

var livelyLang = createLivelyLangObject();



function chain$$1(object) {
  if (!object) return object;

  var chained;
  if (Array.isArray(object)) return createChain(arr, object);
  if (object.constructor.name === "Date") return createChain(date, object);
  switch (typeof object === "undefined" ? "undefined" : _typeof(object)) {
    case 'string':
      return createChain(string, object);
    case 'object':
      return createChain(obj, object);
    case 'function':
      return createChain(fun, object);
    case 'number':
      return createChain(num, object);
  }
  throw new Error("Chain for object " + object + " (" + object.constructor.name + ") no supported");
}

function createChain(interfaceObj, obj) {
  return Object.keys(interfaceObj).reduce(function (chained, methodName) {
    chained[methodName] = function () /*args*/{
      var args = Array.prototype.slice.call(arguments),
          result = interfaceObj[methodName].apply(null, [obj].concat(args));
      return chain$$1(result);
    };
    return chained;
  }, { value: function value() {
      return obj;
    } });
}

function noConflict() {
  if (!isNode) {
    var keepLivelyNS = livelyLang._prevLivelyGlobal;
    if (!keepLivelyNS) delete GLOBAL.lively;else delete GLOBAL.lively.lang;
  }
  return livelyLang;
}

function installGlobals() {
  globalInterfaceSpec.forEach(function (ea) {
    if (ea.action === "installMethods") {
      var targetPath = Path(ea.target);
      if (!targetPath.isIn(GLOBAL)) targetPath.set(GLOBAL, {}, true);
      var sourcePath = Path(ea.sources[0]);
      ea.methods.forEach(function (name) {
        installProperty(sourcePath.concat([name]), targetPath.concat([name]));
      });
      if (ea.alias) ea.alias.forEach(function (mapping) {
        installProperty(sourcePath.concat([mapping[1]]), targetPath.concat([mapping[0]]));
      });
    } else if (ea.action === "installObject") {
      var targetPath = Path(ea.target);
      var source = Path(ea.source).get(livelyLang);
      targetPath.set(GLOBAL, source, true);
    } else throw new Error("Cannot deal with global setup action: " + ea.action);
  });
}

function installProperty(sourcePath, targetPath) {
  if (!sourcePath.isIn(livelyLang)) {
    var err = new Error("property not provided by lively.lang: " + sourcePath);
    console.error(err.stack || err);
    throw err;
  }

  var prop = sourcePath.get(livelyLang);
  if (typeof prop === "function" && targetPath.slice(-2, -1).toString() === "prototype") {
    var origFunc = prop;
    prop = function prop() /*this and args*/{
      var args = Array.prototype.slice.call(arguments);
      args.unshift(this);
      return origFunc.apply(null, args);
    };
    prop.toString = function () {
      return origFunc.toString();
    };
  }
  targetPath.set(GLOBAL, prop, true);
}

function uninstallGlobals() {
  globalInterfaceSpec.forEach(function (ea) {
    if (ea.action === "installMethods") {
      var p = Path(ea.target);
      var source = Path(ea.source).get(livelyLang);
      var target = p.get(GLOBAL);
      if (!target) return;
      ea.methods.filter(function (name) {
        return source === target[name];
      }).forEach(function (name) {
        delete target[name];
      });
      if (ea.alias) ea.alias.filter(function (name) {
        return source === target[name];
      }).forEach(function (mapping) {
        delete target[mapping[0]];
      });
    } else if (ea.action === "installObject") {
      var p = Path(ea.target);
      p.del(GLOBAL);
    } else throw new Error("Cannot deal with global setup action: " + ea.action);
  });
}

exports.worker = worker;
exports.messenger = messenger;
exports.events = events;
exports.tree = tree;
exports.grid = grid;
exports.arrayProjection = arrayProjection;
exports.interval = interval;
exports.graph = graph;
exports.date = date;
exports.properties = properties;
exports.obj = obj;
exports.arr = arr;
exports.fun = fun;
exports.num = num;
exports.string = string;
exports.Closure = Closure;
exports.promise = promise;
exports.Path = Path;
exports.Group = Group;
exports.livelyLang = livelyLang;
exports.chain = chain$$1;
exports.noConflict = noConflict;
exports.installGlobals = installGlobals;
exports.uninstallGlobals = uninstallGlobals;

}((this.lively.lang = this.lively.lang || {})));

  }).call(GLOBAL);
  if (typeof module !== "undefined" && module.exports) module.exports = GLOBAL.lively.lang;
})();

// INLINED END /Users/robin/Development/lively-next/lively.lang/dist/lively.lang.js

// INLINED /Users/robin/Development/lively-next/lively.graphics/dist/lively.graphics.js
(function() {
  var GLOBAL = typeof window !== "undefined" ? window :
      typeof global!=="undefined" ? global :
        typeof self!=="undefined" ? self : this;
  
(function() {
  var GLOBAL = typeof window !== "undefined" ? window :
      typeof global!=="undefined" ? global :
        typeof self!=="undefined" ? self : this;
  if (typeof GLOBAL.lively === "undefined") GLOBAL.lively = {};
  (function() {
    this.lively = this.lively || {};
(function (exports) {
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var get$1 = function get$1(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get$1(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

















var set$1 = function set$1(object, property, value, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent !== null) {
      set$1(parent, property, value, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    desc.value = value;
  } else {
    var setter = desc.set;

    if (setter !== undefined) {
      setter.call(receiver, value);
    }
  }

  return value;
};

// A `Closure` is a representation of a JavaScript function that controls what
// values are bound to out-of-scope variables. By default JavaScript has no
// reflection capabilities over closed values in functions. When needing to
// serialize execution or when behavior should become part of the state of a
// system it is often necessary to have first-class control over this language
// aspect.
//
// Typically closures aren't created directly but with the help of [`asScriptOf`](#)
//
// Example:
// function func(a) { return a + b; }
// var closureFunc = Closure.fromFunction(func, {b: 3}).recreateFunc();
// closureFunc(4) // => 7
// var closure = closureFunc.livelyClosure // => {
// //   varMapping: { b: 3 },
// //   originalFunc: function func(a) {/*...*/}
// // }
// closure.lookup("b") // => 3
// closure.getFuncSource() // => "function func(a) { return a + b; }"

var parameterRegex = /function[^\(]*\(([^\)]*)\)|\(?([^\)=]*)\)?\s*=>/;

var Closure = function () {
  createClass(Closure, null, [{
    key: "fromFunction",
    value: function fromFunction(func, varMapping) {
      /*show-in-doc*/
      return new this(func, varMapping || {});
    }
  }, {
    key: "fromSource",
    value: function fromSource(source, varMapping) {
      /*show-in-doc*/
      return new this(null, varMapping || {}, source);
    }
  }]);

  function Closure(func, varMapping, source, funcProperties) {
    classCallCheck(this, Closure);

    this.originalFunc = func;
    this.varMapping = varMapping || {};
    this.setFuncSource(source || func);
    this.setFuncProperties(func || funcProperties);
  }

  createClass(Closure, [{
    key: "setFuncSource",


    // accessing
    value: function setFuncSource(src) {
      /*show-in-doc*/
      src = typeof lively !== "undefined" && lively.sourceTransform && typeof lively.sourceTransform.stringifyFunctionWithoutToplevelRecorder === "function" ? lively.sourceTransform.stringifyFunctionWithoutToplevelRecorder(src) : String(src);
      return this.source = src;
    }
  }, {
    key: "getFuncSource",
    value: function getFuncSource() {
      /*show-in-doc*/
      return this.source || this.setFuncSource(this.originalFunc);
    }
  }, {
    key: "hasFuncSource",
    value: function hasFuncSource() {
      /*show-in-doc*/
      return this.source && true;
    }
  }, {
    key: "getFunc",
    value: function getFunc() {
      /*show-in-doc*/
      return this.originalFunc || this.recreateFunc();
    }
  }, {
    key: "getFuncProperties",
    value: function getFuncProperties() {
      // ignore-in-doc
      // a function may have state attached
      return this.funcProperties || (this.funcProperties = {});
    }
  }, {
    key: "setFuncProperties",
    value: function setFuncProperties(obj) {
      // ignore-in-doc
      var props = this.getFuncProperties();
      for (var name in obj) {
        // The AST implementation assumes that Function objects are some
        // kind of value object. When their identity changes cached state
        // should not be carried over to new function instances. This is a
        // pretty intransparent way to invalidate attributes that are used
        // for caches.
        // @cschuster, can you please fix this by making invalidation more
        // explicit?
        if (obj.hasOwnProperty(name)) props[name] = obj[name];
      }
    }
  }, {
    key: "lookup",
    value: function lookup(name) {
      /*show-in-doc*/
      return this.varMapping[name];
    }
  }, {
    key: "parameterNames",
    value: function parameterNames(methodString) {
      // ignore-in-doc

      if (typeof lively !== "undefined" && lively.ast) {
        return (lively.ast.parseFunction(methodString).params || []).map(function (ea) {
          if (ea.type === "Identifier") return ea.name;
          if (ea.left && ea.left.type === "Identifier") return ea.left.name;
          return null;
        }).filter(Boolean);
      }

      var paramsMatch = parameterRegex.exec(methodString);
      if (!paramsMatch) return [];
      var paramsString = paramsMatch[1] || paramsMatch[2] || "";
      return paramsString.split(",").map(function (ea) {
        return ea.trim();
      });
    }
  }, {
    key: "firstParameter",
    value: function firstParameter(src) {
      // ignore-in-doc
      return this.parameterNames(src)[0] || null;
    }

    // -=-=-=-=-=-=-=-=-=-
    // function creation
    // -=-=-=-=-=-=-=-=-=-

  }, {
    key: "recreateFunc",
    value: function recreateFunc() {
      // Creates a real function object
      return this.recreateFuncFromSource(this.getFuncSource(), this.originalFunc);
    }
  }, {
    key: "recreateFuncFromSource",
    value: function recreateFuncFromSource(funcSource, optFunc) {
      // ignore-in-doc
      // what about objects that are copied by value, e.g. numbers?
      // when those are modified after the originalFunc we captured
      // varMapping then we will have divergent state
      var closureVars = [],
          thisFound = false,
          specificSuperHandling = this.firstParameter(funcSource) === '$super';
      for (var name in this.varMapping) {
        if (!this.varMapping.hasOwnProperty(name)) continue;
        if (name == 'this') {
          thisFound = true;continue;
        }
        // closureVars.push(`var ${name} = this.varMapping.${name};\n`);
        closureVars.push("var " + name + " = this.varMapping." + name + ";\n");
      }

      var src = "";
      if (closureVars.length > 0) src += closureVars.join("\n");
      if (specificSuperHandling) src += '(function superWrapperForClosure() { return ';
      src += "(" + funcSource + ")";
      if (specificSuperHandling) src += '.apply(this, [$super.bind(this)]' + '.concat(Array.from(arguments))) })';
      try {
        var func = evalJS.call(this, src) || this.couldNotCreateFunc(src);
        this.addFuncProperties(func);
        this.originalFunc = func;
        return func;
      } catch (e) {
        // var msg = `Cannot create function ${e} src: ${src}`;
        var msg = "Cannot create function " + e + " src: " + src;
        console.error(msg);
        throw new Error(msg);
      }
    }
  }, {
    key: "addFuncProperties",
    value: function addFuncProperties(func) {
      // ignore-in-doc
      var props = this.getFuncProperties();
      for (var name in props) {
        if (props.hasOwnProperty(name)) func[name] = props[name];
      }this.addClosureInformation(func);
    }
  }, {
    key: "couldNotCreateFunc",
    value: function couldNotCreateFunc(src) {
      // ignore-in-doc
      var msg = 'Could not recreate closure from source: \n' + src;
      console.error(msg);
      return function () {
        throw new Error(msg);
      };
    }

    // -=-=-=-=-=-
    // conversion
    // -=-=-=-=-=-

  }, {
    key: "asFunction",
    value: function asFunction() {
      /*ignore-in-doc*/
      return this.recreateFunc();
    }

    // -=-=-=-=-=-=-=-=-=-=-=-
    // function modification
    // -=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "addClosureInformation",
    value: function addClosureInformation(f) {
      /*ignore-in-doc-in-doc*/
      f.hasLivelyClosure = true;
      f.livelyClosure = this;
      return f;
    }
  }, {
    key: "isLivelyClosure",
    get: function get() {
      return true;
    }

    // serialization

  }, {
    key: "doNotSerialize",
    get: function get() {
      return ['originalFunc'];
    }
  }]);
  return Closure;
}();

/*global clearTimeout, setTimeout*/

/*
 * Abstractions around first class functions like augmenting and inspecting
 * functions as well as to control function calls like dealing with asynchronous
 * control flows.
 */

// -=-=-=-=-=-=-=-=-
// static functions
// -=-=-=-=-=-=-=-=-

function Empty() {
  /*`function() {}`*/return function () {};
}
function K() {
  /*`function(arg) { return arg; }`*/return function (arg) {
    return arg;
  };
}
function Null() {
  /*`function() { return null; }`*/return function () {
    return null;
  };
}
function False() {
  /*`function() { return false; }`*/return function () {
    return false;
  };
}
function True() {
  /*`function() { return true; }`*/return function () {
    return true;
  };
}
function notYetImplemented() {
  return function () {
    throw new Error('Not yet implemented');
  };
}

// -=-=-=-=-=-
// accessing
// -=-=-=-=-=-
function all(object) {
  // Returns all property names of `object` that reference a function.
  // Example:
  // var obj = {foo: 23, bar: function() { return 42; }};
  // all(obj) // => ["bar"]
  var a = [];
  for (var name in object) {
    if (!object.__lookupGetter__(name) && typeof object[name] === 'function') a.push(name);
  }
  return a;
}

function own(object) {
  // Returns all local (non-prototype) property names of `object` that
  // reference a function.
  // Example:
  // var obj1 = {foo: 23, bar: function() { return 42; }};
  // var obj2 = {baz: function() { return 43; }};
  // obj2.__proto__ = obj1
  // own(obj2) // => ["baz"]
  // /*vs.*/ all(obj2) // => ["baz","bar"]
  var a = [];
  for (var name in object) {
    if (!object.__lookupGetter__(name) && object.hasOwnProperty(name) && typeof object[name] === 'function') a.push(name);
  }
  return a;
}

// -=-=-=-=-=-
// inspection
// -=-=-=-=-=-

function argumentNames(f) {
  // Example:
  // argumentNames(function(arg1, arg2) {}) // => ["arg1","arg2"]
  // argumentNames(function(/*var args*/) {}) // => []
  if (f.superclass) return []; // it's a class...
  var src = f.toString(),
      names = "",
      arrowMatch = src.match(/(?:\(([^\)]*)\)|([^\(\)-+!]+))\s*=>/);
  if (arrowMatch) names = arrowMatch[1] || arrowMatch[2] || "";else {
    var headerMatch = src.match(/^[\s\(]*function[^(]*\(([^)]*)\)/);
    if (headerMatch && headerMatch[1]) names = headerMatch[1];
  }
  return names.replace(/\/\/.*?[\r\n]|\/\*(?:.|[\r\n])*?\*\//g, '').replace(/\s+/g, '').split(',').map(function (ea) {
    return ea.trim();
  }).filter(function (name) {
    return !!name;
  });
}

function qualifiedMethodName(f) {
  // ignore-in-doc
  var objString = "";
  if (f.declaredClass) {
    objString += f.declaredClass + '>>';
  } else if (f.declaredObject) {
    objString += f.declaredObject + '.';
  }
  return objString + (f.methodName || f.displayName || f.name || "anonymous");
}

function extractBody(func) {

  // superflous indent. Useful when you have to stringify code but not want
  // to construct strings by hand.
  // Example:
  // extractBody(function(arg) {
  //   var x = 34;
  //   alert(2 + arg);
  // }) => "var x = 34;\nalert(2 + arg);"
  var codeString = String(func).replace(/^function[^\{]+\{\s*/, '').replace(/\}$/, '').trim(),
      lines = codeString.split(/\n|\r/),
      indent = undefined;
  for (var i = 0; i < lines.length; i++) {
    var m = lines[i].match(/^(\s+)[^\s]/);
    if (m && (indent === undefined || m[1].length < indent.length)) indent = m[1];
  }
  return indent ? codeString.replace(new RegExp("^" + indent, 'gm'), '') : codeString;
}

// -=-=-=-
// timing
// -=-=-=-

function timeToRun(func) {
  // returns synchronous runtime of calling `func` in ms
  // Example:
  // timeToRun(function() { new WebResource("http://google.de").beSync().get() });
  // // => 278 (or something else...)
  var startTime = Date.now();
  func();
  return Date.now() - startTime;
}

function timeToRunN$1(func, n) {
  // Like `timeToRun` but calls function `n` times instead of once. Returns
  // the average runtime of a call in ms.
  var startTime = Date.now();
  for (var i = 0; i < n; i++) {
    func();
  }return (Date.now() - startTime) / n;
}

function delay(func, timeout /*, arg1...argN*/) {
  // Delays calling `func` for `timeout` seconds(!).
  // Example:
  // (function() { alert("Run in the future!"); }).delay(1);
  var args = Array.prototype.slice.call(arguments),
      __method = args.shift(),
      timeout = args.shift() * 1000;
  return setTimeout(function delayed() {
    return __method.apply(__method, args);
  }, timeout);
}

// these last two methods are Underscore.js 1.3.3 and are slightly adapted
// Underscore.js license:
// (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.
// Underscore is distributed under the MIT license.

function throttle(func, wait) {
  // Exec func at most once every wait ms even when called more often
  // useful to calm down eagerly running updaters and such.
  // Example:
  // var i = 0;
  // var throttled = throttle(function() { alert(++i + '-' + Date.now()) }, 500);
  // Array.range(0,100).forEach(function(n) { throttled() });
  var context,
      args,
      timeout,
      throttling,
      more,
      result,
      whenDone = debounce(wait, function () {
    more = throttling = false;
  });
  return function () {
    context = this;args = arguments;
    var later = function later() {
      timeout = null;
      if (more) func.apply(context, args);
      whenDone();
    };
    if (!timeout) timeout = setTimeout(later, wait);
    if (throttling) {
      more = true;
    } else {
      result = func.apply(context, args);
    }
    whenDone();
    throttling = true;
    return result;
  };
}

function debounce(wait, func, immediate) {
  // Call `func` after `wait` milliseconds elapsed since the last invocation.
  // Unlike `throttle` an invocation will restart the wait period. This is
  // useful if you have a stream of events that you want to wait for to finish
  // and run a subsequent function afterwards. When you pass arguments to the
  // debounced functions then the arguments from the last call will be use for
  // the invocation.
  //
  // With `immediate` set to true, immediately call `func` but when called again during `wait` before
  // wait ms are done nothing happens. E.g. to not exec a user invoked
  // action twice accidentally.
  // Example:
  // var start = Date.now();
  // var f = debounce(200, function(arg1) {
  //   alert("running after " + (Date.now()-start) + "ms with arg " + arg1);
  // });
  // f("call1");
  // delay(f.curry("call2"), 0.1);
  // delay(f.curry("call3"), 0.15);
  // // => Will eventually output: "running after 352ms with arg call3"
  var timeout;
  return function () {
    var context = this,
        args = arguments;
    var later = function later() {
      timeout = null;
      if (!immediate) func.apply(context, args);
    };
    if (immediate && !timeout) func.apply(context, args);
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

var _throttledByName = {};
function throttleNamed(name, wait, func) {
  // Like `throttle` but remembers the throttled function once created and
  // repeated calls to `throttleNamed` with the identical name will use the same
  // throttled function. This allows to throttle functions in a central place
  // that might be called various times in different contexts without having to
  // manually store the throttled function.
  var store = _throttledByName;
  if (store[name]) return store[name];
  function throttleNamedWrapper() {
    // ignore-in-doc, cleaning up
    debounceNamed(name, wait, function () {
      delete store[name];
    })();
    func.apply(this, arguments);
  }
  return store[name] = throttle(throttleNamedWrapper, wait);
}

var _debouncedByName = {};
function debounceNamed(name, wait, func, immediate) {
  // Like `debounce` but remembers the debounced function once created and
  // repeated calls to `debounceNamed` with the identical name will use the same
  // debounced function. This allows to debounce functions in a central place
  // that might be called various times in different contexts without having to
  // manually store the debounced function.
  var store = _debouncedByName;
  if (store[name]) return store[name];
  function debounceNamedWrapper() {
    // ignore-in-doc, cleaning up
    delete store[name];
    func.apply(this, arguments);
  }
  return store[name] = debounce(wait, debounceNamedWrapper, immediate);
}

var _queues = {};
function createQueue(id, workerFunc) {
  // A simple queue with an attached asynchronous `workerFunc` to process
  // queued tasks. Calling `createQueue` will return an object with the
  // following interface:
  // ```js
  // {
  //   push: function(task) {/**/},
  //   pushAll: function(tasks) {/**/},
  //   handleError: function(err) {}, // Overwrite to handle errors
  //   dran: function() {}, // Overwrite to react when the queue empties
  // }
  // Example:
  // var sum = 0;
  // var q = createQueue("example-queue", function(arg, thenDo) { sum += arg; thenDo(); });
  // q.pushAll([1,2,3]);
  // queues will be remembered by their name
  // createQueue("example-queue").push(4);
  // sum // => 6

  var store = _queues;

  var queue = store[id] || (store[id] = {
    _workerActive: false,
    worker: workerFunc, tasks: [],
    drain: null, // can be overwritten by a function
    push: function push(task) {
      queue.tasks.push(task);
      queue.activateWorker();
    },
    pushAll: function pushAll(tasks) {
      tasks.forEach(function (ea) {
        queue.tasks.push(ea);
      });
      queue.activateWorker();
    },
    pushNoActivate: function pushNoActivate(task) {
      queue.tasks.push(task);
    },
    handleError: function handleError(err) {
      // can be overwritten
      err && console.error('Error in queue: ' + err);
    },
    activateWorker: function activateWorker() {
      function callback(err) {
        queue.handleError(err);queue.activateWorker();
      }
      var tasks = queue.tasks,
          active = queue._workerActive;
      if (tasks.length === 0) {
        if (active) {
          queue._workerActive = false;
          if (typeof queue.drain === 'function') queue.drain();
        }
        delete store[id];
      } else {
        if (!active) queue._workerActive = true;
        try {
          queue.worker(tasks.shift(), callback);
        } catch (err) {
          callback(err);
        }
      }
    }
  });

  return queue;
}

var _queueUntilCallbacks = {};
function workerWithCallbackQueue(id, workerFunc, optTimeout) {
  // This functions helps when you have a long running computation that
  // multiple call sites (independent from each other) depend on. This
  // function does the housekeeping to start the long running computation
  // just once and returns an object that allows to schedule callbacks
  // once the workerFunc is done.
  // Example:
  // var worker = workerWithCallbackQueue("example",
  //   function slowFunction(thenDo) {
  //     var theAnswer = 42;
  //     setTimeout(function() { thenDo(null, theAnswer); });
  //   });
  // // all "call sites" depend on `slowFunction` but don't have to know about
  // // each other
  // worker.whenDone(function callsite1(err, theAnswer) { alert("callback1: " + theAnswer); })
  // worker.whenDone(function callsite2(err, theAnswer) { alert("callback2: " + theAnswer); })
  // workerWithCallbackQueue("example").whenDone(function callsite3(err, theAnswer) { alert("callback3: " + theAnswer); })
  // // => Will eventually show: callback1: 42, callback2: 42 and callback3: 42


  // ignore-in-doc
  // This is how it works:
  // If `id` does not exist, workerFunc is called, otherwise ignored.
  // workerFunc is expected to call thenDoFunc with arguments: error, arg1, ..., argN
  // if called subsequently before workerFunc is done, the other thenDoFunc
  // will "pile up" and called with the same arguments as the first
  // thenDoFunc once workerFunc is done
  var store = _queueUntilCallbacks,
      queueCallbacks = store[id],
      isRunning = !!queueCallbacks;

  if (isRunning) return queueCallbacks;

  var callbacksRun = false,
      canceled = false;

  function cleanup() {
    if (timeoutProc) clearTimeout(timeoutProc);
    callbacksRun = true;
    delete store[id];
  }

  function runCallbacks(args) {
    if (callbacksRun) return;
    cleanup();
    queueCallbacks.callbacks.forEach(function (cb) {
      try {
        cb.apply(null, args);
      } catch (e) {
        console.error("Error when invoking callbacks in queueUntil [" + id + "]:\n" + String(e.stack || e));
      }
    });
  }

  // timeout
  if (optTimeout) {
    var timeoutProc = setTimeout(function () {
      if (callbacksRun) return;
      runCallbacks([new Error("timeout")]);
    }, optTimeout);
  }

  // init the store
  queueCallbacks = store[id] = {
    callbacks: [],
    cancel: function cancel() {
      canceled = true;
      cleanup();
    },
    whenDone: function whenDone(cb) {
      queueCallbacks.callbacks.push(cb);
      return queueCallbacks;
    }
  };

  // call worker, but delay so we can immediately return
  setTimeout(function () {
    if (canceled) return;
    try {
      workerFunc(function () /*args*/{
        runCallbacks(arguments);
      });
    } catch (e) {
      runCallbacks([e]);
    }
  }, 0);

  return queueCallbacks;
}

function _composeAsyncDefaultEndCallback(err, arg1 /*err + args*/) {
  if (err) console.error("lively.lang.composeAsync error", err);
}

function composeAsync() /*functions*/{
  // Composes functions that are asynchronous and expecting continuations to
  // be called in node.js callback style (error is first argument, real
  // arguments follow).
  // A call like `composeAsync(f,g,h)(arg1, arg2)` has a flow of control like:
  //  `f(arg1, arg2, thenDo1)` -> `thenDo1(err, fResult)`
  // -> `g(fResult, thenDo2)` -> `thenDo2(err, gResult)` ->
  // -> `h(fResult, thenDo3)` -> `thenDo2(err, hResult)`
  // Example:
  // composeAsync(
  //   function(a,b, thenDo) { thenDo(null, a+b); },
  //   function(x, thenDo) { thenDo(x*4); }
  //  )(3,2, function(err, result) { alert(result); });

  var toArray$$1 = Array.prototype.slice,
      functions = toArray$$1.call(arguments),
      defaultEndCb = _composeAsyncDefaultEndCallback,
      endCallback = defaultEndCb,
      endSuccess,
      endFailure,
      endPromise = new Promise(function (resolve, reject) {
    endSuccess = resolve;endFailure = reject;
  });

  return functions.reverse().reduce(function (prevFunc, funcOrPromise, i) {

    var nextActivated = false;
    return function () {
      var args = toArray$$1.call(arguments);

      // ignore-in-doc
      // the last arg needs to be function, discard all non-args
      // following it. This allows to have an optional callback func that can
      // even be `undefined`, e.g. when calling this func from a callsite
      // using var args;
      if (endCallback === defaultEndCb && i === functions.length - 1 /*first function*/) {
          while (args.length && typeof args[args.length - 1] !== 'function') {
            args.pop();
          }if (typeof args[args.length - 1] === 'function') endCallback = args.pop();
        }

      function next() /*err and args*/{
        nextActivated = true;
        var args = toArray$$1.call(arguments),
            err = args.shift();
        if (err) {
          endCallback(err);endFailure(err);
        } else prevFunc.apply(null, args);
      }

      if (typeof funcOrPromise === "function") {
        try {
          var result = funcOrPromise.apply(this, args.concat([next]));
          if (result && typeof result.then === "function" && typeof result.catch === "function") {
            result.then(function (value) {
              return next(null, value);
            }).catch(function (err) {
              return next(err);
            });
          }
        } catch (e) {
          console.error('composeAsync: ', e.stack || e);
          if (!nextActivated) {
            endCallback(e);endFailure(e);
          }
        }
      } else if (funcOrPromise && typeof funcOrPromise.then === "function" && typeof funcOrPromise.catch === "function") {
        funcOrPromise.then(function (value) {
          next(null, value);
        }).catch(function (err) {
          next(err);
        });
      } else {
        var err = new Error("Invalid argument to composeAsync: " + funcOrPromise);
        endCallback(err);
        endFailure(err);
      }

      return endPromise;
    };
  }, function () {
    var args = toArray$$1.call(arguments);
    endCallback.apply(null, [null].concat(args));
    endSuccess(args[0]);
  });
}

function compose() /*functions*/{
  // Composes synchronousefunctions:
  // `compose(f,g,h)(arg1, arg2)` = `h(g(f(arg1, arg2)))`
  // Example:
  // compose(
  //   function(a,b) { return a+b; },
  //   function(x) {return x*4}
  // )(3,2) // => 20

  var functions = Array.prototype.slice.call(arguments);
  return functions.reverse().reduce(function (prevFunc, func) {
    return function () {
      return prevFunc(func.apply(this, arguments));
    };
  }, function (x) {
    return x;
  });
}

function flip(f) {
  // Swaps the first two args
  // Example:
  // flip(function(a, b, c) {
  //   return a + b + c; })(' World', 'Hello', '!') // => "Hello World!"
  return function flipped() /*args*/{
    var args = Array.prototype.slice.call(arguments),
        flippedArgs = [args[1], args[0]].concat(args.slice(2));
    return f.apply(null, flippedArgs);
  };
}

function withNull(func) {
  // returns a modified version of func that will have `null` always curried
  // as first arg. Usful e.g. to make a nodejs-style callback work with a
  // then-able:
  // Example:
  // promise.then(withNull(cb)).catch(cb);
  func = func || function () {};
  return function () /*args*/{
    var args = lively.lang.arr.from(arguments);
    func.apply(null, [null].concat(args));
  };
}

function waitFor(timeoutMs, waitTesterFunc, thenDo) {
  // Wait for waitTesterFunc to return true, then run thenDo, passing
  // failure/timout err as first parameter. A timout occurs after
  // timeoutMs. During the wait period waitTesterFunc might be called
  // multiple times.
  var start = Date.now();
  var timeStep = 50;
  if (!thenDo) {
    thenDo = waitTesterFunc;
    waitTesterFunc = timeoutMs;
    timeoutMs = undefined;
  }
  (function test() {
    if (waitTesterFunc()) return thenDo();
    if (timeoutMs) {
      var duration = Date.now() - start,
          timeLeft = timeoutMs - duration;
      if (timeLeft <= 0) return thenDo(new Error('timeout'));
      if (timeLeft < timeStep) timeStep = timeLeft;
    }
    setTimeout(test, timeStep);
  })();
}

function waitForAll(options, funcs, thenDo) {
  // Wait for multiple asynchronous functions. Once all have called the
  // continuation, call `thenDo`.
  // options can be: `{timeout: NUMBER}` (how long to wait in milliseconds).

  if (!thenDo) {
    thenDo = funcs;funcs = options;options = null;
  }
  options = options || {};

  var results = funcs.map(function () {
    return null;
  });
  if (!funcs.length) {
    thenDo(null, results);return;
  }

  var leftFuncs = Array.prototype.slice.call(funcs);

  funcs.forEach(function (f, i) {
    try {
      f(function () /*err and args*/{
        var args = Array.prototype.slice.call(arguments);
        var err = args.shift();
        markAsDone(f, i, err, args);
      });
    } catch (e) {
      markAsDone(f, i, e, null);
    }
  });

  if (options.timeout) {
    setTimeout(function () {
      if (!leftFuncs.length) return;
      var missing = results.map(function (ea, i) {
        return ea === null && i;
      }).filter(function (ea) {
        return typeof ea === 'number';
      }).join(', ');
      var err = new Error("waitForAll timed out, functions at " + missing + " not done");
      markAsDone(null, null, err, null);
    }, options.timeout);
  }

  function markAsDone(f, i, err, result) {
    if (!leftFuncs.length) return;

    var waitForAllErr = null;
    var fidx = leftFuncs.indexOf(f);
    fidx > -1 && leftFuncs.splice(fidx, 1);
    if (err) {
      leftFuncs.length = 0;
      waitForAllErr = new Error("in waitForAll at" + (typeof i === 'number' ? " " + i : "") + ": \n" + (err.stack || String(err)));
    } else if (result) results[i] = result;
    if (!leftFuncs.length) setTimeout(function () {
      thenDo(waitForAllErr, results);
    }, 0);
  }
}

// -=-=-=-=-
// wrapping
// -=-=-=-=-

function curry(func, arg1, arg2, argN /*func and curry args*/) {
  // Return a version of `func` with args applied.
  // Example:
  // var add1 = (function(a, b) { return a + b; }).curry(1);
  // add1(3) // => 4

  if (arguments.length <= 1) return arguments[0];
  var args = Array.prototype.slice.call(arguments),
      func = args.shift();
  function wrappedFunc() {
    return func.apply(this, args.concat(Array.prototype.slice.call(arguments)));
  }
  wrappedFunc.isWrapper = true;
  wrappedFunc.originalFunction = func;
  return wrappedFunc;
}

function wrap(func, wrapper) {
  // A `wrapper` is another function that is being called with the arguments
  // of `func` and a proceed function that, when called, runs the originally
  // wrapped function.
  // Example:
  // function original(a, b) { return a+b }
  // var wrapped = wrap(original, function logWrapper(proceed, a, b) {
  //   alert("original called with " + a + "and " + b);
  //   return proceed(a, b);
  // })
  // wrapped(3,4) // => 7 and a message will pop up
  var __method = func;
  var wrappedFunc = function wrapped() {
    var args = Array.prototype.slice.call(arguments);
    var wrapperArgs = wrapper.isWrapper ? args : [__method.bind(this)].concat(args);
    return wrapper.apply(this, wrapperArgs);
  };
  wrappedFunc.isWrapper = true;
  wrappedFunc.originalFunction = __method;
  return wrappedFunc;
}

function getOriginal(func) {
  // Get the original function that was augmented by `wrap`. `getOriginal`
  // will traversed as many wrappers as necessary.
  while (func.originalFunction) {
    func = func.originalFunction;
  }return func;
}

function wrapperChain(method) {
  // Function wrappers used for wrapping, cop, and other method
  // manipulations attach a property "originalFunction" to the wrapper. By
  // convention this property references the wrapped method like wrapper
  // -> cop wrapper -> real method.
  // tThis method gives access to the linked list starting with the outmost
  // wrapper.
  var result = [];
  do {
    result.push(method);
    method = method.originalFunction;
  } while (method);
  return result;
}

function replaceMethodForOneCall(obj, methodName, replacement) {
  // Change an objects method for a single invocation.
  // Example:
  // var obj = {foo: function() { return "foo"}};
  // lively.lang.replaceMethodForOneCall(obj, "foo", function() { return "bar"; });
  // obj.foo(); // => "bar"
  // obj.foo(); // => "foo"
  replacement.originalFunction = obj[methodName];
  var reinstall = obj.hasOwnProperty(methodName);
  obj[methodName] = function () {
    if (reinstall) obj[methodName] = replacement.originalFunction;else delete obj[methodName];
    return replacement.apply(this, arguments);
  };
  return obj;
}

function once(func) {
  // Ensure that `func` is only executed once. Multiple calls will not call
  // `func` again but will return the original result.
  if (!func) return undefined;
  if (typeof func !== 'function') throw new Error("once() expecting a function");
  var invoked = false,
      result;
  return function () {
    if (invoked) return result;
    invoked = true;
    return result = func.apply(this, arguments);
  };
}

function either() /*funcs*/{
  // Accepts multiple functions and returns an array of wrapped
  // functions. Those wrapped functions ensure that only one of the original
  // function is run (the first on to be invoked).
  //
  // This is useful if you have multiple asynchronous choices of how the
  // control flow might continue but want to ensure that a continuation
  // is  only triggered once, like in a timeout situation:
  //
  // ```js
  // function outerFunction(callback) {
  //   function timeoutAction() { callback(new Error('timeout!')); }
  //   function otherAction() { callback(null, "All OK"); }
  //   setTimeout(timeoutAction, 200);
  //   doSomethingAsync(otherAction);
  // }
  // ```
  //
  // To ensure that `callback` only runs once you would normally have to write boilerplate like this:
  //
  // ```js
  // var ran = false;
  // function timeoutAction() { if (ran) return; ran = true; callback(new Error('timeout!')); }
  // function otherAction() { if (ran) return; ran = true; callback(null, "All OK"); }
  // ```
  //
  // Since this can get tedious an error prone, especially if more than two choices are involved, `either` can be used like this:
  // Example:
  // function outerFunction(callback) {
  //   var actions = either(
  //     function() { callback(new Error('timeout!')); },
  //     function() { callback(null, "All OK"); });
  //   setTimeout(actions[0], 200);
  //   doSomethingAsync(actions[1]);
  // }
  var funcs = Array.prototype.slice.call(arguments),
      wasCalled = false;
  return funcs.map(function (func) {
    return function () {
      if (wasCalled) return undefined;
      wasCalled = true;
      return func.apply(this, arguments);
    };
  });
}

var _eitherNameRegistry = {};
function eitherNamed(name, func) {
  // Works like [`either`](#) but usage does not require to wrap all
  // functions at once:
  // Example:
  // var log = "", name = "either-example-" + Date.now();
  // function a() { log += "aRun"; };
  // function b() { log += "bRun"; };
  // function c() { log += "cRun"; };
  // setTimeout(eitherNamed(name, a), 100);
  // setTimeout(eitherNamed(name, b), 40);
  // setTimeout(eitherNamed(name, c), 80);
  // setTimeout(function() { alert(log); /* => "bRun" */ }, 150);
  var funcs = Array.prototype.slice.call(arguments);
  var registry = _eitherNameRegistry;
  var name = funcs.shift();
  var eitherCall = registry[name] || (registry[name] = { wasCalled: false, callsLeft: 0 });
  eitherCall.callsLeft++;
  return function () {
    eitherCall.callsLeft--;
    // cleanup the storage if all registered functions fired
    if (eitherCall.callsLeft <= 0) delete registry[name];
    if (eitherCall.wasCalled) return undefined;
    eitherCall.wasCalled = true;
    return func.apply(this, arguments);
  };
}

// -=-=-=-=-
// creation
// -=-=-=-=-
function evalJS(src) {
  return eval(src);
}

function fromString(funcOrString) {
  // Example:
  // fromString("function() { return 3; }")() // => 3
  return evalJS('(' + funcOrString.toString() + ');');
}

function asScript(func, optVarMapping) {
  // Lifts `func` to become a `Closure`, that is that free variables referenced
  // in `func` will be bound to the values of an object that can be passed in as
  // the second parameter. Keys of this object are mapped to the free variables.
  //
  // Please see [`Closure`](#) for a more detailed explanation and examples.
  return Closure.fromFunction(func, optVarMapping).recreateFunc();
}

function asScriptOf(f, obj, optName, optMapping) {
  // Like `asScript` but makes `f` a method of `obj` as `optName` or the name
  // of the function.
  var name = optName || f.name;
  if (!name) {
    throw Error("Function that wants to be a script needs a name: " + this);
  }
  var proto = Object.getPrototypeOf(obj),
      mapping = { "this": obj };
  if (optMapping) mapping = merge([mapping, optMapping]);
  if (proto && proto[name]) {
    var superFunc = function superFunc() {
      try {
        // FIXME super is supposed to be static
        return Object.getPrototypeOf(obj)[name].apply(obj, arguments);
      } catch (e) {
        if ((typeof $world === "undefined" ? "undefined" : _typeof($world)) !== undefined) $world.logError(e, 'Error in $super call');else console.error('Error in $super call: ' + e + '\n' + e.stack);
        return null;
      }
    };
    mapping["$super"] = Closure.fromFunction(superFunc, { obj: obj, name: name }).recreateFunc();
  }
  return addToObject(asScript(f, mapping), obj, name);
}

// -=-=-=-=-=-=-=-=-
// closure related
// -=-=-=-=-=-=-=-=-
function addToObject(f, obj, name) {
  // ignore-in-doc
  f.displayName = name;

  var methodConnections = obj.attributeConnections ? obj.attributeConnections.filter(function (con) {
    return con.getSourceAttrName() === 'update';
  }) : [];

  if (methodConnections) methodConnections.forEach(function (ea) {
    ea.disconnect();
  });

  obj[name] = f;

  if (typeof obj === "undefined" ? "undefined" : _typeof(obj)) f.declaredObject = safeToString(obj);

  // suppport for tracing
  if (typeof lively !== "undefined" && obj && lively.Tracing && lively.Tracing.stackTracingEnabled) {
    lively.Tracing.instrumentMethod(obj, name, {
      declaredObject: safeToString(obj)
    });
  }

  if (methodConnections) methodConnections.forEach(function (ea) {
    ea.connect();
  });

  return f;
}

function binds(f, varMapping) {
  // ignore-in-doc
  // convenience function
  return Closure.fromFunction(f, varMapping || {}).recreateFunc();
}

function setLocalVarValue(f, name, value) {
  // ignore-in-doc
  if (f.hasLivelyClosure) f.livelyClosure.funcProperties[name] = value;
}

function getVarMapping(f) {
  // ignore-in-doc
  if (f.hasLivelyClosure) return f.livelyClosure.varMapping;
  if (f.isWrapper) return f.originalFunction.varMapping;
  if (f.varMapping) return f.varMapping;
  return {};
}

function setProperty(func, name, value) {
  func[name] = value;
  if (func.hasLivelyClosure) func.livelyClosure.funcProperties[name] = value;
}

// -=-=-=-=-=-=-=-=-=-=-=-=-
// class-related functions
// -=-=-=-=-=-=-=-=-=-=-=-=-
function functionNames(klass) {
  // Treats passed function as class (constructor).
  // Example:
  // var Klass1 = function() {}
  // Klass1.prototype.foo = function(a, b) { return a + b; };
  // Klass1.prototype.bar = function(a) { return this.foo(a, 3); };
  // Klass1.prototype.baz = 23;
  // functionNames(Klass1); // => ["bar","foo"]

  var result = [],
      lookupObj = klass.prototype;
  while (lookupObj) {
    result = Object.keys(lookupObj).reduce(function (result, name) {
      if (typeof lookupObj[name] === 'function' && result.indexOf(name) === -1) result.push(name);
      return result;
    }, result);
    lookupObj = Object.getPrototypeOf(lookupObj);
  }
  return result;
}

function localFunctionNames(func) {
  return Object.keys(func.prototype).filter(function (name) {
    return typeof func.prototype[name] === 'function';
  });
}

// -=-=-=-=-=-=-=-=-=-=-
// tracing and logging
// -=-=-=-=-=-=-=-=-=-=-

function logErrors(func, prefix) {
  var advice = function logErrorsAdvice(proceed /*,args*/) {
    var args = Array.prototype.slice.call(arguments);
    args.shift();
    try {
      return proceed.apply(func, args);
    } catch (er) {
      if (typeof lively !== "undefined" && lively.morphic && lively.morphic.World && lively.morphic.World.current()) {
        lively.morphic.World.current().logError(er);
        throw er;
      }

      if (prefix) console.warn("ERROR: %s.%s(%s): err: %s %s", func, prefix, args, er, er.stack || "");else console.warn("ERROR: %s %s", er, er.stack || "");
      throw er;
    }
  };

  advice.methodName = "$logErrorsAdvice";
  var result = wrap(func, advice);
  result.originalFunction = func;
  result.methodName = "$logErrorsWrapper";
  return result;
}

function logCompletion(func, module) {
  var advice = function logCompletionAdvice(proceed) {
    var args = Array.prototype.slice.call(arguments);
    args.shift();
    try {
      var result = proceed.apply(func, args);
    } catch (er) {
      console.warn('failed to load ' + module + ': ' + er);
      if (typeof lively !== 'undefined' && lively.lang.Execution) lively.lang.Execution.showStack();
      throw er;
    }
    console.log('completed ' + module);
    return result;
  };

  advice.methodName = "$logCompletionAdvice::" + module;

  var result = wrap(func, advice);
  result.methodName = "$logCompletionWrapper::" + module;
  result.originalFunction = func;
  return result;
}

function logCalls(func, isUrgent) {
  var original = func,
      advice = function logCallsAdvice(proceed) {
    var args = Array.prototype.slice.call(arguments);
    args.shift(), result = proceed.apply(func, args);
    if (isUrgent) {
      console.warn('%s(%s) -> %s', qualifiedMethodName(original), args, result);
    } else {
      console.log('%s(%s) -> %s', qualifiedMethodName(original), args, result);
    }
    return result;
  };

  advice.methodName = "$logCallsAdvice::" + qualifiedMethodName(func);

  var result = wrap(func, advice);
  result.originalFunction = func;
  result.methodName = "$logCallsWrapper::" + qualifiedMethodName(func);
  return result;
}

function traceCalls(func, stack) {
  var advice = function traceCallsAdvice(proceed) {
    var args = Array.prototype.slice.call(arguments);
    args.shift();
    stack.push(args);
    var result = proceed.apply(func, args);
    stack.pop();
    return result;
  };
  return wrap(func, advice);
}

function webkitStack() {
  // this won't work in every browser
  try {
    throw new Error();
  } catch (e) {
    // remove "Error" and this function from stack, rewrite it nicely
    return String(e.stack).split(/\n/).slice(2).map(function (line) {
      return line.replace(/^\s*at\s*([^\s]+).*/, '$1');
    }).join('\n');
  }
}



var fun = Object.freeze({
	Empty: Empty,
	K: K,
	Null: Null,
	False: False,
	True: True,
	notYetImplemented: notYetImplemented,
	withNull: withNull,
	all: all,
	own: own,
	argumentNames: argumentNames,
	qualifiedMethodName: qualifiedMethodName,
	extractBody: extractBody,
	timeToRun: timeToRun,
	timeToRunN: timeToRunN$1,
	delay: delay,
	throttle: throttle,
	debounce: debounce,
	throttleNamed: throttleNamed,
	debounceNamed: debounceNamed,
	createQueue: createQueue,
	workerWithCallbackQueue: workerWithCallbackQueue,
	composeAsync: composeAsync,
	compose: compose,
	waitFor: waitFor,
	waitForAll: waitForAll,
	flip: flip,
	curry: curry,
	wrap: wrap,
	binds: binds,
	getOriginal: getOriginal,
	wrapperChain: wrapperChain,
	replaceMethodForOneCall: replaceMethodForOneCall,
	once: once,
	either: either,
	eitherNamed: eitherNamed,
	evalJS: evalJS,
	fromString: fromString,
	asScript: asScript,
	asScriptOf: asScriptOf,
	addToObject: addToObject,
	setLocalVarValue: setLocalVarValue,
	getVarMapping: getVarMapping,
	setProperty: setProperty,
	functionNames: functionNames,
	localFunctionNames: localFunctionNames,
	logErrors: logErrors,
	logCompletion: logCompletion,
	logCalls: logCalls,
	traceCalls: traceCalls,
	webkitStack: webkitStack
});

// show-in-doc
// A Grouping is created by arr.groupBy and maps keys to Arrays.

var Group = function () {
  function Group() {
    classCallCheck(this, Group);
  }

  createClass(Group, [{
    key: "toArray",
    value: function toArray() {
      // Example:
      // var group = arr.groupBy([1,2,3,4,5], function(n) { return n % 2; })
      // group.toArray(); // => [[2,4],[1,3,5]]
      return this.reduceGroups(function (all$$1, _, group) {
        return all$$1.concat([group]);
      }, []);
    }
  }, {
    key: "forEach",
    value: function forEach(iterator, context) {
      // Iteration for each item in each group, called like `iterator(groupKey, groupItem)`
      var groups = this;
      Object.keys(groups).forEach(function (groupName) {
        groups[groupName].forEach(iterator.bind(context, groupName));
      });
      return groups;
    }
  }, {
    key: "forEachGroup",
    value: function forEachGroup(iterator, context) {
      // Iteration for each group, called like `iterator(groupKey, group)`
      var groups = this;
      Object.keys(groups).forEach(function (groupName) {
        iterator.call(context, groupName, groups[groupName]);
      });
      return groups;
    }
  }, {
    key: "map",
    value: function map(iterator, context) {
      // Map for each item in each group, called like `iterator(groupKey, group)`
      var result = new Group();
      this.forEachGroup(function (groupName, group) {
        result[groupName] = group.map(iterator.bind(context, groupName));
      });
      return result;
    }
  }, {
    key: "mapGroups",
    value: function mapGroups(iterator, context) {
      // Map for each group, called like `iterator(groupKey, group)`
      var result = new Group();
      this.forEachGroup(function (groupName, group) {
        result[groupName] = iterator.call(context, groupName, group);
      });
      return result;
    }
  }, {
    key: "keys",
    value: function keys() {
      // show-in-docs
      return Object.keys(this);
    }
  }, {
    key: "reduceGroups",
    value: function reduceGroups(iterator, carryOver, context) {
      // Reduce/fold for each group, called like `iterator(carryOver, groupKey, group)`
      this.forEachGroup(function (groupName, group) {
        carryOver = iterator.call(context, carryOver, groupName, group);
      });
      return carryOver;
    }
  }, {
    key: "count",
    value: function count() {
      // counts the elements of each group
      return this.reduceGroups(function (groupCount, groupName, group) {
        groupCount[groupName] = group.length;
        return groupCount;
      }, {});
    }
  }], [{
    key: "fromArray",
    value: function fromArray(array, hashFunc, context) {
      // Example:
      // Group.fromArray([1,2,3,4,5,6], function(n) { return n % 2; })
      // // => {"0": [2,4,6], "1": [1,3,5]}
      var grouping = new Group();
      for (var i = 0, len = array.length; i < len; i++) {
        var hash = hashFunc.call(context, array[i], i);
        if (!grouping[hash]) grouping[hash] = [];
        grouping[hash].push(array[i]);
      }
      return grouping;
    }
  }, {
    key: "by",
    get: function get() {
      return groupBy;
    }
  }]);
  return Group;
}();

/*global System, global*/

/*
 * Methods to make working with arrays more convenient and collection-like
 * abstractions for groups, intervals, grids.
 */

var GLOBAL$1 = typeof System !== "undefined" ? System.global : typeof window !== 'undefined' ? window : global;

var features$1 = {
  from: !!Array.from,
  filter: !!Array.prototype.filter,
  find: !!Array.prototype.find,
  findIndex: !!Array.prototype.findIndex,
  includes: !!Array.prototype.includes
};

// variety of functions for Arrays


// -=-=-=-=-=-=-=-
// array creations
// -=-=-=-=-=-=-=-

function range(begin, end, step) {
  // Examples:
  //   arr.range(0,5) // => [0,1,2,3,4,5]
  //   arr.range(0,10,2) // => [0,2,4,6,8,10]
  step = step || 0;
  var result = [];
  if (begin <= end) {
    if (step <= 0) step = -step || 1;
    for (var i = begin; i <= end; i += step) {
      result.push(i);
    }
  } else {
    if (step >= 0) step = -step || -1;
    for (var i = begin; i >= end; i += step) {
      result.push(i);
    }
  }
  return result;
}

var from = features$1.from ? Array.from : function (iterable) {
  // Makes JS arrays out of array like objects like `arguments` or DOM `childNodes`
  if (!iterable) return [];
  if (Array.isArray(iterable)) return iterable;
  if (iterable.toArray) return iterable.toArray();
  var length = iterable.length,
      results = new Array(length);
  while (length--) {
    results[length] = iterable[length];
  }return results;
};

function withN(n, obj) {
  // Example:
  //   arr.withN(3, "Hello") // => ["Hello","Hello","Hello"]
  var result = new Array(n);
  while (n > 0) {
    result[--n] = obj;
  }return result;
}

function genN(n, generator) {
  // Number -> Function -> Array
  // Takes a generator function that is called for each `n`.
  // Example:
  //   arr.genN(3, num.random) // => [46,77,95]
  var result = new Array(n);
  while (n > 0) {
    result[--n] = generator(n);
  }return result;
}

// -=-=-=-=-
// filtering
// -=-=-=-=-

function filter(array, iterator, context) {
  // [a] -> (a -> Boolean) -> c? -> [a]
  // Calls `iterator` for each element in `array` and returns a subset of it
  // including the elements for which `iterator` returned a truthy value.
  // Like `Array.prototype.filter`.
  return array.filter(iterator, context);
}

var detect = features$1.find ? function (arr, iterator, context) {
  return arr.find(iterator, context);
} : function (arr, iterator, context) {
  // [a] -> (a -> Boolean) -> c? -> a
  // returns the first occurrence of an element in `arr` for which iterator
  // returns a truthy value
  for (var value, i = 0, len = arr.length; i < len; i++) {
    value = arr[i];
    if (iterator.call(context, value, i)) return value;
  }
  return undefined;
};

var findIndex = features$1.findIndex ? function (arr, iterator, context) {
  return arr.findIndex(iterator, context);
} : function (arr, iterator, context) {
  var i = -1;
  return arr.find(function (ea, j) {
    i = j;return iterator.call(ea, context);
  }) ? i : -1;
};

function findAndGet(arr, iterator) {
  // find the first occurence for which `iterator` returns a truthy value and
  // return *this* value, i.e. unlike find the iterator result and not the
  // element of the list is returned
  var result;
  arr.find(function (ea, i) {
    return result = iterator(ea, i);
  });
  return result;
}

function filterByKey(arr, key) {
  // [a] -> String -> [a]
  // Example:
  //   var objects = [{x: 3}, {y: 4}, {x:5}]
  //   arr.filterByKey(objects, "x") // => [{x: 3},{x: 5}]
  return arr.filter(function (ea) {
    return !!ea[key];
  });
}

function grep(arr, filter, context) {
  // [a] -> String|RegExp -> [a]
  // `filter` can be a String or RegExp. Will stringify each element in
  // Example:
  // ["Hello", "World", "Lively", "User"].grep("l") // => ["Hello","World","Lively"]
  if (typeof filter === 'string') filter = new RegExp(filter, 'i');
  return arr.filter(filter.test.bind(filter));
}

function mask(array, mask) {
  // select every element in array for which array's element is truthy
  // Example: [1,2,3].mask([false, true, false]) => [2]
  return array.filter(function (_, i) {
    return !!mask[i];
  });
}

function reject(array, func, context) {
  // show-in-doc
  function iterator(val, i) {
    return !func.call(context, val, i);
  }
  return array.filter(iterator);
}

function rejectByKey(array, key) {
  // show-in-doc
  return array.filter(function (ea) {
    return !ea[key];
  });
}

function without(array, elem) {
  // non-mutating
  // Example:
  // arr.without([1,2,3,4,5,6], 3) // => [1,2,4,5,6]
  return array.filter(function (value) {
    return value !== elem;
  });
}

function withoutAll(array, otherArr) {
  // non-mutating
  // Example:
  // arr.withoutAll([1,2,3,4,5,6], [3,4]) // => [1,2,5,6]
  return array.filter(function (value) {
    return otherArr.indexOf(value) === -1;
  });
}

function uniq(array, sorted) {
  // non-mutating
  // Removes duplicates from array.
  return array.reduce(function (a, value, index) {
    if (0 === index || (sorted ? last(a) != value : a.indexOf(value) === -1)) a.push(value);
    return a;
  }, []);
}

function uniqBy(array, comparator, context) {
  // like `arr.uniq` but with custom equality: `comparator(a,b)` returns
  // BOOL. True if a and be should be regarded equal, false otherwise.
  var result = array.slice();
  for (var i = 0; i < result.length; i++) {
    var item = array[i];
    for (var j = i + 1; j < result.length; j++) {
      if (comparator.call(context, item, result[j])) {
        removeAt(result, j);j--;
      }
    }
  }
  return result;
}

function compact(array) {
  // removes falsy values
  // Example:
  // arr.compact([1,2,undefined,4,0]) // => [1,2,4]
  return array.filter(function (ea) {
    return !!ea;
  });
}

function mutableCompact(array) {
  // fix gaps that were created with 'delete'
  var i = 0,
      j = 0,
      len = array.length;
  while (i < len) {
    if (array.hasOwnProperty(i)) array[j++] = array[i];
    i++;
  }
  while (j++ < len) {
    array.pop();
  }return array;
}

// -=-=-=-=-
// iteration
// -=-=-=-=-

function forEach$1(array, iterator, context) {
  // [a] -> (a -> Undefined) -> c? -> Undefined
  // `iterator` is called on each element in `array` for side effects. Like
  // `Array.prototype.forEach`.
  return array.forEach(iterator, context);
}

function zip() /*arr, arr2, arr3*/{
  // Takes any number of lists as arguments. Combines them elment-wise.
  // Example:
  // arr.zip([1,2,3], ["a", "b", "c"], ["A", "B"])
  // // => [[1,"a","A"],[2,"b","B"],[3,"c",undefined]]
  var args = Array.from(arguments),
      array = args.shift(),
      iterator = typeof last(args) === 'function' ? args.pop() : function (x) {
    return x;
  },
      collections = [array].concat(args).map(function (ea) {
    return Array.from(ea);
  });
  return array.map(function (value, index) {
    return iterator(pluck(collections, index), index);
  });
}

function flatten(array, optDepth) {
  // Turns a nested collection into a flat one.
  // Example:
  // arr.flatten([1, [2, [3,4,5], [6]], 7,8])
  // // => [1,2,3,4,5,6,7,8]
  if (typeof optDepth === "number") {
    if (optDepth <= 0) return array;
    optDepth--;
  }
  return array.reduce(function (flattened, value) {
    return flattened.concat(Array.isArray(value) ? flatten(value, optDepth) : [value]);
  }, []);
}

function flatmap(array, it, ctx) {
  // the simple version
  // Array.prototype.concat.apply([], array.map(it, ctx));
  // causes stack overflows with really big arrays
  var results = [];
  for (var i = 0; i < array.length; i++) {
    results.push.apply(results, it.call(ctx, array[i], i));
  }
  return results;
}

function interpose(array, delim) {
  // Injects delim between elements of array
  // Example:
  // lively.lang.arr.interpose(["test", "abc", 444], "aha"));
  // // => ["test","aha","abc","aha",444]
  return array.reduce(function (xs, x) {
    if (xs.length > 0) xs.push(delim);
    xs.push(x);return xs;
  }, []);
}

function delimWith(array, delim) {
  // ignore-in-doc
  return interpose(array, delim);
}

// -=-=-=-=-
// mapping
// -=-=-=-=-

function map$1(array, iterator, context) {
  // [a] -> (a -> b) -> c? -> [b]
  // Applies `iterator` to each element of `array` and returns a new Array
  // with the results of those calls. Like `Array.prototype.some`.
  return array.map(iterator, context);
}

function invoke(array, method, arg1, arg2, arg3, arg4, arg5, arg6) {
  // Calls `method` on each element in `array`, passing all arguments. Often
  // a handy way to avoid verbose `map` calls.
  // Example: arr.invoke(["hello", "world"], "toUpperCase") // => ["HELLO","WORLD"]
  return array.map(function (ea) {
    return ea[method](arg1, arg2, arg3, arg4, arg5, arg6);
  });
}

function pluck(array, property) {
  // Returns `property` or undefined from each element of array. For quick
  // `map`s and similar to `invoke`.
  // Example: arr.pluck(["hello", "world"], 0) // => ["h","w"]
  return array.map(function (ea) {
    return ea[property];
  });
}

// -=-=-=-=-
// folding
// -=-=-=-=-

function reduce(array, iterator, memo, context) {
  // Array -> Function -> Object? -> Object? -> Object?
  // Applies `iterator` to each element of `array` and returns a new Array
  // with the results of those calls. Like `Array.prototype.some`.
  return array.reduce(iterator, memo, context);
}

function reduceRight(array, iterator, memo, context) {
  // show-in-doc
  return array.reduceRight(iterator, memo, context);
}

// -=-=-=-=-
// testing
// -=-=-=-=-

var isArray$1 = Array.isArray;

var includes$1 = features$1.includes ? function (array, object) {
  return array.includes(object);
} : function (array, object) {
  // Example: arr.include([1,2,3], 2) // => true
  return array.indexOf(object) !== -1;
};

var include$1 = includes$1;

function some(array, iterator, context) {
  // [a] -> (a -> Boolean) -> c? -> Boolean
  // Returns true if there is at least one abject in `array` for which
  // `iterator` returns a truthy result. Like `Array.prototype.some`.
  return array.some(iterator, context);
}

function every(array, iterator, context) {
  // [a] -> (a -> Boolean) -> c? -> Boolean
  // Returns true if for all abjects in `array` `iterator` returns a truthy
  // result. Like `Array.prototype.every`.
  return array.every(iterator, context);
}

function equals$2(array, otherArray) {
  // Returns true iff each element in `array` is equal (`==`) to its
  // corresponding element in `otherArray`
  var len = array.length;
  if (!otherArray || len !== otherArray.length) return false;
  for (var i = 0; i < len; i++) {
    if (array[i] && otherArray[i] && array[i].equals && otherArray[i].equals) {
      if (!array[i].equals(otherArray[i])) {
        return false;
      } else {
        continue;
      }
    }
    if (array[i] != otherArray[i]) return false;
  }
  return true;
}

function deepEquals(array, otherArray) {
  // Returns true iff each element in `array` is structurally equal
  // (`lang.obj.equals`) to its corresponding element in `otherArray`
  var len = array.length;
  if (!otherArray || len !== otherArray.length) return false;
  for (var i = 0; i < len; i++) {
    if (!equals$1(array[i], otherArray[i])) return false;
  }
  return true;
}

// -=-=-=-=-
// sorting
// -=-=-=-=-

function isSorted(array, descending) {
  if (descending) {
    for (var i = 1; i < array.length; i++) {
      if (array[i - 1] < array[i]) return false;
    }
  } else {
    for (var i = 1; i < array.length; i++) {
      if (array[i - 1] > array[i]) return false;
    }
  }
  return true;
}

function sort(array, sortFunc) {
  // [a] -> (a -> Number)? -> [a]
  // Just `Array.prototype.sort`
  return array.sort(sortFunc);
}

function sortBy(array, iterator, context) {
  // Example:
  // arr.sortBy(["Hello", "Lively", "User"], function(ea) {
  //   return ea.charCodeAt(ea.length-1); }) // => ["Hello","User","Lively"]
  return pluck(array.map(function (value, index) {
    return { value: value, criteria: iterator.call(context, value, index) };
  }).sort(function (left, right) {
    var a = left.criteria,
        b = right.criteria;
    return a < b ? -1 : a > b ? 1 : 0;
  }), 'value');
}

function sortByKey(array, key) {
  // Example:
  // lively.lang.arr.sortByKey([{x: 3}, {x: 2}, {x: 8}], "x")
  // // => [{x: 2},{x: 3},{x: 8}]
  return sortBy(array, function (ea) {
    return ea[key];
  });
}

function reverse(array) {
  return array.reverse();
}

function reversed(array) {
  return array.slice().reverse();
}

// -=-=-=-=-=-=-=-=-=-=-=-=-
// RegExp / String matching
// -=-=-=-=-=-=-=-=-=-=-=-=-

function reMatches$1(arr, re, stringifier) {
  // result might include null items if re did not match (usful for masking)
  // Example:
  //   var morphs = $world.withAllSubmorphsDo(function(x) { return x; ;
  //   morphs.mask(morphs.reMatches(/code/i))
  stringifier = stringifier || String;
  return arr.map(function (ea) {
    return stringifier(ea).match(re);
  });
}

// -=-=-=-=-=-
// accessors
// -=-=-=-=-=-

function first(array) {
  return array[0];
}

function last(array) {
  return array[array.length - 1];
}

// -=-=-=-=-=-=-=-
// Set operations
// -=-=-=-=-=-=-=-

function intersect(array1, array2) {
  // set-like intersection
  return uniq(array1).filter(function (item) {
    return array2.indexOf(item) > -1;
  });
}

function union(array1, array2) {
  // set-like union
  var result = array1.slice();
  for (var i = 0; i < array2.length; i++) {
    var item = array2[i];
    if (result.indexOf(item) === -1) result.push(item);
  }
  return result;
}

function pushAt(array, item, index) {
  // inserts `item` at `index`, mutating
  array.splice(index, 0, item);
}

function removeAt(array, index) {
  // inserts item at `index`, mutating
  array.splice(index, 1);
}

function remove(array, item) {
  // removes first occurrence of item in `array`, mutating
  var index = array.indexOf(item);
  if (index >= 0) removeAt(array, index);
  return item;
}

function pushAll$1(array, items) {
  // appends all `items`, mutating
  array.push.apply(array, items);
  return array;
}

function pushAllAt(array, items, idx) {
  // inserts all `items` at `idx`, mutating
  array.splice.apply(array, [idx, 0].concat(items));
}

function pushIfNotIncluded(array, item) {
  // only appends `item` if its not already in `array`, mutating
  if (!array.includes(item)) array.push(item);
}

function replaceAt(array, item, index) {
  // mutating
  array.splice(index, 1, item);
}

function clear(array) {
  // removes all items, mutating
  array.length = 0;return array;
}

function isSubset(list1, list2) {
  // are all elements in list1 in list2?
  for (var i = 0; i < list1.length; i++) {
    if (!list2.includes(list1[i])) return false;
  }return true;
}

// -=-=-=-=-=-=-=-=-=-=-=-
// asynchronous iteration
// -=-=-=-=-=-=-=-=-=-=-=-
function doAndContinue(array, iterator, endFunc, context) {
  // Iterates over array but instead of consecutively calling iterator,
  // iterator gets passed in the invocation for the next iteration step
  // as a function as first parameter. This allows to wait arbitrarily
  // between operation steps, great for managing dependencies between tasks.
  // Related is [`fun.composeAsync`]().
  // Example:
  // arr.doAndContinue([1,2,3,4], function(next, n) {
  //   alert("At " + n);
  //   setTimeout(next, 100);
  // }, function() { alert("Done"); })
  // // If the elements are functions you can leave out the iterator:
  // arr.doAndContinue([
  //   function(next) { alert("At " + 1); next(); },
  //   function(next) { alert("At " + 2); next(); }
  // ], null, function() { alert("Done"); });
  endFunc = endFunc || Null;
  context = context || GLOBAL$1;
  iterator = iterator || function (next, ea, idx) {
    ea.call(context, next, idx);
  };
  return array.reduceRight(function (nextFunc, ea, idx) {
    return function () {
      iterator.call(context, nextFunc, ea, idx);
    };
  }, endFunc)();
}

function nestedDelay(array, iterator, waitSecs, endFunc, context, optSynchronChunks) {
  // Calls `iterator` for every element in `array` and waits between iterator
  // calls `waitSecs`. Eventually `endFunc` is called. When passing a number n
  // as `optSynchronChunks`, only every nth iteration is delayed.
  endFunc = endFunc || function () {};
  return array.clone().reverse().reduce(function (nextFunc, ea, idx) {
    return function () {
      iterator.call(context || GLOBAL$1, ea, idx);
      // only really delay every n'th call optionally
      if (optSynchronChunks && idx % optSynchronChunks !== 0) {
        nextFunc();
      } else {
        nextFunc.delay(waitSecs);
      }
    };
  }, endFunc)();
}

function forEachShowingProgress() /*array, progressBar, iterator, labelFunc, whenDoneFunc, context or spec*/{
  // ignore-in-doc
  var args = Array.from(arguments),
      array = args.shift(),
      steps = array.length,
      progressBar,
      iterator,
      labelFunc,
      whenDoneFunc,
      context,
      progressBarAdded = false;

  // init args
  if (args.length === 1) {
    progressBar = args[0].progressBar;
    iterator = args[0].iterator;
    labelFunc = args[0].labelFunction;
    whenDoneFunc = args[0].whenDone;
    context = args[0].context;
  } else {
    progressBar = args[0];
    iterator = args[1];
    labelFunc = args[2];
    whenDoneFunc = args[3];
    context = args[4];
  }
  if (!context) context = typeof window !== 'undefined' ? window : global;
  if (!labelFunc) labelFunc = function labelFunc(x) {
    return x;
  };

  // init progressbar
  if (!progressBar) {
    progressBarAdded = true;
    var Global = typeof window !== 'undefined' ? window : global;
    var world = Global.lively && lively.morphic && lively.morphic.World.current();
    progressBar = world ? world.addProgressBar() : {
      setValue: function setValue(val) {},
      setLabel: function setLabel() {},
      remove: function remove() {}
    };
  }
  progressBar.setValue(0);

  // nest functions so that the iterator calls the next after a delay
  array.reduceRight(function (nextFunc, item, idx) {
    return function () {
      try {
        progressBar.setValue(idx / steps);
        if (labelFunc) progressBar.setLabel(labelFunc.call(context, item, idx));
        iterator.call(context, item, idx);
      } catch (e) {
        console.error('Error in forEachShowingProgress at %s (%s)\n%s\n%s', idx, item, e, e.stack);
      }
      nextFunc.delay(0);
    };
  }, function () {
    progressBar.setValue(1);
    if (progressBarAdded) (function () {
      progressBar.remove();
    }).delay(0);
    if (whenDoneFunc) whenDoneFunc.call(context);
  })();

  return array;
}

function swap(array, index1, index2) {
  // mutating
  // Example:
  // var a = [1,2,3,4];
  // arr.swap(a, 3, 1);
  // a // => [1,4,3,2]
  if (index1 < 0) index1 = array.length + index1;
  if (index2 < 0) index2 = array.length + index2;
  var temp = array[index1];
  array[index1] = array[index2];
  array[index2] = temp;
  return array;
}

function rotate(array, times) {
  // non-mutating
  // Example:
  // arr.rotate([1,2,3]) // => [2,3,1]
  times = times || 1;
  return array.slice(times).concat(array.slice(0, times));
}

// -=-=-=-=-
// grouping
// -=-=-=-=-

function groupBy(array, iterator, context) {
  // Applies `iterator` to each element in `array`, and puts the return value
  // into a collection (the group) associated to it's stringified representation
  // (the "hash").
  // See [`Group.prototype`] for available operations on groups.
  // Example:
  // Example 1: Groups characters by how often they occur in a string:
  // var chars = arr.from("Hello World");
  // arr.groupBy(arr.uniq(chars), function(c) {
  //   return arr.count(chars, c); })
  // // => {
  // //   "1": ["H","e"," ","W","r","d"],
  // //   "2": ["o"],
  // //   "3": ["l"]
  // // }
  // // Example 2: Group numbers by a custom qualifier:
  // arr.groupBy([3,4,1,7,4,3,8,4], function(n) {
  //   if (n <= 3) return "small";
  //   if (n <= 7) return "medium";
  //   return "large";
  // });
  // // => {
  // //   large: [8],
  // //   medium: [4,7,4,4],
  // //   small: [3,1,3]
  // // }
  return Group.fromArray(array, iterator, context);
}

function groupByKey(array, key) {
  // var objects = [{x: }]
  // arr.groupBy(arr.uniq(chars), function(c) {
  //   return arr.count(chars, c); })
  // // => {
  // //   "1": ["H","e"," ","W","r","d"],
  // //   "2": ["o"],
  // //   "3": ["l"]
  // // }
  return groupBy(array, function (ea) {
    return ea[key];
  });
}

function partition(array, iterator, context) {
  // Example:
  // var array = [1,2,3,4,5,6];
  // arr.partition(array, function(ea) { return ea > 3; })
  // // => [[1,2,3,4],[5,6]]
  iterator = iterator || function (x) {
    return x;
  };
  var trues = [],
      falses = [];
  array.forEach(function (value, index) {
    (iterator.call(context, value, index) ? trues : falses).push(value);
  });
  return [trues, falses];
}

function batchify(array, constrainedFunc, context) {
  // Takes elements and fits them into subarrays (= batches) so that for
  // each batch constrainedFunc returns true. Note that contrained func
  // should at least produce 1-length batches, otherwise an error is raised
  // Example:
  // // Assume you have list of things that have different sizes and you want to
  // // create sub-arrays of these things, with each sub-array having if possible
  // // less than a `batchMaxSize` of combined things in it:
  // var sizes = [
  //   Math.pow(2, 15), // 32KB
  //   Math.pow(2, 29), // 512MB
  //   Math.pow(2, 29), // 512MB
  //   Math.pow(2, 27), // 128MB
  //   Math.pow(2, 26), // 64MB
  //   Math.pow(2, 26), // 64MB
  //   Math.pow(2, 24), // 16MB
  //   Math.pow(2, 26)] // 64MB
  // var batchMaxSize = Math.pow(2, 28)/*256MB*/;
  // function batchConstrained(batch) {
  //   return batch.length == 1 || batch.sum() < batchMaxSize;
  // }
  // var batches = sizes.batchify(batchConstrained);
  // batches.pluck('length') // => [4,1,1,2]
  // batches.map(arr.sum).map(num.humanReadableByteSize) // => ["208.03MB","512MB","512MB","128MB"]

  return findBatches([], array);

  // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  function extractBatch(batch, sizes) {
    // ignore-in-doc
    // Array -> Array -> Array[Array,Array]
    // case 1: no sizes to distribute, we are done
    if (!sizes.length) return [batch, []];
    var first = sizes[0],
        rest = sizes.slice(1);
    // if batch is empty we have to take at least one
    // if batch and first still fits, add first
    var candidate = batch.concat([first]);
    if (constrainedFunc.call(context, candidate)) return extractBatch(candidate, rest);
    // otherwise leave first out for now
    var batchAndSizes = extractBatch(batch, rest);
    return [batchAndSizes[0], [first].concat(batchAndSizes[1])];
  }

  function findBatches(batches, sizes) {
    if (!sizes.length) return batches;
    var extracted = extractBatch([], sizes);
    if (!extracted[0].length) throw new Error('Batchify constrained does not ensure consumption ' + 'of at least one item per batch!');
    return findBatches(batches.concat([extracted[0]]), extracted[1]);
  }
}

function toTuples(array, tupleLength) {
  // Creates sub-arrays with length `tupleLength`
  // Example:
  // arr.toTuples(["H","e","l","l","o"," ","W","o","r","l","d"], 4)
  // // => [["H","e","l","l"],["o"," ","W","o"],["r","l","d"]]
  tupleLength = tupleLength || 1;
  return range(0, Math.ceil(array.length / tupleLength) - 1).map(function (n) {
    return array.slice(n * tupleLength, n * tupleLength + tupleLength);
  }, array);
}

var permutations = function () {
  function computePermutations(restArray, values$$1) {
    return !restArray.length ? [values$$1] : flatmap(restArray, function (ea, i) {
      return computePermutations(restArray.slice(0, i).concat(restArray.slice(i + 1)), values$$1.concat([ea]));
    });
  }
  return function (array) {
    return computePermutations(array, []);
  };
}();

function combinationsPick(listOfListsOfValues, pickIndices) {
  // Given a "listOfListsOfValues" in the form of an array of arrays and
  // `pickIndices` list with the size of the number of arrays which indicates what
  // values to pick from each of the arrays, return a list with two values:
  // 1. values picked from each of the arrays, 2. the next pickIndices or null if at end
  // Example:
  //  var searchSpace = [["a", "b", "c"], [1,2]];
  //  arr.combinationsPick(searchSpace, [0,1]);
  //    // => [["a",2], [1,0]]
  //  arr.combinationsPick(searchSpace, [1,0]);
  //    // => [["b",1], [1,1]]
  var values$$1 = listOfListsOfValues.map(function (subspace, i) {
    return subspace[pickIndices[i]];
  }),
      nextState = pickIndices.slice();
  for (var i = listOfListsOfValues.length; i--; i >= 0) {
    var subspace = listOfListsOfValues[i],
        nextIndex = nextState[i] + 1;
    if (subspace[nextIndex]) {
      nextState[i] = nextIndex;break;
    } else if (i === 0) {
      nextState = undefined;break;
    } else {
      nextState[i] = 0;
    }
  }
  return [values$$1, nextState];
}

function combinations(listOfListsOfValues) {
  // Given a "listOfListsOfValues" in the form of an array of arrays,
  // retrieve all the combinations by picking one item from each array.
  // This basically creates a search tree, traverses it and gathers all node
  // values whenever a leaf node is reached.
  // Example:
  //   lively.lang.arr.combinations([['a', 'b', 'c'], [1, 2]])
  //    // => [["a", 1], ["a", 2], ["b", 1], ["b", 2], ["c", 1], ["c", 2]]
  var size = listOfListsOfValues.reduce(function (prod, space) {
    return prod * space.length;
  }, 1),
      searchState = listOfListsOfValues.map(function (_) {
    return 0;
  }),
      results = new Array(size);
  for (var i = 0; i < size; i++) {
    var result = combinationsPick(listOfListsOfValues, searchState);
    results[i] = result[0];
    searchState = result[1];
  }
  return results;
}

function take(arr, n) {
  return arr.slice(0, n);
}

function drop(arr, n) {
  return arr.slice(n);
}

function takeWhile(arr, fun, context) {
  var i = 0;
  for (; i < arr.length; i++) {
    if (!fun.call(context, arr[i], i)) break;
  }return arr.slice(0, i);
}

function dropWhile(arr, fun, context) {
  var i = 0;
  for (; i < arr.length; i++) {
    if (!fun.call(context, arr[i], i)) break;
  }return arr.slice(i);
}

// -=-=-=-=-=-
// randomness
// -=-=-=-=-=-

function shuffle(array) {
  // Ramdomize the order of elements of array. Does not mutate array.
  // Example:
  // arr.shuffle([1,2,3,4,5]) // => [3,1,2,5,4]
  var unusedIndexes = range(0, array.length - 1);
  return array.reduce(function (shuffled, ea, i) {
    var shuffledIndex = unusedIndexes.splice(Math.round(Math.random() * (unusedIndexes.length - 1)), 1);
    shuffled[shuffledIndex] = ea;
    return shuffled;
  }, Array(array.length));
}

// -=-=-=-=-=-=-=-
// Number related
// -=-=-=-=-=-=-=-

function max(array, iterator, context) {
  // Example:
  //   var array = [{x:3,y:2}, {x:5,y:1}, {x:1,y:5}];
  //   arr.max(array, function(ea) { return ea.x; }) // => {x: 5, y: 1}
  iterator = iterator || function (x) {
    return x;
  };
  var result;
  array.reduce(function (max, ea, i) {
    var val = iterator.call(context, ea, i);
    if (typeof val !== "number" || val <= max) return max;
    result = ea;return val;
  }, -Infinity);
  return result;
}

function min(array, iterator, context) {
  // Similar to `arr.max`.
  iterator = iterator || function (x) {
    return x;
  };
  return max(array, function (ea, i) {
    return -iterator.call(context, ea, i);
  });
}

function sum(array) {
  // show-in-doc
  var sum = 0;
  for (var i = 0; i < array.length; i++) {
    sum += array[i];
  }return sum;
}

function count$1(array, item) {
  return array.reduce(function (count, ea) {
    return ea === item ? count + 1 : count;
  }, 0);
}

function size$1(array) {
  return array.length;
}

function histogram(data, binSpec) {
  // ignore-in-doc
  // Without a `binSpec` argument partition the data
  // var numbers = arr.genN(10, num.random);
  // var numbers = arr.withN(10, "a");
  // => [65,73,34,94,92,31,27,55,95,48]
  // => [[65,73],[34,94],[92,31],[27,55],[95,48]]
  // => [[82,50,16],[25,43,77],[40,64,31],[51,39,13],[17,34,87],[51,33,30]]
  if (typeof binSpec === 'undefined' || typeof binSpec === 'number') {
    var binNumber = binSpec || function sturge() {
      return Math.ceil(Math.log(data.length) / Math.log(2) + 1);
    }(data);
    var binSize = Math.ceil(Math.round(data.length / binNumber));
    return range(0, binNumber - 1).map(function (i) {
      return data.slice(i * binSize, (i + 1) * binSize);
    });
  } else if (binSpec instanceof Array) {
    // ignore-in-doc
    // bins specifies n threshold values that will create n-1 bins.
    // Each data value d is placed inside a bin i if:
    // threshold[i] >= d && threshold[i+1] < d
    var thresholds = binSpec;
    return data.reduce(function (bins, d) {
      if (d < thresholds[1]) {
        bins[0].push(d);return bins;
      }
      for (var i = 1; i < thresholds.length; i++) {
        if (d >= thresholds[i] && (!thresholds[i + 1] || d <= thresholds[i + 1])) {
          bins[i].push(d);return bins;
        }
      }
      throw new Error("Histogram creation: Cannot group data " + d + " into thresholds " + thresholds);
    }, range(1, thresholds.length).map(function () {
      return [];
    }));
  }
}

// -=-=-=-=-
// Copying
// -=-=-=-=-

function clone$1(array) {
  // shallow copy
  return [].concat(array);
}

// -=-=-=-=-=-
// conversion
// -=-=-=-=-=-

function toArray$3(array) {
  return from(array);
}

// -=-=-=-=-=-
// DEPRECATED
// -=-=-=-=-=-

function each(arr, iterator, context) {
  return arr.forEach(iterator, context);
}

function all$1(arr, iterator, context) {
  return arr.every(iterator, context);
}

function any(arr, iterator, context) {
  return arr.some(iterator, context);
}

function collect(arr, iterator, context) {
  return arr.map(iterator, context);
}

function findAll(arr, iterator, context) {
  return arr.filter(iterator, context);
}

function inject(array, memo, iterator, context) {
  if (context) iterator = iterator.bind(context);
  return array.reduce(iterator, memo);
}

// asynch methods
function mapAsyncSeries(array, iterator, callback) {
  // Apply `iterator` over `array`. Unlike `mapAsync` the invocation of
  // the iterator happens step by step in the order of the items of the array
  // and not concurrently.

  // ignore-in-doc
  // Could simply be:
  // return exports.arr.mapAsync(array, {parallel: 1}, iterator, callback);
  // but the version below is 2x faster

  var result = [],
      callbackTriggered = false;
  return array.reduceRight(function (nextFunc, ea, idx) {
    if (callbackTriggered) return;
    return function (err, eaResult) {
      if (err) return maybeDone(err);
      if (idx > 0) result.push(eaResult);
      try {
        iterator(ea, idx, once(nextFunc));
      } catch (e) {
        maybeDone(e);
      }
    };
  }, function (err, eaResult) {
    result.push(eaResult);
    maybeDone(err, true);
  })();

  function maybeDone(err, finalCall) {
    if (callbackTriggered || !err && !finalCall) return;
    callbackTriggered = true;
    try {
      callback(err, result);
    } catch (e) {
      console.error("Error in mapAsyncSeries - callback invocation error:\n" + (e.stack || e));
    }
  }
}

function mapAsync(array, options, iterator, callback) {
  // Apply `iterator` over `array`. In each iterator gets a callback as third
  // argument that should be called when the iteration is done. After all
  // iterators have called their callbacks, the main `callback` function is
  // invoked with the result array.
  // Example:
  // lively.lang.arr.mapAsync([1,2,3,4],
  //   function(n, i, next) { setTimeout(function() { next(null, n + i); }, 20); },
  //   function(err, result) { /* result => [1,3,5,7] */ });

  if (typeof options === "function") {
    callback = iterator;
    iterator = options;
    options = null;
  }
  options = options || {};

  if (!array.length) return callback && callback(null, []);

  if (!options.parallel) options.parallel = Infinity;

  var results = [],
      completed = [],
      callbackTriggered = false,
      lastIteratorIndex = 0,
      nActive = 0;

  var iterators = array.map(function (item, i) {
    return function () {
      nActive++;
      try {
        iterator(item, i, once(function (err, result) {
          results[i] = err || result;
          maybeDone(i, err);
        }));
      } catch (e) {
        maybeDone(i, e);
      }
    };
  });

  return activate();

  // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  function activate() {
    while (nActive < options.parallel && lastIteratorIndex < array.length) {
      iterators[lastIteratorIndex++]();
    }
  }

  function maybeDone(idx, err) {
    if (completed.indexOf(idx) > -1) return;
    completed.push(idx);
    nActive--;
    if (callbackTriggered) return;
    if (!err && completed.length < array.length) {
      activate();return;
    }
    callbackTriggered = true;
    try {
      callback && callback(err, results);
    } catch (e) {
      console.error("Error in mapAsync - main callback invocation error:\n" + (e.stack || e));
    }
  }
}

// poly-filling...
if (!features$1.from) Array.from = from;
if (!features$1.filter) Array.prototype.filter = function (it, ctx) {
  return filter(this, it, ctx);
};
if (!features$1.find) Array.prototype.find = function (it, ctx) {
  return detect(this, it, ctx);
};
if (!features$1.findIndex) Array.prototype.findIndex = function (it, ctx) {
  return findIndex(this, it, ctx);
};
if (!features$1.includes) Array.prototype.includes = function (x) {
  return includes$1(this, x);
};



var arr = Object.freeze({
	range: range,
	from: from,
	withN: withN,
	genN: genN,
	filter: filter,
	detect: detect,
	findIndex: findIndex,
	findAndGet: findAndGet,
	filterByKey: filterByKey,
	grep: grep,
	mask: mask,
	reject: reject,
	rejectByKey: rejectByKey,
	without: without,
	withoutAll: withoutAll,
	uniq: uniq,
	uniqBy: uniqBy,
	compact: compact,
	mutableCompact: mutableCompact,
	forEach: forEach$1,
	zip: zip,
	flatten: flatten,
	flatmap: flatmap,
	interpose: interpose,
	delimWith: delimWith,
	map: map$1,
	invoke: invoke,
	pluck: pluck,
	reduce: reduce,
	reduceRight: reduceRight,
	isArray: isArray$1,
	includes: includes$1,
	include: include$1,
	some: some,
	every: every,
	equals: equals$2,
	deepEquals: deepEquals,
	isSorted: isSorted,
	sort: sort,
	sortBy: sortBy,
	sortByKey: sortByKey,
	reverse: reverse,
	reversed: reversed,
	reMatches: reMatches$1,
	first: first,
	last: last,
	intersect: intersect,
	union: union,
	pushAt: pushAt,
	removeAt: removeAt,
	remove: remove,
	pushAll: pushAll$1,
	pushAllAt: pushAllAt,
	pushIfNotIncluded: pushIfNotIncluded,
	replaceAt: replaceAt,
	clear: clear,
	isSubset: isSubset,
	doAndContinue: doAndContinue,
	nestedDelay: nestedDelay,
	forEachShowingProgress: forEachShowingProgress,
	swap: swap,
	rotate: rotate,
	groupBy: groupBy,
	groupByKey: groupByKey,
	partition: partition,
	batchify: batchify,
	toTuples: toTuples,
	permutations: permutations,
	combinationsPick: combinationsPick,
	combinations: combinations,
	take: take,
	drop: drop,
	takeWhile: takeWhile,
	dropWhile: dropWhile,
	shuffle: shuffle,
	max: max,
	min: min,
	sum: sum,
	count: count$1,
	size: size$1,
	histogram: histogram,
	clone: clone$1,
	toArray: toArray$3,
	each: each,
	all: all$1,
	any: any,
	collect: collect,
	findAll: findAll,
	inject: inject,
	mapAsyncSeries: mapAsyncSeries,
	mapAsync: mapAsync
});

/*
 * Utility functions that help to inspect, enumerate, and create JS objects
 */

// -=-=-=-=-=-=-=-=-
// internal helper
// -=-=-=-=-=-=-=-=-

// serveral methods in lib/object.js are inspired or derived from
// Prototype JavaScript framework, version 1.6.0_rc1
// (c) 2005-2007 Sam Stephenson
// Prototype is freely distributable under the terms of an MIT-style license.
// For details, see the Prototype web site: http://www.prototypejs.org/

function print$1(object) {
  if (object && Array.isArray(object)) {
    return '[' + object.map(print$1) + ']';
  }
  if (typeof object !== "string") {
    return String(object);
  }
  var result = String(object);
  result = result.replace(/\n/g, '\\n\\\n');
  result = result.replace(/(")/g, '\\$1');
  result = '\"' + result + '\"';
  return result;
}

function indent$1(str, indentString, depth) {
  if (!depth || depth <= 0) return str;
  while (depth > 0) {
    depth--;str = indentString + str;
  }
  return str;
}

// show-in-doc

// -=-=-=-=-
// testing
// -=-=-=-=-

function isArray$$1(obj) {
  /*show-in-doc*/return Array.isArray(obj);
}

function isElement(object) {
  /*show-in-doc*/return object && object.nodeType == 1;
}

function isFunction(object) {
  /*show-in-doc*/return object instanceof Function;
}

function isBoolean(object) {
  /*show-in-doc*/return typeof object == "boolean";
}

function isString(object) {
  /*show-in-doc*/return typeof object == "string";
}

function isNumber(object) {
  /*show-in-doc*/return typeof object == "number";
}

function isUndefined(object) {
  /*show-in-doc*/return typeof object == "undefined";
}

function isRegExp(object) {
  /*show-in-doc*/return object instanceof RegExp;
}

function isObject(object) {
  /*show-in-doc*/return (typeof object === "undefined" ? "undefined" : _typeof(object)) == "object";
}

function isPrimitive(obj) {
  // show-in-doc
  if (!obj) return true;
  switch (typeof obj === "undefined" ? "undefined" : _typeof(obj)) {
    case "string":
    case "number":
    case "boolean":
      return true;
  }
  return false;
}

function isEmpty(object) {
  /*show-in-doc*/
  for (var key in object) {
    if (object.hasOwnProperty(key)) return false;
  }return true;
}

function equals$1(a, b) {
  // Is object `a` structurally equivalent to object `b`? Deep comparison.
  if (a === b) return true;
  if (!a && !b) return true;
  if (!a || !b) return false;
  if (Array.isArray(a)) return deepEquals(a, b);
  switch (a.constructor) {
    case String:
    case Date:
    case Boolean:
    case Number:
      return a == b;
  }
  if (typeof a.isEqualNode === "function") return a.isEqualNode(b);
  if (typeof a.equals === "function") return a.equals(b);
  var seenInA = [];
  for (var name in a) {
    seenInA.push(name);
    if (typeof a[name] === "function") continue;
    if (!equals$1(a[name], b[name])) return false;
  }
  for (var name in b) {
    if (seenInA.indexOf(name) !== -1) continue;
    if (typeof b[name] === "function") continue;
    if (!equals$1(b[name], a[name])) return false;
  }
  return true;
}

// -=-=-=-=-=-
// accessing
// -=-=-=-=-=-

var keys$1 = Object.keys;

function values(object) {
  // Example:
  // var obj1 = {x: 22}, obj2 = {x: 23, y: {z: 3}};
  // obj2.__proto__ = obj1;
  // obj.values(obj1) // => [22]
  // obj.values(obj2) // => [23,{z: 3}]
  return object ? Object.keys(object).map(function (k) {
    return object[k];
  }) : [];
}

function select(obj, keys) {
  // return a new object that copies all properties with `keys` from `obj`
  var selected = {};
  for (var i = 0; i < keys.length; i++) {
    selected[keys[i]] = obj[keys[i]];
  }return selected;
}

function dissoc(object, keys) {
  var result = {};
  for (var name in object) {
    if (object.hasOwnProperty(name) && keys.indexOf(name) === -1) result[name] = object[name];
  }return result;
}

function addScript(object, funcOrString, optName, optMapping) {
  var func = fromString(funcOrString);
  return asScriptOf(func, object, optName, optMapping);
}

// -=-=-=-=-
// mutation
// -=-=-=-=-
function extend(destination, source) {
  // Add all properties of `source` to `destination`.
  // Example:
  // var dest = {x: 22}, src = {x: 23, y: 24}
  // obj.extend(dest, src);
  // dest // => {x: 23,y: 24}

  var currentCategoryNames = null;
  for (var i = 1; i < arguments.length; i++) {
    if (typeof arguments[i] == "string") {
      var catName = arguments[i];
      if (!destination.categories) destination.categories = {};
      if (!destination.categories[catName]) destination.categories[catName] = [];
      currentCategoryNames = destination.categories[catName];
      continue;
    }

    var source = arguments[i];
    for (var property in source) {
      var getter = source.__lookupGetter__(property),
          setter = source.__lookupSetter__(property);
      if (getter) destination.__defineGetter__(property, getter);
      if (setter) destination.__defineSetter__(property, setter);
      if (getter || setter) continue;
      var sourceObj = source[property];
      destination[property] = sourceObj;
      if (currentCategoryNames) currentCategoryNames.push(property);
      if (typeof sourceObj === "function") {
        if (!sourceObj.displayName) sourceObj.displayName = property;
        // remember the module that contains the definition
        if (typeof lively !== "undefined" && lively.Module && lively.Module.current) sourceObj.sourceModule = lively.Module.current();
      }
    }
  }

  return destination;
}

// -=-=-=-=-
// clone
// -=-=-=-=-

function clone$$1(object) {
  // Shallow copy
  if (isPrimitive(object)) return object;
  if (Array.isArray(object)) return Array.prototype.slice.call(object);
  var clone$$1 = {};
  for (var key in object) {
    if (object.hasOwnProperty(key)) clone$$1[key] = object[key];
  }
  return clone$$1;
}

function extract(object, properties, mapFunc) {
  // Takes a list of properties and returns a new object with those
  // properties shallow-copied from object
  var copied = {};
  for (var i = 0; i < properties.length; i++) {
    if (properties[i] in object) copied[properties[i]] = mapFunc ? mapFunc(properties[i], object[properties[i]]) : object[properties[i]];
  }
  return copied;
}

// -=-=-=-=-=-
// inspection
// -=-=-=-=-=-
function inspect(object, options, depth) {
  // Prints a human-readable representation of `obj`. The printed
  // representation will be syntactically correct JavaScript but will not
  // necessarily evaluate to a structurally identical object. `inspect` is
  // meant to be used while interactivively exploring JavaScript programs and
  // state.
  //
  // `options` can be {
  //   printFunctionSource: BOOLEAN,
  //   escapeKeys: BOOLEAN,
  //   maxDepth: NUMBER,
  //   customPrinter: FUNCTION
  // }
  options = options || {};
  depth = depth || 0;

  if (options.customPrinter) {
    var ignoreSignal = options._ignoreSignal || (options._ignoreSignal = {});
    var customInspected = options.customPrinter(object, ignoreSignal);
    if (customInspected !== ignoreSignal) return customInspected;
  }
  if (!object) return print$1(object);

  // print function
  if (typeof object === 'function') {
    return options.printFunctionSource ? String(object) : 'function' + (object.name ? ' ' + object.name : '') + '(' + argumentNames(object).join(',') + ') {/*...*/}';
  }

  // print "primitive"
  switch (object.constructor) {
    case String:
    case Boolean:
    case RegExp:
    case Number:
      return print$1(object);
  }

  if (typeof object.serializeExpr === 'function') return object.serializeExpr();

  var isArray$$1 = object && Array.isArray(object),
      openBr = isArray$$1 ? '[' : '{',
      closeBr = isArray$$1 ? ']' : '}';
  if (options.maxDepth && depth >= options.maxDepth) return openBr + '/*...*/' + closeBr;

  var printedProps = [];
  if (isArray$$1) {
    printedProps = object.map(function (ea) {
      return inspect(ea, options, depth + 1);
    });
  } else {
    printedProps = Object.keys(object).sort(function (a, b) {
      var aIsFunc = typeof object[a] === 'function',
          bIsFunc = typeof object[b] === 'function';
      if (aIsFunc === bIsFunc) {
        if (a < b) return -1;
        if (a > b) return 1;
        return 0;
      }
      return aIsFunc ? 1 : -1;
    }).map(function (key, i) {
      if (isArray$$1) inspect(object[key], options, depth + 1);
      var printedVal = inspect(object[key], options, depth + 1);
      return options.escapeKeys ? JSON.stringify(key) : key + ": " + printedVal;
    });
  }

  if (printedProps.length === 0) {
    return openBr + closeBr;
  }

  var printedPropsJoined = printedProps.join(', '),
      useNewLines = (!isArray$$1 || options.newLineInArrays) && (!options.minLengthForNewLine || printedPropsJoined.length >= options.minLengthForNewLine),
      ind = indent$1('', options.indent || '  ', depth),
      propIndent = indent$1('', options.indent || '  ', depth + 1),
      startBreak = useNewLines && !isArray$$1 ? '\n' + propIndent : '',
      eachBreak = useNewLines ? '\n' + propIndent : '',
      endBreak = useNewLines && !isArray$$1 ? '\n' + ind : '';
  if (useNewLines) printedPropsJoined = printedProps.join(',' + eachBreak);
  return openBr + startBreak + printedPropsJoined + endBreak + closeBr;
}

// -=-=-=-=-
// merging
// -=-=-=-=-
function merge(objs) {
  // `objs` can be a list of objects. The return value will be a new object,
  // containing all properties of all objects. If the same property exist in
  // multiple objects, the right-most property takes precedence.
  //
  // Like `extend` but will not mutate objects in `objs`.

  // if objs are arrays just concat them
  // if objs are real objs then merge propertdies
  if (arguments.length > 1) {
    return merge(Array.prototype.slice.call(arguments));
  }

  if (Array.isArray(objs[0])) {
    // test for all?
    return Array.prototype.concat.apply([], objs);
  }

  return objs.reduce(function (merged, ea) {
    for (var name in ea) {
      if (ea.hasOwnProperty(name)) merged[name] = ea[name];
    }return merged;
  }, {});
}

function deepMerge(objA, objB) {
  // `objs` can be a list of objects. The return value will be a new object,
  // containing all properties of all objects. If the same property exist in
  // multiple objects, the right-most property takes precedence.
  //
  // Like `extend` but will not mutate objects in `objs`.

  // if objs are arrays just concat them
  // if objs are real objs then merge propertdies

  if (!objA) return objB;
  if (!objB) return objA;

  if (Array.isArray(objA)) {
    if (!Array.isArray(objB)) return objB;
    var merged = objA.map(function (ea, i) {
      return deepMerge(ea, objB[i]);
    });
    if (objB.length > objA.length) merged = merged.concat(objB.slice(objA.length));
    return merged;
  }

  if ((typeof objA === "undefined" ? "undefined" : _typeof(objA)) !== "object" || (typeof objB === "undefined" ? "undefined" : _typeof(objB)) !== "object") return objB;

  return Object.keys(objA).concat(Object.keys(objB)).reduce(function (merged, name) {
    if (!objA[name]) merged[name] = objB[name];else if (!objB[name]) merged[name] = objA[name];else if (_typeof(objA[name]) !== "object" || _typeof(objB[name]) !== "object") merged[name] = objB[name];else merged[name] = deepMerge(objA[name], objB[name]);
    return merged;
  }, {});
}

function sortKeysWithBeforeAndAfterConstraints(properties) {
  var throwErrorOnMissing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  // Expects `properties` to be a map of keys to objects having optional
  // before/after attributes that, if present, should be lists of other property
  // keys. `sortProperties` will return an ordered list of property keys so
  // that the before / after requirements are fullfilled. If a cyclic
  // dependency is encountered an error will be thrown.
  // Example:
  // ```
  // sortProperties({foo: {}, bar: {after: ["foo"], before: ["baz"]}, "baz": {after: ["foo"]}})
  // // => ["foo","bar","baz"]
  // ```

  // ignore-in-doc
  // 1. convert "before" requirement into "after" and check if all properties
  // mentioned in after/before are actually there
  var keys = [],
      props = [],
      remaining = [];
  for (var key in properties) {
    var prop = properties[key],
        before = prop.hasOwnProperty("before") ? prop.before : prop.before = [],
        after = prop.hasOwnProperty("after") ? prop.after : prop.after = [];

    keys.push(key);
    props.push(prop);

    for (var i = before.length; i--;) {
      var beforePropName = before[i];
      var beforeProp = properties[beforePropName];
      if (!beforeProp) {
        console.warn("[initializeProperties] " + this + " sortProperties: " + ("Property " + key + " requires to be initialized before " + beforePropName + " ") + "but that property cannot be found.");
        before.splice(i, 1);
        continue;
      }
      if (!beforeProp.hasOwnProperty("after")) beforeProp.after = [];
      beforeProp.after.push(key);
    }

    for (var _i = after.length; _i--;) {
      var afterPropName = after[_i];
      var afterProp = properties[afterPropName];
      if (!afterProp) {
        console.warn("[initializeProperties] " + this + " sortProperties: " + ("Property " + key + " requires to be initialized after " + afterPropName + " ") + "but that property cannot be found.");
        after.splice(_i, 1);
      }
    }

    remaining.push(key);
  }

  // ignore-in-doc
  // compute order
  var resolvedGroups = [],
      resolvedKeys = [],
      lastLength = remaining.length + 1;

  while (remaining.length) {
    if (lastLength === remaining.length) throw new Error("Circular dependencies in handler order, could not resolve properties " + remaining.map(function (key) {
      var before = properties[key].before,
          after = properties[key].after;
      if ((!before || !before.length) && (!after || !after.length)) return "";
      var report = key + "\n";
      if (before && before.length) report += "  - before " + before.join(",") + "\n";
      if (after && after.length) report += "  - after " + after.join(",") + "\n";
      return report;
    }).join(""));
    lastLength = remaining.length;
    var resolvedGroup = [];
    for (var _i2 = remaining.length; _i2--;) {
      var _key = remaining[_i2];
      if (isSubset(properties[_key].after, resolvedKeys)) {
        remaining.splice(_i2, 1);
        resolvedKeys.push(_key);
        resolvedGroup.push(_key);
      }
    }
    resolvedGroups.push(resolvedGroup);
  }

  return flatten(resolvedGroups, 1);
}

// -=-=-=-=-=-=-
// inheritance
// -=-=-=-=-=-=-
function inherit(obj) {
  return Object.create(obj);
}

function valuesInPropertyHierarchy(obj, name) {
  // Lookup all properties named name in the proto hierarchy of obj.
  // Example:
  // var a = {foo: 3}, b = Object.create(a), c = Object.create(b);
  // c.foo = 4;
  // obj.valuesInPropertyHierarchy(c, "foo") // => [3,4]
  var result = [],
      lookupObj = obj;
  while (lookupObj) {
    if (lookupObj.hasOwnProperty(name)) result.unshift(lookupObj[name]);
    lookupObj = Object.getPrototypeOf(lookupObj);
  }
  return result;
}

function mergePropertyInHierarchy(obj, propName) {
  // like `merge` but automatically gets all definitions of the value in the
  // prototype chain and merges those.
  // Example:
  // var o1 = {x: {foo: 23}}, o2 = {x: {foo: 24, bar: 15}}, o3 = {x: {baz: "zork"}};
  // o2.__proto__ = o1; o3.__proto__ = o2;
  // obj.mergePropertyInHierarchy(o3, "x");
  // // => {bar: 15, baz: "zork",foo: 24}
  return merge(valuesInPropertyHierarchy(obj, propName));
}

function deepCopy(object) {
  // Recursively traverses `object` and its properties to create a copy.
  if (!object || (typeof object === "undefined" ? "undefined" : _typeof(object)) !== "object" || object instanceof RegExp) return object;
  var result = Array.isArray(object) ? Array(object.length) : {};
  for (var key in object) {
    if (object.hasOwnProperty(key)) result[key] = deepCopy(object[key]);
  }
  return result;
}

// -=-=-=-=-=-=-=-=-
// stringification
// -=-=-=-=-=-=-=-=-
function typeStringOf(obj) {
  // ignore-in-doc
  if (obj === null) return "null";
  if (typeof obj === "undefined") return "undefined";
  return obj.constructor.name;
}

function shortPrintStringOf(obj) {
  // ignore-in-doc
  // primitive values
  if (!isMutableType(obj)) return safeToString(obj);

  // constructed objects
  if (obj.constructor.name !== 'Object' && !Array.isArray(obj)) {
    if (obj.constructor.name) return obj.constructor.name ? obj.constructor.name : Object.prototype.toString.call(obj).split(" ")[1].split("]")[0];
  }

  // arrays or plain objects
  var typeString = "";

  function displayTypeAndLength(obj, collectionType, firstBracket, secondBracket) {
    if (obj.constructor.name === collectionType) {
      typeString += firstBracket;
      if (obj.length || Object.keys(obj).length) typeString += "...";
      typeString += secondBracket;
    }
  }
  displayTypeAndLength(obj, "Object", "{", "}");
  displayTypeAndLength(obj, "Array", "[", "]");
  return typeString;
}

function isMutableType(obj) {
  // Is `obj` a value or mutable type?
  var immutableTypes = ["null", "undefined", "Boolean", "Number", "String"];
  return immutableTypes.indexOf(typeStringOf(obj)) === -1;
}

function safeToString(obj) {
  // Like `toString` but catches errors.
  try {
    return (obj ? obj.toString() : String(obj)).replace('\n', '');
  } catch (e) {
    return '<error printing object>';
  }
}

function asObject(obj) {
  switch (typeof obj === "undefined" ? "undefined" : _typeof(obj)) {
    case 'string':
      return new String(obj);
    case 'boolean':
      return new Boolean(obj);
    case 'number':
      return new Number(obj);
    default:
      return obj;
  }
}

function newKeyIn(obj) {
  var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "_";

  var i = 1,
      key;
  do {
    key = base + "-" + i++;
  } while (key in obj);
  return key;
}



var obj = Object.freeze({
	isArray: isArray$$1,
	isElement: isElement,
	isFunction: isFunction,
	isBoolean: isBoolean,
	isString: isString,
	isNumber: isNumber,
	isUndefined: isUndefined,
	isRegExp: isRegExp,
	isObject: isObject,
	isPrimitive: isPrimitive,
	isEmpty: isEmpty,
	equals: equals$1,
	keys: keys$1,
	values: values,
	select: select,
	dissoc: dissoc,
	addScript: addScript,
	extend: extend,
	clone: clone$$1,
	extract: extract,
	inspect: inspect,
	merge: merge,
	deepMerge: deepMerge,
	inherit: inherit,
	valuesInPropertyHierarchy: valuesInPropertyHierarchy,
	mergePropertyInHierarchy: mergePropertyInHierarchy,
	sortKeysWithBeforeAndAfterConstraints: sortKeysWithBeforeAndAfterConstraints,
	deepCopy: deepCopy,
	typeStringOf: typeStringOf,
	shortPrintStringOf: shortPrintStringOf,
	isMutableType: isMutableType,
	safeToString: safeToString,
	asObject: asObject,
	newKeyIn: newKeyIn
});

/*global btoa*/

// String utility methods for printing, parsing, and converting strings.

var features = {
  repeat: !!String.prototype.repeat,
  includes: !!String.prototype.includes,
  startsWith: !!String.prototype.startsWith,
  endsWith: !!String.prototype.endsWith
};

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// printing and formatting strings
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

function format() {
  // String+ -> String
  // Takes a variable number of arguments. The first argument is the format
  // string. Placeholders in the format string are marked with `"%s"`.
  // Example:
  //   lively.lang.string.format("Hello %s!", "Lively User"); // => "Hello Lively User!"
  return formatFromArray(Array.prototype.slice.call(arguments));
}

function formatFromArray(objects) {
  var self = objects.shift();
  if (!self) {
    console.log("Error in Strings>>formatFromArray, first arg is undefined");
  }

  function appendText(object, string) {
    return "" + object;
  }

  function appendInteger(value, string) {
    return value.toString();
  }

  function appendFloat(value, string, precision) {
    if (precision > -1) return value.toFixed(precision);else return value.toString();
  }

  function appendObject(value, string) {
    return inspect(value);
  }

  var appenderMap = { s: appendText, d: appendInteger, i: appendInteger, f: appendFloat, o: appendObject };
  var reg = /((^%|[^\\]%)(\d+)?(\.)([a-zA-Z]))|((^%|[^\\]%)([a-zA-Z]))/;

  function parseFormat(fmt) {
    var oldFmt = fmt;
    var parts = [];

    for (var m = reg.exec(fmt); m; m = reg.exec(fmt)) {
      var type = m[8] || m[5],
          appender = type in appenderMap ? appenderMap[type] : appendObject,
          precision = m[3] ? parseInt(m[3]) : m[4] == "." ? -1 : 0;
      parts.push(fmt.substr(0, m[0][0] == "%" ? m.index : m.index + 1));
      parts.push({ appender: appender, precision: precision });

      fmt = fmt.substr(m.index + m[0].length);
    }
    if (fmt) parts.push(fmt.toString());

    return parts;
  }

  var parts = parseFormat(self),
      str = "",
      objIndex = 0;

  for (var i = 0; i < parts.length; ++i) {
    var part = parts[i];
    if (part && (typeof part === "undefined" ? "undefined" : _typeof(part)) == "object") {
      var object = objects[objIndex++];
      str += (part.appender || appendText)(object, str, part.precision);
    } else {
      str += appendText(part, str);
    }
  }
  return str;
}

function indent(str, indentString, depth) {
  // String -> String -> String? -> String
  // Example:
  //   string.indent("Hello", "  ", 2) // => "    Hello"
  if (!depth || depth <= 0) return str;
  var indent = "";while (depth > 0) {
    depth--;indent += indentString;
  }
  return lines(str).map(function (line) {
    return indent + line;
  }).join("\n");
}

function minIndent(str, indentString) {
  // Find out what the minum indentation of the text in str is
  // Example:
  //   minIndent("    Hello", "  ") // => 2
  if (!indentString) indentString = "  ";
  var indentRe = new RegExp("^(" + indentString + ")*", "gm");
  return min(str.match(indentRe).map(function (ea) {
    return Math.floor(ea.length / indentString.length);
  }));
}

function changeIndent(str, indentString, depth) {
  // Add or remove indent from lines in str to match depth
  // Example:
  //   string.changeIndent("    Hello", "  ", 1) // => "  Hello"
  if (!indentString) indentString = "  ";
  if (!depth) depth = 0;
  var existingIndent = minIndent(str, indentString);
  if (existingIndent === depth) return str;
  if (existingIndent < depth) return indent(str, indentString, depth - existingIndent);
  var prefixToRemove = indentString.repeat(existingIndent - depth);
  return lines(str).map(function (line) {
    return line.slice(prefixToRemove.length);
  }).join("\n");
}

function quote(str) {
  // Example:
  //   string.print("fo\"o") // => "\"fo\\\"o\""
  return '"' + str.replace(/"/g, '\\"') + '"';
}

function print(obj) {
  // Prints Arrays and escapes quotations. See `obj.inspect` for how to
  // completely print / inspect JavaScript data strcutures
  // Example:
  //   string.print([[1,2,3], "string", {foo: 23}])
  //      // => [[1,2,3],"string",[object Object]]
  if (obj && Array.isArray(obj)) return '[' + obj.map(print) + ']';
  if (typeof obj !== "string") return String(obj);
  var result = String(obj);
  result = result.replace(/\n/g, '\\n\\\n');
  result = result.replace(/(")/g, '\\$1');
  result = '\"' + result + '\"';
  return result;
}

function printNested(list, depth) {
  // Example:
  //   string.printNested([1,2,[3,4,5]]) // => "1\n2\n  3\n  4\n  5\n"
  depth = depth || 0;
  return list.reduce(function (s, ea) {
    return s += Array.isArray(ea) ? printNested(ea, depth + 1) : indent(ea + "\n", '  ', depth);
  }, "");
}

function pad(string, n, left) {
  // Examples:
  // pad("Foo", 2) // => "Foo  "
  // pad("Foo", 2, true) // => "  Foo"
  return left ? ' '.repeat(n) + string : string + ' '.repeat(n);
}

function printTable(tableArray, options) {
  // Array -> Object? -> String
  // Takes a 2D Array and prints a table string. Kind of the reverse
  // operation to `tableize`
  // Example:
  //   string.printTable([["aaa", "b", "c"], ["d", "e","f"]])
  //    // =>
  //    // aaa b c
  //    // d   e f
  var columnWidths = [],
      separator = options && options.separator || ' ',
      alignLeftAll = !options || !options.align || options.align === 'left',
      alignRightAll = options && options.align === 'right';
  function alignRight(columnIndex) {
    if (alignLeftAll) return false;
    if (alignRightAll) return true;
    return options && Array.isArray(options.align) && options.align[columnIndex] === 'right';
  }
  tableArray.forEach(function (row) {
    row.forEach(function (cellVal, i) {
      if (columnWidths[i] === undefined) columnWidths[i] = 0;
      columnWidths[i] = Math.max(columnWidths[i], String(cellVal).length);
    });
  });
  return tableArray.map(function (row) {
    return row.map(function (cellVal, i) {
      var cellString = String(cellVal);
      return pad(cellString, columnWidths[i] - cellString.length, alignRight(i));
    }).join(separator);
  }).join('\n');
}

function printTree(rootNode, nodePrinter, childGetter, indent) {
  // Object -> Function -> Function -> Number? -> String
  // A generic function to print a tree representation from a nested data structure.
  // Receives three arguments:
  // - `rootNode` an object representing the root node of the tree
  // - `nodePrinter` is a function that gets a tree node and should return stringified version of it
  // - `childGetter` is a function that gets a tree node and should return a list of child nodes
  // Example:
  // var root = {name: "a", subs: [{name: "b", subs: [{name: "c"}]}, {name: "d"}]};
  // string.printTree(root, function(n) { return n.name; }, function(n) { return n.subs; });
  // // =>
  // // a
  // // |-b
  // // | \-c
  // // \-d

  var nodeList = [];
  indent = indent || '  ';
  iterator(0, 0, rootNode);
  return nodeList.join('\n');
  // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  function iterator(depth, index, node) {
    // ignore-in-doc
    // 1. Create stringified representation of node
    nodeList[index] = indent.repeat(depth) + nodePrinter(node, depth);
    var children = childGetter(node, depth),
        childIndex = index + 1;
    if (!children || !children.length) return childIndex;
    // 2. If there are children then assemble those linear inside nodeList
    // The childIndex is the pointer of the current items of childList into
    // nodeList.
    var lastIndex = childIndex,
        lastI = children.length - 1;
    children.forEach(function (ea, i) {
      childIndex = iterator(depth + 1, childIndex, ea);
      // 3. When we have printed the recursive version then augment the
      // printed version of the direct children with horizontal slashes
      // directly in front of the represented representation
      var isLast = lastI === i,
          cs = nodeList[lastIndex].split(''),
          fromSlash = depth * indent.length + 1,
          toSlash = depth * indent.length + indent.length;
      for (var i = fromSlash; i < toSlash; i++) {
        cs[i] = '-';
      }if (isLast) cs[depth * indent.length] = '\\';
      nodeList[lastIndex] = cs.join('');
      // 4. For all children (direct and indirect) except for the
      // last one (itself and all its children) add vertical bars in
      // front of each at position of the current nodes depth. This
      // makes is much easier to see which child node belongs to which
      // parent
      if (!isLast) nodeList.slice(lastIndex, childIndex).forEach(function (ea, i) {
        var cs2 = ea.split('');
        cs2[depth * indent.length] = '|';
        nodeList[lastIndex + i] = cs2.join('');
      });
      lastIndex = childIndex;
    });
    return childIndex;
  }
}

function toArray$1(s) {
  // Example:
  // string.toArray("fooo") // => ["f","o","o","o"]
  return s.split('');
}

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// parsing strings into other entities
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

function lines(str) {
  // Example: string.lines("foo\nbar\n\rbaz") // => ["foo","bar","baz"]
  return str.split(/\n\r?/);
}

function paragraphs(string, options) {
  // Examples:
  // var text = "Hello, this is a pretty long sentence\nthat even includes new lines."
  //         + "\n\n\nThis is a sentence in  a new paragraph.";
  // string.paragraphs(text) // => [
  //   // "Hello, this is a pretty long sentence\nthat even includes new lines.",
  //   // "This is a sentence in  a new paragraph."]
  // string.paragraphs(text, {keepEmptyLines: true}) // => [
  //   // "Hello, this is a pretty long sentence\n that even includes new lines.",
  //   // "\n ",
  //   // "This is a sentence in  a new paragraph."]
  var sep = options ? options.sep : '\n\n';
  if (!options || !options.keepEmptyLines) return string.split(new RegExp(sep + '+'));
  function isWhiteSpace(s) {
    return (/^\s*$/.test(s)
    );
  }
  return string.split('\n').concat('').reduce(function (parasAndLast, line) {
    var paras = parasAndLast[0],
        last$$1 = parasAndLast[1];
    if (isWhiteSpace(last$$1) === isWhiteSpace(line)) {
      last$$1 += '\n' + line;
    } else {
      last$$1.length && paras.push(last$$1);last$$1 = line;
    }
    return [paras, last$$1];
  }, [[], ''])[0];
}

function nonEmptyLines(str) {
  // Example: string.nonEmptyLines("foo\n\nbar\n") // => ["foo","bar"]
  return lines(str).compact();
}

function tokens(str, regex) {
  // Example:
  // string.tokens(' a b c') => ['a', 'b', 'c']
  return str.split(regex || /\s+/).filter(function (tok) {
    return !/^\s*$/.test(tok);
  });
}

function tableize(s, options) {
  // String -> Object? -> Array
  // Takes a String representing a "table" and parses it into a 2D-Array (as
  // accepted by the `collection.Grid` methods or `string.printTable`)
  // ```js
  // options = {
  //     convertTypes: BOOLEAN, // automatically convert to Numbers, Dates, ...?
  //     cellSplitter: REGEXP // how to recognize "cells", by default just spaces
  // }
  // ```
  // Examples:
  // string.tableize('a b c\nd e f')
  // // => [["a","b","c"],["d","e","f"]]
  // // can also parse csv like
  // var csv = '"Symbol","Name","LastSale",\n'
  //         + '"FLWS","1-800 FLOWERS.COM, Inc.","5.65",\n'
  //         + '"FCTY","1st Century Bancshares, Inc","5.65",'
  // string.tableize(csv, {cellSplitter: /^\s*"|","|",?\s*$/g})
  // // => [["Symbol","Name","LastSale"],
  // //     ["FLWS","1-800 FLOWERS.COM, Inc.",5.65],
  // //     ["FCTY","1st Century Bancshares, Inc",5.65]]

  options = options || {};
  var splitter = options.cellSplitter || /\s+/,
      emptyStringRe = /^\s*$/,
      convertTypes = options.hasOwnProperty('convertTypes') ? !!options.convertTypes : true,
      _lines = lines(s),
      table = [];
  for (var i = 0; i < _lines.length; i++) {
    var _tokens = tokens(_lines[i], splitter);
    if (convertTypes) {
      _tokens = _tokens.map(function (tok) {
        if (tok.match(emptyStringRe)) return tok;
        var num = Number(tok);
        if (!isNaN(num)) return num;
        var date = new Date(tok);
        if (!isNaN(+date)) return date;
        return tok.trim();
      });
    }
    if (_tokens.length > 0) table.push(_tokens);
  }
  return table;
}

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// (un)escape / encoding / decoding
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

function unescapeCharacterEntities(s) {
  // Converts [character entities](http://dev.w3.org/html5/html-author/charref)
  // into utf-8 strings
  // Example:
  //   string.unescapeCharacterEntities("foo &amp;&amp; bar") // => "foo && bar"
  if (typeof document === 'undefined') throw new Error("Cannot unescapeCharacterEntities");
  var div = document.createElement('div');
  div.innerHTML = s;
  return div.textContent;
}

function toQueryParams(s, separator) {
  // Example:
  // string.toQueryParams("http://example.com?foo=23&bar=test")
  //   // => {bar: "test", foo: "23"}
  var match = s.trim().match(/([^?#]*)(#.*)?$/);
  if (!match) return {};

  var hash = match[1].split(separator || '&').inject({}, function (hash, pair) {
    if ((pair = pair.split('='))[0]) {
      var key = decodeURIComponent(pair.shift());
      var value = pair.length > 1 ? pair.join('=') : pair[0];
      if (value != undefined) value = decodeURIComponent(value);

      if (key in hash) {
        if (!Array.isArray(hash[key])) hash[key] = [hash[key]];
        hash[key].push(value);
      } else hash[key] = value;
    }
    return hash;
  });
  return hash;
}

// -=-=-=-=-=-=-=-=-=-=-=-=-
// file system path support
// -=-=-=-=-=-=-=-=-=-=-=-=-
function joinPath() /*paths*/{
  // Joins the strings passed as paramters together so that ea string is
  // connected via a single "/".
  // Example:
  // string.joinPath("foo", "bar") // => "foo/bar";
  var args = Array.prototype.slice.call(arguments);
  return args.reduce(function (path, ea) {
    return typeof ea === "string" ? path.replace(/\/*$/, "") + "/" + ea.replace(/^\/*/, "") : path;
  });
}

// -=-=-=-=-=-=-=-=-
// ids and hashing
// -=-=-=-=-=-=-=-=-

function newUUID() {
  // Example:
  //   string.newUUID() // => "3B3E74D0-85EA-45F2-901C-23ECF3EAB9FB"
  var id = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0,
        v = c == 'x' ? r : r & 0x3 | 0x8;
    return v.toString(16);
  }).toUpperCase();
  return id;
}

function createDataURI(content, mimeType) {
  // String -> String -> String
  // Takes some string representing content and a mime type.
  // For a list of mime types see: [http://www.iana.org/assignments/media-types/media-types.xhtml]()
  // More about data URIs: [https://developer.mozilla.org/en-US/docs/Web/HTTP/data_URIs]()
  // Example:
  //   window.open(string.createDataURI('<h1>test</h1>', 'text/html'));
  mimeType = mimeType || "text/plain";
  return "data:" + mimeType + ";base64," + btoa(content);
}

function hashCode(s) {
  // [http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/]()
  // Example: string.hashCode("foo") // => 101574
  var hash = 0,
      len = s.length;
  if (len == 0) return hash;
  for (var i = 0; i < len; i++) {
    var c = s.charCodeAt(i);
    hash = (hash << 5) - hash + c;
    hash = hash & hash; // Convert to 32bit integer
  }
  return hash;
}

function md5(string) {
  // © Joseph Myers [http://www.myersdaily.org/joseph/javascript/md5-text.html]()
  // Example:
  //   string.md5("foo") // => "acbd18db4cc2f85cedef654fccc4a4d8"

  /* ignore-in-doc
  this function is much faster,
  so if possible we use it. Some IEs
  are the only ones I know of that
  need the idiotic second function,
  generated by an if clause.  */
  // var add32 = hex(md51("hello")) === "5d41402abc4b2a76b9719d911017c592" ?
  //   function add32(a, b) { return (a + b) & 0xFFFFFFFF; } :
  var add32 = function add32(x, y) {
    var lsw = (x & 0xFFFF) + (y & 0xFFFF),
        msw = (x >> 16) + (y >> 16) + (lsw >> 16);
    return msw << 16 | lsw & 0xFFFF;
  };

  function cmn(q, a, b, x, s, t) {
    a = add32(add32(a, q), add32(x, t));
    return add32(a << s | a >>> 32 - s, b);
  }

  function ff(a, b, c, d, x, s, t) {
    return cmn(b & c | ~b & d, a, b, x, s, t);
  }

  function gg(a, b, c, d, x, s, t) {
    return cmn(b & d | c & ~d, a, b, x, s, t);
  }

  function hh(a, b, c, d, x, s, t) {
    return cmn(b ^ c ^ d, a, b, x, s, t);
  }

  function ii(a, b, c, d, x, s, t) {
    return cmn(c ^ (b | ~d), a, b, x, s, t);
  }

  function md5cycle(x, k) {
    var a = x[0],
        b = x[1],
        c = x[2],
        d = x[3];

    a = ff(a, b, c, d, k[0], 7, -680876936);
    d = ff(d, a, b, c, k[1], 12, -389564586);
    c = ff(c, d, a, b, k[2], 17, 606105819);
    b = ff(b, c, d, a, k[3], 22, -1044525330);
    a = ff(a, b, c, d, k[4], 7, -176418897);
    d = ff(d, a, b, c, k[5], 12, 1200080426);
    c = ff(c, d, a, b, k[6], 17, -1473231341);
    b = ff(b, c, d, a, k[7], 22, -45705983);
    a = ff(a, b, c, d, k[8], 7, 1770035416);
    d = ff(d, a, b, c, k[9], 12, -1958414417);
    c = ff(c, d, a, b, k[10], 17, -42063);
    b = ff(b, c, d, a, k[11], 22, -1990404162);
    a = ff(a, b, c, d, k[12], 7, 1804603682);
    d = ff(d, a, b, c, k[13], 12, -40341101);
    c = ff(c, d, a, b, k[14], 17, -1502002290);
    b = ff(b, c, d, a, k[15], 22, 1236535329);

    a = gg(a, b, c, d, k[1], 5, -165796510);
    d = gg(d, a, b, c, k[6], 9, -1069501632);
    c = gg(c, d, a, b, k[11], 14, 643717713);
    b = gg(b, c, d, a, k[0], 20, -373897302);
    a = gg(a, b, c, d, k[5], 5, -701558691);
    d = gg(d, a, b, c, k[10], 9, 38016083);
    c = gg(c, d, a, b, k[15], 14, -660478335);
    b = gg(b, c, d, a, k[4], 20, -405537848);
    a = gg(a, b, c, d, k[9], 5, 568446438);
    d = gg(d, a, b, c, k[14], 9, -1019803690);
    c = gg(c, d, a, b, k[3], 14, -187363961);
    b = gg(b, c, d, a, k[8], 20, 1163531501);
    a = gg(a, b, c, d, k[13], 5, -1444681467);
    d = gg(d, a, b, c, k[2], 9, -51403784);
    c = gg(c, d, a, b, k[7], 14, 1735328473);
    b = gg(b, c, d, a, k[12], 20, -1926607734);

    a = hh(a, b, c, d, k[5], 4, -378558);
    d = hh(d, a, b, c, k[8], 11, -2022574463);
    c = hh(c, d, a, b, k[11], 16, 1839030562);
    b = hh(b, c, d, a, k[14], 23, -35309556);
    a = hh(a, b, c, d, k[1], 4, -1530992060);
    d = hh(d, a, b, c, k[4], 11, 1272893353);
    c = hh(c, d, a, b, k[7], 16, -155497632);
    b = hh(b, c, d, a, k[10], 23, -1094730640);
    a = hh(a, b, c, d, k[13], 4, 681279174);
    d = hh(d, a, b, c, k[0], 11, -358537222);
    c = hh(c, d, a, b, k[3], 16, -722521979);
    b = hh(b, c, d, a, k[6], 23, 76029189);
    a = hh(a, b, c, d, k[9], 4, -640364487);
    d = hh(d, a, b, c, k[12], 11, -421815835);
    c = hh(c, d, a, b, k[15], 16, 530742520);
    b = hh(b, c, d, a, k[2], 23, -995338651);

    a = ii(a, b, c, d, k[0], 6, -198630844);
    d = ii(d, a, b, c, k[7], 10, 1126891415);
    c = ii(c, d, a, b, k[14], 15, -1416354905);
    b = ii(b, c, d, a, k[5], 21, -57434055);
    a = ii(a, b, c, d, k[12], 6, 1700485571);
    d = ii(d, a, b, c, k[3], 10, -1894986606);
    c = ii(c, d, a, b, k[10], 15, -1051523);
    b = ii(b, c, d, a, k[1], 21, -2054922799);
    a = ii(a, b, c, d, k[8], 6, 1873313359);
    d = ii(d, a, b, c, k[15], 10, -30611744);
    c = ii(c, d, a, b, k[6], 15, -1560198380);
    b = ii(b, c, d, a, k[13], 21, 1309151649);
    a = ii(a, b, c, d, k[4], 6, -145523070);
    d = ii(d, a, b, c, k[11], 10, -1120210379);
    c = ii(c, d, a, b, k[2], 15, 718787259);
    b = ii(b, c, d, a, k[9], 21, -343485551);

    x[0] = add32(a, x[0]);
    x[1] = add32(b, x[1]);
    x[2] = add32(c, x[2]);
    x[3] = add32(d, x[3]);
  }

  function md51(s) {
    var n = s.length,
        state = [1732584193, -271733879, -1732584194, 271733878],
        i;
    for (i = 64; i <= n; i += 64) {
      md5cycle(state, md5blk(s.substring(i - 64, i)));
    }
    s = s.substring(i - 64);
    var tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        sl = s.length;
    for (i = 0; i < sl; i++) {
      tail[i >> 2] |= s.charCodeAt(i) << (i % 4 << 3);
    }tail[i >> 2] |= 0x80 << (i % 4 << 3);
    if (i > 55) {
      md5cycle(state, tail);
      i = 16;
      while (i--) {
        tail[i] = 0;
      }
      //			for (i=0; i<16; i++) tail[i] = 0;
    }
    tail[14] = n * 8;
    md5cycle(state, tail);
    return state;
  }

  /* ignore-in-doc
   * there needs to be support for Unicode here,
   * unless we pretend that we can redefine the MD-5
   * algorithm for multi-byte characters (perhaps
   * by adding every four 16-bit characters and
   * shortening the sum to 32 bits). Otherwise
   * I suggest performing MD-5 as if every character
   * was two bytes--e.g., 0040 0025 = @%--but then
   * how will an ordinary MD-5 sum be matched?
   * There is no way to standardize text to something
   * like UTF-8 before transformation; speed cost is
   * utterly prohibitive. The JavaScript standard
   * itself needs to look at this: it should start
   * providing access to strings as preformed UTF-8
   * 8-bit unsigned value arrays.
   */
  function md5blk(s) {
    // ignore-in-doc
    /* I figured global was faster.   */
    var md5blks = [],
        i; /* Andy King said do it this way. */
    for (i = 0; i < 64; i += 4) {
      md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
    }
    return md5blks;
  }

  var hex_chr = '0123456789abcdef'.split('');

  function rhex(n) {
    var s = '',
        j = 0;
    for (; j < 4; j++) {
      s += hex_chr[n >> j * 8 + 4 & 0x0F] + hex_chr[n >> j * 8 & 0x0F];
    }return s;
  }

  function hex(x) {
    var l = x.length;
    for (var i = 0; i < l; i++) {
      x[i] = rhex(x[i]);
    }return x.join('');
  }

  return hex(md51(string));
}

// -=-=-=-=-=-=-=-=-=-=-=-=-=-
// matching strings / regexps
// -=-=-=-=-=-=-=-=-=-=-=-=-=-

function reMatches$$1(string, re) {
  // Different to the native `match` function this method returns an object
  // with `start`, `end`, and `match` fields
  // Example:
  //   string.reMatches("Hello World", /o/g)
  //   // => [{start: 4, end: 5, match: "o"},{start: 7, end: 8, match: "o"}]
  var matches = [];
  string.replace(re, function (match, idx) {
    matches.push({ match: match, start: idx, end: idx + match.length });
  });
  return matches;
}

function stringMatch(s, patternString, options) {
  // returns `{matched: true}` if success otherwise
  // `{matched: false, error: EXPLANATION, pattern: STRING|RE, pos: NUMBER}`
  // Example:
  //   string.stringMatch("foo 123 bar", "foo __/[0-9]+/__ bar") // => {matched: true}
  //   string.stringMatch("foo aaa bar", "foo __/[0-9]+/__ bar")
  //     // => {
  //     //   error: "foo <--UNMATCHED-->aaa bar",
  //     //   matched: false,
  //     //   pattern: /[0-9]+/,
  //     //   pos: 4
  //     // }
  options = options || {};
  if (!!options.normalizeWhiteSpace) s = s.replace(/\s+/g, ' ');
  if (!!options.ignoreIndent) {
    s = s.replace(/^\s+/gm, '');
    patternString = patternString.replace(/^\s+/gm, '');
  }
  return s == patternString ? { matched: true } : embeddedReMatch(s, patternString);

  // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  function splitInThree(string, start, end, startGap, endGap) {
    // ignore-in-doc
    // split string at start and end
    // return (0, start), (start, end), (end, ...)
    startGap = startGap || 0;endGap = endGap || 0;
    return [string.slice(0, start), string.slice(start + startGap, end - endGap), string.slice(end)];
  }

  function matchStringForward(s, pattern) {
    // ignore-in-doc
    // try to match pattern at beginning of string. if matched, return
    // result object with {
    //   match: STRING,
    //   REST: STRING -- remaining string after pattern was consumed
    // }
    if (pattern.constructor !== RegExp) {
      var idx = s.indexOf(pattern);
      if (idx === 0) return { match: pattern, rest: s.slice(pattern.length) };
      // no match
      for (var i = 0; i < pattern.length; i++) {
        // figure out where we failed
        if (pattern[i] != s[i]) return { match: null, pos: i };
      }return { match: null };
    }
    var matches = reMatches$$1(s, pattern);
    // show(matches)
    // show(string.slice(matches[0].end));
    return !matches || !matches.length || matches[0].start !== 0 ? { match: null } : { match: matches[0].match, rest: s.slice(matches[0].end) };
  }

  function matchStringForwardWithAllPatterns(s, patterns) {
    // ignore-in-doc
    // like matchStringForward, just apply list of patterns
    var pos = 0;
    for (var i = 0; i < patterns.length; i++) {
      var p = patterns[i],
          result = matchStringForward(s, p);
      if (!result.match) return { matched: false, pos: pos + (result.pos || 0), pattern: p };
      pos += result.match.length;
      s = result.rest;
    }
    return s.length ? { matched: false, pos: pos } : { matched: true };
  }

  function splitIntoPatterns(matcher) {
    var starts = reMatches$$1(matcher, /__\//g),
        ends = reMatches$$1(matcher, /\/__/g);
    if (starts.length !== ends.length) {
      throw new Error("pattern invalid: " + matcher + " cannot be split into __/.../__ embedded RegExps" + "\nstarts: " + JSON.stringify(starts) + '\nvs ends:\n' + JSON.stringify(ends));
    }
    var consumed = 0;
    return starts.reduce(function (patterns, start, i) {
      var end = ends[i];
      var matcher = patterns.pop();
      var splitted = splitInThree(matcher, start.start - consumed, end.end - consumed, 3, 3);
      if (splitted[0].length) {
        patterns.push(splitted[0]);
        consumed += splitted[0].length;
      }
      try {
        if (splitted[1].length) {
          patterns.push(new RegExp(splitted[1]));
          consumed += splitted[1].length + 3 + 3;
        }
      } catch (e) {
        throw new Error("Cannot create pattern re from: " + inspect(splitted));
      }
      if (splitted[2].length) {
        patterns.push(splitted[2]);
      }
      return patterns;
    }, [matcher]);
  }

  function embeddedReMatch(s, patternString) {
    // ignore-in-doc
    // the main match func
    var patterns = splitIntoPatterns(patternString);
    var result = matchStringForwardWithAllPatterns(s, patterns);
    if (result.matched) return result;
    result.error = s.slice(0, result.pos) + '<--UNMATCHED-->' + s.slice(result.pos);
    return result;
  }
}

function peekRight(s, start, needle) {
  // Finds the next occurence of `needle` (String or RegExp). Returns delta
  // index.
  // Example:
  // peekRight("Hello World", 0, /o/g) // => 4
  // peekRight("Hello World", 5, /o/) // => 2
  s = s.slice(start);
  if (typeof needle === 'string') {
    var idx = s.indexOf(needle);
    return idx === -1 ? null : idx + start;
  } else if (needle.constructor === RegExp) {
    var matches = reMatches$$1(s, needle);
    return matches[0] ? matches[0].start : null;
  }
  return null;
}

function peekLeft(s, start, needle) {
  // Similar to `peekRight`
  s = s.slice(0, start);
  if (typeof needle === 'string') {
    var idx = s.lastIndexOf(needle);
    return idx === -1 ? null : idx;
  } else if (needle.constructor === RegExp) {
    var matches = reMatches$$1(s, needle);
    return last(matches) ? last(matches).start : null;
  }
  return null;
}

function lineIndexComputer(s) {
  // String -> Function
  // For converting character positions to line numbers.
  // Returns a function accepting char positions. If the char pos is outside
  // of the line ranges -1 is returned.
  // Example:
  // var idxComp = lineIndexComputer("Hello\nWorld\n\nfoo");
  // idxComp(3) // => 0 (index 3 is "l")
  // idxComp(6) // => 1 (index 6 is "W")
  // idxComp(12) // => 2 (index 12 is "\n")

  // ignore-in-doc
  // line ranges: list of numbers, each line has two entries:
  // i -> start of line, i+1 -> end of line
  var _lineRanges = lineRanges(s);
  // ignore-in-doc
  // FIXME, this is O(n). Make cumputation more efficient, binary lookup?
  return function (pos) {
    for (var line = 0; line < _lineRanges.length; line++) {
      var lineRange = _lineRanges[line];
      if (pos >= lineRange[0] && pos < lineRange[1]) return line;
    }
    return -1;
  };
}

function lineNumberToIndexesComputer(s) {
  // String -> Function
  // For converting line numbers to [startIndex, endIndex]
  // Example:
  // var idxComp = lineNumberToIndexesComputer("Hello\nWorld\n\nfoo");
  // idxComp(1) // => [6,12]
  return function (lineNo) {
    return lineRanges(s)[lineNo];
  };
}

function lineRanges(s) {
  return lines(s).reduce(function (akk, line) {
    var start = akk.indexCount,
        end = akk.indexCount + line.length + 1;
    akk.lineRanges.push([start, end]);
    akk.indexCount = end;
    return akk;
  }, { lineRanges: [], indexCount: 0 }).lineRanges;
}

// -=-=-=-=-
// diffing
// -=-=-=-=-

function diff(s1, s2) {
  if (typeof JsDiff === "undefined") return 'diff not supported';
  return JsDiff.convertChangesToXML(JsDiff.diffWordsWithSpace(s1, s2));
}

// -=-=-=-=-
// testing
// -=-=-=-=-

function empty(s) {
  // show-in-doc
  return s == '';
}

var includes$$1 = features.includes ? function (s, pattern) {
  return s.includes(pattern);
} : function (s, pattern) {
  // Example:
  // include("fooo!", "oo") // => true
  return s.indexOf(pattern) > -1;
};

var include$$1 = includes$$1;

var startsWith = features.startsWith ? function (s, pattern) {
  return s.startsWith(pattern);
} : function (s, pattern) {
  // Example:
  // startsWith("fooo!", "foo") // => true
  return s.indexOf(pattern) === 0;
};

function startsWithVowel(s) {
  // show-in-doc
  var c = s[0];
  return c === 'A' || c === 'E' || c === 'I' || c === 'O' || c === 'U' || c === 'a' || c === 'e' || c === 'i' || c === 'o' || c === 'u' || false;
}

var endsWith = features.endsWith ? function (s, pattern) {
  return s.endsWith(pattern);
} : function (s, pattern) {
  // Example:
  // endsWith("fooo!", "o!") // => true
  var d = s.length - pattern.length;
  return d >= 0 && s.lastIndexOf(pattern) === d;
};

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// string conversion and manipulation
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

function withDecimalPrecision(str, precision) {
  // String -> Number -> String
  // Example: withDecimalPrecision("1.12345678", 3) // => "1.123"
  var floatValue = parseFloat(str);
  return isNaN(floatValue) ? str : floatValue.toFixed(precision);
}

function capitalize(s) {
  // Example:
  // capitalize("foo bar") // => "Foo bar"
  return s.length ? s.charAt(0).toUpperCase() + s.slice(1) : s;
}

function camelCaseString(s) {
  // Spaces to camels, including first char
  // Example: camelCaseString("foo bar baz") // => "FooBarBaz"
  return s.split(" ").invoke('capitalize').join("");
}

function camelize(s) {
  // Dashes to camels, excluding first char
  // Example: camelize("foo-bar-baz") // => "fooBarBaz"
  var parts = s.split('-'),
      len = parts.length;
  if (len == 1) return parts[0];

  var camelized = s.charAt(0) == '-' ? parts[0].charAt(0).toUpperCase() + parts[0].substring(1) : parts[0];
  for (var i = 1; i < len; i++) {
    camelized += parts[i].charAt(0).toUpperCase() + parts[i].substring(1);
  }return camelized;
}

function truncate(s, length, truncation) {
  // Enforces that s is not more then `length` characters long.
  // Example:
  // truncate("123456789", 5) // => "12..."
  length = length || 30;
  truncation = truncation === undefined ? '...' : truncation;
  return s.length > length ? s.slice(0, length - truncation.length) + truncation : String(s);
}

function truncateLeft(s, length, truncation) {
  // Enforces that s is not more then `length` characters long.
  // Example:
  // truncate("123456789", 5) // => "12..."
  length = length || 30;
  truncation = truncation === undefined ? '...' : truncation;
  return s.length > length ? truncation + s.slice(-length) : String(s);
}

function regExpEscape(s) {
  // For creating RegExps from strings and not worrying about proper escaping
  // of RegExp special characters to literally match those.
  // Example:
  // var re = new RegExp(regExpEscape("fooo{20}"));
  // re.test("fooo") // => false
  // re.test("fooo{20}") // => true
  return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
}

function succ(s) {
  // Uses char code.
  // Example:
  // succ("a") // => "b"
  // succ("Z") // => "["
  return s.slice(0, s.length - 1) + String.fromCharCode(s.charCodeAt(s.length - 1) + 1);
}

function digitValue(s) {
  // ignore-in-doc
  return s.charCodeAt(0) - "0".charCodeAt(0);
}

var times = features.repeat ? function (s, count$$1) {
  return s.repeat(count$$1);
} : function (s, count$$1) {
  // Example:
  // string.times("test", 3) // => "testtesttest"
  return count$$1 < 1 ? '' : new Array(count$$1 + 1).join(s);
};

function applyChange(string, change) {
  // change is of the form
  // `{start: Number, end: Number, lines: [String], action: "insert"|"remove"}`
  if (change.action === "insert") {
    return string.slice(0, change.start) + change.lines.join("\n") + string.slice(change.start);
  } else if (change.action === "remove") {
    return string.slice(0, change.start) + string.slice(change.end);
  }
  return string;
}

function applyChanges(s, changes) {
  return changes.reduce(function (result, change) {
    return applyChange(s, change);
  }, s);
}

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// diffing / comparing

function levenshtein(a, b) {
  // How many edit operations separate string a from b?
  // MIT licensed, https://gist.github.com/andrei-
  // Copyright (c) 2011 Andrei Mackenzie and https://github.com/kigiri
  if (a.length === 0) return b.length;
  if (b.length === 0) return a.length;
  var tmp, i, j, prev, val, row;
  // swap to save some memory O(min(a,b)) instead of O(a)
  if (a.length > b.length) {
    tmp = a;a = b;b = tmp;
  }

  row = Array(a.length + 1);
  // init the row
  for (i = 0; i <= a.length; i++) {
    row[i] = i;
  } // fill in the rest
  for (i = 1; i <= b.length; i++) {
    prev = i;
    for (j = 1; j <= a.length; j++) {
      if (b[i - 1] === a[j - 1]) {
        val = row[j - 1]; // match
      } else {
        val = Math.min(row[j - 1] + 1, // substitution
        Math.min(prev + 1, // insertion
        row[j] + 1)); // deletion
      }
      row[j - 1] = prev;
      prev = val;
    }
    row[a.length] = prev;
  }
  return row[a.length];
}



var string = Object.freeze({
	format: format,
	formatFromArray: formatFromArray,
	indent: indent,
	minIndent: minIndent,
	changeIndent: changeIndent,
	quote: quote,
	print: print,
	printNested: printNested,
	pad: pad,
	printTable: printTable,
	printTree: printTree,
	toArray: toArray$1,
	lines: lines,
	paragraphs: paragraphs,
	nonEmptyLines: nonEmptyLines,
	tokens: tokens,
	tableize: tableize,
	unescapeCharacterEntities: unescapeCharacterEntities,
	toQueryParams: toQueryParams,
	joinPath: joinPath,
	newUUID: newUUID,
	createDataURI: createDataURI,
	hashCode: hashCode,
	md5: md5,
	reMatches: reMatches$$1,
	stringMatch: stringMatch,
	peekRight: peekRight,
	peekLeft: peekLeft,
	lineIndexComputer: lineIndexComputer,
	lineNumberToIndexesComputer: lineNumberToIndexesComputer,
	lineRanges: lineRanges,
	diff: diff,
	empty: empty,
	includes: includes$$1,
	include: include$$1,
	startsWith: startsWith,
	startsWithVowel: startsWithVowel,
	endsWith: endsWith,
	withDecimalPrecision: withDecimalPrecision,
	capitalize: capitalize,
	camelCaseString: camelCaseString,
	camelize: camelize,
	truncate: truncate,
	truncateLeft: truncateLeft,
	regExpEscape: regExpEscape,
	succ: succ,
	digitValue: digitValue,
	times: times,
	applyChange: applyChange,
	applyChanges: applyChanges,
	levenshtein: levenshtein
});

/*
 * Utility functions for JS Numbers.
 */

function random(min, max) {
  // random number between (and including) `min` and `max`
  min = min || 0;
  max = max || 100;
  return Math.round(Math.random() * (max - min) + min);
}

var normalRandom = function (mean, stdDev) {
  // returns randomized numbers in a normal distribution that can be
  // controlled ising the `mean` and `stdDev` parameters
  var spare,
      isSpareReady = false;
  return function (mean, stdDev) {
    if (isSpareReady) {
      isSpareReady = false;
      return spare * stdDev + mean;
    } else {
      var u, v, s;
      do {
        u = Math.random() * 2 - 1;
        v = Math.random() * 2 - 1;
        s = u * u + v * v;
      } while (s >= 1 || s == 0);
      var mul = Math.sqrt(-2.0 * Math.log(s) / s);
      spare = v * mul;
      isSpareReady = true;
      return mean + stdDev * u * mul;
    }
  };
}();

function randomSmallerInteger(n) {
  return Math.floor(Math.random() * n);
}

function humanReadableByteSize(n) {
  // interpret `n` as byte size and print a more readable version
  // Example:
  //   num.humanReadableByteSize(Math.pow(2,32)) // => "4096MB"
  function round(n) {
    return Math.round(n * 100) / 100;
  }
  if (n < 1000) return String(round(n)) + 'B';
  n = n / 1024;
  if (n < 1000) return String(round(n)) + 'KB';
  n = n / 1024;
  return String(round(n)) + 'MB';
}

function average(numbers) {
  // show-in-doc
  return numbers.reduce(function (sum, n) {
    return sum + n;
  }, 0) / numbers.length;
}

function median(numbers) {
  // show-in-doc
  var sorted = numbers.sort(function (a, b) {
    return b - a;
  }),
      len = numbers.length;
  return len % 2 === 0 ? 0.5 * (sorted[len / 2 - 1] + sorted[len / 2]) : sorted[(len - 1) / 2];
}

function between(x, a, b, eps) {
  // is `a` <= `x` <= `y`?
  eps = eps || 0;
  var min, max;
  if (a < b) {
    min = a, max = b;
  } else {
    max = a, min = b;
  }
  return max - x + eps >= 0 && min - x - eps <= 0;
}

function sort$1(arr) {
  // numerical sort, JavaScript native `sort` function is lexical by default.
  return arr.sort(function (a, b) {
    return a - b;
  });
}

function parseLength(string, toUnit) {
  // This converts the length value to pixels or the specified `toUnit`.
  // length converstion, supported units are: mm, cm, in, px, pt, pc
  // Examples:
  // num.parseLength('3cm') // => 113.38582677165354
  // num.parseLength('3cm', "in") // => 1.1811023622047243
  toUnit = toUnit || 'px';
  var match = string.match(/([0-9\.]+)\s*(.*)/);
  if (!match || !match[1]) return undefined;
  var length = parseFloat(match[1]),
      fromUnit = match[2];
  return convertLength(length, fromUnit, toUnit);
}

var convertLength = function () {
  // ignore-in-doc
  // num.convertLength(20, 'px', 'pt').roundTo(0.01)
  function toCm(n, unit) {
    // as defined in http://www.w3.org/TR/css3-values/#absolute-lengths
    if (unit === 'cm') return n;else if (unit === 'mm') return n * 0.1;else if (unit === 'in') return n * 2.54;else if (unit === 'px') return n * toCm(1 / 96, 'in');else if (unit === 'pt') return n * toCm(1 / 72, 'in');else if (unit === 'pc') return n * toCm(12, 'pt');
  }
  return function to(length, fromUnit, toUnit) {
    if (fromUnit === toUnit) return length;else if (toUnit === "cm") return toCm(length, fromUnit);else if (fromUnit === "cm") return length / toCm(1, toUnit);else return to(to(length, fromUnit, 'cm'), 'cm', toUnit);
  };
}();

function roundTo(n, quantum) {
  // `quantum` is something like 0.01,

  // for JS rounding to work we need the reciprocal
  quantum = 1 / quantum;
  return Math.round(n * quantum) / quantum;
}

function detent(n, detent, grid, snap) {
  // This function is useful to implement smooth transitions and snapping.
  // Map all values that are within detent/2 of any multiple of grid to
  // that multiple. Otherwise, if snap is true, return self, meaning that
  // the values in the dead zone will never be returned. If snap is
  // false, then expand the range between dead zone so that it covers the
  // range between multiples of the grid, and scale the value by that
  // factor.
  // Examples:
  // // With snapping:
  // num.detent(0.11, 0.2, 0.5, true) // => 0.11
  // num.detent(0.39, 0.2, 0.5, true) // => 0.39
  // num.detent(0.55, 0.2, 0.5, true)  // => 0.5
  // num.detent(0.61, 0.2, 0.5, true)   // => 0.61
  // // Smooth transitions without snapping:
  // num.detent(0.1,  0.2, 0.5) // => 0
  // num.detent(0.11,  0.2, 0.5) // => 0.0166666
  // num.detent(0.34,  0.2, 0.5)  // => 0.4
  // num.detent(0.39,  0.2, 0.5) // => 0.4833334
  // num.detent(0.4,  0.2, 0.5) // => 0.5
  // num.detent(0.6,  0.2, 0.5) // => 0.5
  var r1 = roundTo(n, grid); // Nearest multiple of grid
  if (Math.abs(n - r1) < detent / 2) return r1; // Snap to that multiple...
  if (snap) return n; // ...and return n
  // or compute nearest end of dead zone
  var r2 = n < r1 ? r1 - detent / 2 : r1 + detent / 2;
  // and scale values between dead zones to fill range between multiples
  return r1 + (n - r2) * grid / (grid - detent);
}

function toDegrees(n) {
  // Example:
  // num.toDegrees(Math.PI/2) // => 90
  return n * 180 / Math.PI % 360;
}

function toRadians(n) {
  // Example:
  // num.toRadians(180) // => 3.141592653589793
  return n / 180 * Math.PI;
}



var num = Object.freeze({
	random: random,
	normalRandom: normalRandom,
	randomSmallerInteger: randomSmallerInteger,
	humanReadableByteSize: humanReadableByteSize,
	average: average,
	median: median,
	between: between,
	sort: sort$1,
	parseLength: parseLength,
	convertLength: convertLength,
	roundTo: roundTo,
	detent: detent,
	toDegrees: toDegrees,
	toRadians: toRadians
});

function all$2(object, predicate) {
  // ignore-in-doc
  var a = [];
  for (var name in object) {
    if ((object.__lookupGetter__(name) || typeof object[name] !== 'function') && (predicate ? predicate(name, object) : true)) a.push(name);
  }
  return a;
}

function allOwnPropertiesOrFunctions(obj, predicate) {
  // ignore-in-doc
  return Object.getOwnPropertyNames(obj).reduce(function (result, name) {
    if (predicate ? predicate(obj, name) : true) result.push(name);
    return result;
  }, []);
}

function own$1(object) {
  // ignore-in-doc
  var a = [];
  for (var name in object) {
    if (object.hasOwnProperty(name) && (object.__lookupGetter__(name) || object[name] !== 'function')) a.push(name);
  }
  return a;
}

function forEachOwn(object, func, context) {
  // ignore-in-doc
  var result = [];
  for (var name in object) {
    if (!object.hasOwnProperty(name)) continue;
    var value = object[name];
    if (value !== 'function') {
      result.push(func.call(context || this, name, value));
    }
  }
  return result;
}

function nameFor(object, value) {
  // ignore-in-doc
  for (var name in object) {
    if (object[name] === value) return name;
  }return undefined;
}

function values$1(obj) {
  // ignore-in-doc
  var values = [];
  for (var name in obj) {
    values.push(obj[name]);
  }return values;
}

function ownValues(obj) {
  // ignore-in-doc
  var values = [];
  for (var name in obj) {
    if (obj.hasOwnProperty(name)) values.push(obj[name]);
  }return values;
}

function any$1(obj, predicate) {
  // ignore-in-doc
  for (var name in obj) {
    if (predicate(obj, name)) return true;
  }return false;
}

function allProperties(obj, predicate) {
  // ignore-in-doc
  var result = [];
  for (var name in obj) {
    if (predicate ? predicate(obj, name) : true) result.push(name);
  }return result;
}

function hash(obj) {
  // ignore-in-doc
  // Using the property names of `obj` to generate a hash value.
  return Object.keys(obj).sort().join('').hashCode();
}



var properties = Object.freeze({
	all: all$2,
	allOwnPropertiesOrFunctions: allOwnPropertiesOrFunctions,
	own: own$1,
	forEachOwn: forEachOwn,
	nameFor: nameFor,
	values: values$1,
	ownValues: ownValues,
	any: any$1,
	allProperties: allProperties,
	hash: hash
});

/*
 * Util functions to print and work with JS date objects.
 */

var dateFormat = function setupDateFormat() {

    /*
     * Date Format 1.2.3
     * (c) 2007-2009 Steven Levithan <stevenlevithan.com>
     * MIT license
     *
     * Includes enhancements by Scott Trenda <scott.trenda.net>
     * and Kris Kowal <cixar.com/~kris.kowal/>
     *
     * Accepts a date, a mask, or a date and a mask.
     * Returns a formatted version of the given date.
     * The date defaults to the current date/time.
     * The mask defaults to dateFormat.masks.default.
     */

    // http://blog.stevenlevithan.com/archives/date-time-format

    var dateFormat = function () {
        var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g,
            timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
            timezoneClip = /[^-+\dA-Z]/g,
            pad = function pad(val, len) {
            val = String(val);
            len = len || 2;
            while (val.length < len) {
                val = "0" + val;
            }return val;
        };

        // Regexes and supporting functions are cached through closure
        return function (date, mask, utc) {
            var dF = dateFormat;

            // You can't provide utc if you skip other args (use the "UTC:" mask prefix)
            if (arguments.length == 1 && Object.prototype.toString.call(date) == "[object String]" && !/\d/.test(date)) {
                mask = date;
                date = undefined;
            }

            // Passing date through Date applies Date.parse, if necessary
            date = date ? new Date(date) : new Date();
            if (isNaN(date)) throw SyntaxError("invalid date");

            mask = String(dF.masks[mask] || mask || dF.masks["default"]);

            // Allow setting the utc argument via the mask
            if (mask.slice(0, 4) == "UTC:") {
                mask = mask.slice(4);
                utc = true;
            }

            var _ = utc ? "getUTC" : "get",
                d = date[_ + "Date"](),
                D = date[_ + "Day"](),
                m = date[_ + "Month"](),
                y = date[_ + "FullYear"](),
                H = date[_ + "Hours"](),
                M = date[_ + "Minutes"](),
                s = date[_ + "Seconds"](),
                L = date[_ + "Milliseconds"](),
                o = utc ? 0 : date.getTimezoneOffset(),
                flags = {
                d: d,
                dd: pad(d),
                ddd: dF.i18n.dayNames[D],
                dddd: dF.i18n.dayNames[D + 7],
                m: m + 1,
                mm: pad(m + 1),
                mmm: dF.i18n.monthNames[m],
                mmmm: dF.i18n.monthNames[m + 12],
                yy: String(y).slice(2),
                yyyy: y,
                h: H % 12 || 12,
                hh: pad(H % 12 || 12),
                H: H,
                HH: pad(H),
                M: M,
                MM: pad(M),
                s: s,
                ss: pad(s),
                l: pad(L, 3),
                L: pad(L > 99 ? Math.round(L / 10) : L),
                t: H < 12 ? "a" : "p",
                tt: H < 12 ? "am" : "pm",
                T: H < 12 ? "A" : "P",
                TT: H < 12 ? "AM" : "PM",
                Z: utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, ""),
                o: (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
                S: ["th", "st", "nd", "rd"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]
            };

            return mask.replace(token, function ($0) {
                return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1);
            });
        };
    }();

    // Some common format strings
    dateFormat.masks = {
        "default": "ddd mmm dd yyyy HH:MM:ss",
        shortDate: "m/d/yy",
        mediumDate: "mmm d, yyyy",
        longDate: "mmmm d, yyyy",
        fullDate: "dddd, mmmm d, yyyy",
        shortTime: "h:MM TT",
        mediumTime: "h:MM:ss TT",
        longTime: "h:MM:ss TT Z",
        isoDate: "yyyy-mm-dd",
        isoTime: "HH:MM:ss",
        isoDateTime: "yyyy-mm-dd'T'HH:MM:ss",
        isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
    };

    // Internationalization strings
    dateFormat.i18n = {
        dayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        monthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
    };

    return dateFormat;
}(); // end of setupDateFormat


function format$1(date, mask, utc) {
    // Custom date / time stringifier. Provides default masks:
    //
    // Mask           | Pattern
    // ---------------|--------------------------------
    // default        | `"ddd mmm dd yyyy HH:MM:ss"`
    // shortDate      | `"m/d/yy"`
    // mediumDate     | `"mmm d, yyyy"`
    // longDate       | `"mmmm d, yyyy"`
    // fullDate       | `"dddd, mmmm d, yyyy"`
    // shortTime      | `"h:MM TT"`
    // mediumTime     | `"h:MM:ss TT"`
    // longTime       | `"h:MM:ss TT Z"`
    // isoDate        | `"yyyy-mm-dd"`
    // isoTime        | `"HH:MM:ss"`
    // isoDateTime    | `"yyyy-mm-dd'T'HH:MM:ss"`
    // isoUtcDateTime | `"UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"`
    //
    // and internationalized strings via `date.format.i18n.dayNames`
    // and `date.format.i18n.dayNames`
    // Examples:
    //   date.format(new Date(), date.format.masks.longTime) // => "7:13:31 PM PDT"
    //   date.format(new Date(), "yyyy/mm/dd") // => "2014/10/09"
    return dateFormat(date, mask, utc);
}

function equals$3(date, otherDate) {
    // show-in-doc
    return otherDate && otherDate instanceof Date && otherDate.getTime() === date.getTime();
}

function relativeTo(date, otherDate) {
    // Prints a human readable difference of two Date objects. The older date
    // goes first.
    // Examples:
    //   var now = new Date();
    //   date.relativeTo(new Date(now-2000), now) // => "2 secs"
    //   date.relativeTo(new Date("10/11/2014"), new Date("10/12/2014")) // => "1 day"
    if (!(otherDate instanceof Date)) return '';
    if (otherDate < date) return '';
    if (otherDate === date) return 'now';
    var minuteString = 'min',
        secondString = 'sec',
        hourString = 'hour',
        dayString = 'day',
        diff = otherDate - date,
        totalSecs = Math.round(diff / 1000),
        secs = totalSecs % 60,
        mins = Math.floor(totalSecs / 60) % 60,
        hours = Math.floor(totalSecs / 60 / 60) % 24,
        days = Math.floor(totalSecs / 60 / 60 / 24),
        parts = [];
    if (days > 0) {
        parts.push(days);
        if (days > 1) dayString += 's';
        parts.push(dayString);
    }
    if (hours > 0 && days < 2) {
        parts.push(hours);
        if (hours > 1) hourString += 's';
        parts.push(hourString);
    }
    if (mins > 0 && hours < 3 && days === 0) {
        parts.push(mins);
        if (mins > 1) minuteString += 's';
        parts.push(minuteString);
    }
    if (secs > 0 && mins < 3 && hours === 0 && days === 0) {
        parts.push(secs);
        if (secs > 1) secondString += 's';
        parts.push(secondString);
    }
    return parts.join(' ');
}



var date = Object.freeze({
	format: format$1,
	equals: equals$3,
	relativeTo: relativeTo
});

/*global require, process, Promise*/

/*
 * Methods helping with promises (Promise/A+ model). Not a promise shim.
 */

function promise(obj) {
  // Promise object / function converter
  // Example:
  // promise("foo");
  //   // => Promise({state: "fullfilled", value: "foo"})
  // lively.lang.promise({then: (resolve, reject) => resolve(23)})
  //   // => Promise({state: "fullfilled", value: 23})
  // lively.lang.promise(function(val, thenDo) { thenDo(null, val + 1) })(3)
  //   // => Promise({state: "fullfilled", value: 4})
  return typeof obj === "function" ? promise.convertCallbackFun(obj) : Promise.resolve(obj);
}

function delay$1(ms, resolveVal) {
  // Like `Promise.resolve(resolveVal)` but waits for `ms` milliseconds
  // before resolving
  return new Promise(function (resolve) {
    return setTimeout(resolve, ms, resolveVal);
  });
}

function delayReject(ms, rejectVal) {
  // like `promise.delay` but rejects
  return new Promise(function (_, reject) {
    return setTimeout(reject, ms, rejectVal);
  });
}

function timeout(ms, promise) {
  // Takes a promise and either resolves to the value of the original promise
  // when it succeeds before `ms` milliseconds passed or fails with a timeout
  // error
  return new Promise(function (resolve, reject) {
    var done = false;
    setTimeout(function () {
      return !done && (done = true) && reject(new Error('Promise timed out'));
    }, ms);
    promise.then(function (val) {
      return !done && (done = true) && resolve(val);
    }, function (err) {
      return !done && (done = true) && reject(err);
    });
  });
}

function waitFor$1(ms, tester) {
  // Tests for a condition calling function `tester` until the result is
  // truthy. Resolves with last return value of `tester`. If `ms` is defined
  // and `ms` milliseconds passed, reject with timeout error

  return new Promise(function (resolve, reject) {
    if (typeof ms === "function") {
      tester = ms;ms = undefined;
    }
    var stopped = false,
        error = null,
        value = undefined,
        i = setInterval(function () {
      if (stopped) {
        clearInterval(i);return;
      }
      try {
        value = tester();
      } catch (e) {
        error = e;
      }
      if (value || error) {
        stopped = true;
        clearInterval(i);
        error ? reject(error) : resolve(value);
      }
    }, 10);
    if (typeof ms === "number") {
      setTimeout(function () {
        error = new Error('timeout');
      }, ms);
    }
  });
}

function deferred() {
  // returns an object
  // `{resolve: FUNCTION, reject: FUNCTION, promise: PROMISE}`
  // that separates the resolve/reject handling from the promise itself
  // Similar to the deprecated `Promise.defer()`
  var resolve,
      reject,
      promise = new Promise(function (_resolve, _reject) {
    resolve = _resolve;reject = _reject;
  });
  return { resolve: resolve, reject: reject, promise: promise };
}

function convertCallbackFun(func) {
  // Takes a function that accepts a nodejs-style callback function as a last
  // parameter and converts it to a function *not* taking the callback but
  // producing a promise instead. The promise will be resolved with the
  // *first* non-error argument.
  // nodejs callback convention: a function that takes as first parameter an
  // error arg and second+ parameters are the result(s).
  // Example:
  // var fs = require("fs"),
  //     readFile = promise.convertCallbackFun(fs.readFile);
  // readFile("./some-file.txt")
  //   .then(content => console.log(String(content)))
  //   .catch(err => console.error("Could not read file!", err));
  return function promiseGenerator() /*args*/{
    var args = Array.from(arguments),
        self = this;
    return new Promise(function (resolve, reject) {
      args.push(function (err, result) {
        return err ? reject(err) : resolve(result);
      });
      func.apply(self, args);
    });
  };
}

function convertCallbackFunWithManyArgs(func) {
  // like convertCallbackFun but the promise will be resolved with the
  // all non-error arguments wrapped in an array.
  return function promiseGenerator() /*args*/{
    var args = Array.from(arguments),
        self = this;
    return new Promise(function (resolve, reject) {
      args.push(function () /*err + args*/{
        var args = Array.from(arguments),
            err = args.shift();
        return err ? reject(err) : resolve(args);
      });
      func.apply(self, args);
    });
  };
}

function _chainResolveNext(promiseFuncs, prevResult, akku, resolve, reject) {
  var next = promiseFuncs.shift();
  if (!next) resolve(prevResult);else {
    try {
      Promise.resolve(next(prevResult, akku)).then(function (result) {
        return _chainResolveNext(promiseFuncs, result, akku, resolve, reject);
      }).catch(function (err) {
        reject(err);
      });
    } catch (err) {
      reject(err);
    }
  }
}

function chain$1(promiseFuncs) {
  // Similar to Promise.all but takes a list of promise-producing functions
  // (instead of Promises directly) that are run sequentially. Each function
  // gets the result of the previous promise and a shared "state" object passed
  // in. The function should return either a value or a promise. The result of
  // the entire chain call is a promise itself that either resolves to the last
  // returned value or rejects with an error that appeared somewhere in the
  // promise chain. In case of an error the chain stops at that point.
  // Example:
  // lively.lang.promise.chain([
  //   () => Promise.resolve(23),
  //   (prevVal, state) => { state.first = prevVal; return prevVal + 2 },
  //   (prevVal, state) => { state.second = prevVal; return state }
  // ]).then(result => console.log(result));
  // // => prints {first: 23,second: 25}
  return new Promise(function (resolve, reject) {
    return _chainResolveNext(promiseFuncs.slice(), undefined, {}, resolve, reject);
  });
}

function promise_finally(promise, finallyFn) {
  return Promise.resolve(promise).then(function (result) {
    try {
      finallyFn();
    } catch (err) {
      console.error("Error in promise finally: " + err.stack || err);
    }return result;
  }).catch(function (err) {
    try {
      finallyFn();
    } catch (err) {
      console.error("Error in promise finally: " + err.stack || err);
    }throw err;
  });
}

// FIXME!
Object.assign(promise, {
  delay: delay$1,
  delayReject: delayReject,
  timeout: timeout,
  waitFor: waitFor$1,
  deferred: deferred,
  convertCallbackFun: convertCallbackFun,
  convertCallbackFunWithManyArgs: convertCallbackFunWithManyArgs,
  chain: chain$1,
  "finally": promise_finally
});

// -=-=-=-=-=-=-=-=-=-=-=-=-=-
// js object path accessor
// -=-=-=-=-=-=-=-=-=-=-=-=-=-

// show-in-doc
// A `Path` is an objectified chain of property names (kind of a "complex"
// getter and setter). Path objects can make access and writes into deeply nested
// structures more convenient. `Path` provide "safe" get and set operations and
// can be used for debugging by providing a hook that allows users to find out
// when get/set operations happen.

function Path(p, splitter) {
  if (p instanceof Path) return p;
  if (!(this instanceof Path)) return new Path(p, splitter);
  this.setSplitter(splitter || '.');
  this.fromPath(p);
}

Object.assign(Path.prototype, {

  get isPathAccessor() {
    return true;
  },

  fromPath: function fromPath(path) {
    // ignore-in-doc
    if (typeof path === "string" && path !== '' && path !== this.splitter) {
      this._parts = path.split(this.splitter);
      this._path = path;
    } else if (Array.isArray(path)) {
      this._parts = [].concat(path);
      this._path = path.join(this.splitter);
    } else {
      this._parts = [];
      this._path = '';
    }
    return this;
  },
  setSplitter: function setSplitter(splitter) {
    // ignore-in-doc
    if (splitter) this.splitter = splitter;
    return this;
  },
  parts: function parts() {
    /*key names as array*/return this._parts;
  },
  size: function size() {
    /*show-in-doc*/return this._parts.length;
  },
  slice: function slice(n, m) {
    /*show-in-doc*/return Path(this.parts().slice(n, m));
  },
  normalizePath: function normalizePath() {
    // ignore-in-doc
    // FIXME: define normalization
    return this._path;
  },
  isRoot: function isRoot(obj) {
    return this._parts.length === 0;
  },
  isIn: function isIn(obj) {
    // Does the Path resolve to a value when applied to `obj`?
    if (this.isRoot()) return true;
    var parent = this.get(obj, -1);
    return parent && parent.hasOwnProperty(this._parts[this._parts.length - 1]);
  },
  equals: function equals(obj) {
    // Example:
    // var p1 = Path("foo.1.bar.baz"), p2 = Path(["foo", 1, "bar", "baz"]);
    // // Path's can be both created via strings or pre-parsed with keys in a list.
    // p1.equals(p2) // => true
    return obj && obj.isPathAccessor && this.parts().equals(obj.parts());
  },
  isParentPathOf: function isParentPathOf(otherPath) {
    // Example:
    // var p1 = Path("foo.1.bar.baz"), p2 = Path("foo.1.bar");
    // p2.isParentPathOf(p1) // => true
    // p1.isParentPathOf(p2) // => false
    otherPath = otherPath && otherPath.isPathAccessor ? otherPath : Path(otherPath);
    var parts = this.parts(),
        otherParts = otherPath.parts();
    for (var i = 0; i < parts.length; i++) {
      if (parts[i] != otherParts[i]) return false;
    }
    return true;
  },
  relativePathTo: function relativePathTo(otherPath) {
    // Example:
    // var p1 = Path("foo.1.bar.baz"), p2 = Path("foo.1");
    // p2.relativePathTo(p1) // => Path(["bar","baz"])
    // p1.relativePathTo(p2) // => undefined
    otherPath = Path(otherPath);
    return this.isParentPathOf(otherPath) ? otherPath.slice(this.size(), otherPath.size()) : undefined;
  },
  del: function del(obj) {
    if (this.isRoot()) return false;
    var parent = obj;
    for (var i = 0; i < this._parts.length - 1; i++) {
      var part = this._parts[i];
      if (parent.hasOwnProperty(part)) {
        parent = parent[part];
      } else return false;
    }
    return delete parent[this._parts[this._parts.length - 1]];
  },
  withParentAndKeyDo: function withParentAndKeyDo(obj, ensure, doFunc) {
    // Deeply resolve path in `obj`, not fully, however, only to the parent
    // element of the last part of path. Take the parent, the key (the last
    // part of path) and pass it to `doFunc`. When `ensure` is true, create
    // objects along path it path does not resolve
    if (this.isRoot()) return doFunc(null, null);
    var parent = obj;
    for (var i = 0; i < this._parts.length - 1; i++) {
      var part = this._parts[i];
      if (parent.hasOwnProperty(part) && (_typeof(parent[part]) === "object" || typeof parent[part] === "function")) {
        parent = parent[part];
      } else if (ensure) {
        parent = parent[part] = {};
      } else {
        return doFunc(null, part);
      }
    }
    return doFunc(parent, this._parts[this._parts.length - 1]);
  },
  set: function set(obj, val, ensure) {
    // Deeply resolve path in `obj` and set the resulting property to `val`. If
    // `ensure` is true, create nested structure in between as necessary.
    // Example:
    // var o1 = {foo: {bar: {baz: 42}}};
    // var path = Path("foo.bar.baz");
    // path.set(o1, 43)
    // o1 // => {foo: {bar: {baz: 43}}}
    // var o2 = {foo: {}};
    // path.set(o2, 43, true)
    // o2 // => {foo: {bar: {baz: 43}}}
    return this.withParentAndKeyDo(obj, ensure, function (parent, key) {
      return parent ? parent[key] = val : undefined;
    });
  },
  defineProperty: function defineProperty(obj, propertySpec, ensure) {
    // like `Path>>set`, however uses Objeect.defineProperty
    return this.withParentAndKeyDo(obj, ensure, function (parent, key) {
      return parent ? Object.defineProperty(parent, key, propertySpec) : undefined;
    });
  },
  get: function get(obj, n) {
    // show-in-doc
    var parts = n ? this._parts.slice(0, n) : this._parts;
    return parts.reduce(function (current, pathPart) {
      return current ? current[pathPart] : current;
    }, obj);
  },
  concat: function concat(p, splitter) {
    // show-in-doc
    return Path(this.parts().concat(Path(p, splitter).parts()));
  },
  toString: function toString() {
    return this.normalizePath();
  },
  serializeExpr: function serializeExpr() {
    // ignore-in-doc
    return 'lively.lang.Path(' + inspect(this.parts()) + ')';
  },
  watch: function watch(options) {
    // React or be notified on reads or writes to a path in a `target`. Options:
    // ```js
    // {
    //   target: OBJECT,
    //   uninstall: BOOLEAN,
    //   onGet: FUNCTION,
    //   onSet: FUNCTION,
    //   haltWhenChanged: BOOLEAN,
    //   verbose: BOOLEAN
    // }
    // ```
    // Example:
    // // Quite useful for debugging to find out what call-sites change an object.
    // var o = {foo: {bar: 23}};
    // Path("foo.bar").watch({target: o, verbose: true});
    // o.foo.bar = 24; // => You should see: "[object Object].bar changed: 23 -> 24"
    if (!options || this.isRoot()) return;
    var target = options.target,
        parent = this.get(target, -1),
        propName = this.parts().slice(-1)[0],
        newPropName = 'propertyWatcher$' + propName,
        watcherIsInstalled = parent && parent.hasOwnProperty(newPropName),
        uninstall = options.uninstall,
        haltWhenChanged = options.haltWhenChanged,
        showStack = options.showStack,
        getter = parent.__lookupGetter__(propName),
        setter = parent.__lookupSetter__(propName);
    if (!target || !propName || !parent) return;
    if (uninstall) {
      if (!watcherIsInstalled) return;
      delete parent[propName];
      parent[propName] = parent[newPropName];
      delete parent[newPropName];
      var msg = 'Watcher for ' + parent + '.' + propName + ' uninstalled';
      show(msg);
      return;
    }
    if (watcherIsInstalled) {
      var msg = 'Watcher for ' + parent + '.' + propName + ' already installed';
      show(msg);
      return;
    }
    if (getter || setter) {
      var msg = parent + '["' + propName + '"] is a getter/setter, watching not support';
      console.log(msg);
      if (typeof show === "undefined") show(msg);
      return;
    }
    // observe slots, for debugging
    parent[newPropName] = parent[propName];
    parent.__defineSetter__(propName, function (v) {
      var oldValue = parent[newPropName];
      if (options.onSet) options.onSet(v, oldValue);
      var msg = parent + "." + propName + " changed: " + oldValue + " -> " + v;
      if (showStack) msg += '\n' + (typeof lively !== "undefined" ? lively.printStack() : console.trace());
      if (options.verbose) {
        console.log(msg);
        if (typeof show !== 'undefined') show(msg);
      }
      if (haltWhenChanged) debugger;
      return parent[newPropName] = v;
    });
    parent.__defineGetter__(propName, function () {
      if (options.onGet) options.onGet(parent[newPropName]);
      return parent[newPropName];
    });
    var msg = 'Watcher for ' + parent + '.' + propName + ' installed';
    console.log(msg);
    if (typeof show !== 'undefined') show(msg);
  },
  debugFunctionWrapper: function debugFunctionWrapper(options) {
    // ignore-in-doc
    // options = {target, [haltWhenChanged, showStack, verbose, uninstall]}
    var target = options.target,
        parent = this.get(target, -1),
        funcName = this.parts().slice(-1)[0],
        uninstall = options.uninstall,
        haltWhenChanged = options.haltWhenChanged === undefined ? true : options.haltWhenChanged,
        showStack = options.showStack,
        func = parent && funcName && parent[funcName],
        debuggerInstalled = func && func.isDebugFunctionWrapper;
    if (!target || !funcName || !func || !parent) return;
    if (uninstall) {
      if (!debuggerInstalled) return;
      parent[funcName] = parent[funcName].debugTargetFunction;
      var msg = 'Uninstalled debugFunctionWrapper for ' + parent + '.' + funcName;
      console.log(msg);
      if (typeof show !== 'undefined') show(msg);
      show(msg);
      return;
    }
    if (debuggerInstalled) {
      var msg = 'debugFunctionWrapper for ' + parent + '.' + funcName + ' already installed';
      console.log(msg);
      if (typeof show !== 'undefined') show(msg);
      return;
    }
    var debugFunc = parent[funcName] = func.wrap(function (proceed) {
      var args = Array.from(arguments);
      if (haltWhenChanged) debugger;
      if (showStack) show(lively.printStack());
      if (options.verbose) show(funcName + ' called');
      return args.shift().apply(parent, args);
    });
    debugFunc.isDebugFunctionWrapper = true;
    debugFunc.debugTargetFunction = func;
    var msg = 'debugFunctionWrapper for ' + parent + '.' + funcName + ' installed';
    console.log(msg);
    if (typeof show !== 'undefined') show(msg);
  }
});

/*
Computation over graphs. Unless otherwise specified a graph is a simple JS
object whose properties are interpreted as nodes that refer to arrays whose
elements describe edges. Example:

```js
var testGraph = {
  "a": ["b", "c"],
  "b": ["c", "d", "e", "f"],
  "d": ["c", "f"],
  "e": ["a", "f"],
  "f": []
}
```
*/

// show-in-doc
function clone$2(graph) {
  // return a copy of graph map
  var cloned = {};
  for (var id in graph) {
    cloned[id] = graph[id].slice();
  }return cloned;
}

function without$1(graph, ids) {
  // return a copy of graph map with ids removed
  var cloned = {};
  for (var id in graph) {
    if (ids.indexOf(id) > -1) continue;
    cloned[id] = graph[id].filter(function (id) {
      return ids.indexOf(id) === -1;
    });
  }
  return cloned;
}

function hull(graphMap, id, ignore, maxDepth) {
  // Takes a graph in object format and a start id and then traverses the
  // graph and gathers all nodes that can be reached from that start id.
  // Returns a list of those nodes.
  // Optionally use `ignore` list to filter out certain nodes that shouldn't
  // be considered and maxDepth to stop early. By default a maxDepth of 20 is
  // used.
  // Example:
  // var testGraph = {
  // "a": ["b", "c"],
  // "b": ["c", "d", "e", "f"],
  // "d": ["c", "f"],
  // "e": ["a", "f"],
  // "f": []
  // }
  // hull(testGraph, "d") // => ["c", "f"]
  // hull(testGraph, "e") // => ['a', 'f', 'b', 'c', 'd', 'e']
  // hull(testGraph, "e", ["b"]) // =? ["a", "f", "c"]
  return uniq(flatten(values(subgraphReachableBy(graphMap, id, ignore, maxDepth))));
}

function subgraphReachableBy(graphMap, id, ignore, maxDepth) {
  // show-in-doc
  // Like hull but returns subgraph map of `graphMap`
  // Example:
  // subgraphReachableBy(testGraph, "e", [], 2);
  // // => {e: [ 'a', 'f' ], a: [ 'b', 'c' ], f: []}
  maxDepth = maxDepth || 10;
  if (ignore) graphMap = without$1(graphMap, ignore);
  var ids = [id],
      step = 0,
      subgraph = {};
  while (ids.length && step++ < maxDepth) {
    ids = ids.reduce(function (ids, id) {
      return subgraph[id] ? ids : ids.concat(subgraph[id] = graphMap[id] || []);
    }, []);
  }
  return subgraph;
}

function invert(g) {
  // inverts the references of graph object `g`.
  // Example:
  // invert({a: ["b"], b: ["a", "c"]})
  //   // => {a: ["b"], b: ["a"], c: ["b"]}
  return Object.keys(g).reduce(function (inverted, k) {
    g[k].forEach(function (k2) {
      if (!inverted[k2]) inverted[k2] = [k];else inverted[k2].push(k);
    });
    return inverted;
  }, {});
}

function sortByReference(depGraph, startNode) {
  // Sorts graph into an array of arrays. Each "bucket" contains the graph
  // nodes that have no other incoming nodes than those already visited. This
  // means, we start with the leaf nodes and then walk our way up.
  // This is useful for computing how to traverse a dependency graph: You get
  // a sorted list of dependencies that also allows circular references.
  // Example:
  // var depGraph = {a: ["b", "c"], b: ["c"], c: ["b"]};
  // sortByReference(depGraph, "a");
  // // => [["c"], ["b"], ["a"]]

  var all$$1 = [startNode].concat(hull(depGraph, startNode)),
      seen = [],
      groups = [];

  while (seen.length !== all$$1.length) {
    var depsRemaining = withoutAll(all$$1, seen).reduce(function (depsRemaining, node) {
      depsRemaining[node] = withoutAll(depGraph[node] || [], seen).length;
      return depsRemaining;
    }, {}),
        min$$1 = withoutAll(all$$1, seen).reduce(function (minNode, node) {
      return depsRemaining[node] <= depsRemaining[minNode] ? node : minNode;
    });

    if (depsRemaining[min$$1] === 0) {
      groups.push(Object.keys(depsRemaining).filter(function (key) {
        return depsRemaining[key] === 0;
      }));
    } else {
      groups.push([min$$1]);
    }

    seen = flatten(groups);
  }

  return groups;
}

function reduce$1(doFunc, graph, rootNode, carryOver, ignore, context) {
  // Starts with `rootNode` and visits all (in)directly related nodes, calling
  // `doFunc` at each node. The result of `doFunc` is passed as first
  // argument to the next iterator call. For the first call the value
  // `carryOver` is used.
  // Example:
  // var depGraph = {a: ["b", "c"],b: ["c"]}
  // graphReduce((_, ea, i) => console.log("%s %s", ea, i), depGraph, "a")

  var visitedNodes = ignore || [],
      index = 0;
  iterator(rootNode);
  return carryOver;

  function iterator(currentNode) {
    if (visitedNodes.indexOf(currentNode) > -1) return;
    carryOver = doFunc.call(context, carryOver, currentNode, index++);
    visitedNodes = visitedNodes.concat([currentNode]);
    var next = withoutAll(graph[currentNode] || [], visitedNodes);
    next.forEach(function (ea) {
      return iterator(ea);
    });
  }
}



var graph = Object.freeze({
	clone: clone$2,
	without: without$1,
	hull: hull,
	subgraphReachableBy: subgraphReachableBy,
	invert: invert,
	sortByReference: sortByReference,
	reduce: reduce$1
});

/*global System, global*/

// show-in-doc
// Intervals are arrays whose first two elements are numbers and the
// first element should be less or equal the second element, see
// [`interval.isInterval`](). This abstraction is useful when working with text
// ranges in rich text, for example.

var GLOBAL$2 = typeof System !== "undefined" ? System.global : typeof window !== 'undefined' ? window : global;

function isInterval(object) {
  // Example:
  // interval.isInterval([1,12]) // => true
  // interval.isInterval([1,12, {property: 23}]) // => true
  // interval.isInterval([1]) // => false
  // interval.isInterval([12, 1]) // => false
  return Array.isArray(object) && object.length >= 2 && object[0] <= object[1];
}

function sort$2(intervals) {
  // Sorts intervals according to rules defined in [`interval.compare`]().
  return intervals.sort(compare);
}

function compare(a, b) {
  // How [`interval.sort`]() compares.
  // We assume that `a[0] <= a[1] and b[0] <= b[1]` according to `isInterval`
  // ```
  // -3: a < b and non-overlapping, e.g [1,2] and [3,4]
  // -2: a < b and intervals border at each other, e.g [1,3] and [3,4]
  // -1: a < b and overlapping, e.g, [1,3] and [2,4] or [1,3] and [1,4]
  //  0: a = b, e.g. [1,2] and [1,2]
  //  1: a > b and overlapping, e.g. [2,4] and [1,3]
  //  2: a > b and share border, e.g [1,4] and [0,1]
  //  3: a > b and non-overlapping, e.g [2,4] and [0,1]
  // ```
  if (a[0] < b[0]) {
    // -3 || -2 || -1
    if (a[1] < b[0]) return -3;
    if (a[1] === b[0]) return -2;
    return -1;
  }
  if (a[0] === b[0]) {
    // -1 || 0 || 1
    if (a[1] === b[1]) return 0;
    return a[1] < b[1] ? -1 : 1;
  }
  // we know a[0] > b[0], 1 || 2 || 3
  return -1 * compare(b, a);
}

function coalesce(interval1, interval2, optMergeCallback) {
  // Turns two interval into one iff compare(interval1, interval2) ∈ [-2,
  // -1,0,1, 2] (see [`inerval.compare`]()).
  // Otherwise returns null. Optionally uses merge function.
  // Examples:
  //   interval.coalesce([1,4], [5,7]) // => null
  //   interval.coalesce([1,2], [1,2]) // => [1,2]
  //   interval.coalesce([1,4], [3,6]) // => [1,6]
  //   interval.coalesce([3,6], [4,5]) // => [3,6]
  var cmpResult = this.compare(interval1, interval2);
  switch (cmpResult) {
    case -3:
    case 3:
      return null;
    case 0:
      optMergeCallback && optMergeCallback(interval1, interval2, interval1);
      return interval1;
    case 2:
    case 1:
      var temp = interval1;interval1 = interval2;interval2 = temp; // swap
    case -2:
    case -1:
      var coalesced = [interval1[0], Math.max(interval1[1], interval2[1])];
      optMergeCallback && optMergeCallback(interval1, interval2, coalesced);
      return coalesced;
    default:
      throw new Error("Interval compare failed");
  }
}

function coalesceOverlapping(intervals, mergeFunc) {
  // Like `coalesce` but accepts an array of intervals.
  // Example:
  //   interval.coalesceOverlapping([[9,10], [1,8], [3, 7], [15, 20], [14, 21]])
  //   // => [[1,8],[9,10],[14,21]]
  var condensed = [],
      len = intervals.length;
  while (len > 0) {
    var ival = intervals.shift();len--;
    for (var i = 0; i < len; i++) {
      var otherInterval = intervals[i],
          coalesced = coalesce(ival, otherInterval, mergeFunc);
      if (coalesced) {
        ival = coalesced;
        intervals.splice(i, 1);
        len--;i--;
      }
    }
    condensed.push(ival);
  }
  return this.sort(condensed);
}

function mergeOverlapping(intervalsA, intervalsB, mergeFunc) {
  var result = [];
  while (intervalsA.length > 0) {
    var intervalA = intervalsA.shift();

    var toMerge = intervalsB.map(function (intervalB) {
      var cmp = compare(intervalA, intervalB);
      return cmp === -1 || cmp === 0 || cmp === 1;
    });

    result.push(mergeFunc(intervalA, toMerge[0]));

    result.push(intervalA);
  }
  return result;
}

function intervalsInRangeDo(start, end, intervals, iterator, mergeFunc, context) {
  // Merges and iterates through sorted intervals. Will "fill up"
  // intervals. This is currently used for computing text chunks in
  // lively.morphic.TextCore.
  // Example:
  // interval.intervalsInRangeDo(
  //   2, 10, [[0, 1], [5,8], [2,4]],
  //   function(i, isNew) { i.push(isNew); return i; })
  // // => [[2,4,false],[4,5,true],[5,8,false],[8,10,true]]

  context = context || GLOBAL$2;
  // need to be sorted for the algorithm below
  intervals = this.sort(intervals);
  var free = [],
      nextInterval,
      collected = [];
  // merged intervals are already sorted, simply "negate" the interval array;
  while (nextInterval = intervals.shift()) {
    if (nextInterval[1] < start) continue;
    if (nextInterval[0] < start) {
      nextInterval = Array.prototype.slice.call(nextInterval);
      nextInterval[0] = start;
    }
    var nextStart = end < nextInterval[0] ? end : nextInterval[0];
    if (start < nextStart) {
      collected.push(iterator.call(context, [start, nextStart], true));
    }
    if (end < nextInterval[1]) {
      nextInterval = Array.prototype.slice.call(nextInterval);
      nextInterval[1] = end;
    }
    // special case, the newly constructed interval has length 0,
    // happens when intervals contains doubles at the start
    if (nextInterval[0] === nextInterval[1]) {
      var prevInterval;
      if (mergeFunc && (prevInterval = collected.slice(-1)[0])) {
        // arguments: a, b, merged, like in the callback of #merge
        mergeFunc.call(context, prevInterval, nextInterval, prevInterval);
      }
    } else {
      collected.push(iterator.call(context, nextInterval, false));
    }
    start = nextInterval[1];
    if (start >= end) break;
  }
  if (start < end) collected.push(iterator.call(context, [start, end], true));
  return collected;
}

function intervalsInbetween(start, end, intervals) {
  // Computes "free" intervals between the intervals given in range start - end
  // currently used for computing text chunks in lively.morphic.TextCore
  // Example:
  // interval.intervalsInbetween(0, 10,[[1,4], [5,8]])
  // // => [[0,1],[4,5],[8,10]]
  return intervalsInRangeDo(start, end, coalesceOverlapping(Array.prototype.slice.call(intervals)), function (interval, isNew) {
    return isNew ? interval : null;
  }).filter(Boolean);
}

function mapToMatchingIndexes(intervals, intervalsToFind) {
  // Returns an array of indexes of the items in intervals that match
  // items in `intervalsToFind`.
  // Note: We expect intervals and intervals to be sorted according to [`interval.compare`]()!
  // This is the optimized version of:
  // ```
  // return intervalsToFind.collect(function findOne(toFind) {
  //    var startIdx, endIdx;
  //    var start = intervals.detect(function(ea, i) {
  //       startIdx = i; return ea[0] === toFind[0]; });
  //    if (start === undefined) return [];
  //    var end = intervals.detect(function(ea, i) {
  //       endIdx = i; return ea[1] === toFind[1]; });
  //    if (end === undefined) return [];
  //    return Array.range(startIdx, endIdx);
  // });
  // ```

  var startIntervalIndex = 0,
      endIntervalIndex,
      currentInterval;
  return intervalsToFind.map(function (toFind) {
    while (currentInterval = intervals[startIntervalIndex]) {
      if (currentInterval[0] < toFind[0]) {
        startIntervalIndex++;continue;
      }
      break;
    }
    if (currentInterval && currentInterval[0] === toFind[0]) {
      endIntervalIndex = startIntervalIndex;
      while (currentInterval = intervals[endIntervalIndex]) {
        if (currentInterval[1] < toFind[1]) {
          endIntervalIndex++;continue;
        }
        break;
      }
      if (currentInterval && currentInterval[1] === toFind[1]) {
        return range(startIntervalIndex, endIntervalIndex);
      }
    }
    return [];
  });
}



var interval = Object.freeze({
	isInterval: isInterval,
	sort: sort$2,
	compare: compare,
	coalesce: coalesce,
	coalesceOverlapping: coalesceOverlapping,
	mergeOverlapping: mergeOverlapping,
	intervalsInRangeDo: intervalsInRangeDo,
	intervalsInbetween: intervalsInbetween,
	mapToMatchingIndexes: mapToMatchingIndexes
});

// show-in-doc
// Accessor to sub-ranges of arrays. This is used, for example, for rendering
// large lists or tables in which only a part of the items should be used for
// processing or rendering. An array projection provides convenient access and
// can apply operations to sub-ranges.

function create(array, length, optStartIndex) {
  // Example:
  // arrayProjection.create([1,2,3,4,5,6,7,8,9], 4, 1)
  // // => { array: [/*...*/], from: 1, to: 5 }
  var startIndex = optStartIndex || 0;
  if (startIndex + length > array.length) startIndex -= startIndex + length - array.length;
  return { array: array, from: startIndex, to: startIndex + length };
}

function toArray$4(projection) {
  // show-in-doc
  return projection.array.slice(projection.from, projection.to);
}

function originalToProjectedIndex(projection, index) {
  // Maps index from original Array to projection.
  // Example:
  //   var proj = arrayProjection.create([1,2,3,4,5,6,7,8,9], 4, 3);
  //   arrayProjection.originalToProjectedIndex(proj, 1) // => null
  //   arrayProjection.originalToProjectedIndex(proj, 3) // => 0
  //   arrayProjection.originalToProjectedIndex(proj, 5) // => 2
  return index < projection.from || index >= projection.to ? null : index - projection.from;
}

function projectedToOriginalIndex(projection, index) {
  // Inverse to `originalToProjectedIndex`.
  // Example:
  //   var proj = arrayProjection.create([1,2,3,4,5,6,7,8,9], 4, 3);
  //   arrayProjection.projectedToOriginalIndex(proj, 1) // => 4
  if (index < 0 || index > projection.to - projection.from) return null;
  return projection.from + index;
}

function transformToIncludeIndex(projection, index) {
  // Computes how the projection needs to shift minimally (think "scroll"
  // down or up) so that index becomes "visible" in projection.
  // Example:
  // var proj = arrayProjection.create([1,2,3,4,5,6,7,8,9], 4, 3);
  // arrayProjection.transformToIncludeIndex(proj, 1)
  // // => { array: [/*...*/], from: 1, to: 5 }
  if (!(index in projection.array)) return null;
  var delta = 0;
  if (index < projection.from) delta = -projection.from + index;
  if (index >= projection.to) delta = index - projection.to + 1;
  if (delta === 0) return projection;
  return create(projection.array, projection.to - projection.from, projection.from + delta);
}



var arrayProjection = Object.freeze({
	create: create,
	toArray: toArray$4,
	originalToProjectedIndex: originalToProjectedIndex,
	projectedToOriginalIndex: projectedToOriginalIndex,
	transformToIncludeIndex: transformToIncludeIndex
});

// show-in-doc
// A grid is a two-dimaensional array, representing a table-like data

function get$2(grid, nRow, nCol) {
  var row = grid[nRow];
  return row ? row[nCol] : undefined;
}

function set$2(grid, nRow, nCol, obj) {
  var row = grid[nRow];
  if (row) row[nCol] = obj;
  return obj;
}

function getRow(grid, nRow) {
  return grid[nRow];
}

function setRow(grid, nRow, newRow) {
  return grid[nRow] = newRow;
}

function getCol(grid, nCol) {
  return grid.reduce(function (col, row) {
    col.push(row[nCol]);return col;
  }, []);
}

function setCol(grid, nCol, newCol) {
  return grid.map(function (row, i) {
    return row[nCol] ? row[nCol] = newCol[i] : undefined;
  });
}

function create$1(rows, columns, initialObj) {
  // Example:
  // grid.create(3, 2, "empty")
  // // => [["empty","empty"],
  // //     ["empty","empty"],
  // //     ["empty","empty"]]
  var result = new Array(rows);
  while (rows > 0) {
    result[--rows] = withN(columns, initialObj);
  }return result;
}

function mapCreate(rows, cols, func, context) {
  // like `grid.create` but takes generator function for cells
  var result = new Array(rows);
  for (var i = 0; i < rows; i++) {
    result[i] = new Array(cols);
    for (var j = 0; j < cols; j++) {
      result[i][j] = func.call(context || this, i, j);
    }
  }
  return result;
}

function forEach$2(grid, func, context) {
  // iterate, `func` is called as `func(cellValue, i, j)`
  grid.forEach(function (row, i) {
    row.forEach(function (val, j) {
      func.call(context || this, val, i, j);
    });
  });
}

function map$2(grid, func, context) {
  // map, `func` is called as `func(cellValue, i, j)`
  var result = new Array(grid.length);
  grid.forEach(function (row, i) {
    result[i] = new Array(row.length);
    row.forEach(function (val, j) {
      result[i][j] = func.call(context || this, val, i, j);
    });
  });
  return result;
}

function toObjects(grid) {
  // The first row of the grid defines the propNames
  // for each following row create a new object with those porperties
  // mapped to the cells of the row as values
  // Example:
  // grid.toObjects([['a', 'b'],[1,2],[3,4]])
  // // => [{a:1,b:2},{a:3,b:4}]
  var props = grid[0],
      objects = new Array(grid.length - 1);
  for (var i = 1; i < grid.length; i++) {
    var obj = objects[i - 1] = {};
    for (var j = 0; j < props.length; j++) {
      obj[props[j]] = grid[i][j];
    }
  }
  return objects;
}

function tableFromObjects(objects, valueForUndefined) {
  // Reverse operation to `grid.toObjects`. Useful for example to convert objectified
  // SQL result sets into tables that can be printed via Strings.printTable.
  // Objects are key/values like [{x:1,y:2},{x:3},{z:4}]. Keys are interpreted as
  // column names and objects as rows.
  // Example:
  // grid.tableFromObjects([{x:1,y:2},{x:3},{z:4}])
  // // => [["x","y","z"],
  // //    [1,2,null],
  // //    [3,null,null],
  // //    [null,null,4]]

  if (!Array.isArray(objects)) objects = [objects];
  var table = [[]],
      columns = table[0],
      rows = objects.reduce(function (rows, ea) {
    return rows.concat([Object.keys(ea).reduce(function (row, col) {
      var colIdx = columns.indexOf(col);
      if (colIdx === -1) {
        colIdx = columns.length;columns.push(col);
      }
      row[colIdx] = ea[col];
      return row;
    }, [])]);
  }, []);
  valueForUndefined = arguments.length === 1 ? null : valueForUndefined;
  rows.forEach(function (row) {
    // fill cells with no value with null
    for (var i = 0; i < columns.length; i++) {
      if (!row[i]) row[i] = valueForUndefined;
    }
  });
  return table.concat(rows);
}



var grid = Object.freeze({
	get: get$2,
	set: set$2,
	getRow: getRow,
	setRow: setRow,
	getCol: getCol,
	setCol: setCol,
	create: create$1,
	mapCreate: mapCreate,
	forEach: forEach$2,
	map: map$2,
	toObjects: toObjects,
	tableFromObjects: tableFromObjects
});

/*
 * Methods for traversing and transforming tree structures.
 */

function prewalk(treeNode, iterator, childGetter) {
  var counter = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : { i: 0 };
  var depth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

  var i = counter.i++;
  iterator(treeNode, i, depth);
  (childGetter(treeNode, i, depth) || []).forEach(function (ea) {
    return prewalk(ea, iterator, childGetter, counter, depth + 1);
  });
}

function postwalk(treeNode, iterator, childGetter) {
  var counter = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : { i: 0 };
  var depth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

  var i = counter.i++;
  (childGetter(treeNode, i, depth) || []).forEach(function (ea) {
    return postwalk(ea, iterator, childGetter);
  });
  iterator(treeNode, i, depth);
}

function find(treeNode, testFunc, childGetter) {
  // Traverses a `treeNode` recursively and returns the first node for which
  // `testFunc` returns true. `childGetter` is a function to retrieve the
  // children from a node.
  if (testFunc(treeNode)) return treeNode;
  var children = childGetter(treeNode);
  if (!children || !children.length) return undefined;
  for (var i = 0; i < children.length; i++) {
    var found = find(children[i], testFunc, childGetter);
    if (found) return found;
  }
  return undefined;
}
var detect$1 = find;

function filter$1(treeNode, testFunc, childGetter) {
  // Traverses a `treeNode` recursively and returns all nodes for which
  // `testFunc` returns true. `childGetter` is a function to retrieve the
  // children from a node.
  var result = [];
  if (testFunc(treeNode)) result.push(treeNode);
  return result.concat(flatten((childGetter(treeNode) || []).map(function (n) {
    return filter$1(n, testFunc, childGetter);
  })));
}

function map$3(treeNode, mapFunc, childGetter) {
  var depth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

  // Traverses a `treeNode` recursively and call `mapFunc` on each node. The
  // return values of all mapFunc calls is the result. `childGetter` is a
  // function to retrieve the children from a node.
  return [mapFunc(treeNode, depth)].concat(flatten((childGetter(treeNode) || []).map(function (n) {
    return map$3(n, mapFunc, childGetter, depth);
  })));
}

function mapTree(treeNode, mapFunc, childGetter) {
  var depth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

  // Traverses the tree and creates a structurally identical tree but with
  // mapped nodes
  var mappedNodes = (childGetter(treeNode) || []).map(function (n) {
    return mapTree(n, mapFunc, childGetter, depth);
  });
  return mapFunc(treeNode, mappedNodes, depth);
}



var tree = Object.freeze({
	prewalk: prewalk,
	postwalk: postwalk,
	find: find,
	detect: detect$1,
	filter: filter$1,
	map: map$3,
	mapTree: mapTree
});

/*global process, require*/

/*
 * A simple node.js-like cross-platform event emitter implementation that can
 * be used as a mixin. Emitters support the methods: `on(eventName, handlerFunc)`,
 * `once(eventName, handlerFunc)`, `emit(eventName, eventData)`,
 * `removeListener(eventName, handlerFunc)`, `removeAllListeners(eventName)`
 * Example:
 * var emitter = events.makeEmitter({});
 * var log = [];
 * emitter.on("test", function() { log.push("listener1"); });
 * emitter.once("test", function() { log.push("listener2"); });
 * emitter.emit("test");
 * emitter.emit("test");
 * log // => ["listener1","listener2","listener1"]
 * emitter.removeAllListeners("test");
 * emitter.emit("test");
 * log // => is still ["listener1","listener2","listener1"]
 */

var isNode$1 = typeof process !== 'undefined' && process.versions && process.versions.node;

var makeEmitter = isNode$1 ? function (obj, options) {
  if (obj.on && obj.removeListener) return obj;
  var events = typeof System !== "undefined" ? System._nodeRequire("events") : require("events");
  Object.assign(obj, events.EventEmitter.prototype);
  events.EventEmitter.call(obj);
  if (options && options.maxListenerLimit) obj.setMaxListeners(options.maxListenerLimit);

  return obj;
} : function (obj) {
  if (obj.on && obj.removeListener) return obj;

  obj.listeners = {};

  obj.on = function (type, handler) {
    if (!handler) return;
    if (!obj.listeners[type]) obj.listeners[type] = [];
    obj.listeners[type].push(handler);
  };

  obj.once = function (type, handler) {
    if (!handler) return;
    function onceHandler /*ignore-in-docs args*/() {
      obj.removeListener(type, onceHandler);
      handler.apply(this, arguments);
    }
    obj.on(type, onceHandler);
  };

  obj.removeListener = function (type, handler) {
    if (!obj.listeners[type]) return;
    obj.listeners[type] = obj.listeners[type].filter(function (h) {
      return h !== handler;
    });
  };

  obj.removeAllListeners = function (type) {
    if (!obj.listeners[type]) return;
    obj.listeners[type] = [];
  };

  obj.emit = function () /*type and args*/{
    var args = Array.prototype.slice.call(arguments),
        type = args.shift(),
        handlers = obj.listeners[type];
    if (!handlers || !handlers.length) return;
    handlers.forEach(function (handler) {
      try {
        handler.apply(null, args);
      } catch (e) {
        console.error("Error in event handler: %s", e.stack || String(e));
      }
    });
  };

  return obj;
};



var events = Object.freeze({
	makeEmitter: makeEmitter
});

/*global clearTimeout, setTimeout, clearInterval, setInterval*/

/*
 * A pluggable interface to provide asynchronous, actor-like message
 * communication between JavaScript systems. Provides a unified message protocol
 * and send / receive methods.
 */

var OFFLINE = 'offline';
var ONLINE = 'online';
/*

TODO: move to promises! include broadcast API

renames:
listen() => open()
id() => id

*/

/*

A messenger is an object that provides a common, message-based interface. Messengers expect you to provide an implementation of a small number of methods: `send`, `listen`, `close`, and `isOnline`. A messenger will then provide a unified interface for sending and receiving messages. Common boilerplate functionality such as queuing messages, error handling, dealing with instable connections, heartbeats, etc. is handled by the messenger object automatically (and can be parameterized).

This allows to use a single interface across a range of heterogeneous objects without having to implement every detail of the abstraction repeatedly. This is especially valuable when dealing with asynchronous or remote communication (web workers, XHR requests, WebSockets, node.js processes, ...).

To see a minimal example of how to use messengers for the local communication between JavaScript objects [see this example](#messenger-example).

A more sophisticated example of messengers is [the worker implementation](worker.js) which provides an actor-like worker interface that uses web workers in web browsers and child_process.fork in node.js.

```js
var msger = lively.lang.messenger.create({
  send: function(msg, onSendDone) { console.log(msg); onSendDone(); },
  listen: function(thenDo) { thenDo(); },
  close: function(thenDo) { thenDo(); },
  isOnline: function() { return true }
});
```

#### Messenger interface

The interface methods are build to enable an user to send and receive
messages. Each messenger provides the following methods:

##### msger.id()

Each msger has an id that can either be defined by the user when the
msger is created or is automatically assigned. The id should be unique for each
messenger in a messenger network. It is used as the `target` attribute to
address messages and internally in the messaging implementation for routing.
See the [message protocol](#messenger-message-protocol) description for more info.

##### msger.isOnline()

Can the msger send and receive messages right now?

##### msger.heartbeatEnabled()

Does the msger send automated heartbeat messages?

##### msger.listen(optionalCallback)

Brings the messenger "online": Starts listening for messages and brings it
into a state to send messages. `optionalCallback` is a function that is called
when listening begins. It should accept one argument `error` that is null if no
error occured when listening was started, an Error object otherwise.

##### msger.send(msg, onReceiveFunc)

Sends a message. The message should be structured according to the [message
protocol](#messenger-message-protocol). `onReceiveFunc` is triggered when the `msg` is being
answered. `onReceiveFunc` should take two arguments: `error` and `answer`.
`answer` is itself a message object.

##### msger.sendTo(target, action, data, onReceiveFunc)

A simpler `send`, the `msg` object is automatically assembled. `target`
should be an id of the receiver and `action` a string naming the service that
should be triggered on the receiver.

##### msger.answer(msg, data, expectMore, whenSend)

Assembles an answer message for `msg` that includes `data`. `expectMore`
should be truthy when multiple answers should be send (a streaming response,
see the [messaging protocol](#messenger-message-protocol)).

##### msger.close(thenDo)

Stops listening.

##### msger.whenOnline(thenDo)

Registers a callback that is triggered as soon as a listen attempt succeeds
(or when the messenger is listening already then it succeeds immediately).

##### msger.outgoingMessages()

Returns the messages that are currently inflight or not yet send.

##### msger.addServices(serviceSpec)

Add services to the messenger. `serviceSpec` should be  JS object whose keys
correspond to message actions:

```js
msg.addServices({
  helloWorld: function(msg, messenger) {
    messenger.answer(msg, "received a message!");
  }
});
```

See the examples below for more information.

##### *[event]* msger.on("message")

To allow users to receive messages that were not initiated by a send,
messengers are [event emitters](events.js) that emit `"message"` events
whenever they receive a new message.

The messenger object is used to create new messenger interfaces and ties
them to a specific implementation. Please see [worker.js]() for examples of
how web workers and node.js processes are wrapped to provide a cross-platform
interface to a worker abstraction.


#### <a name="messenger-message-protocol"></a>Message protocol

A message is a JSON object with the following fields:

```js
var messageSchema = {

    // REQUIRED selector for service lookup. By convention action gets
    // postfixed with "Result" for response messages
    action: STRING,

    // REQUIRED target of the message, the id of the receiver
    target: UUID,

    // OPTIONAL arguments
    data: OBJECT,

    // OPTIONAL identifier of the message, will be provided if not set by user
    messageId: UUID,

    // OPTIONAL sender of the message, will be provided if not set by user
    sender: UUID,

    // OPTIONAL identifier of a message that this message answers, will be provided
    inResponseTo: UUID,

    // OPTIONAL if message is an answer. Can be interpreted by the receiver as
    // a streaming response. Lively participants (tracker and clients) will
    // trigger data bindings and fire callbacks for a message for every streaming
    // response
    expectMoreResponses: BOOL,

    // EXPERIMENTAL UUIDs of trackers/sessions handlers that forwarded this
    // message
    route: ARRAY
}
```

The `sendTo` and `answer` methods of messengers will automatically create these
messages. If the user invokes the `send` method then a JS object according to
the schema above should be passed as the first argument.

#### <a name="messenger-example"></a>Messenger examples

The following code implements what is needed to use a messenger to communicate
between any number of local JavaScript objects. Instead of dispatching methods using
a local list of messengers you will most likely use an existing networking /
messaging mechanism.

See the [worker](#) and [its implementation](worker.js) for a real use case in
which forking processes in the browser using Web Workers and in node.js using
child_process.fork is unified.

```js
// spec that defines message sending in terms of receivers in the messengers list
var messengers = [];
var messengerSpec = {
  send: function(msg, onSendDone) {
    var err = null, recv = arr.detect(messengers, function(ea) {
          return ea.id() === msg.target; });
    if (recv) recv.onMessage(msg);
    else err = new Error("Could not find receiver " + msg.target);
    onSendDone(err);
  },
  listen: function(thenDo) { arr.pushIfNotIncluded(messengers, this); },
  close: function(thenDo) { arr.remove(messengers, this); },
  isOnline: function() { return arr.include(messengers, this); }
};

// Create the messengers and add a simple "service"
var msger1 = messenger.create(messengerSpec);
var msger2 = messenger.create(messengerSpec);
msger2.addServices({
  add: function(msg, msger) { msger.answer(msg, {result: msg.data.a + msg.data.b}); }
});

// turn'em on...
msger1.listen();
msger2.listen();

// ...and action!
msger1.sendTo(msger2.id(), 'add', {a: 3, b: 4},
  function(err, answer) { alert(answer.data.result); });
```

*/

function create$2(spec) {

  var expectedMethods = [{ name: "send", args: ['msg', 'callback'] }, { name: "listen", args: ['messenger', 'callback'] }, { name: "close", args: ['messenger', 'callback'] }, { name: "isOnline", args: [] }];

  var ignoredAttributes = expectedMethods.map(function (ea) {
    return ea.name;
  }).concat(["id", "sendHeartbeat", "heartbeatInterval", "ignoreUnknownMessages", "allowConcurrentSends", "sendTimeout", "services"]);

  expectedMethods.forEach(function (exp) {
    if (spec[exp.name]) return;
    var msg = "message implementation needs function " + exp.name + "(" + exp.args.join(',') + ")";
    throw new Error(msg);
  });

  var heartbeatInterval = spec.sendHeartbeat && (spec.heartbeatInterval || 1000);
  var ignoreUnknownMessages = spec.hasOwnProperty("ignoreUnknownMessages") ? spec.ignoreUnknownMessages : false;

  var messenger = {

    _outgoing: [],
    _inflight: [],
    _id: spec.id || newUUID(),
    _ignoreUnknownMessages: ignoreUnknownMessages,
    _services: {},
    _messageCounter: 0,
    _messageResponseCallbacks: {},
    _whenOnlineCallbacks: [],
    _statusWatcherProc: null,
    _startHeartbeatProcessProc: null,
    _listenInProgress: null,
    _heartbeatInterval: heartbeatInterval,
    _status: OFFLINE,

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    _runWhenOnlineCallbacks: function _runWhenOnlineCallbacks() {
      var cbs = messenger._whenOnlineCallbacks.slice();
      messenger._whenOnlineCallbacks = [];
      cbs.forEach(function (ea) {
        try {
          ea.call(null, null, messenger);
        } catch (e) {
          console.error("error in _runWhenOnlineCallbacks: %s", e);
        }
      });
    },

    _ensureStatusWatcher: function _ensureStatusWatcher() {
      if (messenger._statusWatcherProc) return;
      messenger._statusWatcherProc = setInterval(function () {
        if (messenger.isOnline() && messenger._whenOnlineCallbacks.length) messenger._runWhenOnlineCallbacks();
        var prevStatus = messenger._status;
        messenger._status = messenger.isOnline() ? ONLINE : OFFLINE;
        if (messenger._status !== ONLINE && messenger._statusWatcherProc) {
          messenger.reconnect();
        }
        if (messenger._status !== prevStatus && messenger.onStatusChange) {
          messenger.onStatusChange();
        }
      }, 20);
    },

    _addMissingData: function _addMissingData(msg) {
      if (!msg.target) throw new Error("Message needs target!");
      if (!msg.action) throw new Error("Message needs action!");
      if (!msg.data) msg.data = null;
      if (!msg.messageId) msg.messageId = newUUID();
      msg.sender = messenger.id();
      msg.messageIndex = messenger._messageCounter++;
      return msg;
    },

    _queueSend: function _queueSend(msg, onReceiveFunc) {
      if (onReceiveFunc && typeof onReceiveFunc !== 'function') throw new Error("Expecing a when send callback, got: " + onReceiveFunc);
      messenger._outgoing.push([msg, onReceiveFunc]);
    },

    _deliverMessageQueue: function _deliverMessageQueue() {
      if (!spec.allowConcurrentSends && messenger._inflight.length) return;

      var queued = messenger._outgoing.shift();
      if (!queued) return;

      messenger._inflight.push(queued);
      if (messenger.isOnline()) deliver(queued);else messenger.whenOnline(function () {
        deliver(queued);
      });
      startTimeoutProc(queued);

      if (spec.allowConcurrentSends && messenger._outgoing.length) messenger._deliverMessageQueue();

      // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

      function deliver(queued) {
        // ignore-in-doc
        if (messenger._inflight.indexOf(queued) === -1) return; // timed out
        var msg = queued[0],
            callback = queued[1];
        if (callback) messenger._messageResponseCallbacks[msg.messageId] = callback;

        spec.send.call(messenger, msg, function (err) {
          remove(messenger._inflight, queued);
          if (err) onSendError(err, queued);
          messenger._deliverMessageQueue();
        });
      }

      function startTimeoutProc(queued) {
        if (typeof spec.sendTimeout !== 'number') return;
        setTimeout(function () {
          if (messenger._inflight.indexOf(queued) === -1) return; // delivered
          remove(messenger._inflight, queued);
          onSendError(new Error('Timeout sending message'), queued);
          messenger._deliverMessageQueue();
        }, spec.sendTimeout);
      }

      function onSendError(err, queued) {
        var msg = queued[0],
            callback = queued[1];
        delete messenger._messageResponseCallbacks[msg.messageId];
        console.error(err);
        callback && callback(err);
      }
    },

    _startHeartbeatProcess: function _startHeartbeatProcess() {
      if (messenger._startHeartbeatProcessProc) return;
      messenger._startHeartbeatProcessProc = setTimeout(function () {
        spec.sendHeartbeat.call(messenger, function (err, result) {
          messenger._startHeartbeatProcessProc = null;
          messenger._startHeartbeatProcess();
        });
      }, messenger._heartbeatInterval);
    },

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

    id: function id() {
      return messenger._id;
    },

    isOnline: function isOnline() {
      return spec.isOnline.call(messenger);
    },

    heartbeatEnabled: function heartbeatEnabled() {
      return typeof messenger._heartbeatInterval === 'number';
    },

    listen: function listen(thenDo) {
      if (messenger._listenInProgress) return;
      messenger._listenInProgress = true;
      messenger._ensureStatusWatcher();
      return spec.listen.call(messenger, function (err) {
        messenger._listenInProgress = null;
        thenDo && thenDo(err);
        if (messenger.heartbeatEnabled()) messenger._startHeartbeatProcess();
      });
      return messenger;
    },

    reconnect: function reconnect() {
      if (messenger._status === ONLINE) return;
      messenger.listen();
      return messenger;
    },

    send: function send(msg, onReceiveFunc) {
      messenger._addMissingData(msg);
      messenger._queueSend(msg, onReceiveFunc);
      messenger._deliverMessageQueue();
      return msg;
    },

    sendTo: function sendTo(target, action, data, onReceiveFunc) {
      var msg = { target: target, action: action, data: data };
      return messenger.send(msg, onReceiveFunc);
    },

    onMessage: function onMessage(msg) {
      messenger.emit("message", msg);
      if (msg.inResponseTo) {
        var cb = messenger._messageResponseCallbacks[msg.inResponseTo];
        if (cb && !msg.expectMoreResponses) delete messenger._messageResponseCallbacks[msg.inResponseTo];
        if (cb) cb(null, msg);
      } else {
        var action = messenger._services[msg.action];
        if (action) {
          try {
            action.call(null, msg, messenger);
          } catch (e) {
            var errmMsg = String(e.stack || e);
            console.error("Error invoking service: " + errmMsg);
            messenger.answer(msg, { error: errmMsg });
          }
        } else if (!messenger._ignoreUnknownMessages) {
          var err = new Error("messageNotUnderstood: " + msg.action);
          messenger.answer(msg, { error: String(err) });
        }
      }
    },

    answer: function answer(msg, data, expectMore, whenSend) {
      if (typeof expectMore === 'function') {
        whenSend = expectMore;expectMore = false;
      }
      var answer = {
        target: msg.sender,
        action: msg.action + 'Result',
        inResponseTo: msg.messageId,
        data: data };
      if (expectMore) answer.expectMoreResponses = true;
      return messenger.send(answer, whenSend);
    },

    close: function close(thenDo) {
      clearInterval(messenger._statusWatcherProc);
      messenger._statusWatcherProc = null;
      spec.close.call(messenger, function (err) {
        messenger._status = OFFLINE;
        thenDo && thenDo(err);
      });
      return messenger;
    },

    whenOnline: function whenOnline(thenDo) {
      messenger._whenOnlineCallbacks.push(thenDo);
      if (messenger.isOnline()) messenger._runWhenOnlineCallbacks();
      return messenger;
    },

    outgoingMessages: function outgoingMessages() {
      return pluck(messenger._inflight.concat(messenger._outgoing), 0);
    },

    addServices: function addServices(serviceSpec) {
      Object.assign(messenger._services, serviceSpec);
      return messenger;
    }
  };

  if (spec.services) messenger.addServices(spec.services);
  makeEmitter(messenger);

  for (var name in spec) {
    if (ignoredAttributes.indexOf(name) === -1 && spec.hasOwnProperty(name)) {
      messenger[name] = spec[name];
    }
  }

  return messenger;
}



var messenger = Object.freeze({
	create: create$2
});

/*global require, Worker, URL, webkitURL, Blob, BlobBuilder, process, require*/

/*
 * A platform-independent worker interface that will spawn new processes per
 * worker (if the platform you use it on supports it).
 */

var isNodejs = typeof require !== 'undefined' && typeof process !== 'undefined';

// ignore-in-doc
// Code in worker setup is evaluated in the context of workers, it will get to
// workers in a stringified form(!).
var WorkerSetup = {

  loadDependenciesBrowser: function loadDependenciesBrowser(options) {
    var me = typeof self !== "undefined" ? self : this;
    importScripts.apply(me, options.scriptsToLoad || []);
  },

  loadDependenciesNodejs: function loadDependenciesNodejs(options) {
    var lv = global.lively || (global.lively = {});
    lv.lang = require(require("path").join(options.libLocation, "index"));
  },

  // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  // yoshiki and robert, 05/08/13: Inserted code that sets up the lively context
  // and globals of Lively and other required objects:
  initBrowserGlobals: function initBrowserGlobals(options) {
    remoteWorker.send = function (msg) {
      postMessage(msg);
    };
    var me = typeof self !== "undefined" ? self : this;
    var Global = me.Global = me;
    Global.window = Global;
    Global.console = Global.console || function () {
      var c = {};
      ['log', 'error', 'warn'].forEach(function (name) {
        c[name] = function () /*args*/{
          var string = arguments[0];
          for (var i = 1; i < arguments.length; i++) {
            string = string.replace('%s', arguments[i]);
          }remoteWorker.send({
            type: name,
            message: ['[', name.toUpperCase(), '] ', string].join('')
          });
        };
      });
      return c;
    }();
  },

  initOnMessageHandler: function initOnMessageHandler(options) {
    if (remoteWorker.on) remoteWorker.on('message', onMessage);else remoteWorker.onmessage = onMessage;

    function onMessage(msg) {
      msg = msg.data.data ? msg.data : msg;
      if (remoteWorker.messenger) remoteWorker.messenger.onMessage(msg);else if (msg.action == "close") {
        remoteWorker.send({ type: "closed", workerReady: false });
        remoteWorker.close();
        return;
      }
    }
  },

  initWorkerInterface: function initWorkerInterface(options) {
    remoteWorker.callStringifiedFunction = function (stringifiedFunc, args, thenDo) {
      // ignore-in-doc
      // runs stringified function and passing args. stringifiedFunc might
      // be asynchronous if it takes an addaitional argument. In this case a
      // callback to call when the work is done is passed, otherwise thenDo
      // will be called immediatelly after creating and calling the function

      var func;
      try {
        func = eval('(' + stringifiedFunc + ')');
      } catch (e) {
        thenDo(new Error("Cannot create function from string: " + e.stack || e));
        return;
      }

      // ignore-in-doc
      // when it takes one more arg then we assume that this is the callback
      // to be called by the run func when it considers to be done
      var usesCallback = func.length === args.length + 1;
      var whenDone = lively.lang.fun.once(function (err, result) {
        remoteWorker.isBusy = false;thenDo(err, result);
      });
      remoteWorker.isBusy = true;

      if (usesCallback) args.push(whenDone);

      try {
        var result = func.apply(remoteWorker, args.concat([whenDone]));
      } catch (e) {
        whenDone(e, null);return;
      }

      if (!usesCallback) whenDone(null, result);
    };

    remoteWorker.httpRequest = function (options) {
      if (!options.url) {
        console.log("Error, httpRequest needs url");
        return;
      }
      var req = new XMLHttpRequest(),
          method = options.method || 'GET';
      function handleStateChange() {
        if (req.readyState === 4) {
          // req.status
          options.done && options.done(req);
        }
      }
      req.onreadystatechange = handleStateChange;
      req.open(method, options.url);
      req.send();
    };

    remoteWorker.terminateIfNotBusyIn = function (ms) {
      setTimeout(function () {
        if (remoteWorker.isBusy) {
          remoteWorker.terminateIfNotBusyIn(ms);return;
        }
        remoteWorker.send({ type: "closed", workerReady: false });
        remoteWorker.close();
      }, ms);
    };
  },

  // ignore-in-doc
  // setting up the worker messenger interface, this is how the worker
  // should be communicated with
  initWorkerMessenger: function initWorkerMessenger(options) {
    if (!options.useMessenger) return null;
    if (!lively.lang.messenger) throw new Error("worker.create requires messenger.js to be loaded!");
    if (!lively.lang.events) throw new Error("worker.create requires events.js to be loaded!");

    return remoteWorker.messenger = lively.lang.messenger.create({
      services: {

        remoteEval: function remoteEval(msg, messenger) {
          var result;
          try {
            result = eval(msg.data.expr);
          } catch (e) {
            result = e.stack || e;
          }
          messenger.answer(msg, { result: String(result) });
        },

        run: function run(msg, messenger) {
          var funcString = msg.data.func,
              args = msg.data.args;
          if (!funcString) {
            messenger.answer(msg, { error: 'no funcString' });return;
          }
          remoteWorker.callStringifiedFunction(funcString, args, function (err, result) {
            messenger.answer(msg, { error: err ? String(err) : null, result: result });
          });
        },

        close: function close(msg, messenger) {
          messenger.answer(msg, { status: "OK" });
          remoteWorker.send({ type: "closed", workerReady: false });
          remoteWorker.close();
        }
      },

      isOnline: function isOnline() {
        return true;
      },
      send: function send(msg, whenSend) {
        remoteWorker.send(msg);whenSend();
      },
      listen: function listen(whenListening) {
        whenListening();
      },
      close: function close(whenClosed) {
        remoteWorker.send({ type: "closed", workerReady: false });remoteWorker.close();
      }

    });
  }

};

var BrowserWorker = {

  create: function create$3(options) {
    // ignore-in-doc
    // this function instantiates a browser worker object. We provide a
    // messenger-based interface to the pure Worker. Please use create to get an
    // improved interface to a worker

    options = options || {};

    // ignore-in-doc
    // figure out where the other lang libs can be loaded from
    if (!options.libLocation && !options.scriptsToLoad) {
      var workerScript = document.querySelector("script[src$=\"worker.js\"]");
      if (!workerScript) throw new Error("Cannot find library path to start worker. Use worker.create({libLocation: \"...\"}) to explicitly define the path!");
      options.libLocation = workerScript.src.replace(/worker.js$/, '');
    }

    var workerSetupCode = String(workerSetupFunction).replace("__FUNCTIONDECLARATIONS__", [WorkerSetup.initBrowserGlobals, WorkerSetup.loadDependenciesBrowser, WorkerSetup.initOnMessageHandler, WorkerSetup.initWorkerInterface, WorkerSetup.initWorkerMessenger].join('\n'));
    var workerCode = '(' + workerSetupCode + ')();';
    var worker = new Worker(makeDataURI(workerCode));
    init(options, worker);
    return worker;

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

    // ignore-in-doc
    // This code is triggered in the UI process directly after the
    // creation of the worker and sends the setup message to the worker
    // for initializing it.
    function init(options, worker) {
      makeEmitter(worker);

      if (!options.scriptsToLoad) {
        options.scriptsToLoad = ['base.js', 'events.js', 'object.js', 'collection.js', 'function.js', 'string.js', 'number.js', 'date.js', 'messenger.js', 'worker.js'].map(function (ea) {
          return options.libLocation + ea;
        });
      }

      var workerOptions = Object.keys(options).reduce(function (opts, key) {
        if (typeof options[key] !== 'function') opts[key] = options[key];
        return opts;
      }, {});

      worker.onmessage = function (evt) {
        if (evt.data.workerReady !== undefined) {
          worker.ready = !!evt.data.workerReady;
          if (worker.ready) worker.emit("ready");else worker.emit("close");
        } else worker.emit('message', evt.data);
      };

      worker.errors = [];
      worker.onerror = function (evt) {
        console.error(evt);
        worker.errors.push(evt);
        worker.emit("error", evt);
      };

      worker.postMessage({ action: 'setup', options: workerOptions });
    }

    // ignore-in-doc
    // This code is run inside the worker and bootstraps the messenger
    // interface. It also installs a console.log method since since this is not
    // available by default.
    function workerSetupFunction() {
      var remoteWorker = self;
      remoteWorker.onmessage = function (evt) {
        if (evt.data.action !== "setup") {
          throw new Error("expected setup to be first message but got " + JSON.stringify(evt.data));
        }
        var options = evt.data.options || {};
        initBrowserGlobals(options);
        loadDependenciesBrowser(options);
        initOnMessageHandler(options);
        initWorkerInterface(options);
        initWorkerMessenger(options);
        postMessage({ workerReady: true });
      };
      __FUNCTIONDECLARATIONS__;
    }

    function makeDataURI(codeToInclude) {
      // ignore-in-doc
      // see http://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string
      var blob;
      try {
        blob = new Blob([codeToInclude], { type: "text/javascript" });
      } catch (e) {
        /* ignore-in-doc Backwards-compatibility*/
        window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
        blob = new BlobBuilder();
        blob.append(codeToInclude);
        blob = blob.getBlob();
      }
      var urlInterface = typeof webkitURL !== 'undefined' ? webkitURL : URL;
      return urlInterface.createObjectURL(blob);
    }
  }

};

var NodejsWorker = {

  debug: false,
  initCodeFileCreated: false,

  create: function create$3(options) {
    options = options || {};

    // ignore-in-doc
    // figure out where the other lang libs can be loaded from
    // if (!options.libLocation && !options.scriptsToLoad) {
    //   var workerScript = document.querySelector("script[src$=\"worker.js\"]");
    //   if (!workerScript) throw new Error("Cannot find library path to start worker. Use worker.create({libLocation: \"...\"}) to explicitly define the path!");
    //   options.libLocation = workerScript.src.replace(/worker.js$/, '');
    // }

    var workerProc;
    var worker = makeEmitter({
      ready: false,
      errors: [],

      postMessage: function postMessage(msg) {
        if (!workerProc) {
          worker.emit("error", new Error('nodejs worker process not yet created'));
          return;
        }
        if (!worker.ready) {
          worker.emit("error", new Error('nodejs worker process not ready or already closed'));
          return;
        }
        workerProc.send(msg);
      }
    });

    NodejsWorker.startWorker(options, function (err, _workerProc) {
      if (err) {
        worker.ready = false;worker.emit("error", err);return;
      }

      workerProc = _workerProc;

      workerProc.on('message', function (m) {
        NodejsWorker.debug && console.log('[WORKER PARENT] got message:', m);
        worker.emit("message", m);
      });

      workerProc.on('close', function () {
        console.log("[WORKER PARENT] worker closed");
        worker.emit("close");
      });

      workerProc.on('error', function (err) {
        console.log("[WORKER PARENT] error ", err);
        worker.errors.push(err);
        worker.emit("error", err);
      });

      worker.ready = true;
      worker.emit("ready");
    });

    return worker;
  },

  // this code is run in the context of the worker process
  workerSetupFunction: function workerSetupFunction() {
    var remoteWorker = process;
    var debug = true;
    var close = false;

    debug && console.log("[WORKER] Starting init");
    // ignore-in-doc
    // process.on('message', function(m) {
    //   debug && console.log('[WORKER] got message:', m);
    //   if (m.action === 'ping') process.send({action: 'pong', data: m});
    //   else if (m.action === 'close') close = true;
    //   else if (m.action === 'setup') setup(m.data);
    //   else console.error('[WORKER] unknown message: ', m);
    // });

    remoteWorker.on("message", function (msg) {
      if (msg.action !== "setup") {
        throw new Error("expected setup to be first message but got " + JSON.stringify(msg.data));
      }
      remoteWorker.removeAllListeners("message");
      var options = msg.data.options || {};
      debug && console.log("[WORKER] running setup with options", options);
      loadDependenciesNodejs(options);
      initOnMessageHandler(options);
      initWorkerInterface(options);
      initWorkerMessenger(options);
      remoteWorker.send({ workerReady: true });
    });
    __FUNCTIONDECLARATIONS__;
  },

  ensureInitCodeFile: function ensureInitCodeFile(options, initCode, thenDo) {
    var path = require("path");
    var os = require("os");
    var fs = require("fs");

    var workerTmpDir = path.join(os.tmpDir(), 'lively-nodejs-workers/');
    var fn = path.join(workerTmpDir, 'nodejs-worker-init.js');

    if (!NodejsWorker.initCodeFileCreated) NodejsWorker.createWorkerCodeFile(options, fn, initCode, thenDo);else fs.exists(fn, function (exists) {
      if (exists) thenDo(null, fn);else NodejsWorker.createWorkerCodeFile(options, fn, initCode, thenDo);
    });
  },

  createWorkerCodeFile: function createWorkerCodeFile(options, fileName, initCode, thenDo) {
    var path = require("path");
    var fs = require("fs");
    var exec = require("child_process").exec;

    exec("mkdir -p " + path.dirname(fileName), function (code, out, err) {
      if (code) {
        thenDo(new Error(["[WORKER PARENT] Could not create worker temp dir:", out, err].join('\n')));
        return;
      }
      fs.writeFile(fileName, initCode, function (err) {
        NodejsWorker.debug && console.log('worker code file %s created', fileName);
        NodejsWorker.initCodeFileCreated = true;
        thenDo(err, fileName);
      });
    });
  },

  startWorker: function startWorker(options, thenDo) {
    var util = require("util");
    var fork = require("child_process").fork;

    var workerSetupCode = String(NodejsWorker.workerSetupFunction).replace("__FUNCTIONDECLARATIONS__", [WorkerSetup.loadDependenciesNodejs, WorkerSetup.initOnMessageHandler, WorkerSetup.initWorkerInterface, WorkerSetup.initWorkerMessenger].join('\n'));

    var initCode = util.format("(%s)();\n", workerSetupCode);
    NodejsWorker.ensureInitCodeFile(options, initCode, function (err, codeFileName) {
      if (err) return thenDo(err);
      var worker = fork(codeFileName, {});
      NodejsWorker.debug && console.log('worker forked');
      worker.on('message', function (m) {
        if (m.action === 'pong') console.log("[WORKER pong] ", m);else if (m.action === 'log') console.log("[Message from WORKER] ", m.data);
      });
      worker.once('message', function (m) {
        NodejsWorker.debug && console.log('worker setup done');
        thenDo(null, worker, m);
      });
      worker.on('close', function () {
        NodejsWorker.debug && console.log("[WORKER PARENT] worker closed");
      });
      worker.send({ action: "setup", data: { options: options } });
      global.WORKER = worker;
    });
  }

};

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
// the worker interface, usable both in browser and node.js contexts
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

/*
Worker objects allow to fork processes in both Web and node.js JavaScript
environments. They provide this mechanism using web workers in the browser and
node.js child processes in node.js. The interface is unified for all platforms.
 */

function fork(options, workerFunc, thenDo) {
  // Fork automatically starts a worker and calls `workerFunc`. `workerFunc`
  // gets as a last paramter a callback, that, when invoked with an error and
  // result object, ends the worker execution.
  //
  // Options are the same as in `create` except for an `args` property that
  // can be an array of objects. These objects will be passed to `workerFunc`
  // as arguments.
  //
  // Note: `workerFunc` will not be able to capture outside variables (create a
  // closure).
  //
  // Example:
  // // When running this inside a browser: Note how the UI does not block.
  // worker.fork({args: [40]},
  //   function(n, thenDo) {
  //     function fib(n) { return n <= 1 ? n : fib(n-1) + fib(n-2); }
  //     thenDo(null, fib(n));
  //   },
  //   function(err, result) { show(err ? err.stack : result); })

  if (!thenDo) {
    thenDo = workerFunc;workerFunc = options;options = null;
  }
  options = options || {};
  var args = options.args || [];
  var w = create$3(options);
  w.run.apply(w, [workerFunc].concat(args).concat(thenDo));
  return w;
}

function create$3(options) {
  // Explicitly creates a first-class worker. Options:
  // ```js
  // {
  //   workerId: STRING, // optional, id for worker, will be auto assigned if not provided
  //   libLocation: STRING, // optional, path to where the lively.lang lib is located. Worker will try to find it automatically if not provided.
  //   scriptsToLoad: ARRAY // optional, list of path/urls to load. Overwrites `libLocation`
  // }
  // ```
  //
  // Example:
  // // this is just a helper function
  // function resultHandler(err, result) { alert(err ? String(err) : result); }
  //
  // // 1. Create the worker
  // var worker = lively.lang.worker.create({libLocation: baseURL});
  //
  // // 2. You can evaluate arbitrary JS code
  // worker.eval("1+2", function(err, result) { show(err ? String(err) : result); });
  //
  // // 3. Arbitrary functions can be called inside the worker context.
  // //    Note: functions shouldn't be closures / capture local state!) and passing
  // //    in arguments!
  // worker.run(
  //   function(a, b, thenDo) { setTimeout(function() { thenDo(null, a+b); }, 300); },
  //   19, 4, resultHandler);
  //
  // // 4. You can also install your own messenger services...
  // worker.run(
  //   function(thenDo) {
  //     self.messenger.addServices({
  //       foo: function(msg, messenger) { messenger.answer(msg, "bar!"); }
  //     });
  //     thenDo(null, "Service installed!");
  //   }, resultHandler);
  //
  // // ... and call them via the messenger interface
  // worker.sendTo("worker", "foo", {}, resultHandler);
  //
  // // 5. afterwards: shut it down
  // worker.close(function(err) { err && show(String(err)); alertOK("worker shutdown"); })

  options = options || {};
  options.useMessenger = true;

  // if (!exports.messenger)
  //   throw new Error("worker.create requires messenger.js to be loaded!")
  // if (!exports.events)
  //   throw new Error("worker.create requires events.js to be loaded!")
  // if (!exports.obj)
  //   throw new Error("worker.create requires object.js to be loaded!")

  var workerId = options.workerId || newUUID();

  var messenger = create$2({
    sendTimeout: 5000,

    send: function send(msg, whenSend) {
      messenger.worker.postMessage(msg);
      whenSend();
    },

    listen: function listen(whenListening) {
      var w = messenger.worker = isNodejs ? NodejsWorker.create(options) : BrowserWorker.create(options);
      w.on("message", function (msg) {
        messenger.onMessage(msg);
      });
      w.on('ready', function () {
        NodejsWorker.debug && console.log("WORKER READY!!!");
      });
      w.on('close', function () {
        NodejsWorker.debug && console.log("WORKER CLOSED...!!!");
      });
      w.once('ready', whenListening);
    },

    close: function close(whenClosed) {
      if (!messenger.worker.ready) return whenClosed(null);
      return messenger.sendTo(workerId, 'close', {}, function (err, answer) {
        err = err || answer.data.error;
        err && console.error("Error in worker messenger close: " + err.stack || err);
        if (err) whenClosed(err);else {
          var closed = false;
          messenger.worker.once('close', function () {
            closed = true;
          });
          waitFor(1000, function () {
            return !!closed;
          }, whenClosed);
        }
      });
    },

    isOnline: function isOnline() {
      return messenger.worker && messenger.worker.ready;
    }

  });

  Object.assign(messenger, {
    eval: function _eval(code, thenDo) {
      messenger.sendTo(workerId, "remoteEval", { expr: code }, function (err, answer) {
        thenDo(err, answer ? answer.data.result : null);
      });
    },
    run: function run() /*runFunc, arg1, ... argN, thenDo*/{
      var args = Array.prototype.slice.call(arguments),
          workerFunc = args.shift(),
          thenDo = args.pop();
      if (typeof workerFunc !== "function") throw new Error("run: no function that should run in worker passed");
      if (typeof thenDo !== "function") throw new Error("run: no callback passed");

      return messenger.sendTo(workerId, 'run', { func: String(workerFunc), args: args }, function (err, answer) {
        thenDo(err || answer.data.error, answer ? answer.data.result : null);
      });
    }
  });

  messenger.listen();

  return messenger;
}



var worker = Object.freeze({
	fork: fork,
	create: create$3
});

var GLOBAL = typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : undefined;

var isNode = typeof process !== "undefined" && process.env && typeof process.exit === "function";

var globalInterfaceSpec = [{ action: "installMethods", target: "Array", sources: ["arr"], methods: ["from", "genN", "range", "withN"] }, { action: "installMethods", target: "Array.prototype", sources: ["arr"], methods: ["all", "any", "batchify", "clear", "clone", "collect", "compact", "delimWith", "detect", "doAndContinue", "each", "equals", "filterByKey", "findAll", "first", "flatten", "forEachShowingProgress", "grep", "groupBy", "groupByKey", "histogram", "include", "inject", "intersect", "invoke", "last", "mapAsync", "mapAsyncSeries", "mask", "max", "min", "mutableCompact", "nestedDelay", "partition", "pluck", "pushAll", "pushAllAt", "pushAt", "pushIfNotIncluded", "reMatches", "reject", "rejectByKey", "remove", "removeAt", "replaceAt", "rotate", "shuffle", "size", "sortBy", "sortByKey", "sum", "swap", "toArray", "toTuples", "union", "uniq", "uniqBy", "without", "withoutAll", "zip"], alias: [["select", "filter"]] }, { action: "installMethods", target: "Date", sources: ["date"], methods: [/*"parse"*/] }, { action: "installMethods", target: "Date.prototype", sources: ["date"], methods: ["equals", "format", "relativeTo"] }, { action: "installMethods", target: "Function", sources: ["fun"], methods: ["fromString"] }, { action: "installMethods", target: "Function.prototype", sources: ["fun"], methods: [/*"addProperties",*/"addToObject", "argumentNames", "asScript", "asScriptOf", "binds", "curry", "delay", "functionNames", "localFunctionNames", "getOriginal", "getVarMapping", "logCalls", "logCompletion", "logErrors", "qualifiedMethodName", "setProperty", "traceCalls", "wrap"] }, { action: "installMethods", target: "Number", sources: ["num"], methods: [] }, { action: "installMethods", target: "Number.prototype", sources: ["num"], methods: ["detent", "randomSmallerInteger", "roundTo", "toDegrees", "toRadians"] }, { action: "installMethods", target: "Object", sources: ["obj"], methods: ["addScript", "clone", "deepCopy", "extend", "inherit", "isArray", "isBoolean", "isElement", "isEmpty", "isFunction", "isNumber", "isObject", "isRegExp", "isString", "isUndefined", "merge", "mergePropertyInHierarchy", "values", "valuesInPropertyHierarchy"] }, { action: "installMethods", target: "Object.prototype", sources: ["obj"], methods: [] }, { action: "installMethods", target: "String.prototype", sources: ["string"], methods: ["camelize", "capitalize", "digitValue", "empty", "hashCode", "include", "pad", "regExpEscape", "startsWithVowel", "succ", "times", "toArray", "toQueryParams", "truncate"] }, { action: "installMethods", target: "Function.prototype", sources: ["klass"], methods: ["create", "addMethods", "isSubclassOf", "superclasses", "categoryNameFor", "remove"], alias: [["subclass", "create"]] }, { action: "installObject", target: "Numbers", source: "num", methods: ["average", "between", "convertLength", "humanReadableByteSize", "median", "normalRandom", "parseLength", "random", "sort"] }, { action: "installObject", target: "Properties", source: "properties", methods: ["all", "allOwnPropertiesOrFunctions", "allProperties", "any", "forEachOwn", "hash", "nameFor", "own", "ownValues", "values"] }, { action: "installObject", target: "Strings", source: "string", methods: ["camelCaseString", "createDataURI", "diff", "format", "formatFromArray", "indent", "lineIndexComputer", "lines", "md5", "newUUID", "nonEmptyLines", "pad", "paragraphs", "peekLeft", "peekRight", "print", "printNested", "printTable", "printTree", "quote", "reMatches", "stringMatch", "tableize", "tokens", "unescapeCharacterEntities", "withDecimalPrecision"] }, { action: "installObject", target: "Objects", source: "obj", methods: ["asObject", "equals", "inspect", "isMutableType", "safeToString", "shortPrintStringOf", "typeStringOf"] }, { action: "installObject", target: "Functions", source: "fun", methods: ["all", "compose", "composeAsync", "createQueue", "debounce", "debounceNamed", "either", "extractBody", "flip", "notYetImplemented", "once", "own", "throttle", "throttleNamed", "timeToRun", "timeToRunN", "waitFor", "workerWithCallbackQueue", "wrapperChain"] }, { action: "installObject", target: "Grid", source: "grid" }, { action: "installObject", target: "Interval", source: "interval" }, { action: "installObject", target: "lively.ArrayProjection", source: "arrayProjection" }, { action: "installObject", target: "lively.Closure", source: "Closure" }, { action: "installObject", target: "lively.Grouping", source: "Group" }, { action: "installObject", target: "lively.PropertyPath", source: "Path" }, { action: "installObject", target: "lively.Worker", source: "worker" }, { action: "installObject", target: "lively.Class", source: "classHelper" }];

function createLivelyLangObject() {
  return {
    chain: chain$$1,
    noConflict: noConflict,
    installGlobals: installGlobals,
    uninstallGlobals: uninstallGlobals,
    globalInterfaceSpec: globalInterfaceSpec,
    toString: function toString() {
      return "[object lively.lang]";
    }
  };
}

var livelyLang = createLivelyLangObject();



function chain$$1(object) {
  if (!object) return object;

  var chained;
  if (Array.isArray(object)) return createChain(arr, object);
  if (object.constructor.name === "Date") return createChain(date, object);
  switch (typeof object === "undefined" ? "undefined" : _typeof(object)) {
    case 'string':
      return createChain(string, object);
    case 'object':
      return createChain(obj, object);
    case 'function':
      return createChain(fun, object);
    case 'number':
      return createChain(num, object);
  }
  throw new Error("Chain for object " + object + " (" + object.constructor.name + ") no supported");
}

function createChain(interfaceObj, obj) {
  return Object.keys(interfaceObj).reduce(function (chained, methodName) {
    chained[methodName] = function () /*args*/{
      var args = Array.prototype.slice.call(arguments),
          result = interfaceObj[methodName].apply(null, [obj].concat(args));
      return chain$$1(result);
    };
    return chained;
  }, { value: function value() {
      return obj;
    } });
}

function noConflict() {
  if (!isNode) {
    var keepLivelyNS = livelyLang._prevLivelyGlobal;
    if (!keepLivelyNS) delete GLOBAL.lively;else delete GLOBAL.lively.lang;
  }
  return livelyLang;
}

function installGlobals() {
  globalInterfaceSpec.forEach(function (ea) {
    if (ea.action === "installMethods") {
      var targetPath = Path(ea.target);
      if (!targetPath.isIn(GLOBAL)) targetPath.set(GLOBAL, {}, true);
      var sourcePath = Path(ea.sources[0]);
      ea.methods.forEach(function (name) {
        installProperty(sourcePath.concat([name]), targetPath.concat([name]));
      });
      if (ea.alias) ea.alias.forEach(function (mapping) {
        installProperty(sourcePath.concat([mapping[1]]), targetPath.concat([mapping[0]]));
      });
    } else if (ea.action === "installObject") {
      var targetPath = Path(ea.target);
      var source = Path(ea.source).get(livelyLang);
      targetPath.set(GLOBAL, source, true);
    } else throw new Error("Cannot deal with global setup action: " + ea.action);
  });
}

function installProperty(sourcePath, targetPath) {
  if (!sourcePath.isIn(livelyLang)) {
    var err = new Error("property not provided by lively.lang: " + sourcePath);
    console.error(err.stack || err);
    throw err;
  }

  var prop = sourcePath.get(livelyLang);
  if (typeof prop === "function" && targetPath.slice(-2, -1).toString() === "prototype") {
    var origFunc = prop;
    prop = function prop() /*this and args*/{
      var args = Array.prototype.slice.call(arguments);
      args.unshift(this);
      return origFunc.apply(null, args);
    };
    prop.toString = function () {
      return origFunc.toString();
    };
  }
  targetPath.set(GLOBAL, prop, true);
}

function uninstallGlobals() {
  globalInterfaceSpec.forEach(function (ea) {
    if (ea.action === "installMethods") {
      var p = Path(ea.target);
      var source = Path(ea.source).get(livelyLang);
      var target = p.get(GLOBAL);
      if (!target) return;
      ea.methods.filter(function (name) {
        return source === target[name];
      }).forEach(function (name) {
        delete target[name];
      });
      if (ea.alias) ea.alias.filter(function (name) {
        return source === target[name];
      }).forEach(function (mapping) {
        delete target[mapping[0]];
      });
    } else if (ea.action === "installObject") {
      var p = Path(ea.target);
      p.del(GLOBAL);
    } else throw new Error("Cannot deal with global setup action: " + ea.action);
  });
}

exports.worker = worker;
exports.messenger = messenger;
exports.events = events;
exports.tree = tree;
exports.grid = grid;
exports.arrayProjection = arrayProjection;
exports.interval = interval;
exports.graph = graph;
exports.date = date;
exports.properties = properties;
exports.obj = obj;
exports.arr = arr;
exports.fun = fun;
exports.num = num;
exports.string = string;
exports.Closure = Closure;
exports.promise = promise;
exports.Path = Path;
exports.Group = Group;
exports.livelyLang = livelyLang;
exports.chain = chain$$1;
exports.noConflict = noConflict;
exports.installGlobals = installGlobals;
exports.uninstallGlobals = uninstallGlobals;

}((this.lively.lang = this.lively.lang || {})));

  }).call(GLOBAL);
  if (typeof module !== "undefined" && module.exports) module.exports = GLOBAL.lively.lang;
})();

  this.lively = this.lively || {};
(function (exports,lively_lang) {
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var get$1 = function get$1(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get$1(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};



var set$1 = function set$1(object, property, value, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent !== null) {
      set$1(parent, property, value, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    desc.value = value;
  } else {
    var setter = desc.set;

    if (setter !== undefined) {
      setter.call(receiver, value);
    }
  }

  return value;
};













var toArray = function (arr$$1) {
  return Array.isArray(arr$$1) ? arr$$1 : Array.from(arr$$1);
};

function parse$1(string$$1) {
	var color = new Color$1(string$$1);
	return { red: color.red() / 255, green: color.green() / 255, blue: color.blue() / 255, alpha: color.alpha() };
}

// http://upshots.org/javascript/javascript-color-class
// MIT licensed, Copyright (c) 2011 Mike Dunn
// https://github.com/moagrius/Color/blob/master/LICENSE

var Events = {
	RGB_UPDATED: 'RGBUpdated',
	HSL_UPDATED: 'HSLUpdated',
	HSV_UPDATED: 'HSVUpdated',
	HEX_UPDATED: 'HexUpdated',
	INT_UPDATED: 'IntUpdated',
	UPDATED: 'updated'
};

var namedColors = {
	'transparent': 'rgba(0, 0, 0, 0)', 'aliceblue': '#F0F8FF', 'antiquewhite': '#FAEBD7', 'aqua': '#00FFFF', 'aquamarine': '#7FFFD4',
	'azure': '#F0FFFF', 'beige': '#F5F5DC', 'bisque': '#FFE4C4', 'black': '#000000', 'blanchedalmond': '#FFEBCD', 'blue': '#0000FF', 'blueviolet': '#8A2BE2',
	'brown': '#A52A2A', 'burlywood': '#DEB887', 'cadetblue': '#5F9EA0', 'chartreuse': '#7FFF00', 'chocolate': '#D2691E', 'coral': '#FF7F50',
	'cornflowerblue': '#6495ED', 'cornsilk': '#FFF8DC', 'crimson': '#DC143C', 'cyan': '#00FFFF', 'darkblue': '#00008B', 'darkcyan': '#008B8B', 'darkgoldenrod': '#B8860B',
	'darkgray': '#A9A9A9', 'darkgrey': '#A9A9A9', 'darkgreen': '#006400', 'darkkhaki': '#BDB76B', 'darkmagenta': '#8B008B', 'darkolivegreen': '#556B2F',
	'darkorange': '#FF8C00', 'darkorchid': '#9932CC', 'darkred': '#8B0000', 'darksalmon': '#E9967A', 'darkseagreen': '#8FBC8F', 'darkslateblue': '#483D8B',
	'darkslategray': '#2F4F4F', 'darkslategrey': '#2F4F4F', 'darkturquoise': '#00CED1', 'darkviolet': '#9400D3', 'deeppink': '#FF1493', 'deepskyblue': '#00BFFF',
	'dimgray': '#696969', 'dimgrey': '#696969', 'dodgerblue': '#1E90FF', 'firebrick': '#B22222', 'floralwhite': '#FFFAF0', 'forestgreen': '#228B22',
	'fuchsia': '#FF00FF', 'gainsboro': '#DCDCDC', 'ghostwhite': '#F8F8FF', 'gold': '#FFD700', 'goldenrod': '#DAA520', 'gray': '#808080', 'grey': '#808080',
	'green': '#008000', 'greenyellow': '#ADFF2F', 'honeydew': '#F0FFF0', 'hotpink': '#FF69B4', 'indianred': '#CD5C5C', 'indigo': '#4B0082', 'ivory': '#FFFFF0',
	'khaki': '#F0E68C', 'lavender': '#E6E6FA', 'lavenderblush': '#FFF0F5', 'lawngreen': '#7CFC00', 'lemonchiffon': '#FFFACD', 'lightblue': '#ADD8E6',
	'lightcoral': '#F08080', 'lightcyan': '#E0FFFF', 'lightgoldenrodyellow': '#FAFAD2', 'lightgray': '#D3D3D3', 'lightgrey': '#D3D3D3', 'lightgreen': '#90EE90',
	'lightpink': '#FFB6C1', 'lightsalmon': '#FFA07A', 'lightseagreen': '#20B2AA', 'lightskyblue': '#87CEFA', 'lightslategray': '#778899',
	'lightslategrey': '#778899', 'lightsteelblue': '#B0C4DE', 'lightyellow': '#FFFFE0', 'lime': '#00FF00', 'limegreen': '#32CD32', 'linen': '#FAF0E6',
	'magenta': '#FF00FF', 'maroon': '#800000', 'mediumaquamarine': '#66CDAA', 'mediumblue': '#0000CD', 'mediumorchid': '#BA55D3', 'mediumpurple': '#9370D8',
	'mediumseagreen': '#3CB371', 'mediumslateblue': '#7B68EE', 'mediumspringgreen': '#00FA9A', 'mediumturquoise': '#48D1CC', 'mediumvioletred': '#C71585',
	'midnightblue': '#191970', 'mintcream': '#F5FFFA', 'mistyrose': '#FFE4E1', 'moccasin': '#FFE4B5', 'navajowhite': '#FFDEAD', 'navy': '#000080', 'oldlace': '#FDF5E6',
	'olive': '#808000', 'olivedrab': '#6B8E23', 'orange': '#FFA500', 'orangered': '#FF4500', 'orchid': '#DA70D6', 'palegoldenrod': '#EEE8AA',
	'palegreen': '#98FB98', 'paleturquoise': '#AFEEEE', 'palevioletred': '#D87093', 'papayawhip': '#FFEFD5', 'peachpuff': '#FFDAB9', 'peru': '#CD853F',
	'pink': '#FFC0CB', 'plum': '#DDA0DD', 'powderblue': '#B0E0E6', 'purple': '#800080', 'red': '#FF0000', 'rosybrown': '#BC8F8F', 'royalblue': '#4169E1',
	'saddlebrown': '#8B4513', 'salmon': '#FA8072', 'sandybrown': '#F4A460', 'seagreen': '#2E8B57', 'seashell': '#FFF5EE', 'sienna': '#A0522D', 'silver': '#C0C0C0',
	'skyblue': '#87CEEB', 'slateblue': '#6A5ACD', 'slategray': '#708090', 'slategrey': '#708090', 'snow': '#FFFAFA', 'springgreen': '#00FF7F',
	'steelblue': '#4682B4', 'tan': '#D2B48C', 'teal': '#008080', 'thistle': '#D8BFD8', 'tomato': '#FF6347', 'turquoise': '#40E0D0', 'violet': '#EE82EE'
};

var absround = function absround(number) {
	return 0.5 + number << 0;
};

var hue2rgb = function hue2rgb(a, b, c) {
	if (c < 0) c += 1;
	if (c > 1) c -= 1;
	if (c < 1 / 6) return a + (b - a) * 6 * c;
	if (c < 1 / 2) return b;
	if (c < 2 / 3) return a + (b - a) * (2 / 3 - c) * 6;
	return a;
};

var p2v = function p2v(p) {
	return isPercent.test(p) ? absround(parseInt(p) * 2.55) : p;
};

var isHex = /^#?([0-9a-f]{3}|[0-9a-f]{6})$/i;
var isHSL = /^hsla?\((\d{1,3}?),\s*(\d{1,3}%),\s*(\d{1,3}%)(,\s*[01]?\.?\d*)?\)$/;
var isRGB = /^rgba?\((\d{1,3}%?),\s*(\d{1,3}%?),\s*(\d{1,3}%?)(,\s*[01]?\.?\d*)?\)$/;
var isPercent = /^\d+(\.\d+)*%$/;

var hexBit = /([0-9a-f])/gi;
var leadHex = /^#/;

var matchHSL = /^hsla?\((\d{1,3}),\s*(\d{1,3})%,\s*(\d{1,3})%(,\s*([01]?\.?\d*))?\)$/;
var matchRGB = /^rgba?\((\d{1,3}%?),\s*(\d{1,3}%?),\s*(\d{1,3}%?)(,\s*([01]?\.?\d*))?\)$/;

function Color$1(value) {

	this._listeners = {};

	this.subscribe(Events.RGB_UPDATED, this._RGBUpdated);
	this.subscribe(Events.HEX_UPDATED, this._HEXUpdated);
	this.subscribe(Events.HSL_UPDATED, this._HSLUpdated);
	this.subscribe(Events.HSV_UPDATED, this._HSVUpdated);
	this.subscribe(Events.INT_UPDATED, this._INTUpdated);

	this.parse(value);
}

Color$1.prototype._decimal = 0;
Color$1.prototype._hex = '#000000';
Color$1.prototype._red = 0;
Color$1.prototype._green = 0;
Color$1.prototype._blue = 0;
Color$1.prototype._hue = 0;
Color$1.prototype._saturation = 0;
Color$1.prototype._lightness = 0;
Color$1.prototype._brightness = 0;
Color$1.prototype._alpha = 1;

Color$1.prototype.parse = function (value) {
	if (typeof value == 'undefined') {
		return this;
	}
	switch (true) {
		case isFinite(value):
			this.decimal(value);
			this.output = Color$1.INT;
			return this;
		case value instanceof Color$1:
			this.copy(value);
			return this;
		default:
			switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {
				case 'object':
					this.set(value);
					return this;
				case 'string':
					switch (true) {
						case namedColors.hasOwnProperty(value):
							value = namedColors[value];
							var stripped = value.replace(leadHex, '');
							this.decimal(parseInt(stripped, 16));
							return this;
						case isHex.test(value):
							var stripped = value.replace(leadHex, '');
							if (stripped.length == 3) {
								stripped = stripped.replace(hexBit, '$1$1');
							};
							this.decimal(parseInt(stripped, 16));
							return this;
						case isRGB.test(value):
							var parts = value.match(matchRGB);
							this.red(p2v(parts[1]));
							this.green(p2v(parts[2]));
							this.blue(p2v(parts[3]));
							this.alpha(parseFloat(parts[5]) || 1);
							this.output = (isPercent.test(parts[1]) ? 2 : 1) + (parts[5] ? 2 : 0);
							return this;
						case isHSL.test(value):
							var parts = value.match(matchHSL);
							this.hue(parseInt(parts[1]));
							this.saturation(parseInt(parts[2]));
							this.lightness(parseInt(parts[3]));
							this.alpha(parseFloat(parts[5]) || 1);
							this.output = parts[5] ? 6 : 5;
							return this;
					};
			};

	}
	return this;
};

Color$1.prototype.clone = function () {
	return new Color$1(this.decimal());
};

Color$1.prototype.copy = function (color) {
	this.set(color.decimal());
	return this;
};

Color$1.prototype.set = function (key, value) {
	if (arguments.length == 1) {
		if ((typeof key === 'undefined' ? 'undefined' : _typeof(key)) == 'object') {
			for (var p in key) {
				if (typeof this[p] == 'function') {
					this[p](key[p]);
				}
			}
		} else if (isFinite(key)) {
			this.decimal(key);
		}
	} else if (typeof this[key] == 'function') {
		this[key](value);
	}
	return this;
};

Color$1.prototype.interpolate = function (destination, factor) {
	if (!(destination instanceof Color$1)) {
		destination = new Color$1(destination);
	}
	this._red = absround(+this._red + (destination._red - this._red) * factor);
	this._green = absround(+this._green + (destination._green - this._green) * factor);
	this._blue = absround(+this._blue + (destination._blue - this._blue) * factor);
	this._alpha = absround(+this._alpha + (destination._alpha - this._alpha) * factor);
	this.broadcast(Events.RGB_UPDATED);
	this.broadcast(Events.UPDATED);
	return this;
};

Color$1.prototype._RGB2HSL = function () {

	var r = this._red / 255;
	var g = this._green / 255;
	var b = this._blue / 255;

	var max = Math.max(r, g, b);
	var min = Math.min(r, g, b);
	var l = (max + min) / 2;
	var v = max;

	if (max == min) {
		this._hue = 0;
		this._saturation = 0;
		this._lightness = absround(l * 100);
		this._brightness = absround(v * 100);
		return;
	}

	var d = max - min;
	var s = d / (l <= 0.5 ? max + min : 2 - max - min);
	var h = (max == r ? (g - b) / d + (g < b ? 6 : 0) : max == g ? (b - r) / d + 2 : (r - g) / d + 4) / 6;

	this._hue = absround(h * 360);
	this._saturation = absround(s * 100);
	this._lightness = absround(l * 100);
	this._brightness = absround(v * 100);
};

Color$1.prototype._HSL2RGB = function () {
	var h = this._hue / 360;
	var s = this._saturation / 100;
	var l = this._lightness / 100;
	var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
	var p = 2 * l - q;
	this._red = absround(hue2rgb(p, q, h + 1 / 3) * 255);
	this._green = absround(hue2rgb(p, q, h) * 255);
	this._blue = absround(hue2rgb(p, q, h - 1 / 3) * 255);
};

Color$1.prototype._HSV2RGB = function () {
	var h = this._hue / 360;
	var s = this._saturation / 100;
	var v = this._brightness / 100;
	var r = 0;
	var g = 0;
	var b = 0;
	var i = Math.floor(h * 6);
	var f = h * 6 - i;
	var p = v * (1 - s);
	var q = v * (1 - f * s);
	var t = v * (1 - (1 - f) * s);
	switch (i % 6) {
		case 0:
			r = v, g = t, b = p;
			break;
		case 1:
			r = q, g = v, b = p;
			break;
		case 2:
			r = p, g = v, b = t;
			break;
		case 3:
			r = p, g = q, b = v;
			break;
		case 4:
			r = t, g = p, b = v;
			break;
		case 5:
			r = v, g = p, b = q;
			break;
	}
	this._red = absround(r * 255);
	this._green = absround(g * 255);
	this._blue = absround(b * 255);
};

Color$1.prototype._INT2HEX = function () {
	var x = this._decimal.toString(16);
	x = '000000'.substr(0, 6 - x.length) + x;
	this._hex = '#' + x.toUpperCase();
};

Color$1.prototype._INT2RGB = function () {
	this._red = this._decimal >> 16;
	this._green = this._decimal >> 8 & 0xFF;
	this._blue = this._decimal & 0xFF;
};

Color$1.prototype._HEX2INT = function () {
	this._decimal = parseInt(this._hex, 16);
};

Color$1.prototype._RGB2INT = function () {
	this._decimal = this._red << 16 | this._green << 8 & 0xffff | this._blue;
};

Color$1.prototype._RGBUpdated = function () {
	this._RGB2INT();
	this._RGB2HSL();
	this._INT2HEX();
};
Color$1.prototype._HSLUpdated = function () {
	this._HSL2RGB();
	this._RGB2INT();
	this._INT2HEX();
};
Color$1.prototype._HSVUpdated = function () {
	this._HSV2RGB();
	this._RGB2INT();
	this._INT2HEX();
};
Color$1.prototype._HEXUpdated = function () {
	this._HEX2INT();
	this._INT2RGB();
	this._RGB2HSL();
};
Color$1.prototype._INTUpdated = function () {
	this._INT2RGB();
	this._RGB2HSL();
	this._INT2HEX();
};

Color$1.prototype._broadcastUpdate = function () {
	this.broadcast(Event.UPDATED);
};

Color$1.prototype.decimal = function (value) {
	return this._handle('_decimal', value, Events.INT_UPDATED);
};

Color$1.prototype.hex = function (value) {
	return this._handle('_hex', value, Events.HEX_UPDATED);
};

Color$1.prototype.red = function (value) {
	return this._handle('_red', value, Events.RGB_UPDATED);
};

Color$1.prototype.green = function (value) {
	return this._handle('_green', value, Events.RGB_UPDATED);
};

Color$1.prototype.blue = function (value) {
	return this._handle('_blue', value, Events.RGB_UPDATED);
};

Color$1.prototype.hue = function (value) {
	return this._handle('_hue', value, Events.HSL_UPDATED);
};

Color$1.prototype.saturation = function (value) {
	return this._handle('_saturation', value, Events.HSL_UPDATED);
};

Color$1.prototype.lightness = function (value) {
	return this._handle('_lightness', value, Events.HSL_UPDATED);
};

Color$1.prototype.brightness = function (value) {
	return this._handle('_brightness', value, Events.HSV_UPDATED);
};

Color$1.prototype.alpha = function (value) {
	return this._handle('_alpha', value);
};

Color$1.prototype._handle = function (prop, value, event) {
	if (typeof this[prop] != 'undefined') {
		if (typeof value != 'undefined') {
			if (value != this[prop]) {
				this[prop] = value;
				if (event) {
					this.broadcast(event);
				}
			}
			this.broadcast(Event.UPDATED);
		}
	}
	return this[prop];
};

Color$1.prototype.getHex = function () {
	return this._hex;
};

Color$1.prototype.getRGB = function () {
	var components = [absround(this._red), absround(this._green), absround(this._blue)];
	return 'rgb(' + components.join(', ') + ')';
};

Color$1.prototype.getPRGB = function () {
	var components = [absround(100 * this._red / 255) + '%', absround(100 * this._green / 255) + '%', absround(100 * this._blue / 255) + '%'];
	return 'rgb(' + components.join(', ') + ')';
};

Color$1.prototype.getRGBA = function () {
	var components = [absround(this._red), absround(this._green), absround(this._blue), this._alpha];
	return 'rgba(' + components.join(', ') + ')';
};

Color$1.prototype.getPRGBA = function () {
	var components = [absround(100 * this._red / 255) + '%', absround(100 * this._green / 255) + '%', absround(100 * this._blue / 255) + '%', this._alpha];
	return 'rgba(' + components.join(', ') + ')';
};

Color$1.prototype.getHSL = function () {
	var components = [absround(this._hue), absround(this._saturation) + '%', absround(this._lightness) + '%'];
	return 'hsl(' + components.join(', ') + ')';
};

Color$1.prototype.getHSLA = function () {
	var components = [absround(this._hue), absround(this._saturation) + '%', absround(this._lightness) + '%', this._alpha];
	return 'hsla(' + components.join(', ') + ')';
};

Color$1.prototype.format = function (string$$1) {
	var tokens = {
		r: this._red,
		g: this._green,
		b: this._blue,
		h: this._hue,
		s: this._saturation,
		l: this._lightness,
		v: this._brightness,
		a: this._alpha,
		x: this._hex,
		d: this._decimal
	};
	for (var token in tokens) {
		string$$1 = string$$1.split('%' + token + '%').join(tokens[token]);
	}
	return string$$1;
};

Color$1.prototype.output = 0;

Color$1.HEX = 0;
Color$1.RGB = 1;
Color$1.PRGB = 2;
Color$1.RGBA = 3;
Color$1.PRGBA = 4;
Color$1.HSL = 5;
Color$1.HSLA = 6;
Color$1.INT = 7;

Color$1.prototype.toString = function () {
	switch (this.output) {
		case 0:
			return this.getHex();
		case 1:
			return this.getRGB();
		case 2:
			return this.getPRGB();
		case 3:
			return this.getRGBA();
		case 4:
			return this.getPRGBA();
		case 5:
			return this.getHSL();
		case 6:
			return this.getHSLA();
		case 7:
			return this._decimal;
	}
	return this.getHex();
};

Color$1.prototype._listeners = null;
Color$1.prototype._isSubscribed = function (type) {
	return this._listeners[type] != null;
};

Color$1.prototype.subscribe = function (type, callback) {
	if (!this._isSubscribed(type)) {
		this._listeners[type] = [];
	}
	this._listeners[type].push(callback);
};

Color$1.prototype.unsubscribe = function (type, callback) {
	if (!this._isSubscribed(type)) {
		return;
	}
	var stack = this._listeners[type];
	for (var i = 0, l = stack.length; i < l; i++) {
		if (stack[i] === callback) {
			stack.splice(i, 1);
			return this.unsubscribe(type, callback);
		}
	}
};

Color$1.prototype.broadcast = function (type, params) {
	if (!this._isSubscribed(type)) {
		return;
	}
	var stack = this._listeners[type];
	var l = stack.length;
	for (var i = 0; i < l; i++) {
		stack[i].apply(this, params);
	}
};

Color$1.prototype.tween = function (duration, color) {
	if (!(color instanceof Color$1)) {
		color = new Color$1(color);
	}
	var start = +new Date();
	var ref = this;
	this.broadcast('tweenStart');
	var interval = setInterval(function () {
		var ellapsed = +new Date() - start;
		var delta = Math.min(1, ellapsed / duration);
		ref.interpolate(color, delta);
		ref.broadcast('tweenProgress');
		if (delta == 1) {
			clearInterval(interval);
			ref.broadcast('tweenComplete');
		}
	}, 20);
	return interval;
};

Color$1.prototype.bind = function (object, property) {
	var ref = this;
	this.subscribe('updated', function () {
		object[property] = ref.toString();
	});
};

Color$1.random = function () {
	return new Color$1(absround(Math.random() * 16777215));
};

Color$1.bind = function (object, property) {
	var color = new Color$1(object[property]);
	color.bind(object, property);
	return color;
};

// adapted from convert-css-length
// MIT licensed, Copyright (c) 2015 Kyle Mathews
// https://github.com/KyleAMathews/convert-css-length/blob/master/LICENSE

var baseFontSize = "16px";
var parseUnit;
var unit;
var unitLess;

if (System.get("@system-env").browser) {
  try {
    var newBaseFontSize = cssLengthParser(16)(window.getComputedStyle(document.body).fontSize);
    if (newBaseFontSize && newBaseFontSize.slice(0, 3) !== "NaN") baseFontSize = newBaseFontSize;
  } catch (e) {}
}

function unit(length) {
  return parseUnit(length)[1];
}

function unitLess(length) {
  return parseUnit(length)[0];
}

function genericCssLengthParser(baseFontSize) {
  if (baseFontSize == null) {
    baseFontSize = baseFontSize;
  }
  return function (length, toUnit, fromContext, toContext) {
    var fromUnit, outputLength, pxLength;
    if (fromContext == null) {
      fromContext = baseFontSize;
    }
    if (toContext == null) {
      toContext = fromContext;
    }
    fromUnit = unit(length);
    if (fromUnit === toUnit) {
      return length;
    }
    pxLength = unitLess(length);
    if (unit(fromContext) !== "px") {
      console.warn("Parameter fromContext must resolve to a value in pixel units.");
    }
    if (unit(toContext) !== "px") {
      console.warn("Parameter toContext must resolve to a value in pixel units.");
    }
    if (fromUnit !== "px") {
      if (fromUnit === "em") {
        pxLength = unitLess(length) * unitLess(fromContext);
      } else if (fromUnit === "rem") {
        pxLength = unitLess(length) * unitLess(baseFontSize);
      } else if (fromUnit === "ex") {
        pxLength = unitLess(length) * unitLess(fromContext) * 2;
      } else if (fromUnit === "ch" || fromUnit === "vw" || fromUnit === "vh" || fromUnit === "vmin") {
        console.warn(fromUnit + " units can't be reliably converted; Returning original value.");
        return length;
      } else {
        console.warn(fromUnit + " is an unknown or unsupported length unit; Returning original value.");
        return length;
      }
    }
    outputLength = pxLength;
    if (toUnit !== "px") {
      if (toUnit === "em") {
        outputLength = pxLength / unitLess(toContext);
      } else if (toUnit === "rem") {
        outputLength = pxLength / unitLess(baseFontSize);
      } else if (toUnit === "ex") {
        outputLength = pxLength / unitLess(toContext) / 2;
      } else if (toUnit === "ch" || toUnit === "vw" || toUnit === "vh" || toUnit === "vmin") {
        console.warn(toUnit + " units can't be reliably converted; Returning original value.");
        return length;
      } else {
        console.warn(toUnit + " is an unknown or unsupported length unit; Returning original value.");
        return length;
      }
    }
    return parseFloat(outputLength.toFixed(5)) + toUnit;
  };
}

var parseCssLength = genericCssLengthParser(baseFontSize);

function cssLengthToPixels(length) {
  return Number(parseCssLength(length, "px").slice(0, -2));
}

var Point = function () {
  createClass(Point, null, [{
    key: "ensure",
    value: function ensure(duck) {
      return duck instanceof Point ? duck : new Point(duck.x, duck.y);
    }
  }, {
    key: "polar",
    value: function polar(r, theta) {
      // theta=0 is East on the screen,
      // increases in counter-clockwise direction
      return new Point(r * Math.cos(theta), r * Math.sin(theta));
    }
  }, {
    key: "random",
    value: function random(scalePt) {
      return new Point(lively_lang.num.randomSmallerInteger(scalePt.x), lively_lang.num.randomSmallerInteger(scalePt.y));
    }
  }, {
    key: "fromLiteral",
    value: function fromLiteral(literal) {
      return pt(literal.x, literal.y);
    }
  }, {
    key: "fromTuple",
    value: function fromTuple(tuple) {
      return pt(tuple[0], tuple[1]);
    }
  }]);

  function Point(x, y) {
    classCallCheck(this, Point);

    this.x = x || 0;
    this.y = y || 0;
  }

  createClass(Point, [{
    key: "getX",


    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // accessing
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    value: function getX() {
      return this.x;
    }
  }, {
    key: "getY",
    value: function getY() {
      return this.y;
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // arithmetic
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "toFixed",
    value: function toFixed(val) {
      return new Point(this.x.toFixed(val), this.y.toFixed(val));
    }
  }, {
    key: "addPt",
    value: function addPt(p) {
      return new Point(this.x + p.x, this.y + p.y);
    }
  }, {
    key: "addXY",
    value: function addXY(dx, dy) {
      return new Point(this.x + dx, this.y + dy);
    }
  }, {
    key: "midPt",
    value: function midPt(p) {
      return new Point((this.x + p.x) / 2, (this.y + p.y) / 2);
    }
  }, {
    key: "subPt",
    value: function subPt(p) {
      return new Point(this.x - p.x, this.y - p.y);
    }
  }, {
    key: "subXY",
    value: function subXY(dx, dy) {
      return new Point(this.x - dx, this.y - dy);
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // transforming
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "scaleBy",
    value: function scaleBy(scaleX, scaleYOrUndefined) {
      return new Point(this.x * scaleX, this.y * (scaleYOrUndefined || scaleX));
    }
  }, {
    key: "scaleByPt",
    value: function scaleByPt(scalePt) {
      return new Point(this.x * scalePt.x, this.y * scalePt.y);
    }
  }, {
    key: "negated",
    value: function negated() {
      return new Point(-this.x, -this.y);
    }
  }, {
    key: "inverted",
    value: function inverted() {
      return new Point(1.0 / this.x, 1.0 / this.y);
    }
  }, {
    key: "invertedSafely",
    value: function invertedSafely() {
      return new Point(this.x && 1.0 / this.x, this.y && 1.0 / this.y);
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // comparing
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "lessPt",
    value: function lessPt(p) {
      return this.x < p.x && this.y < p.y;
    }
  }, {
    key: "leqPt",
    value: function leqPt(p) {
      return this.x <= p.x && this.y <= p.y;
    }
  }, {
    key: "eqPt",
    value: function eqPt(p) {
      return this.x == p.x && this.y == p.y;
    }
  }, {
    key: "equals",
    value: function equals(p) {
      return this.x == p.x && this.y == p.y;
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // instance creation
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "withX",
    value: function withX(x) {
      return pt(x, this.y);
    }
  }, {
    key: "withY",
    value: function withY(y) {
      return pt(this.x, y);
    }
  }, {
    key: "copy",
    value: function copy() {
      return new Point(this.x, this.y);
    }
  }, {
    key: "minPt",
    value: function minPt(p, acc) {
      if (!acc) acc = new Point(0, 0);
      acc.x = Math.min(this.x, p.x);
      acc.y = Math.min(this.y, p.y);
      return acc;
    }
  }, {
    key: "maxPt",
    value: function maxPt(p, acc) {
      if (!acc) acc = new Point(0, 0);
      acc.x = Math.max(this.x, p.x);
      acc.y = Math.max(this.y, p.y);
      return acc;
    }
  }, {
    key: "random",
    value: function random() {
      return Point.random(this);
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // point functions
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "normalized",
    value: function normalized() {
      var r = this.r();
      return pt(this.x / r, this.y / r);
    }
  }, {
    key: "fastNormalized",
    value: function fastNormalized() {
      var r = this.fastR();
      return pt(this.x / r, this.y / r);
    }
  }, {
    key: "dotProduct",
    value: function dotProduct(p) {
      return this.x * p.x + this.y * p.y;
    }
  }, {
    key: "matrixTransform",
    value: function matrixTransform(mx, acc) {
      var x = mx.a * this.x + mx.c * this.y + mx.e,
          y = mx.b * this.x + mx.d * this.y + mx.f;
      // if no accumulator passed, allocate a fresh one
      return !acc ? pt(x, y) : Object.assign(acc, { x: x, y: y });
    }
  }, {
    key: "matrixTransformDirection",
    value: function matrixTransformDirection(mx, acc) {
      var x = mx.a * this.x + mx.c * this.y,
          y = mx.b * this.x + mx.d * this.y;
      // if no accumulator passed, allocate a fresh one
      return !acc ? pt(x, y) : Object.assign(acc, { x: x, y: y });
    }
  }, {
    key: "griddedBy",
    value: function griddedBy(grid) {
      return pt(this.x - this.x % grid.x, this.y - this.y % grid.y);
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // geometry computation
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "roundTo",
    value: function roundTo(quantum) {
      return new Point(lively_lang.num.roundTo(this.x, quantum), lively_lang.num.roundTo(this.y, quantum));
    }
  }, {
    key: "dist",
    value: function dist(p) {
      var dx = this.x - p.x,
          dy = this.y - p.y;
      return Math.sqrt(dx * dx + dy * dy);
    }
  }, {
    key: "distSquared",
    value: function distSquared(p) {
      var dx = this.x - p.x,
          dy = this.y - p.y;
      return dx * dx + dy * dy;
    }
  }, {
    key: "nearestPointOnLineBetween",
    value: function nearestPointOnLineBetween(p1, p2) {
      if (p1.x == p2.x) return pt(p1.x, this.y);
      if (p1.y == p2.y) return pt(this.x, p1.y);
      var x1 = p1.x,
          y1 = p1.y,
          x21 = p2.x - x1,
          y21 = p2.y - y1,
          t = ((this.y - y1) / x21 + (this.x - x1) / y21) / (x21 / y21 + y21 / x21);
      return pt(x1 + t * x21, y1 + t * y21);
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // polar coordinates
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "r",
    value: function r() {
      // Polar coordinates (theta=0 is East on screen, and increases in CCW
      // direction
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
  }, {
    key: "fastR",
    value: function fastR() {
      // actually, r() might be faster...
      var a = this.x * this.x + this.y * this.y;
      var x = 17;
      for (var i = 0; i < 6; i++) {
        x = (x + a / x) / 2;
      }return x;
    }
  }, {
    key: "theta",
    value: function theta() {
      return Math.atan2(this.y, this.x);
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // converting
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "asRectangle",
    value: function asRectangle() {
      return new Rectangle(this.x, this.y, 0, 0);
    }
  }, {
    key: "extent",
    value: function extent(ext) {
      return new Rectangle(this.x, this.y, ext.x, ext.y);
    }
  }, {
    key: "extentAsRectangle",
    value: function extentAsRectangle() {
      return new Rectangle(0, 0, this.x, this.y);
    }
  }, {
    key: "lineTo",
    value: function lineTo(end) {
      return new Line(this, end);
    }
  }, {
    key: "toTuple",
    value: function toTuple() {
      return [this.x, this.y];
    }
  }, {
    key: "toLiteral",
    value: function toLiteral() {
      return { x: this.x, y: this.y };
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // debugging
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "toString",
    value: function toString() {
      return lively_lang.string.format("pt(%1.f,%1.f)", this.x, this.y);
    }
  }, {
    key: "inspect",
    value: function inspect() {
      return JSON.stringify(this);
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // serialization
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "__serialize__",
    value: function __serialize__() {
      return { __expr__: this.toString(), bindings: { "lively.graphics/geometry-2d.js": ["pt"] } };
    }
  }, {
    key: "isPoint",
    get: function get() {
      return true;
    }
  }]);
  return Point;
}();

var Rectangle = function () {
  createClass(Rectangle, [{
    key: "corners",


    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    //  initialize
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    get: function get() {
      return ["topLeft", "topRight", "bottomRight", "bottomLeft"];
    }
  }, {
    key: "sides",
    get: function get() {
      return ["leftCenter", "rightCenter", "topCenter", "bottomCenter"];
    }
  }], [{
    key: "fromAny",


    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // factory methods
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

    value: function fromAny(ptA, ptB) {
      return rect(ptA.minPt(ptB), ptA.maxPt(ptB));
    }
  }, {
    key: "fromLiteral",
    value: function fromLiteral(literal) {
      return new Rectangle(literal.x, literal.y, literal.width, literal.height);
    }
  }, {
    key: "fromTuple",
    value: function fromTuple(tuple) {
      return new Rectangle(tuple[0], tuple[1], tuple[2], tuple[3]);
    }
  }, {
    key: "unionPts",
    value: function unionPts(points) {
      var min = points[0],
          max = points[0];

      // starts from 1 intentionally
      for (var i = 1; i < points.length; i++) {
        min = min.minPt(points[i]);
        max = max.maxPt(points[i]);
      }

      return rect(min, max);
    }
  }, {
    key: "ensure",
    value: function ensure(duck) {
      return duck instanceof Rectangle ? duck : new Rectangle(duck.x, duck.y, duck.width, duck.height);
    }
  }, {
    key: "fromElement",
    value: function fromElement(element) {
      // FIXME
      if (typeof element.getBoundingClientRect === "function") {
        var b = element.getBoundingClientRect();
        return rect(b.left, b.top, b.width, b.height);
      } else if (element.namespaceURI == "http://www.w3.org/1999/xhtml") {
        var x = cssLengthToPixels(element.style.left || "0px"),
            y = cssLengthToPixels(element.style.top || "0px"),
            width = cssLengthToPixels(element.style.width || "0px"),
            height = cssLengthToPixels(element.style.hieght || "0px");
        return new Rectangle(x, y, width, height);
      }
      if (element.namespaceURI == "http://www.w3.org/2000/svg") {
        return new Rectangle(element.x.baseVal.value, element.y.baseVal.value, element.width.baseVal.value, element.height.baseVal.value);
      }
      throw new Error('Cannot create Rectangle from ' + element);
    }
  }, {
    key: "inset",
    value: function inset(left, top, right, bottom) {
      if (top === undefined) top = left;
      if (right === undefined) right = left;
      if (bottom === undefined) bottom = top;
      return new Rectangle(left, top, right - left, bottom - top);
    }
  }]);

  function Rectangle(x, y, w, h) {
    classCallCheck(this, Rectangle);

    this.x = x || 0;
    this.y = y || 0;
    this.width = w || 0;
    this.height = h || 0;
  }

  createClass(Rectangle, [{
    key: "getX",


    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // accessing
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    value: function getX() {
      return this.x;
    }
  }, {
    key: "getY",
    value: function getY() {
      return this.y;
    }
  }, {
    key: "getWidth",
    value: function getWidth() {
      return this.width;
    }
  }, {
    key: "getHeight",
    value: function getHeight() {
      return this.height;
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // instance creation
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "copy",
    value: function copy() {
      return new Rectangle(this.x, this.y, this.width, this.height);
    }
  }, {
    key: "toFixed",
    value: function toFixed(val) {
      return new Rectangle(this.x.toFixed(val), this.y.toFixed(val), this.width.toFixed(val), this.height.toFixed(val));
    }
  }, {
    key: "withWidth",
    value: function withWidth(w) {
      return new Rectangle(this.x, this.y, w, this.height);
    }
  }, {
    key: "withHeight",
    value: function withHeight(h) {
      return new Rectangle(this.x, this.y, this.width, h);
    }
  }, {
    key: "withX",
    value: function withX(x) {
      return new Rectangle(x, this.y, this.width, this.height);
    }
  }, {
    key: "withY",
    value: function withY(y) {
      return new Rectangle(this.x, y, this.width, this.height);
    }
  }, {
    key: "withExtent",
    value: function withExtent(ext) {
      return new Rectangle(this.x, this.y, ext.x, ext.y);
    }
  }, {
    key: "withTopLeft",
    value: function withTopLeft(p) {
      return Rectangle.fromAny(p, this.bottomRight());
    }
  }, {
    key: "withTopRight",
    value: function withTopRight(p) {
      return Rectangle.fromAny(this.bottomLeft(), p);
    }
  }, {
    key: "withBottomRight",
    value: function withBottomRight(p) {
      return Rectangle.fromAny(p, this.topLeft());
    }
  }, {
    key: "withBottomLeft",
    value: function withBottomLeft(p) {
      return Rectangle.fromAny(p, this.topRight());
    }
  }, {
    key: "withLeftCenter",
    value: function withLeftCenter(p) {
      return new Rectangle(p.x, this.y, this.width + (this.x - p.x), this.height);
    }
  }, {
    key: "withRightCenter",
    value: function withRightCenter(p) {
      return new Rectangle(this.x, this.y, p.x - this.x, this.height);
    }
  }, {
    key: "withTopCenter",
    value: function withTopCenter(p) {
      return new Rectangle(this.x, p.y, this.width, this.height + (this.y - p.y));
    }
  }, {
    key: "withBottomCenter",
    value: function withBottomCenter(p) {
      return new Rectangle(this.x, this.y, this.width, p.y - this.y);
    }
  }, {
    key: "withCenter",
    value: function withCenter(p) {
      return new Rectangle(p.x - this.width / 2, p.y - this.height / 2, this.width, this.height);
    }
  }, {
    key: "insetBy",
    value: function insetBy(d) {
      return new Rectangle(this.x + d, this.y + d, this.width - d * 2, this.height - d * 2);
    }
  }, {
    key: "insetByPt",
    value: function insetByPt(p) {
      return new Rectangle(this.x + p.x, this.y + p.y, this.width - p.x * 2, this.height - p.y * 2);
    }
  }, {
    key: "grid",
    value: function grid(rows, cols) {
      var w = this.width / cols,
          h = this.height / rows;
      return lively_lang.grid.mapCreate(rows, cols, function (i, j) {
        return new Rectangle(w * j, h * i, w, h);
      });
    }
  }, {
    key: "divide",
    value: function divide(relativeRects) {
      // takes an array of rectangles specifying the relative parts to divide
      // this by. Example:
      // rect(0,0,100,50).divide([rect(0.2,0,0.3,0.5)])
      //   === [rect(20,0,30,25)]
      var orig = this;
      return relativeRects.map(function (relRect) {
        return rect(orig.x + orig.width * relRect.x, orig.y + orig.height * relRect.y, orig.width * relRect.width, orig.height * relRect.height);
      });
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // converting
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "toTuple",
    value: function toTuple() {
      return [this.x, this.y, this.width, this.height];
    }
  }, {
    key: "lineTo",
    value: function lineTo(otherRect) {
      var center1 = this.center(),
          center2 = otherRect.center(),
          lineBetween = center1.lineTo(center2),
          start = this.lineIntersection(lineBetween)[0],
          end = otherRect.lineIntersection(lineBetween)[0];
      return start && end && start.lineTo(end);
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // comparing
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "equals",
    value: function equals(other) {
      if (!other) {
        return false;
      }
      return this.x == other.x && this.y == other.y && this.width == other.width && this.height == other.height;
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // debugging
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "inspect",
    value: function inspect() {
      return JSON.stringify(this);
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // accessing
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "topLeft",
    value: function topLeft() {
      return new Point(this.x, this.y);
    }
  }, {
    key: "topRight",
    value: function topRight() {
      return new Point(this.maxX(), this.y);
    }
  }, {
    key: "bottomRight",
    value: function bottomRight() {
      return new Point(this.maxX(), this.maxY());
    }
  }, {
    key: "bottomLeft",
    value: function bottomLeft() {
      return new Point(this.x, this.maxY());
    }
  }, {
    key: "leftCenter",
    value: function leftCenter() {
      return new Point(this.x, this.center().y);
    }
  }, {
    key: "rightCenter",
    value: function rightCenter() {
      return new Point(this.maxX(), this.center().y);
    }
  }, {
    key: "topCenter",
    value: function topCenter() {
      return new Point(this.center().x, this.y);
    }
  }, {
    key: "bottomCenter",
    value: function bottomCenter() {
      return new Point(this.center().x, this.maxY());
    }
  }, {
    key: "extent",
    value: function extent() {
      return new Point(this.width, this.height);
    }
  }, {
    key: "center",
    value: function center() {
      return new Point(this.x + this.width / 2, this.y + this.height / 2);
    }
  }, {
    key: "topEdge",
    value: function topEdge() {
      return new Line(this.topLeft(), this.topRight());
    }
  }, {
    key: "bottomEdge",
    value: function bottomEdge() {
      return new Line(this.bottomLeft(), this.bottomRight());
    }
  }, {
    key: "leftEdge",
    value: function leftEdge() {
      return new Line(this.topLeft(), this.bottomLeft());
    }
  }, {
    key: "rightEdge",
    value: function rightEdge() {
      return new Line(this.topRight(), this.bottomRight());
    }
  }, {
    key: "edges",
    value: function edges() {
      return [this.topEdge(), this.rightEdge(), this.bottomEdge(), this.leftEdge()];
    }
  }, {
    key: "allPoints",
    value: function allPoints() {
      // take rectangle as discrete grid and return all points in the grid
      // rect(3,4,2,3).allPoints() == [pt(3,4),pt(4,4),pt(3,5),pt(4,5),pt(3,6),pt(4,6)]
      // if you want to convert points to indices use
      // var w = 5, h = 7; rect(3,4,2,3).allPoints().map(function(p) { return p.y * w + p.x; }) == [23,24,28,29,33,34]
      var x = this.x,
          y = this.y,
          w = this.width,
          h = this.height,
          points = [];
      for (var j = y; j < y + h; j++) {
        for (var i = x; i < x + w; i++) {
          points.push(pt(i, j));
        }
      }return points;
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // testing
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "isNonEmpty",
    value: function isNonEmpty(rect) {
      return this.width > 0 && this.height > 0;
    }
  }, {
    key: "containsRect",
    value: function containsRect(r) {
      return this.x <= r.x && this.y <= r.y && r.maxX() <= this.maxX() && r.maxY() <= this.maxY();
    }
  }, {
    key: "intersects",
    value: function intersects(r) {
      return this.intersection(r).isNonEmpty();
    }
  }, {
    key: "containsPoint",
    value: function containsPoint(p) {
      return this.x <= p.x && p.x <= this.x + this.width && this.y <= p.y && p.y <= this.y + this.height;
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // transforming
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "translatedBy",
    value: function translatedBy(d) {
      return new Rectangle(this.x + d.x, this.y + d.y, this.width, this.height);
    }
  }, {
    key: "scaleByRect",
    value: function scaleByRect(r) {
      // r is a relative rect, as a pane spec in a window
      return new Rectangle(this.x + r.x * this.width, this.y + r.y * this.height, r.width * this.width, r.height * this.height);
    }
  }, {
    key: "scaleRectIn",
    value: function scaleRectIn(fullRect) {
      // return a relative rect for this as a part of fullRect
      return new Rectangle((this.x - fullRect.x) / fullRect.width, (this.y - fullRect.y) / fullRect.height, this.width / fullRect.width, this.height / fullRect.height);
    }
  }, {
    key: "scaleRectTo",
    value: function scaleRectTo(fullRect) {
      // scale the rect until it reaches the bounds of the full rect
      var height, width, scale;
      if (this.width > this.height) {
        width = this.width;
      } else {
        height = this.height;
      }

      if (width) {
        scale = fullRect.width / width;
      } else {
        scale = fullRect.height / height;
      }

      return this.withExtent(this.extent().scaleBy(scale)).withCenter(this.center());
    }
  }, {
    key: "expandBy",
    value: function expandBy(delta) {
      return this.insetBy(0 - delta);
    }
  }, {
    key: "translateForInclusion",
    value: function translateForInclusion(other) {
      var x = other.x,
          y = other.y,
          r = x + other.width,
          b = y + other.height;
      if (r > this.right()) x -= r - this.right();
      if (b > this.bottom()) y -= b - this.bottom();
      if (x < this.x) x = this.x;
      if (y < this.y) y = this.y;
      return rect(x, y, other.width, other.height);
    }
  }, {
    key: "transformRectForInclusion",
    value: function transformRectForInclusion(other) {
      var topLeft = this.topLeft().maxPt(other.topLeft()),
          newBottomRight = topLeft.addPt(other.extent()),
          innerBottomRight = this.bottomRight().minPt(newBottomRight);
      return rect(topLeft, innerBottomRight);
    }
  }, {
    key: "insetByRect",
    value: function insetByRect(r) {
      return new Rectangle(this.x + r.left(), this.y + r.top(), this.width - (r.left() + r.right()), this.height - (r.top() + r.bottom()));
    }
  }, {
    key: "outsetByRect",
    value: function outsetByRect(r) {
      return new Rectangle(this.x - r.left(), this.y - r.top(), this.width + (r.left() + r.right()), this.height + (r.top() + r.bottom()));
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // relations
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "intersection",
    value: function intersection(rect) {
      var nx = Math.max(this.x, rect.x);
      var ny = Math.max(this.y, rect.y);
      var nw = Math.min(this.x + this.width, rect.x + rect.width) - nx;
      var nh = Math.min(this.y + this.height, rect.y + rect.height) - ny;
      return new Rectangle(nx, ny, nw, nh);
    }
  }, {
    key: "union",
    value: function union(r) {
      return rect(this.topLeft().minPt(r.topLeft()), this.bottomRight().maxPt(r.bottomRight()));
    }
  }, {
    key: "lineIntersection",
    value: function lineIntersection(line) {
      return this.edges().map(function (edge) {
        return edge.intersection(line);
      }).filter(function (ea) {
        return !!ea;
      });
    }
  }, {
    key: "dist",
    value: function dist(rect) {
      var p1 = this.closestPointToPt(rect.center());
      var p2 = rect.closestPointToPt(p1);
      return p1.dist(p2);
    }
  }, {
    key: "relativeToAbsPoint",
    value: function relativeToAbsPoint(relPt) {
      return new Point(this.x + this.width * relPt.x, this.y + this.height * relPt.y);
    }
  }, {
    key: "closestPointToPt",
    value: function closestPointToPt(p) {
      // Assume p lies outside me; return a point on my perimeter
      return pt(Math.min(Math.max(this.x, p.x), this.maxX()), Math.min(Math.max(this.y, p.y), this.maxY()));
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // properties
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "maxX",
    value: function maxX() {
      return this.x + this.width;
    }
  }, {
    key: "maxY",
    value: function maxY() {
      return this.y + this.height;
    }
  }, {
    key: "realWidth",
    value: function realWidth() {
      return this.x < 0 ? -this.x + this.width : this.width;
    }
  }, {
    key: "realHeight",
    value: function realHeight() {
      return this.y < 0 ? -this.y + this.height : this.height;
    }
  }, {
    key: "area",
    value: function area() {
      var area = this.width * this.height,
          sign = this.width < 0 && this.height < 0 ? -1 : 1;
      return sign * area;
    }
  }, {
    key: "randomPoint",
    value: function randomPoint() {
      return Point.random(pt(this.width, this.height)).addPt(this.topLeft());
    }
  }, {
    key: "constrainPt",
    value: function constrainPt(pt) {
      return pt.maxPt(this.topLeft()).minPt(this.bottomRight());
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // SVG interface
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // modeled after the CSS box model: http://www.w3.org/TR/REC-CSS2/box.html

  }, {
    key: "left",
    value: function left() {
      return this.x;
    }
  }, {
    key: "right",
    value: function right() {
      return this.maxX();
    }
  }, {
    key: "top",
    value: function top() {
      return this.y;
    }
  }, {
    key: "bottom",
    value: function bottom() {
      return this.maxY();
    }
  }, {
    key: "toInsetTuple",
    value: function toInsetTuple() {
      return [this.left(), this.top(), this.right(), this.bottom()];
    }
  }, {
    key: "toAttributeValue",
    value: function toAttributeValue(d) {
      var d = 0.01,
          result = [this.left()];
      if (this.top() === this.bottom() && this.left() === this.right()) {
        if (this.top() === this.left()) result.push(this.top());
      } else result = result.concat([this.top(), this.right(), this.bottom()]);
      return result.invoke('roundTo', d || 0.01);
    }
  }, {
    key: "toLiteral",
    value: function toLiteral() {
      return { x: this.x, y: this.y, width: this.width, height: this.height };
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // part support
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "partNamed",
    value: function partNamed(partName) {
      return this[partName].call(this);
    }
  }, {
    key: "withPartNamed",
    value: function withPartNamed(partName, newValue) {
      return this[this.setterName(partName)].call(this, newValue);
    }
  }, {
    key: "setterName",
    value: function setterName(partName) {
      return "with" + partName[0].toUpperCase() + partName.slice(1);
    }
  }, {
    key: "partNameNear",
    value: function partNameNear(partNames, p, dist) {
      var partName = this.partNameNearest(partNames, p);
      return p.dist(this.partNamed(partName)) < dist ? partName : null;
    }
  }, {
    key: "partNameNearest",
    value: function partNameNearest(partNames, p) {
      var dist = 1.0e99,
          partName = partNames[0];

      for (var i = 0; i < partNames.length; i++) {
        var partName = partNames[i],
            pDist = p.dist(this.partNamed(partName));
        if (pDist < dist) {
          var nearest = partName;dist = pDist;
        }
      }

      return nearest;
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // printing
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "toString",
    value: function toString() {
      return lively_lang.string.format("rect(%s,%s,%s,%s)", this.x, this.y, this.width, this.height);
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // serialization
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "__serialize__",
    value: function __serialize__() {
      return { __expr__: this.toString(), bindings: { "lively.graphics/geometry-2d.js": ["rect"] } };
    }
  }, {
    key: "isRectangle",
    get: function get() {
      return true;
    }
  }]);
  return Rectangle;
}();

var Transform = function () {
  createClass(Transform, [{
    key: "exp",
    get: function get() {
      return 0.0001; /*precision*/
    }
  }]);

  function Transform(translation, rotation, scale) {
    classCallCheck(this, Transform);

    // matrix is a duck with a,b,c,d,e,f, could be an SVG matrix or a
    // Lively Transform
    // alternatively, its a combination of translation rotation and scale
    if (translation) {
      if (translation instanceof Point) {
        var delta = translation,
            angleInRadians = rotation || 0.0,
            scale = scale;
        if (scale === undefined) {
          scale = pt(1.0, 1.0);
        }
        this.a = this.ensureNumber(scale.x * Math.cos(angleInRadians));
        this.b = this.ensureNumber(scale.y * Math.sin(angleInRadians));
        this.c = this.ensureNumber(scale.x * -Math.sin(angleInRadians));
        this.d = this.ensureNumber(scale.y * Math.cos(angleInRadians));
        this.e = this.ensureNumber(delta.x);
        this.f = this.ensureNumber(delta.y);

        // avoid inaccurate translations in Chrome
        if (this.a > 1) this.a = Math.round(this.a * Math.pow(10, 2)) / Math.pow(10, 2);
        if (this.d > 1) this.d = Math.round(this.d * Math.pow(10, 2)) / Math.pow(10, 2);
      } else {
        this.fromMatrix(translation);
      }
    } else {
      this.a = this.d = 1.0;
      this.b = this.c = this.e = this.f = 0.0;
    }
  }

  createClass(Transform, [{
    key: "copy",
    value: function copy() {
      return new Transform(this);
    }
  }, {
    key: "fromMatrix",
    value: function fromMatrix(mx) {
      this.a = this.ensureNumber(mx.a);
      this.b = this.ensureNumber(mx.b);
      this.c = this.ensureNumber(mx.c);
      this.d = this.ensureNumber(mx.d);
      this.e = this.ensureNumber(mx.e);
      this.f = this.ensureNumber(mx.f);
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // accessing
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "getRotation",
    value: function getRotation() {
      // in degrees
      // Note the ambiguity with negative scales is resolved by assuming
      // scale x is positive
      var r = lively_lang.num.toDegrees(Math.atan2(-this.c, this.a));

      // don't bother with values very close to 0
      return Math.abs(r) < this.eps ? 0 : r;
    }
  }, {
    key: "getScale",
    value: function getScale() {
      // Note the ambiguity with negative scales and rotation is resolved by assuming scale x is positive
      var a = this.a,
          c = this.c,
          s = Math.sqrt(a * a + c * c);

      // don't bother with values very close to 1
      return Math.abs(s - 1) < this.eps ? 1 : s;
    }
  }, {
    key: "getScalePoint",
    value: function getScalePoint() {
      // Note the ambiguity with negative scales and rotation is resolved by
      // assuming scale x is positive
      var a = this.a,
          b = this.b,
          c = this.c,
          d = this.d,
          sx = Math.sqrt(a * a + c * c),
          r = Math.atan2(-c, a),
          // radians
      // avoid div by 0
      sy = Math.abs(b) > Math.abs(d) ? b / Math.sin(r) : d / Math.cos(r);
      return pt(sx, sy);
    }
  }, {
    key: "getTranslation",
    value: function getTranslation() {
      return pt(this.e, this.f);
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // testing
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "isTranslation",
    value: function isTranslation() {
      // as specified in:
      // http://www.w3.org/TR/SVG11/coords.html#InterfaceSVGTransform
      return this.a == 1 && this.b == 0 && this.c == 0 && this.d == 1;
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // converting
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "toSVGAttributeValue",
    value: function toSVGAttributeValue() {
      var delta = this.getTranslation(),
          attr = "translate(" + delta.x + "," + delta.y + ")",
          theta = this.getRotation(),
          sp = this.getScalePoint();

      if (theta != 0.0) attr += " rotate(" + this.getRotation() + ")"; // in degrees
      if (sp.x != 1.0 || sp.y != 1.0) attr += " scale(" + sp.x + "," + sp.y + ")";

      return attr;
    }
  }, {
    key: "toCSSValue",
    value: function toCSSValue(bounds) {
      var attr = '',
          delta = this.getTranslation();

      attr += "translate(" + delta.x.toFixed(2) + "px," + delta.y.toFixed(2) + "px)";

      if (bounds) {
        // FIXME this is to fix the rotation...!
        var offsetX = bounds.width / 2;
        var offsetY = bounds.height / 2;
        attr += " translate(" + offsetX.toFixed(2) + "px," + offsetY.toFixed(2) + "px)";
      }

      var theta = this.getRotation();
      if (theta != 0.0) attr += " rotate(" + this.getRotation().toFixed(2) + "deg)";

      if (bounds) {
        // FIXME this is to fix the rotation...!
        var offsetX = bounds.width / 2;
        var offsetY = bounds.height / 2;
        attr += " translate(" + (offsetX * -1).toFixed(2) + "px," + (offsetY * -1).toFixed(2) + "px)";
      }

      var sp = this.getScalePoint();
      if (sp.x != 1.0 || sp.y != 1.0) {
        attr += " scale(" + sp.x.toFixed(2) + "," + sp.y.toFixed(2) + ")";
      }

      return attr;
    }
  }, {
    key: "toCSSTransformString",
    value: function toCSSTransformString() {
      var rot = this.getRotation(),
          scale = this.getScale();
      return "translate(" + this.e + "px," + this.f + "px) rotate(" + rot + "deg) scale(" + scale + "," + scale + ")";
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.toCSSTransformString();
    }
  }, {
    key: "toMatrix",
    value: function toMatrix() {
      return this.copy();
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // transforming
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "transformPoint",
    value: function transformPoint(p, acc) {
      return p.matrixTransform(this, acc);
    }
  }, {
    key: "transformDirection",
    value: function transformDirection(p, acc) {
      return p.matrixTransformDirection(this, acc);
    }
  }, {
    key: "matrixTransformForMinMax",
    value: function matrixTransformForMinMax(pt, minPt, maxPt) {
      var x = this.a * pt.x + this.c * pt.y + this.e,
          y = this.b * pt.x + this.d * pt.y + this.f;
      if (x > maxPt.x) maxPt.x = x;
      if (y > maxPt.y) maxPt.y = y;
      if (x < minPt.x) minPt.x = x;
      if (y < minPt.y) minPt.y = y;
    }
  }, {
    key: "transformRectToRect",
    value: function transformRectToRect(r) {
      var minPt = pt(Infinity, Infinity),
          maxPt = pt(-Infinity, -Infinity);
      this.matrixTransformForMinMax(r.topLeft(), minPt, maxPt);
      this.matrixTransformForMinMax(r.bottomRight(), minPt, maxPt);
      if (!this.isTranslation()) {
        this.matrixTransformForMinMax(r.topRight(), minPt, maxPt);
        this.matrixTransformForMinMax(r.bottomLeft(), minPt, maxPt);
      }
      return rect(minPt, maxPt);
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // matrix operations
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "preConcatenate",
    value: function preConcatenate(t) {
      var m = this.matrix_ || this.toMatrix();
      this.a = t.a * m.a + t.c * m.b;
      this.b = t.b * m.a + t.d * m.b;
      this.c = t.a * m.c + t.c * m.d;
      this.d = t.b * m.c + t.d * m.d;
      this.e = t.a * m.e + t.c * m.f + t.e;
      this.f = t.b * m.e + t.d * m.f + t.f;
      this.matrix_ = this.toMatrix();
      return this;
    }
  }, {
    key: "invert",
    value: function invert() {
      var m = this.copy();

      var det = m.a * m.d - m.c * m.b,
          invdet = 1 / det;

      this.a = m.d * invdet;
      this.b = -m.b * invdet;
      this.c = -m.c * invdet;
      this.d = m.a * invdet;
      this.e = (m.c * m.f - m.e * m.d) * invdet;
      this.f = -(m.a * m.f - m.b * m.e) * invdet;

      return this;
    }
  }, {
    key: "inverse",
    value: function inverse() {
      var matrix = this.matrix_ || this.toMatrix();
      var result = new this.constructor(matrix);
      result.invert();
      return result;
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // helper
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "ensureNumber",
    value: function ensureNumber(value) {
      // note that if a,b,.. f are not numbers, it's usually a
      // problem, which may crash browsers (like Safari) that don't
      // do good typechecking of SVGMatrix properties
      if (isNaN(value)) {
        throw new Error('not a number');
      }
      return value;
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // serialization
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "__serialize__",
    value: function __serialize__() {
      return {
        __expr__: "new Transform({a: " + this.a + ", b: " + this.b + ", c: " + this.c + ", d: " + this.d + ", e: " + this.e + ", f: " + this.f + "})",
        bindings: { "lively.graphics/geometry-2d.js": ["Transform"] }
      };
    }
  }, {
    key: "isTransform",
    get: function get() {
      return true;
    }
  }]);
  return Transform;
}();

var Line = function () {
  createClass(Line, null, [{
    key: "fromCoords",
    value: function fromCoords(startX, startY, endX, endY) {
      return new Line(pt(startX, startY), pt(endX, endY));
    }
  }]);

  function Line(start, end) {
    classCallCheck(this, Line);

    this.start = start;
    this.end = end;
  }

  createClass(Line, [{
    key: "sampleN",


    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // accessing
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    value: function sampleN(n) {
      // return n points that are collinear with this and are between
      // this.start and this.end
      n = n || 10;
      var vector = this.end.subPt(this.start),
          stepPt = vector.scaleBy(1 / n),
          result = [];
      for (var i = 0; i <= n; i++) {
        result.push(this.start.addPt(stepPt.scaleBy(i)));
      }
      return result;
    }
  }, {
    key: "sample",
    value: function sample(length) {
      return this.sampleN(this.length() / length);
    }
  }, {
    key: "length",
    value: function length() {
      return this.start.dist(this.end);
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // testing
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "equals",
    value: function equals(otherLine) {
      if (!otherLine) return false;
      return this.start.eqPt(otherLine.start) && this.end.eqPt(otherLine.end);
    }
  }, {
    key: "includesPoint",
    value: function includesPoint(p, unconstrained) {
      // test whether p is collinear with this.start, this.end
      // constrained: p also needs to be on segment between start, end
      var x1 = this.start.x,
          y1 = this.start.y,
          x2 = this.end.x,
          y2 = this.end.y,
          x3 = p.x,
          y3 = p.y,
          collinear = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1) === 0;
      if (unconstrained || !collinear) return collinear;
      var xMin = Math.min(x1, x2),
          yMin = Math.min(y1, y2),
          xMax = Math.max(x1, x2),
          yMax = Math.max(y1, y2);
      return xMin <= x3 && x3 <= xMax && yMin <= y3 && y3 <= yMax;
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // intersection
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "intersection",
    value: function intersection(otherLine, unconstrained) {
      // constrained: intersection has to be between start/ends of this and
      // otherLine
      // http://en.wikipedia.org/wiki/Line-line_intersection
      //       .. (x1, y1)
      //         ..              ..... (x4,y4)
      //           ..    ........
      // (x3,y3) .....X..
      //    .....      ..
      //                 ..  (x2, y2)
      var eps = 0.0001,
          start1 = this.start,
          end1 = this.end,
          start2 = otherLine.start,
          end2 = otherLine.end,
          x1 = start1.x,
          y1 = start1.y,
          x2 = end1.x,
          y2 = end1.y,
          x3 = start2.x,
          y3 = start2.y,
          x4 = end2.x,
          y4 = end2.y;

      var x = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / ((x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)),
          y = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / ((x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4));

      // are lines parallel?
      if (x === Infinity || y === Infinity) return null;

      if (!unconstrained) {
        if (!lively_lang.num.between(x, x1, x2, eps) || !lively_lang.num.between(y, y1, y2, eps) || !lively_lang.num.between(x, x3, x4, eps) || !lively_lang.num.between(y, y3, y4, eps)) return null;
      }

      return pt(x, y);
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // debugging
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "toString",
    value: function toString() {
      return lively_lang.string.format('Line((%s,%s), (%s,%s))', this.start.x, this.start.y, this.end.x, this.end.y);
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // serialization
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "__serialize__",
    value: function __serialize__() {
      return {
        __expr__: "Line.fromCoords(" + this.start.x + ", " + this.start.y + ", " + this.end.x + ", " + this.end.y + ")",
        bindings: { "lively.graphics/geometry-2d.js": ["Line"] }
      };
    }
  }, {
    key: "isLine",
    get: function get() {
      return true;
    }
  }]);
  return Line;
}();

function rect(arg1, arg2, arg3, arg4) {
  // arg1 and arg2 can be location and corner or
  // arg1/arg2 = location x/y and arg3/arg4 = extent x/y
  var x, y, w, h;
  if (typeof arg1 === 'number') {
    x = arg1, y = arg2, w = arg3, h = arg4;
  } else {
    x = arg1.x;y = arg1.y;
    w = arg2.x - x;h = arg2.y - y;
  }
  return new Rectangle(x, y, w, h);
}

function pt(x, y) {
  return new Point(x, y);
}

function floor(x) {
  return Math.floor(x * 255.99);
}

var rgbaRegex = new RegExp('\\s*rgba?\\s*\\(\\s*(\\d+)(%?)\\s*,\\s*(\\d+)(%?)\\s*,\\s*(\\d+)(%?)\\s*(?:,\\s*([0-9\\.]+)\\s*)?\\)\\s*');

var ColorHarmony = function () {
  function ColorHarmony() {
    classCallCheck(this, ColorHarmony);
  }

  createClass(ColorHarmony, null, [{
    key: "offsets",
    value: function offsets() {
      return null;
    }
  }, {
    key: "stepCount",
    value: function stepCount() {
      return 0;
    }
  }, {
    key: "stepSize",
    value: function stepSize() {
      return 0;
    }
  }, {
    key: "chord",
    value: function chord(_ref) {
      var _this = this;

      var hue = _ref.hue,
          saturation = _ref.saturation,
          brightness = _ref.brightness;

      var offsets = this.offsets() || lively_lang.arr.range(0, this.steps()).map(function (i) {
        return i * _this.stepSize();
      });
      return offsets.map(function (offset) {
        return Color.hsb(hue + offset % 360, saturation, brightness);
      });
    }
  }, {
    key: "name",
    get: function get() {
      return "Color Harmony";
    }
  }]);
  return ColorHarmony;
}();

var Complementary = function (_ColorHarmony) {
  inherits(Complementary, _ColorHarmony);

  function Complementary() {
    classCallCheck(this, Complementary);
    return possibleConstructorReturn(this, (Complementary.__proto__ || Object.getPrototypeOf(Complementary)).apply(this, arguments));
  }

  createClass(Complementary, null, [{
    key: "steps",
    value: function steps() {
      return 1;
    }
  }, {
    key: "stepSize",
    value: function stepSize() {
      return 180;
    }
  }, {
    key: "name",
    get: function get() {
      return "Complement";
    }
  }]);
  return Complementary;
}(ColorHarmony);

var Triadic = function (_ColorHarmony2) {
  inherits(Triadic, _ColorHarmony2);

  function Triadic() {
    classCallCheck(this, Triadic);
    return possibleConstructorReturn(this, (Triadic.__proto__ || Object.getPrototypeOf(Triadic)).apply(this, arguments));
  }

  createClass(Triadic, null, [{
    key: "steps",
    value: function steps() {
      return 2;
    }
  }, {
    key: "stepSize",
    value: function stepSize() {
      return 120;
    }
  }, {
    key: "name",
    get: function get() {
      return "Triadic";
    }
  }]);
  return Triadic;
}(ColorHarmony);

var Tetradic = function (_ColorHarmony3) {
  inherits(Tetradic, _ColorHarmony3);

  function Tetradic() {
    classCallCheck(this, Tetradic);
    return possibleConstructorReturn(this, (Tetradic.__proto__ || Object.getPrototypeOf(Tetradic)).apply(this, arguments));
  }

  createClass(Tetradic, null, [{
    key: "offsets",
    value: function offsets() {
      return [0, 60, 180, 240];
    }
  }, {
    key: "name",
    get: function get() {
      return "Tetradic";
    }
  }]);
  return Tetradic;
}(ColorHarmony);

var Quadratic = function (_ColorHarmony4) {
  inherits(Quadratic, _ColorHarmony4);

  function Quadratic() {
    classCallCheck(this, Quadratic);
    return possibleConstructorReturn(this, (Quadratic.__proto__ || Object.getPrototypeOf(Quadratic)).apply(this, arguments));
  }

  createClass(Quadratic, null, [{
    key: "steps",
    value: function steps() {
      return 3;
    }
  }, {
    key: "stepSize",
    value: function stepSize() {
      return 90;
    }
  }, {
    key: "name",
    get: function get() {
      return "Quadratic";
    }
  }]);
  return Quadratic;
}(ColorHarmony);

var Analogous = function (_ColorHarmony5) {
  inherits(Analogous, _ColorHarmony5);

  function Analogous() {
    classCallCheck(this, Analogous);
    return possibleConstructorReturn(this, (Analogous.__proto__ || Object.getPrototypeOf(Analogous)).apply(this, arguments));
  }

  createClass(Analogous, null, [{
    key: "steps",
    value: function steps() {
      return 5;
    }
  }, {
    key: "offsets",
    value: function offsets() {
      return [-60, -30, 0, 30, 60];
    }
  }, {
    key: "name",
    get: function get() {
      return "Analogous";
    }
  }]);
  return Analogous;
}(ColorHarmony);

var Neutral = function (_ColorHarmony6) {
  inherits(Neutral, _ColorHarmony6);

  function Neutral() {
    classCallCheck(this, Neutral);
    return possibleConstructorReturn(this, (Neutral.__proto__ || Object.getPrototypeOf(Neutral)).apply(this, arguments));
  }

  createClass(Neutral, null, [{
    key: "offsets",
    value: function offsets() {
      return [-30, -15, 0, 15, 30];
    }
  }, {
    key: "name",
    get: function get() {
      return "Neutral";
    }
  }]);
  return Neutral;
}(ColorHarmony);

var Color = function () {
  createClass(Color, [{
    key: "isColor",


    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // instance side
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

    get: function get() {
      return true;
    }
  }], [{
    key: "random",


    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // class side
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

    value: function random(min, max) {
      if (min === undefined) min = 0;
      if (max === undefined) max = 255;
      return Color.rgb(lively_lang.num.random(min, max), lively_lang.num.random(min, max), lively_lang.num.random(min, max));
    }
  }, {
    key: "hsb",
    value: function hsb(hue, sat, brt) {
      var s = sat,
          b = brt;
      // zero saturation yields gray with the given brightness
      if (sat == 0) return new Color(b, b, b);
      var h = hue % 360,
          h60 = h / 60,
          i = Math.floor(h60),
          // integer part of hue
      f = h60 - i,
          // fractional part of hue
      p = (1.0 - s) * b,
          q = (1.0 - s * f) * b,
          t = (1.0 - s * (1.0 - f)) * b;

      switch (i) {
        case 0:
          return new Color(b, t, p);
        case 1:
          return new Color(q, b, p);
        case 2:
          return new Color(p, b, t);
        case 3:
          return new Color(p, q, b);
        case 4:
          return new Color(t, p, b);
        case 5:
          return new Color(b, p, q);
        default:
          return new Color(0, 0, 0);
      }
    }
  }, {
    key: "wheel",
    value: function wheel() {
      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
      return Color.wheelHsb(n, 0.0, 0.9, 0.7);
    }
  }, {
    key: "wheelHsb",
    value: function wheelHsb(n, hue, sat, brt) {
      // Return an array of n colors of varying hue
      var a = new Array(n),
          step = 360.0 / Math.max(n, 1);
      for (var i = 0; i < n; i++) {
        a[i] = Color.hsb(hue + i * step, sat, brt);
      }
      return a;
    }
  }, {
    key: "rgb",
    value: function rgb(r, g, b) {
      return new Color(r / 255, g / 255, b / 255);
    }
  }, {
    key: "rgbHex",
    value: function rgbHex(colorHexString) {
      var colorData = this.parseHex(colorHexString);
      if (colorData && colorData[0] >= 0 && colorData[1] >= 0 && colorData[2] >= 0) {
        return new Color(colorData[0], colorData[1], colorData[2]);
      } else {
        return null;
      }
    }
  }, {
    key: "rgba",
    value: function rgba(r, g, b, a) {
      return new Color(r / 255, g / 255, b / 255, a);
    }
  }, {
    key: "fromLiteral",
    value: function fromLiteral(spec) {
      return new Color(spec.r, spec.g, spec.b, spec.a);
    }
  }, {
    key: "fromTuple",
    value: function fromTuple(tuple) {
      return new Color(tuple[0], tuple[1], tuple[2], tuple[3]);
    }
  }, {
    key: "fromTuple8Bit",
    value: function fromTuple8Bit(tuple) {
      return new Color(tuple[0] / 255, tuple[1] / 255, tuple[2] / 255, tuple[3] / 255);
    }
  }, {
    key: "fromString",
    value: function fromString(str) {
      if (!str || str === 'none') {
        return null;
      } else {
        return parse$1(str);
      }
    }
  }, {
    key: "parse",
    value: function parse(str) {
      var color;
      if (!str || str === 'none') {
        return null;
      } else {
        color = parse$1(str);
        return [color.red(), color.green(), color.blue(), color.alpha()];
      }
    }
  }, {
    key: "parseRGB",
    value: function parseRGB(str) {
      // match string of the form rgb([r],[g],[b]) or rgb([r%],[g%],[b%]),
      // allowing whitespace between all components
      var match = str.match(this.rgbaRegex);
      if (match) {
        var r = parseInt(match[1]) / (match[2] ? 100 : 255);
        var g = parseInt(match[3]) / (match[4] ? 100 : 255);
        var b = parseInt(match[5]) / (match[6] ? 100 : 255);
        var a = match[7] ? parseFloat(match[7]) : 1.0;
        return [r, g, b, a];
      }
      return null;
    }
  }, {
    key: "parseHex",
    value: function parseHex(colStr) {
      var rHex,
          gHex,
          bHex,
          str = '';
      for (var i = 0; i < colStr.length; i++) {
        var c = colStr[i].toLowerCase();
        if (c == 'a' || c == 'b' || c == 'c' || c == 'd' || c == 'e' || c == 'f' || c == '0' || c == '1' || c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9') {
          str += c;
        }
      }
      if (str.length == 6) {
        rHex = str.substring(0, 2);
        gHex = str.substring(2, 4);
        bHex = str.substring(4, 6);
      } else if (str.length == 3) {
        // short form like #C00
        rHex = str.substring(0, 1);
        rHex += rHex;
        gHex = str.substring(1, 2);
        gHex += gHex;
        bHex = str.substring(2, 3);
        bHex += bHex;
      } else {
        return null;
      }
      var r = parseInt(rHex, 16) / 255,
          g = parseInt(gHex, 16) / 255,
          b = parseInt(bHex, 16) / 255;
      return [r, g, b];
    }
  }, {
    key: "rgbaRegex",
    get: function get() {
      return rgbaRegex;
    }
  }, {
    key: "black",
    get: function get() {
      return black;
    }
  }, {
    key: "almostBlack",
    get: function get() {
      return almostBlack;
    }
  }, {
    key: "white",
    get: function get() {
      return white;
    }
  }, {
    key: "gray",
    get: function get() {
      return gray;
    }
  }, {
    key: "red",
    get: function get() {
      return red;
    }
  }, {
    key: "green",
    get: function get() {
      return green;
    }
  }, {
    key: "yellow",
    get: function get() {
      return yellow;
    }
  }, {
    key: "blue",
    get: function get() {
      return blue;
    }
  }, {
    key: "purple",
    get: function get() {
      return purple;
    }
  }, {
    key: "magenta",
    get: function get() {
      return magenta;
    }
  }, {
    key: "pink",
    get: function get() {
      return pink;
    }
  }, {
    key: "turquoise",
    get: function get() {
      return turquoise;
    }
  }, {
    key: "tangerine",
    get: function get() {
      return tangerine;
    }
  }, {
    key: "orange",
    get: function get() {
      return orange;
    }
  }, {
    key: "cyan",
    get: function get() {
      return cyan;
    }
  }, {
    key: "brown",
    get: function get() {
      return brown;
    }
  }, {
    key: "limeGreen",
    get: function get() {
      return limeGreen;
    }
  }, {
    key: "darkGray",
    get: function get() {
      return darkGray;
    }
  }, {
    key: "lightGray",
    get: function get() {
      return lightGray;
    }
  }, {
    key: "veryLightGray",
    get: function get() {
      return veryLightGray;
    }
  }, {
    key: "transparent",
    get: function get() {
      return transparent;
    }
  }]);

  function Color(r, g, b, a) {
    classCallCheck(this, Color);

    this.r = r || 0;
    this.g = g || 0;
    this.b = b || 0;
    this.a = a || (a === 0 ? 0 : 1);
  }

  // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  // accessing
  // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-


  createClass(Color, [{
    key: "grayValue",
    value: function grayValue() {
      return (this.r + this.g + this.b) / 3;
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // comparing
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "equals",
    value: function equals(other) {
      if (!other) return false;
      return this.r === other.r && this.g === other.g && this.b === other.b && this.a === other.a;
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // transforming
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "darker",
    value: function darker(recursion) {
      var result = this.mixedWith(Color.black, 0.5);
      return recursion > 1 ? result.darker(recursion - 1) : result;
    }
  }, {
    key: "lighter",
    value: function lighter(recursion) {
      if (recursion == 0) return this;
      var result = this.mixedWith(Color.white, 0.5);
      return recursion > 1 ? result.lighter(recursion - 1) : result;
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // printing
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "toString",
    value: function toString() {
      return this.a === 1 ? "rgb(" + floor(this.r) + "," + floor(this.g) + "," + floor(this.b) + ")" : this.toRGBAString();
    }
  }, {
    key: "toRGBAString",
    value: function toRGBAString() {
      function floor(x) {
        return Math.floor(x * 255.99);
      }
      return "rgba(" + floor(this.r) + "," + floor(this.g) + "," + floor(this.b) + "," + this.a + ")";
    }
  }, {
    key: "toHexString",
    value: function toHexString() {
      function floor(x) {
        return Math.floor(x * 255.99);
      }
      function addLeadingZero(string$$1) {
        var s = string$$1;
        while (s.length < 2) {
          s = '0' + s;
        }
        return s;
      }
      return addLeadingZero(floor(this.r).toString(16)) + addLeadingZero(floor(this.g).toString(16)) + addLeadingZero(floor(this.b).toString(16));
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // converting
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "toTuple",
    value: function toTuple() {
      return [this.r, this.g, this.b, this.a];
    }
  }, {
    key: "toTuple8Bit",
    value: function toTuple8Bit() {
      return [this.r * 255, this.g * 255, this.b * 255, this.a * 255];
    }
  }, {
    key: "toHSB",
    value: function toHSB() {
      var max = Math.max(this.r, this.g, this.b),
          min = Math.min(this.r, this.g, this.b),
          h,
          s,
          b = max;
      if (max == min) {
        h = 0;
      } else if (max == this.r) {
        h = 60 * (0 + (this.g - this.b) / (max - min));
      } else if (max == this.g) {
        h = 60 * (2 + (this.b - this.r) / (max - min));
      } else if (max == this.b) {
        h = 60 * (4 + (this.r - this.g) / (max - min));
      }
      h = (h + 360) % 360;
      s = max == 0 ? 0 : (max - min) / max;
      return [h, s, b];
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // instance creation
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "withA",
    value: function withA(a) {
      return new Color(this.r, this.g, this.b, a);
    }
  }, {
    key: "mixedWith",
    value: function mixedWith(other, proportion) {
      // Mix with another color -- 1.0 is all this, 0.0 is all other
      var p = proportion,
          q = 1.0 - p;
      return new Color(this.r * p + other.r * q, this.g * p + other.g * q, this.b * p + other.b * q, this.a * p + other.a * q);
    }

    // FIXME: invert sounds like mutation, versus createInverse or similar

  }, {
    key: "invert",
    value: function invert() {
      return Color.rgb(255 * (1 - this.r), 255 * (1 - this.g), 255 * (1 - this.b));
    }
  }, {
    key: "toCSSString",
    value: function toCSSString() {
      return this.toRGBAString();
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // serialization
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "__serialize__",
    value: function __serialize__() {
      return {
        __expr__: "Color." + this.toString(),
        bindings: { "lively.graphics/color.js": ["Color"] }
      };
    }
  }]);
  return Color;
}();

var Gradient = function () {
  function Gradient(stops) {
    classCallCheck(this, Gradient);

    this.stops = stops || [];
  }

  createClass(Gradient, [{
    key: "getStopsLighter",
    value: function getStopsLighter(n) {
      return this.stops.collect(function (ea) {
        return { offset: ea.offset, color: ea.color.lighter(n) };
      });
    }
  }, {
    key: "getStopsDarker",
    value: function getStopsDarker(n) {
      return this.stops.collect(function (ea) {
        return { offset: ea.offset, color: ea.color.darker(n) };
      });
    }
  }, {
    key: "isGradient",
    get: function get() {
      return true;
    }
  }]);
  return Gradient;
}();

var LinearGradient = function (_Gradient) {
  inherits(LinearGradient, _Gradient);

  function LinearGradient(_ref2) {
    var stops = _ref2.stops,
        vector = _ref2.vector;
    classCallCheck(this, LinearGradient);

    var _this8 = possibleConstructorReturn(this, (LinearGradient.__proto__ || Object.getPrototypeOf(LinearGradient)).call(this, stops));

    _this8.vector = vector;
    return _this8;
  }

  createClass(LinearGradient, [{
    key: "angleToRect",
    value: function angleToRect(rad) {
      return Point.polar(1, rad).extentAsRectangle().withCenter(pt(.5, .5));
    }
  }, {
    key: "vectorAsAngle",
    value: function vectorAsAngle() {
      return this.vector.extent().theta();
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.toCSSString();
    }
  }, {
    key: "lighter",
    value: function lighter(n) {
      return new this.constructor(this.getStopsLighter(n), this.vector);
    }
  }, {
    key: "darker",
    value: function darker() {
      return new this.constructor(this.getStopsDarker(), this.vector);
    }
  }, {
    key: "toCSSString",
    value: function toCSSString() {
      var platform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "webkit";

      // default webkit way of defining gradients
      var _stops = toArray(this.stops),
          first = _stops[0],
          rest = _stops.slice(1),
          last = lively_lang.arr.last(rest),
          middle = lively_lang.arr.takeWhile(rest, function (stop) {
        return stop != last;
      });

      switch (platform) {
        case "moz":
          return this._mozString(first, middle, last);
        default:
          return this._webkitString(first, middle, last);
      }
    }
  }, {
    key: "_webkitString",
    value: function _webkitString(first, middle, last) {
      var str = "-webkit-gradient(linear,\n        " + this.vector.x * 100.0 + "% \n        " + this.vector.y * 100.0 + "%, \n        " + this.vector.maxX() * 100.0 + "% \n        " + this.vector.maxY() * 100.0 + "%,\n        from(" + ((first.offset * 100).toFixed() + "%") + ", " + first.color.toRGBAString() + "),";
      for (var i in middle) {
        str += "color-stop(" + ((middle[i].offset * 100).toFixed() + "%") + ", " + middle[i].color.toRGBAString() + "),";
      }str += "to(" + last.color.toRGBAString() + "))";
      return str;
    }
  }, {
    key: "_mozString",
    value: function _mozString(first, middle, last) {}
  }, {
    key: "type",
    get: function get() {
      return "linearGradient";
    }
  }, {
    key: "vectors",
    get: function get() {
      return {
        northsouth: rect(pt(0, 0), pt(0, 1)),
        northeast: rect(pt(1, 0), pt(0, 1)),
        westeast: rect(pt(1, 0), pt(0, 0)),
        southeast: rect(pt(1, 1), pt(0, 0)),
        southnorth: rect(pt(0, 1), pt(0, 0)),
        southwest: rect(pt(0, 1), pt(1, 0)), // Down and to the left
        eastwest: rect(pt(0, 0), pt(1, 0)),

        northwest: rect(pt(0, 0), pt(1, 1))
      };
    }
  }, {
    key: "vector",
    get: function get() {
      return this._vector;
    },
    set: function set(value) {
      if (!value) this._vector = this.vectors.northsouth;else if (typeof value === "string") this._vector = this.vectors[value.toLowerCase()];else if (typeof value === "number") this._vector = this.angleToRect(value); //radians
      else this._vector = value;
    }
  }]);
  return LinearGradient;
}(Gradient);

var RadialGradient = function (_Gradient2) {
  inherits(RadialGradient, _Gradient2);

  function RadialGradient(_ref3) {
    var stops = _ref3.stops,
        focus = _ref3.focus,
        bounds = _ref3.bounds;
    classCallCheck(this, RadialGradient);

    var _this9 = possibleConstructorReturn(this, (RadialGradient.__proto__ || Object.getPrototypeOf(RadialGradient)).call(this, stops));

    _this9.focus = focus || pt(0.5, 0.5);
    _this9.bounds = bounds || new Rectangle(0, 0, 20, 20);
    return _this9;
  }

  createClass(RadialGradient, [{
    key: "toString",
    value: function toString() {
      return this.toCSSString();
    }
  }, {
    key: "lighter",
    value: function lighter(n) {
      return new this.constructor(this.getStopsLighter(n), this.focus);
    }
  }, {
    key: "darker",
    value: function darker() {
      return new this.constructor(this.getStopsDarker(), this.focus);
    }
  }, {
    key: "toCSSString",
    value: function toCSSString() {
      var innerCircle = this.focus.scaleBy(100.0),
          ext = this.bounds.extent();
      var str = "radial-gradient(" + ext.x / 2 + "px " + ext.y / 2 + "px ellipse at " + innerCircle.x + "% " + innerCircle.y + "% ";
      for (var i = 0; i < this.stops.length; i++) {
        str += "," + this.stops[i].color.toRGBAString() + " " + ((this.stops[i].offset * 100).toFixed() + "%");
      }str += ')';
      return str;
    }
  }, {
    key: "type",
    get: function get() {
      return "radialGradient";
    }
  }]);
  return RadialGradient;
}(Gradient);

/* 
   Flat design or flat UI colors are quite popular in web design today 
   where bold, bright colors are used to create clean, simple interfaces.
*/

var flatDesignColors = ["#1abc9c", "#e8f8f5", "#d1f2eb", "#a3e4d7", "#76d7c4", "#48c9b0", "#1abc9c", "#17a589", "#148f77", "#117864", "#0e6251", "#16a085", "#e8f6f3", "#d0ece7", "#a2d9ce", "#73c6b6", "#45b39d", "#16a085", "#138d75", "#117a65", "#0e6655", "#0b5345", "#2ecc71", "#eafaf1", "#d5f5e3", "#abebc6", "#82e0aa", "#58d68d", "#2ecc71", "#28b463", "#239b56", "#1d8348", "#186a3b", "#27ae60", "#e9f7ef", "#d4efdf", "#a9dfbf", "#7dcea0", "#52be80", "#27ae60", "#229954", "#1e8449", "#196f3d", "#145a32", "#3498db", "#ebf5fb", "#d6eaf8", "#aed6f1", "#85c1e9", "#5dade2", "#3498db", "#2e86c1", "#2874a6", "#21618c", "#1b4f72", "#2980b9", "#eaf2f8", "#d4e6f1", "#a9cce3", "#7fb3d5", "#5499c7", "#2980b9", "#2471a3", "#1f618d", "#1a5276", "#154360", "#9b59b6", "#f5eef8", "#ebdef0", "#d7bde2", "#c39bd3", "#af7ac5", "#9b59b6", "#884ea0", "#76448a", "#633974", "#512e5f", "#8e44ad", "#f4ecf7", "#e8daef", "#d2b4de", "#bb8fce", "#a569bd", "#8e44ad", "#7d3c98", "#6c3483", "#5b2c6f", "#4a235a", "#34495e", "#ebedef", "#d6dbdf", "#aeb6bf", "#85929e", "#5d6d7e", "#34495e", "#2e4053", "#283747", "#212f3c", "#1b2631", "#2c3e50", "#eaecee", "#d5d8dc", "#abb2b9", "#808b96", "#566573", "#2c3e50", "#273746", "#212f3d", "#1c2833", "#17202a", "#f1c40f", "#fef9e7", "#fcf3cf", "#f9e79f", "#f7dc6f", "#f4d03f", "#f1c40f", "#d4ac0d", "#b7950b", "#9a7d0a", "#7d6608", "#f39c12", "#fef5e7", "#fdebd0", "#fad7a0", "#f8c471", "#f5b041", "#f39c12", "#d68910", "#b9770e", "#9c640c", "#7e5109", "#e67e22", "#fdf2e9", "#fae5d3", "#f5cba7", "#f0b27a", "#eb984e", "#e67e22", "#ca6f1e", "#af601a", "#935116", "#784212", "#d35400", "#fbeee6", "#f6ddcc", "#edbb99", "#e59866", "#dc7633", "#d35400", "#ba4a00", "#a04000", "#873600", "#6e2c00", "#e74c3c", "#fdedec", "#fadbd8", "#f5b7b1", "#f1948a", "#ec7063", "#e74c3c", "#cb4335", "#b03a2e", "#943126", "#78281f", "#c0392b", "#f9ebea", "#f2d7d5", "#e6b0aa", "#d98880", "#cd6155", "#c0392b", "#a93226", "#922b21", "#7b241c", "#641e16", "#ecf0f1", "#fdfefe", "#fbfcfc", "#f7f9f9", "#f4f6f7", "#f0f3f4", "#ecf0f1", "#d0d3d4", "#b3b6b7", "#979a9a", "#7b7d7d", "#bdc3c7", "#f8f9f9", "#f2f3f4", "#e5e7e9", "#d7dbdd", "#cacfd2", "#bdc3c7", "#a6acaf", "#909497", "#797d7f", "#626567", "#95a5a6", "#f4f6f6", "#eaeded", "#d5dbdb", "#bfc9ca", "#aab7b8", "#95a5a6", "#839192", "#717d7e", "#5f6a6a", "#4d5656", "#7f8c8d", "#f2f4f4", "#e5e8e8", "#ccd1d1", "#b2babb", "#99a3a4", "#7f8c8d", "#707b7c", "#616a6b", "#515a5a", "#424949"];

/*
  Material design is a visual language and design system developed 
  by Google with an almost flat style and vibrant color schemes.
*/

var materialDesignColors = ["#f44336", "#ffebee", "#ffcdd2", "#ef9a9a", "#e57373", "#ef5350", "#f44336", "#e53935", "#d32f2f", "#c62828", "#b71c1c", "#ff8a80", "#ff5252", "#ff1744", "#d50000", "#e91e63", "#fce4ec", "#f8bbd0", "#f48fb1", "#f06292", "#ec407a", "#e91e63", "#d81b60", "#c2185b", "#ad1457", "#880e4f", "#ff80ab", "#ff4081", "#f50057", "#c51162", "#9c27b0", "#f3e5f5", "#e1bee7", "#ce93d8", "#ba68c8", "#ab47bc", "#9c27b0", "#8e24aa", "#7b1fa2", "#6a1b9a", "#4a148c", "#ea80fc", "#e040fb", "#d500f9", "#aa00ff", "#673ab7", "#ede7f6", "#d1c4e9", "#b39ddb", "#9575cd", "#7e57c2", "#673ab7", "#5e35b1", "#512da8", "#4527a0", "#311b92", "#b388ff", "#7c4dff", "#651fff", "#6200ea", "#3f51b5", "#e8eaf6", "#c5cae9", "#9fa8da", "#7986cb", "#5c6bc0", "#3f51b5", "#3949ab", "#303f9f", "#283593", "#1a237e", "#8c9eff", "#536dfe", "#3d5afe", "#304ffe", "#2196f3", "#e3f2fd", "#bbdefb", "#90caf9", "#64b5f6", "#42a5f5", "#2196f3", "#1e88e5", "#1976d2", "#1565c0", "#0d47a1", "#82b1ff", "#448aff", "#2979ff", "#2962ff", "#03a9f4", "#e1f5fe", "#b3e5fc", "#81d4fa", "#4fc3f7", "#29b6f6", "#03a9f4", "#039be5", "#0288d1", "#0277bd", "#01579b", "#80d8ff", "#40c4ff", "#00b0ff", "#0091ea", "#00bcd4", "#e0f7fa", "#b2ebf2", "#80deea", "#4dd0e1", "#26c6da", "#00bcd4", "#00acc1", "#0097a7", "#00838f", "#006064", "#84ffff", "#18ffff", "#00e5ff", "#00b8d4", "#009688", "#e0f2f1", "#b2dfdb", "#80cbc4", "#4db6ac", "#26a69a", "#009688", "#00897b", "#00796b", "#00695c", "#004d40", "#a7ffeb", "#64ffda", "#1de9b6", "#00bfa5", "#4caf50", "#e8f5e9", "#c8e6c9", "#a5d6a7", "#81c784", "#66bb6a", "#4caf50", "#43a047", "#388e3c", "#2e7d32", "#1b5e20", "#b9f6ca", "#69f0ae", "#00e676", "#00c853", "#8bc34a", "#f1f8e9", "#dcedc8", "#c5e1a5", "#aed581", "#9ccc65", "#8bc34a", "#7cb342", "#689f38", "#558b2f", "#33691e", "#ccff90", "#b2ff59", "#76ff03", "#64dd17", "#cddc39", "#f9fbe7", "#f0f4c3", "#e6ee9c", "#dce775", "#d4e157", "#cddc39", "#c0ca33", "#afb42b", "#9e9d24", "#827717", "#f4ff81", "#eeff41", "#c6ff00", "#aeea00", "#ffeb3b", "#fffde7", "#fff9c4", "#fff59d", "#fff176", "#ffee58", "#ffeb3b", "#fdd835", "#fbc02d", "#f9a825", "#f57f17", "#ffff8d", "#ffff00", "#ffea00", "#ffd600", "#ffc107", "#fff8e1", "#ffecb3", "#ffe082", "#ffd54f", "#ffca28", "#ffc107", "#ffb300", "#ffa000", "#ff8f00", "#ff6f00", "#ffe57f", "#ffd740", "#ffc400", "#ffab00", "#ff9800", "#fff3e0", "#ffe0b2", "#ffcc80", "#ffb74d", "#ffa726", "#ff9800", "#fb8c00", "#f57c00", "#ef6c00", "#e65100", "#ffd180", "#ffab40", "#ff9100", "#ff6d00", "#ff5722", "#fbe9e7", "#ffccbc", "#ffab91", "#ff8a65", "#ff7043", "#ff5722", "#f4511e", "#e64a19", "#d84315", "#bf360c", "#ff9e80", "#ff6e40", "#ff3d00", "#dd2c00", "#795548", "#efebe9", "#d7ccc8", "#bcaaa4", "#a1887f", "#8d6e63", "#795548", "#6d4c41", "#5d4037", "#4e342e", "#3e2723", "#9e9e9e", "#fafafa", "#f5f5f5", "#eeeeee", "#e0e0e0", "#bdbdbd", "#9e9e9e", "#757575", "#616161", "#424242", "#212121", "#607d8b", "#eceff1", "#cfd8dc", "#b0bec5", "#90a4ae", "#78909c", "#607d8b", "#546e7a", "#455a64", "#37474f", "#263238", "#ffffff", "#000000"];

var webSafeColors = ["ccff00", "ccff33", "ccff66", "ccff99", "ccffcc", "ccffff", "ffffff", "ffffcc", "ffff99", "ffff66", "ffff33", "ffff00", "cccc00", "cccc33", "cccc66", "cccc99", "cccccc", "ccccff", "ffccff", "ffcccc", "ffcc99", "ffcc66", "ffcc33", "ffcc00", "cc9900", "cc9933", "cc9966", "cc9999", "cc99cc", "cc99ff", "ff99ff", "ff99cc", "ff9999", "ff9966", "ff9933", "ff9900", "cc6600", "cc6633", "cc6666", "cc6699", "cc66cc", "cc66ff", "ff66ff", "ff66cc", "ff6699", "ff6666", "ff6633", "ff6600", "cc3300", "cc3333", "cc3366", "cc3399", "cc33cc", "cc33ff", "ff33ff", "ff33cc", "ff3399", "ff3366", "ff3333", "ff3300", "cc0000", "cc0033", "cc0066", "cc0099", "cc00cc", "cc00ff", "ff00ff", "ff00cc", "ff0099", "ff0066", "ff0033", "ff0000", "660000", "660033", "660066", "660099", "6600cc", "6600ff", "9900ff", "9900cc", "990099", "990066", "990033", "990000", "663300", "663333", "663366", "663399", "6633cc", "6633ff", "9933ff", "9933cc", "993399", "993366", "993333", "993300", "666600", "666633", "666666", "666699", "6666cc", "6666ff", "9966ff", "9966cc", "996699", "996666", "996633", "996600", "669900", "669933", "669966", "669999", "6699cc", "6699ff", "9999ff", "9999cc", "999999", "999966", "999933", "999900", "66cc00", "66cc33", "66cc66", "66cc99", "66cccc", "66ccff", "99ccff", "99cccc", "99cc99", "99cc66", "99cc33", "99cc00", "66ff00", "66ff33", "66ff66", "66ff99", "66ffcc", "66ffff", "99ffff", "99ffcc", "99ff99", "99ff66", "99ff33", "99ff00", "00ff00", "00ff33", "00ff66", "00ff99", "00ffcc", "00ffff", "33ffff", "33ffcc", "33ff99", "33ff66", "33ff33", "33ff00", "00cc00", "00cc33", "00cc66", "00cc99", "00cccc", "00ccff", "33ccff", "33cccc", "33cc99", "33cc66", "33cc33", "33cc00", "009900", "009933", "009966", "009999", "0099cc", "0099ff", "3399ff", "3399cc", "339999", "339966", "339933", "339900", "006600", "006633", "006666", "006699", "0066cc", "0066ff", "3366ff", "3366cc", "336699", "336666", "336633", "336600", "003300", "003333", "003366", "003399", "0033cc", "0033ff", "3333ff", "3333cc", "333399", "333366", "333333", "333300", "000000", "000033", "000066", "000099", "0000cc", "0000ff", "3300ff", "3300cc", "330099", "330066", "330033", "330000"];

// well-known colors
var black = new Color(0, 0, 0);
var almostBlack = Color.rgb(64, 64, 64);
var white = new Color(1, 1, 1);
var gray = new Color(0.8, 0.8, 0.8);
var red = new Color(0.8, 0, 0);
var green = new Color(0, 0.8, 0);
var yellow = new Color(0.8, 0.8, 0);
var blue = new Color(0, 0, 0.8);
var purple = new Color(1, 0, 1);
var magenta = new Color(1, 0, 1);
var pink = Color.rgb(255, 30, 153);
var turquoise = Color.rgb(0, 240, 255);
var tangerine = Color.rgb(242, 133, 0);
var orange = Color.rgb(255, 153, 0);
var cyan = Color.rgb(0, 255, 255);
var brown = Color.rgb(182, 67, 0);
var limeGreen = Color.rgb(51, 255, 0);
var darkGray = Color.rgb(102, 102, 102);
var lightGray = Color.rgb(230, 230, 230);
var veryLightGray = Color.rgb(243, 243, 243);
var transparent = Color.rgba(0, 0, 0, 0);

exports.Complementary = Complementary;
exports.Triadic = Triadic;
exports.Tetradic = Tetradic;
exports.Quadratic = Quadratic;
exports.Analogous = Analogous;
exports.Neutral = Neutral;
exports.Color = Color;
exports.LinearGradient = LinearGradient;
exports.RadialGradient = RadialGradient;
exports.flatDesignColors = flatDesignColors;
exports.materialDesignColors = materialDesignColors;
exports.webSafeColors = webSafeColors;
exports.black = black;
exports.almostBlack = almostBlack;
exports.white = white;
exports.gray = gray;
exports.red = red;
exports.green = green;
exports.yellow = yellow;
exports.blue = blue;
exports.purple = purple;
exports.magenta = magenta;
exports.pink = pink;
exports.turquoise = turquoise;
exports.tangerine = tangerine;
exports.orange = orange;
exports.cyan = cyan;
exports.brown = brown;
exports.limeGreen = limeGreen;
exports.darkGray = darkGray;
exports.lightGray = lightGray;
exports.veryLightGray = veryLightGray;
exports.transparent = transparent;
exports.Point = Point;
exports.Rectangle = Rectangle;
exports.Transform = Transform;
exports.Line = Line;
exports.rect = rect;
exports.pt = pt;

}((this.lively.graphics = this.lively.graphics || {}),lively.lang));

  if (typeof module !== "undefined" && module.exports) module.exports = GLOBAL.lively.graphics;
})();
// INLINED END /Users/robin/Development/lively-next/lively.graphics/dist/lively.graphics.js

// INLINED /Users/robin/Development/lively-next/lively.serializer2/dist/lively.serializer2.js
this.lively = this.lively || {};
(function (exports,lively_lang) {
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj$$1) {
  return typeof obj$$1;
} : function (obj$$1) {
  return obj$$1 && typeof Symbol === "function" && obj$$1.constructor === Symbol && obj$$1 !== Symbol.prototype ? "symbol" : typeof obj$$1;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var get$1 = function get$1(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get$1(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

















var set = function set(object, property, value, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent !== null) {
      set(parent, property, value, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    desc.value = value;
  } else {
    var setter = desc.set;

    if (setter !== undefined) {
      setter.call(receiver, value);
    }
  }

  return value;
};















var toConsumableArray = function (arr$$1) {
  if (Array.isArray(arr$$1)) {
    for (var i = 0, arr2 = Array(arr$$1.length); i < arr$$1.length; i++) arr2[i] = arr$$1[i];

    return arr2;
  } else {
    return Array.from(arr$$1);
  }
};

/*global Map, System*/
// extensions to native JS objects to support serialization


Object.defineProperty(Symbol.prototype, "__serialize__", {
  configurable: true,
  value: function () {
    var knownSymbols = function () {
      return Object.getOwnPropertyNames(Symbol).filter(function (ea) {
        return _typeof(Symbol[ea]) === "symbol";
      }).reduce(function (map, ea) {
        return map.set(Symbol[ea], "Symbol." + ea);
      }, new Map());
    }(),
        symMatcher = /^Symbol\((.*)\)$/;

    return function () {
      // turns a symbol into a __expr__ object.
      var sym = typeof this[Symbol.toPrimitive] === "function" ? this[Symbol.toPrimitive]() : this,
          symKey = Symbol.keyFor(sym);
      if (symKey) return { __expr__: "Symbol.for(\"" + symKey + "\")" };
      if (knownSymbols.get(sym)) return { __expr__: knownSymbols.get(sym) };
      var match = String(sym).match(symMatcher);
      return { __expr__: match ? "Symbol(\"" + match[1] + "\")" : "Symbol()" };
    };
  }()
});

Object.defineProperty(System, "__serialize__", {
  configurable: true,
  value: function value() {
    return { __expr__: "System" };
  }
});

var classMetaForSerializationProp = "lively.serializer-class-info";
var moduleMetaInClassProp = Symbol.for("lively-module-meta");

var ClassHelper = function () {
  createClass(ClassHelper, [{
    key: "classNameProperty",
    get: function get() {
      return '__LivelyClassName__';
    }
  }, {
    key: "sourceModuleNameProperty",
    get: function get() {
      return '__SourceModuleName__';
    }
  }], [{
    key: "moduleMetaInClassProp",
    get: function get() {
      return moduleMetaInClassProp;
    }
  }, {
    key: "classMetaForSerializationProp",
    get: function get() {
      return classMetaForSerializationProp;
    }
  }]);

  function ClassHelper(options) {
    classCallCheck(this, ClassHelper);

    this.options = _extends({ ignoreClassNotFound: true }, options);
    this[Symbol.for('lively-instance-restorer')] = true; // for Class.intializer
  }

  // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
  // class info persistence

  createClass(ClassHelper, [{
    key: "addClassInfo",
    value: function addClassInfo(objRef, realObj, snapshot) {

      // store class into persistentCopy if original is an instance
      if (!realObj || !realObj.constructor) return;

      var className = realObj.constructor.name;

      if (!className) {
        console.warn("Cannot serialize class info of anonymous class of instance " + realObj);
        return;
      }

      var moduleMeta = realObj.constructor[moduleMetaInClassProp];
      if (className === "Object" && !moduleMeta) return;
      snapshot[classMetaForSerializationProp] = { className: className, module: moduleMeta };
    }
  }, {
    key: "restoreIfClassInstance",
    value: function restoreIfClassInstance(objRef, snapshot) {
      if (!snapshot.hasOwnProperty(classMetaForSerializationProp)) return;
      var meta = snapshot[classMetaForSerializationProp];
      if (!meta.className) return;

      var klass = this.locateClass(meta);
      if (!klass || typeof klass !== "function") {
        var msg = "Trying to deserialize instance of " + JSON.stringify(meta) + " but this class cannot be found!";
        if (!this.options.ignoreClassNotFound) throw new Error(msg);
        console.error(msg);
        return { isClassPlaceHolder: true, className: meta.className };
      }

      return new klass(this);
    }
  }, {
    key: "locateClass",
    value: function locateClass(meta) {
      // meta = {className, module: {package, pathInPackage}}
      var m = meta.module;
      if (m && m.package && m.package.name) {
        var packagePath = System.decanonicalize(m.package.name + "/"),
            moduleId = lively.lang.string.joinPath(packagePath, m.pathInPackage),
            realModule = System.get("@lively-env").moduleEnv(moduleId);
        if (!realModule) console.warn("Trying to deserialize instance of class " + meta.className + " but the module " + moduleId + " is not yet loaded");else return realModule.recorder[meta.className];
      }

      // is it a global?
      return System.global[meta.className];
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // searching

  }], [{
    key: "sourceModulesInObjRef",
    value: function sourceModulesInObjRef(snapshotedObjRef) {
      //                                  /--- that's the ref
      // from snapshot = {[key]: {..., props: [...]}}
      var modules = [],
          prop = snapshotedObjRef && snapshotedObjRef[classMetaForSerializationProp];
      if (prop && prop.module) modules.push(prop.module);
      return modules;
    }
  }, {
    key: "sourceModulesIn",
    value: function sourceModulesIn(snapshots) {

      var modules = [];

      Object.keys(snapshots).forEach(function (id) {
        var snapshot = snapshots[id];
        if (snapshot && snapshot[classMetaForSerializationProp]) modules.push(snapshot[classMetaForSerializationProp]);
      });

      return lively_lang.arr.uniqBy(modules, function (a, b) {
        var modA = a.module,
            modB = b.module;
        if (!modA && !modB || modA && !modB || !modA && modB) return a.className === b.className;
        return a.className === b.className && modA.package.name == modB.package.name && modA.package.pathInPackage == modB.package.pathInPackage;
      });
    }
  }]);
  return ClassHelper;
}();

var ExpressionSerializer = function () {
  function ExpressionSerializer(opts) {
    classCallCheck(this, ExpressionSerializer);

    var _prefix$opts = _extends({
      prefix: "__lv_expr__"
    }, opts),
        prefix = _prefix$opts.prefix;

    this.prefix = prefix + ":";
  }

  createClass(ExpressionSerializer, [{
    key: "isSerializedExpression",
    value: function isSerializedExpression(string$$1) {
      return string$$1.indexOf(this.prefix) === 0;
    }
  }, {
    key: "requiredModulesOf__expr__",
    value: function requiredModulesOf__expr__(__expr__) {
      if (!this.isSerializedExpression(__expr__)) return null;

      var _exprStringDecode = this.exprStringDecode(__expr__),
          bindings = _exprStringDecode.bindings;

      return bindings ? Object.keys(bindings) : null;
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // encode / decode of serialized expressions
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "exprStringDecode",
    value: function exprStringDecode(string$$1) {
      // 1. read prefix
      // string = "_prefix:{foo}:package/foo.js:foo()"
      // => {expr: "foo()", bindings: {"package/foo.js": ["foo"]}}

      var idx, prefix, rest;

      idx = string$$1.indexOf(":"), prefix = string$$1.slice(0, idx), rest = string$$1.slice(idx + 1);

      var bindings = {},
          hasBindings = false;
      // 2. bindings?
      while (rest && rest.startsWith("{") && (idx = rest.indexOf("}:")) >= 0) {
        hasBindings = true;
        var importedVars = rest.slice(1, idx);
        rest = rest.slice(idx + 2); // skip }:
        idx = rest.indexOf(":"); // end of package
        var from = rest.slice(0, idx);
        bindings[from] = importedVars.split(",");
        rest = rest.slice(idx + 1); // skip :
      }

      return { __expr__: rest, bindings: hasBindings ? bindings : null };
    }
  }, {
    key: "exprStringEncode",
    value: function exprStringEncode(_ref) {
      var __expr__ = _ref.__expr__,
          bindings = _ref.bindings;

      // {expr: "foo()", bindings: {"package/foo.js": ["foo"]}}
      // => "_prefix:{foo}:package/foo.js:foo()"

      var string$$1 = String(__expr__);
      if (bindings) {
        var keys = Object.keys(bindings);
        for (var i = 0; i < keys.length; i++) {
          var from = keys[i];
          string$$1 = "{" + bindings[from].join(",") + "}:" + from + ":" + string$$1;
        }
      }
      return this.prefix + string$$1;
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // serialization
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

  }, {
    key: "convert__expr__obj",
    value: function convert__expr__obj(obj$$1) {
      // obj.__expr__ is encoded serialized expression *without* prefix
      console.assert("__expr__" in obj$$1, "obj has no property __expr__");
      return this.prefix + obj$$1.__expr__;
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // deserialization
    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

    // note __boundValues__ becomes a dynamically scoped "variable" inside eval

  }, {
    key: "__eval__",
    value: function __eval__(__source__, __boundValues__) {
      return eval(__source__);
    }
  }, {
    key: "deserializeExpr",
    value: function deserializeExpr(encoded) {
      if (!encoded.startsWith(this.prefix)) throw new Error("\"" + encoded + "\" is not a serialized expression, missing prefix \"" + this.prefix + "\"");
      return this.deserializeExprObj(this.exprStringDecode(encoded));
    }
  }, {
    key: "deserializeExprObj",
    value: function deserializeExprObj(_ref2) {
      var source = _ref2.__expr__,
          bindings = _ref2.bindings;


      if (bindings) {
        var __boundValues__ = {},
            mods = bindings ? Object.keys(bindings) : [];

        // synchronously get modules specified in bindings object and pull out
        // the vars needed for evaluating source. Add those to __boundValues__
        for (var i = 0; i < mods.length; i++) {
          var modName = mods[i],
              vars = bindings[modName],
              module = System.get(System.decanonicalize(modName));
          if (!module) throw new Error("[lively.serializer] expression eval: bindings specify to import " + modName + " but this module is not loaded!");

          for (var j = 0; j < vars.length; j++) {
            var varName = vars[j];
            __boundValues__[varName] = module[varName];
            source = "var " + varName + " = __boundValues__." + varName + ";\n" + source;
          }
        }
      }

      // evaluate
      return this.__eval__(source, __boundValues__);
    }
  }]);
  return ExpressionSerializer;
}();

function isPrimitive(obj$$1) {
  // primitive objects don't need to be registered
  if (obj$$1 == null) return true;
  var t = typeof obj$$1 === "undefined" ? "undefined" : _typeof(obj$$1);
  if ("boolean" === t || "number" === t || "string" === t) return true;
  return false;
}

var debugSerialization = false;
var debugDeserialization = false;

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-


var ObjectRef = function () {
  createClass(ObjectRef, null, [{
    key: "fromSnapshot",
    value: function fromSnapshot(id, snapshot, pool) {
      var path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
      var idPropertyName = arguments[4];

      var ref = new this(id, undefined, undefined, idPropertyName);
      return pool.internalAddRef(ref).recreateObjFromSnapshot(snapshot, pool, path);
    }
  }]);

  function ObjectRef(id, realObj, snapshot) {
    var idPropertyName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "id";
    classCallCheck(this, ObjectRef);

    this.id = id;
    this.idPropertyName = idPropertyName;
    this.realObj = realObj;
    this.snapshotVersions = [];
    this.snapshots = {};
    if (snapshot) {
      var rev = snapshot.rev || 0;
      this.snapshotVersions.push(rev);
      this.snapshots[rev] = snapshot;
    }
  }

  createClass(ObjectRef, [{
    key: "asRefForSerializedObjMap",
    value: function asRefForSerializedObjMap() {
      var rev = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "????";

      return { __ref__: true, id: this.id, rev: rev };
    }
  }, {
    key: "snapshotObject",
    value: function snapshotObject(serializedObjMap, pool) {
      var _this = this;

      var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

      // serializedObjMap: maps ids to snapshots

      debugSerialization && console.log("[serialize] " + path.join("."));

      if (path.length > 100) throw new Error("Stopping serializer, encountered a possibly infinit loop: " + path.join("."));

      var id = this.id,
          realObj = this.realObj,
          snapshots = this.snapshots;


      if (!realObj) {
        console.error("Cannot marshall object ref " + id + ", no real object!");
        return _extends({}, this.asRefForSerializedObjMap(), { isMissing: true });
      }

      var rev = realObj._rev || 0,
          ref = this.asRefForSerializedObjMap(rev);
      lively_lang.arr.pushIfNotIncluded(this.snapshotVersions, rev);

      // do we already have serialized a current version of realObj?
      if (snapshots[rev]) {
        if (!serializedObjMap[id]) serializedObjMap[id] = snapshots[rev];
        return ref;
      }

      // can realObj be manually serialized, e.g. into an expression?
      if (typeof realObj.__serialize__ === "function") {
        var serialized = realObj.__serialize__(this, serializedObjMap, pool);
        if (serialized.hasOwnProperty("__expr__")) serialized = { __expr__: pool.expressionSerializer.exprStringEncode(serialized) };
        snapshots[rev] = serializedObjMap[id] = serialized;
        return ref;
      }

      // do the generic serialization, i.e. enumerate all properties and
      // serialize the referenced objects recursively
      var snapshot = snapshots[rev] = serializedObjMap[id] = { rev: rev, props: {} },
          props = snapshot.props,
          keys;

      if (realObj.__dont_serialize__) {
        var exceptions = lively_lang.obj.mergePropertyInHierarchy(realObj, "__dont_serialize__");
        keys = lively_lang.arr.withoutAll(Object.getOwnPropertyNames(realObj), exceptions);
      } else if (realObj.__only_serialize__) {
        // FIXME what about __only_serialize__ && __dont_serialize__?
        keys = realObj.__only_serialize__;
      } else keys = Object.getOwnPropertyNames(realObj);

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        props[key] = {
          key: key,
          value: this.snapshotProperty(realObj[key], path.concat([key]), serializedObjMap, pool)
        };
      }
      pool.classHelper.addClassInfo(this, realObj, snapshots[rev]);

      if (typeof realObj.__additionally_serialize__ === "function") realObj.__additionally_serialize__(snapshot, this, function (key, value) {
        var verbatim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        return props[key] = verbatim ? { key: key, value: value, verbatim: verbatim } : { key: key, value: _this.snapshotProperty(value, path.concat([key]), serializedObjMap, pool) };
      });

      return ref;
    }
  }, {
    key: "snapshotProperty",
    value: function snapshotProperty(value, path, serializedObjMap, pool) {
      var _this2 = this;

      // returns the value to serialize, i.e. what to put into the snapshot object

      if (typeof value === "function") return undefined; // FIXME

      if (isPrimitive(value)) return value; // stored as is

      if (typeof value.__serialize__ === "function") {
        var serialized = value.__serialize__(this, serializedObjMap, pool);
        if (serialized.hasOwnProperty("__expr__")) serialized = pool.expressionSerializer.exprStringEncode(serialized);
        return serialized;
      }

      if (Array.isArray(value)) return value.map(function (ea, i) {
        return _this2.snapshotProperty(ea, path.concat(i), serializedObjMap, pool);
      });

      var ref = pool.add(value);

      return ref && ref.isObjectRef ? ref.snapshotObject(serializedObjMap, pool, path) : ref;
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-


  }, {
    key: "recreateObjFromSnapshot",
    value: function recreateObjFromSnapshot(serializedObjMap, pool, path) {
      // serializedObjMap: map from ids to object snapshots

      if (this.realObj) return this;

      debugDeserialization && console.log("[deserialize] " + path.join("."));

      var snapshot = serializedObjMap[this.id];
      if (!snapshot) {
        console.error("Cannot recreateObjFromSnapshot ObjectRef " + (this.id + " b/c of missing snapshot in snapshot map!"));
        return this;
      }

      var rev = snapshot.rev,
          __expr__ = snapshot.__expr__;

      rev = rev || 0;
      this.snapshotVersions.push(rev);
      this.snapshots[rev] = snapshot;

      var newObj;
      if (__expr__) {
        newObj = pool.expressionSerializer.deserializeExpr(__expr__);
      } else {
        newObj = pool.classHelper.restoreIfClassInstance(this, snapshot) || {};
        if (!newObj._rev) newObj._rev = rev;
      }

      this.realObj = newObj;

      pool.internalAddRef(this); // for updating realObj

      if (!newObj) return this;

      if (typeof newObj.__deserialize__ === "function") newObj.__deserialize__(snapshot, this);

      var props = snapshot.props;

      if (props) {
        var highPriorityKeys = ["submorphs"]; // FIXME!!!
        for (var i = 0; i < highPriorityKeys.length; i++) {
          var key = highPriorityKeys[i];
          if (key in props) this.recreatePropertyAndSetProperty(newObj, props, key, serializedObjMap, pool, path);
        }

        for (var key in props) {
          if (!highPriorityKeys.includes(key)) this.recreatePropertyAndSetProperty(newObj, props, key, serializedObjMap, pool, path);
        }
      }

      var idPropertyName = newObj.__serialization_id_property__ || this.idPropertyName;
      if (pool.reinitializeIds && newObj.hasOwnProperty(idPropertyName)) newObj[idPropertyName] = pool.reinitializeIds(this.id, this);

      if (typeof newObj.__after_deserialize__ === "function") newObj.__after_deserialize__(snapshot, this);

      return this;
    }
  }, {
    key: "recreatePropertyAndSetProperty",
    value: function recreatePropertyAndSetProperty(newObj, props, key, serializedObjMap, pool, path) {
      var _props$key = props[key],
          verbatim = _props$key.verbatim,
          value = _props$key.value;

      try {
        newObj[key] = verbatim ? value : this.recreateProperty(key, value, serializedObjMap, pool, path.concat(key));
      } catch (e) {
        var objString;
        try {
          objString = String(newObj);
        } catch (e) {
          objString = "[some " + newObj.constructor.name + "]";
        }
        if (!e.__seen) {
          var printedProp = key + " of " + objString + " (" + JSON.stringify(value) + ")";
          console.error("Error deserializing property " + printedProp);
          e.__seen = true;
        } else console.error("Error deserializing property " + key + " of " + objString);
        throw e;
      }
    }
  }, {
    key: "recreateProperty",
    value: function recreateProperty(key, value, serializedObjMap, pool, path) {
      var _this3 = this;

      if (typeof value === "string" && pool.expressionSerializer.isSerializedExpression(value)) return pool.expressionSerializer.deserializeExpr(value);

      if (isPrimitive(value)) return value;

      if (Array.isArray(value)) return value.map(function (ea, i) {
        return _this3.recreateProperty(i, ea, serializedObjMap, pool, path.concat(i));
      });

      var idPropertyName = value.__serialization_id_property__ || this.idPropertyName;
      var valueRef = pool.refForId(value[idPropertyName]) || ObjectRef.fromSnapshot(value[idPropertyName], serializedObjMap, pool, path, this.idPropertyName);
      return valueRef.realObj;
    }
  }, {
    key: "isObjectRef",
    get: function get() {
      return true;
    }
  }, {
    key: "currentSnapshot",
    get: function get() {
      return this.snapshots[lively_lang.arr.last(this.snapshotVersions)];
    }
  }]);
  return ObjectRef;
}();

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-


var ObjectPool = function () {
  createClass(ObjectPool, null, [{
    key: "requiredModulesOfSnapshot",
    value: function requiredModulesOfSnapshot(snapshot, options) {
      return new this(options).requiredModulesOfSnapshot(snapshot);
    }
  }, {
    key: "fromJSONSnapshot",
    value: function fromJSONSnapshot(jsonSnapshoted, options) {
      return this.fromSnapshot(JSON.parse(jsonSnapshoted), options);
    }
  }, {
    key: "fromSnapshot",
    value: function fromSnapshot(snapshoted, options) {
      return new this(options).readSnapshot(snapshoted);
    }
  }]);

  function ObjectPool(options) {
    classCallCheck(this, ObjectPool);

    this.uuidGen = lively_lang.string.newUUID;
    this._obj_ref_map = new Map();
    this._id_ref_map = {};

    options = _extends({ ignoreClassNotFound: true, idPropertyName: "id" }, options);
    this.classHelper = new ClassHelper(options);
    this.expressionSerializer = new ExpressionSerializer();
    this.reinitializeIds = null;
    this.setOptions(options);
  }

  createClass(ObjectPool, [{
    key: "setOptions",
    value: function setOptions() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (options.idPropertyName) this.idPropertyName = options.idPropertyName;
      if (options.uuidGen) this.uuidGen = options.uuidGen;
      if (options.reinitializeIds) this.reinitializeIds = options.reinitializeIds;
      if (options.hasOwnProperty("ignoreClassNotFound")) this.classHelper.options.ignoreClassNotFound = options.ignoreClassNotFound;
    }
  }, {
    key: "knowsId",
    value: function knowsId(id) {
      return !!this._id_ref_map[id];
    }
  }, {
    key: "refForId",
    value: function refForId(id) {
      return this._id_ref_map[id];
    }
  }, {
    key: "resolveToObj",
    value: function resolveToObj(id) {
      var ref = this._id_ref_map[id];return ref ? ref.realObj : undefined;
    }
  }, {
    key: "ref",
    value: function ref(obj$$1) {
      return this._obj_ref_map.get(obj$$1);
    }
  }, {
    key: "objects",
    value: function objects() {
      return Array.from(this._obj_ref_map.keys());
    }
  }, {
    key: "objectRefs",
    value: function objectRefs() {
      return Array.from(this._obj_ref_map.values());
    }
  }, {
    key: "internalAddRef",
    value: function internalAddRef(ref) {
      if (ref.realObj) this._obj_ref_map.set(ref.realObj, ref);
      this._id_ref_map[ref.id] = ref;
      return ref;
    }
  }, {
    key: "add",
    value: function add(obj$$1) {
      var _this4 = this;

      // adds an object to the object pool and returns a "ref" object
      // that is guaranteed to be JSON.stringifyable and that can be used as a place
      // holder in a serialized graph / list

      // primitive objects don't need to be registered
      if (isPrimitive(obj$$1)) return undefined;

      if (Array.isArray(obj$$1)) return obj$$1.map(function (element) {
        return _this4.add(element);
      });

      var idPropertyName = obj$$1.__serialization_id_property__ || this.idPropertyName;
      return this.ref(obj$$1) || this.internalAddRef(new ObjectRef(obj$$1[idPropertyName] || this.uuidGen(), obj$$1, undefined, this.idPropertyName));
    }
  }, {
    key: "snapshot",
    value: function snapshot() {
      var snapshot = {};
      for (var i = 0, ids = Object.keys(this._id_ref_map); i < ids.length; i++) {
        var ref = this._id_ref_map[ids[i]];
        ref.snapshotObject(snapshot, this);
      }
      return snapshot;
    }
  }, {
    key: "readSnapshot",
    value: function readSnapshot(snapshot) {
      for (var i = 0, ids = Object.keys(snapshot); i < ids.length; i++) {
        if (!this.resolveToObj(ids[i])) ObjectRef.fromSnapshot(ids[i], snapshot, this, [], this.idPropertyName);
      }return this;
    }
  }, {
    key: "jsonSnapshot",
    value: function jsonSnapshot() {
      return JSON.stringify(this.snapshot(), null, 2);
    }
  }, {
    key: "requiredModulesOfSnapshot",
    value: function requiredModulesOfSnapshot(snapshot) {
      var modules = [];

      for (var i = 0, ids = Object.keys(snapshot); i < ids.length; i++) {
        var _modules2;

        var ref = snapshot[ids[i]];

        if (ref.__expr__) {
          var _modules;

          var exprModules = this.expressionSerializer.requiredModulesOf__expr__(ref.__expr__);
          if (exprModules) (_modules = modules).push.apply(_modules, toConsumableArray(exprModules));
          continue;
        }

        var classModules = ClassHelper.sourceModulesInObjRef(ref);
        if (classModules && classModules.length) (_modules2 = modules).push.apply(_modules2, toConsumableArray(classModules.map(function (spec) {
          return (spec.package && spec.package.name || "") + "/" + spec.pathInPackage;
        })));

        if (ref.props) {
          for (var j = 0; j < ref.props.length; j++) {
            var val = ref.props[j].value;
            if (typeof val === "string") {
              var _modules3;

              var _exprModules = this.expressionSerializer.requiredModulesOf__expr__(val);
              if (_exprModules) (_modules3 = modules).push.apply(_modules3, toConsumableArray(_exprModules));
            }
          }
        }
      }

      modules = lively_lang.arr.uniq(modules);

      return modules;
    }
  }]);
  return ObjectPool;
}();

function serialize(obj$$1) {
  var idPropertyName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "id";

  var objPool = new ObjectPool({ idPropertyName: idPropertyName });
  objPool.add(obj$$1);
  return objPool.snapshot();
}

exports.ObjectRef = ObjectRef;
exports.ObjectPool = ObjectPool;
exports.serialize = serialize;

}((this.lively.serializer2 = this.lively.serializer2 || {}),lively.lang));

// INLINED END /Users/robin/Development/lively-next/lively.serializer2/dist/lively.serializer2.js

// INLINED /Users/robin/Development/lively-next/lively.bindings/dist/lively.bindings.js
this.lively = this.lively || {};
(function (exports,lively_lang) {
'use strict';

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

















var set = function set(object, property, value, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent !== null) {
      set(parent, property, value, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    desc.value = value;
  } else {
    var setter = desc.set;

    if (setter !== undefined) {
      setter.call(receiver, value);
    }
  }

  return value;
};

var AttributeConnection = function () {
  function AttributeConnection(source, sourceProp, target, targetProp, spec) {
    classCallCheck(this, AttributeConnection);

    this.init(source, sourceProp, target, targetProp, spec);
  }

  createClass(AttributeConnection, [{
    key: 'init',
    value: function init(source, sourceProp, target, targetProp, spec) {
      this.doNotSerialize = ['isActive', 'converter', 'updater'];
      this.sourceObj = source;
      this.sourceAttrName = sourceProp;
      this.targetObj = target;
      this.targetMethodName = targetProp;
      this.varMapping = { source: source, target: target };

      spec = _extends({
        removeAfterUpdate: false,
        forceAttributeConnection: false,
        garbageCollect: true,
        signalOnAssignment: true
      }, spec);

      if (spec.removeAfterUpdate) this.removeAfterUpdate = true;
      if (spec.forceAttributeConnection) this.forceAttributeConnection = true;
      if (typeof spec.garbageCollect === "boolean") this.garbageCollect = spec.garbageCollect;
      if (typeof spec.signalOnAssignment === "boolean") this.signalOnAssignment = spec.signalOnAssignment;

      // when converter function references objects from its environment
      // we can't serialize it. To fail as early as possible we will
      // serialize the converter / updater already in the setters
      if (spec.converter) this.setConverter(spec.converter);
      if (spec.updater) this.setUpdater(spec.updater);
      if (spec.varMapping) this.varMapping = Object.assign(spec.varMapping, this.varMapping);

      return this;
    }
  }, {
    key: '__after_deserialize__',
    value: function __after_deserialize__(snapshot, objRef) {
      this.connect();
    }
  }, {
    key: 'onSourceAndTargetRestored',
    value: function onSourceAndTargetRestored() {
      if (this.sourceObj && this.targetObj) this.connect();
    }
  }, {
    key: 'copy',
    value: function copy(copier) {
      return AttributeConnection.fromLiteral(this.toLiteral(), copier);
    }
  }, {
    key: 'fixInstanceAfterCopyingFromSite',
    value: function fixInstanceAfterCopyingFromSite(name, ref, index) {
      // alert("removed connection: "  + this)
      this.disconnect();
    }
  }, {
    key: 'clone',
    value: function clone() {
      //rk 2012-10-09: What is the reason to have clone AND copy?!
      var con = new this.constructor(this.getSourceObj(), this.getSourceAttrName(), this.getTargetObj(), this.getTargetMethodName(), this.getSpec());
      if (this.dependedBy) con.dependedBy = this.dependedBy;
      return con;
    }

    // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    // accessing

  }, {
    key: 'getTargetObj',
    value: function getTargetObj() {
      return this.targetObj;
    }
  }, {
    key: 'getSourceObj',
    value: function getSourceObj() {
      return this.sourceObj;
    }
  }, {
    key: 'getSourceAttrName',
    value: function getSourceAttrName() {
      return this.sourceAttrName;
    }
  }, {
    key: 'getTargetMethodName',
    value: function getTargetMethodName() {
      return this.targetMethodName;
    }
  }, {
    key: 'getSourceValue',
    value: function getSourceValue() {
      return this.getSourceObj()[this.getSourceAttrName()];
    }
  }, {
    key: 'getPrivateSourceValue',
    value: function getPrivateSourceValue() {
      return this.sourceObj[this.privateAttrName(this.sourceAttrName)];
    }
  }, {
    key: 'getConverter',
    value: function getConverter() {
      if (!this.converterString) return null;
      if (!this.converter) this.converter = lively_lang.Closure.fromSource(this.converterString, this.varMapping).recreateFunc();
      return this.converter;
    }
  }, {
    key: 'setConverter',
    value: function setConverter(funcOrSource) {
      delete this.converter;
      return this.converterString = funcOrSource ? String(funcOrSource) : null;
    }
  }, {
    key: 'getUpdater',
    value: function getUpdater() {
      if (!this.updaterString) return null;
      if (!this.updater) {
        this.updater = lively_lang.Closure.fromSource(this.updaterString, this.varMapping).recreateFunc();
      }
      return this.updater;
    }
  }, {
    key: 'setUpdater',
    value: function setUpdater(funcOrSource) {
      delete this.updater;
      return this.updaterString = funcOrSource ? String(funcOrSource) : null;
    }
  }, {
    key: 'getSpec',
    value: function getSpec() {
      var spec = {};
      if (this.updaterString) spec.updater = this.getUpdater();
      if (this.converterString) spec.converter = this.getConverter();
      if (this.removeAfterUpdate) spec.removeAfterUpdate = true;
      if (this.forceAttributeConnection) spec.forceAttributeConnection = true;
      if (this.hasOwnProperty("garbageCollect")) spec.garbageCollect = this.garbageCollect;
      if (this.hasOwnProperty("signalOnAssignment")) spec.signalOnAssignment = this.signalOnAssignment;
      return spec;
    }
  }, {
    key: 'resetSpec',
    value: function resetSpec() {
      delete this.garbageCollect;
      delete this.signalOnAssignment;
      delete this.removeAfterUpdate;
      delete this.forceAttributeConnection;
      delete this.converter;
      delete this.converterString;
      delete this.updater;
      delete this.updaterString;
    }
  }, {
    key: 'privateAttrName',
    value: function privateAttrName(attrName) {
      return '$$' + attrName;
    }
  }, {
    key: 'activate',
    value: function activate() {
      this.isActive = true;
    }
  }, {
    key: 'deactivate',
    value: function deactivate() {
      delete this.isActive;
    }
  }, {
    key: 'connect',
    value: function connect() {
      var existing = this.getExistingConnection();
      if (existing !== this) {
        // when existing == null just add new connection when
        // existing === this then connect was called twice or we are in
        // deserialization. Just do nothing then.
        existing && existing.disconnect();
        this.addAttributeConnection();
      }

      // Check for existing getters that might be there and not belong to
      // lively.bindings We deal with them in addSourceObjGetterAndSetter()
      var existingSetter = this.sourceObj.__lookupSetter__(this.sourceAttrName),
          existingGetter = this.sourceObj.__lookupGetter__(this.sourceAttrName);

      // Check if a method is the source. We check both the value behind
      // sourceAttrName and $$sourceAttrName because when deserializing
      // scripts those get currently stored in $$sourceAttrName (for
      // non-scripts it doesn't matter since those methods should be in the
      // prototype chain)
      var methodOrValue = !existingSetter && !existingGetter && (this.getSourceValue() || this.getPrivateSourceValue());

      // method connect... FIXME refactori into own class!
      if (typeof methodOrValue === "function" && !this.forceAttributeConnection) {
        if (!methodOrValue.isWrapped) {
          this.addConnectionWrapper(this.sourceObj, this.sourceAttrName, methodOrValue);
        }
      } else {
        // attribute connect
        this.addSourceObjGetterAndSetter(existingGetter, existingSetter);
      }

      return this;
    }
  }, {
    key: 'disconnect',
    value: function disconnect() {
      var _this = this;

      var obj = this.sourceObj;
      if (!obj || !obj.attributeConnections) return this.removeSourceObjGetterAndSetter();

      obj.attributeConnections = obj.attributeConnections.filter(function (con) {
        return !_this.isSimilarConnection(con);
      });
      var connectionsWithSameSourceAttr = obj.attributeConnections.filter(function (con) {
        return _this.getSourceAttrName() == con.getSourceAttrName();
      });
      if (obj.attributeConnections.length == 0) delete obj.attributeConnections;
      if (connectionsWithSameSourceAttr.length == 0) this.removeSourceObjGetterAndSetter();

      return null;
    }
  }, {
    key: 'update',
    value: function update(newValue, oldValue) {
      // This method is optimized for Safari and Chrome.
      // See tests.BindingTests.BindingsProfiler
      // The following requirements exists:
      // - Complete Customization of control (how often, if at all, binding
      //   should be activated, parameters passed, delay,... )
      // - run converter with oldValue and newValue
      // - when updater is existing run converter only if update is proceeded
      // - bind is slow
      // - arguments is slow when it's items are accessed or it's converted
      //   using arr.from. Note 2014-02-10: We currently need to modify the
      //   argument array for allowing conversion.

      if (this.isActive /*this.isRecursivelyActivated()*/) return null;
      var connection = this,
          updater = this.getUpdater(),
          converter = this.getConverter(),
          target = this.targetObj,
          propName = this.targetMethodName;
      if (!target || !propName) {
        var msg = 'Cannot update ' + this.toString(newValue) + ' because of no target (' + target + ') or targetProp (' + propName + ') ';
        if (this.isWeakConnection) {
          this.disconnect();
        }
        console.error(msg);

        return null;
      }
      var targetMethod = target[propName],
          callOrSetTarget = function callOrSetTarget(newValue, oldValue) {
        // use a function and not a method to capture this in self and so
        // that no bind is necessary and oldValue is accessible. Note that
        // when updater calls this method arguments can be more than just
        // the new value
        var args = lively_lang.arr.from(arguments);
        if (converter) {
          newValue = converter.call(connection, newValue, oldValue);
          args[0] = newValue;
        }
        var result = typeof targetMethod === 'function' ? targetMethod.apply(target, args) : target[propName] = newValue;
        if (connection.removeAfterUpdate) connection.disconnect();
        return result;
      };

      try {
        this.isActive = true;
        return updater ? updater.call(this, callOrSetTarget, newValue, oldValue) : callOrSetTarget(newValue, oldValue);
      } catch (e) {
        var world = this.sourceObj && typeof this.sourceObj.world === "function" && this.sourceObj.world() || this.targetObj && typeof this.targetObj.world === "function" && this.targetObj.world();
        if (world) {
          world.logError(e, 'AttributeConnection>>update: ');
        } else {
          console.error('Error when trying to update ' + this + ' with value ' + newValue + ':\n' + e + '\n' + e.stack);
        }
      } finally {
        delete this.isActive;
      }

      return null;
    }
  }, {
    key: 'addSourceObjGetterAndSetter',
    value: function addSourceObjGetterAndSetter(existingGetter, existingSetter) {
      if (existingGetter && existingGetter.isAttributeConnectionGetter || existingSetter && existingSetter.isAttributeConnectionSetter) {
        return;
      }

      var sourceObj = this.sourceObj,
          sourceAttrName = this.sourceAttrName,
          newAttrName = this.privateAttrName(sourceAttrName);

      if (sourceObj[newAttrName]) {
        console.warn('newAttrName ' + newAttrName + ' already exists.' + 'Are there already other connections?');
      }

      // add new attr to the serialization ignore list
      if (!sourceObj.hasOwnProperty('doNotSerialize')) sourceObj.doNotSerialize = [];
      lively_lang.arr.pushIfNotIncluded(sourceObj.doNotSerialize, newAttrName);

      if (!sourceObj.hasOwnProperty('doNotCopyProperties')) sourceObj.doNotCopyProperties = [];
      lively_lang.arr.pushIfNotIncluded(sourceObj.doNotCopyProperties, newAttrName);

      if (existingGetter) sourceObj.__defineGetter__(newAttrName, existingGetter);
      if (existingSetter) sourceObj.__defineSetter__(newAttrName, existingSetter);

      // assign old value to new slot
      if (!existingGetter && !existingSetter && sourceObj.hasOwnProperty(sourceAttrName)) sourceObj[newAttrName] = sourceObj[sourceAttrName];

      this.sourceObj.__defineSetter__(sourceAttrName, function (newVal) {
        var oldVal = sourceObj[newAttrName];
        sourceObj[newAttrName] = newVal;
        if (sourceObj.attributeConnections === undefined) {
          console.error('Sth wrong with sourceObj, has no attributeConnections');
          return null;
        }
        sourceObj.attributeConnections.forEach(function (c) {
          if (c && c.getSourceAttrName() === sourceAttrName && c.signalOnAssignment) c.update(newVal, oldVal);
        });
        return newVal;
      });
      this.sourceObj.__lookupSetter__(sourceAttrName).isAttributeConnectionSetter = true;

      this.sourceObj.__defineGetter__(this.sourceAttrName, function () {
        return sourceObj[newAttrName];
      });
      this.sourceObj.__lookupGetter__(sourceAttrName).isAttributeConnectionGetter = true;
    }
  }, {
    key: 'addConnectionWrapper',
    value: function addConnectionWrapper(sourceObj, methodName, origMethod) {
      if (typeof origMethod !== "function") {
        throw new Error('addConnectionWrapper didnt get a method to wrap');
      }

      // save so that it can be restored
      sourceObj[this.privateAttrName(methodName)] = origMethod;
      sourceObj[methodName] = function connectionWrapper() {
        if (this.attributeConnections === undefined) throw new Error('Sth wrong with this, has no attributeConnections');
        var conns = lively.lang.obj.clone(this.attributeConnections),
            result = this[methodName].originalFunction.apply(this, arguments);
        conns.forEach(function (c) {
          if (c.getSourceAttrName() === methodName) result = c.update(result);
        });
        return result;
      };

      sourceObj[methodName].isWrapped = true;
      sourceObj[methodName].isConnectionWrapper = true;
      sourceObj[methodName].originalFunction = origMethod; // for getOriginal()
    }
  }, {
    key: 'removeSourceObjGetterAndSetter',
    value: function removeSourceObjGetterAndSetter() {
      // delete the getter and setter and the slot were the real value was stored
      // assign the real value to the old slot
      var realAttrName = this.sourceAttrName,
          helperAttrName = this.privateAttrName(realAttrName),
          srcObj = this.sourceObj;

      if (!srcObj) return;

      if (srcObj.__lookupGetter__(realAttrName)) {
        delete srcObj[realAttrName];
        srcObj[realAttrName] = srcObj[helperAttrName];
        delete srcObj[helperAttrName];
      } else if (srcObj[realAttrName] && srcObj[realAttrName].isConnectionWrapper) {
        srcObj[realAttrName] = srcObj[realAttrName].originalFunction;
      }

      if (srcObj.doNotSerialize && srcObj.doNotSerialize.includes(helperAttrName)) {
        srcObj.doNotSerialize = lively_lang.arr.without(srcObj.doNotSerialize, helperAttrName);
        if (srcObj.doNotSerialize.length == 0) delete srcObj.doNotSerialize;
      }

      if (srcObj.doNotCopyProperties && srcObj.doNotCopyProperties.includes(helperAttrName)) {
        srcObj.doNotCopyProperties = lively_lang.arr.without(srcObj.doNotCopyProperties, helperAttrName);
        if (srcObj.doNotCopyProperties.length == 0) delete srcObj.doNotCopyProperties;
      }
    }
  }, {
    key: 'addAttributeConnection',
    value: function addAttributeConnection() {
      if (!this.sourceObj.attributeConnections) this.sourceObj.attributeConnections = [];
      this.sourceObj.attributeConnections.push(this);
    }
  }, {
    key: 'getExistingConnection',
    value: function getExistingConnection() {
      var conns = this.sourceObj && this.sourceObj.attributeConnections;
      if (!conns) return null;
      for (var i = 0, len = conns.length; i < len; i++) {
        if (this.isSimilarConnection(conns[i])) return conns[i];
      }
      return null;
    }
  }, {
    key: 'isRecursivelyActivated',
    value: function isRecursivelyActivated() {
      // is this enough? Maybe use Stack?
      return this.isActive;
    }
  }, {
    key: 'isSimilarConnection',
    value: function isSimilarConnection(other) {
      if (!other) return false;
      if (other.constructor != this.constructor) return false;
      return this.sourceObj == other.sourceObj && this.sourceAttrName == other.sourceAttrName && this.targetObj == other.targetObj && this.targetMethodName == other.targetMethodName;
    }
  }, {
    key: 'toString',
    value: function toString(optValue) {
      try {
        return lively_lang.string.format('AttributeConnection(%s.%s %s %s.%s)', this.getSourceObj(), this.getSourceAttrName(), optValue ? '-->' + String(optValue) + '-->' : '-->', this.getTargetObj(), this.getTargetMethodName());
      } catch (e) {
        return '<Error in AttributeConnection>>toString>';
      }
    }
  }]);
  return AttributeConnection;
}();

// AttributeConnection.addMethods({
//   toLiteral() {
//     var self  = this;
//     function getId(obj) {
//       if (!obj) {
//         console.warn('Cannot correctly serialize connections having '
//               + 'undefined source or target objects');
//         return null;
//       }
//       if (obj.id && Object.isFunction(obj.id))
//         return obj.id();
//       if (obj.nodeType && obj.getAttribute) { // is it a real node?
//         var id = obj.getAttribute('id')
//         if (!id) { // create a new id
//           id = 'ElementConnection--' + Date.now();
//           obj.setAttribute('id', id);
//         }
//         return id;
//       }
//       console.warn('Cannot correctly serialize connections having '
//             + 'source or target objects that have no id: ' + self);
//       return null
//     }
//     var literal = {
//       sourceObj: getId(this.sourceObj),
//       sourceAttrName: this.sourceAttrName,
//       targetObj: getId(this.targetObj),
//       targetMethodName: this.targetMethodName
//     };
//     if (this.converterString) literal.converter = this.converterString;
//     if (this.updaterString) literal.updater = this.updaterString;
//     if (this.removeAfterUpdate) literal.removeAfterUpdate = true;
//     if (this.forceAttributeConnection) literal.forceAttributeConnection = true;
//     return literal;
//   }
// })

// Object.extend(AttributeConnection, {
//   fromLiteral(literal, importer) {
//     if (!importer)
//       throw new Error('AttributeConnection needs importer for resolving uris!!!');

//     // just create the connection, connection not yet installed!!!
//     var con = new AttributeConnection(
//       null, literal.sourceAttrName, null, literal.targetMethodName, literal);

//     // when target/source obj are restored asynchronly
//     new AttributeConnection(con, 'sourceObj', con, 'onSourceAndTargetRestored',
//       {removeAfterUpdate: true}).connect();
//     new AttributeConnection(con, 'targetObj', con, 'onSourceAndTargetRestored',
//       {removeAfterUpdate: true}).connect();

//     function restore(id, fieldName) {
//       if (!id) {
//         console.warn('cannot deserialize ' + fieldName + ' when deserilaizing a connect');
//         return
//       }
//       if (id.split('--')[0] == 'ElementConnection') { // FIXME brittle!!!
//         con[fieldName] = importer.canvas().ownerDocument.getElementById(id);
//         return
//       }
//       importer.addPatchSite(con, fieldName, id);
//     };

//     restore(literal.sourceObj, 'sourceObj');
//     restore(literal.targetObj, 'targetObj');

//     return con;
//   }
// });

// AttributeConnection.addMethods('serialization', {
//   onrestore() {
//     try {
//       if (this.targetObj && this.sourceObj) this.connect();
//     } catch(e) {
//       dbgOn(true);
//       console.error('AttributeConnection>>onrestore: Cannot restore ' + this + '\n' + e);
//     }
//   }
// });


// documentation: 'connect parameters: source, sourceProp, target, targetProp, spec\n'
//       + 'spec can be: {\n'
//       + '  removeAfterUpdate: Boolean,\n'
//       + '  forceAttributeConnection: Boolean,\n'
//       + '  converter: Function,\n'
//       + '  updater: Function,\n'
//       + '  varMapping: Object\n'
//       + '}',

function connect(sourceObj, attrName, targetObj, targetMethodName, specOrConverter) {
  // 1: determine what kind of connection to create. Default is
  //  AttributeConnection but source.connections/
  //  source.getConnectionPoints can specify different settings
  var connectionPoints = sourceObj.getConnectionPoints && sourceObj.getConnectionPoints() || sourceObj.connections,
      connectionPoint = connectionPoints && connectionPoints[attrName],
      klass = connectionPoint && connectionPoint.map && lively.morphic && lively.morphic.GeometryConnection || connectionPoint && connectionPoint.connectionClassType && lively.Class.forName(connectionPoint.connectionClassType) || AttributeConnection,
      spec;

  // 2: connection settings: converter/updater/...
  if (typeof specOrConverter === "function") {
    console.warn('Directly passing a converter function to connect() ' + 'is deprecated! Use spec object instead!');
    spec = { converter: specOrConverter };
  } else {
    spec = specOrConverter;
  }

  if (connectionPoint) spec = lively.lang.obj.merge(connectionPoint, spec);

  // 3: does a similar connection exist? Yes: update it with new specs,
  //  no: create new connection
  var connection = new klass(sourceObj, attrName, targetObj, targetMethodName, spec),
      existing = connection.getExistingConnection();
  if (existing) {
    existing.resetSpec();
    existing.init(sourceObj, attrName, targetObj, targetMethodName, spec);
    return existing;
  }
  var result = connection.connect();

  // 4: notify source object if it has a #onConnect method
  if (typeof sourceObj.onConnect === "function") {
    sourceObj.onConnect(attrName, targetObj, targetMethodName);
  }

  // 5: If wanted updated the connection right now
  if (connectionPoint && connectionPoint.updateOnConnect) {
    connection.update(sourceObj[attrName]);
  }
  return result;
}

function disconnect(sourceObj, attrName, targetObj, targetMethodName) {
  if (!sourceObj.attributeConnections) return;

  sourceObj.attributeConnections.slice().forEach(function (con) {
    if (con.getSourceAttrName() == attrName && con.getTargetObj() === targetObj && con.getTargetMethodName() == targetMethodName) con.disconnect();
  });

  if (typeof sourceObj['onDisconnect'] == 'function') {
    sourceObj.onDisconnect(attrName, targetObj, targetMethodName);
  }
}

function disconnectAll(sourceObj) {
  while (sourceObj.attributeConnections && sourceObj.attributeConnections.length > 0) {
    sourceObj.attributeConnections[0].disconnect();
  }
}

function once(sourceObj, attrName, targetObj, targetMethodName, spec) {
  spec = spec || {};
  spec.removeAfterUpdate = true;
  return connect(sourceObj, attrName, targetObj, targetMethodName, spec);
}

function signal(sourceObj, attrName, newVal) {
  var connections = sourceObj.attributeConnections;
  if (!connections) return;
  var oldVal = sourceObj[attrName];
  for (var i = 0, len = connections.length; i < len; i++) {
    var c = connections[i];
    if (c.getSourceAttrName() == attrName) c.update(newVal, oldVal);
  }
}

function callWhenNotNull(sourceObj, sourceProp, targetObj, targetSelector) {
  // ensure that sourceObj[sourceProp] is not null, then run targetObj[targetProp]()
  if (sourceObj[sourceProp] != null) {
    targetObj[targetSelector](sourceObj[sourceProp]);
  } else {
    connect(sourceObj, sourceProp, targetObj, targetSelector, { removeAfterUpdate: true });
  }
}

function callWhenPathNotNull(source, path, target, targetProp) {
  var helper = {
    key: path.pop(),
    whenDefined: function whenDefined(context) {
      callWhenNotNull(context, this.key, target, targetProp);
    }
  };

  while (path.length > 0) {
    helper = {
      key: path.pop(),
      next: helper,
      whenDefined: function whenDefined(context) {
        callWhenNotNull(context, this.key, this.next, 'whenDefined');
      }
    };
  }

  helper.whenDefined(source);
}

function noUpdate(noUpdateSpec, func) {
  var globalNoUpdate = false,
      result;
  if (!func && typeof noUpdateSpec === "function") {
    func = noUpdateSpec;globalNoUpdate = true;
  }
  if (globalNoUpdate) {
    // rather a hack for now
    var proto = AttributeConnection.prototype;
    if (!proto.isActive) proto.isActive = 0;
    proto.isActive++;
    try {
      result = func();
    } finally {
      proto.isActive--;
      if (proto.isActive <= 0) proto.isActive;
    }
  } else {
    var obj = noUpdateSpec.sourceObj,
        attr = noUpdateSpec.sourceAttribute,
        targetObj = noUpdateSpec.targetObj,
        targetAttr = noUpdateSpec.targetAttribute,
        filter = targetObj && targetAttr ? function (ea) {
      return ea.getSourceAttrName() === attr && targetObj === ea.getTargetObj() && targetAttr === ea.getTargetMethodName();
    } : function (ea) {
      return ea.getSourceAttrName() === attr;
    },
        conns = obj.attributeConnections.filter(filter);
    lively_lang.arr.invoke(conns, 'activate');
    try {
      result = func();
    } finally {
      lively_lang.arr.invoke(conns, 'deactivate');
    }
  }
  return result;
}

exports.connect = connect;
exports.disconnect = disconnect;
exports.disconnectAll = disconnectAll;
exports.once = once;
exports.signal = signal;
exports.noUpdate = noUpdate;
exports.callWhenNotNull = callWhenNotNull;
exports.callWhenPathNotNull = callWhenPathNotNull;

}((this.lively.bindings = this.lively.bindings || {}),lively.lang));

// INLINED END /Users/robin/Development/lively-next/lively.bindings/dist/lively.bindings.js

/*!
 * VERSION: 1.19.1
 * DATE: 2017-01-17
 * UPDATES AND DOCS AT: http://greensock.com
 * 
 * Includes all of the following: TweenLite, TweenMax, TimelineLite, TimelineMax, EasePack, CSSPlugin, RoundPropsPlugin, BezierPlugin, AttrPlugin, DirectionalRotationPlugin
 *
 * @license Copyright (c) 2008-2017, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/
var _gsScope="undefined"!=typeof module&&module.exports&&"undefined"!=typeof global?global:this||window;(_gsScope._gsQueue||(_gsScope._gsQueue=[])).push(function(){"use strict";_gsScope._gsDefine("TweenMax",["core.Animation","core.SimpleTimeline","TweenLite"],function(a,b,c){var d=function(a){var b,c=[],d=a.length;for(b=0;b!==d;c.push(a[b++]));return c},e=function(a,b,c){var d,e,f=a.cycle;for(d in f)e=f[d],a[d]="function"==typeof e?e(c,b[c]):e[c%e.length];delete a.cycle},f=function(a,b,d){c.call(this,a,b,d),this._cycle=0,this._yoyo=this.vars.yoyo===!0,this._repeat=this.vars.repeat||0,this._repeatDelay=this.vars.repeatDelay||0,this._dirty=!0,this.render=f.prototype.render},g=1e-10,h=c._internals,i=h.isSelector,j=h.isArray,k=f.prototype=c.to({},.1,{}),l=[];f.version="1.19.1",k.constructor=f,k.kill()._gc=!1,f.killTweensOf=f.killDelayedCallsTo=c.killTweensOf,f.getTweensOf=c.getTweensOf,f.lagSmoothing=c.lagSmoothing,f.ticker=c.ticker,f.render=c.render,k.invalidate=function(){return this._yoyo=this.vars.yoyo===!0,this._repeat=this.vars.repeat||0,this._repeatDelay=this.vars.repeatDelay||0,this._uncache(!0),c.prototype.invalidate.call(this)},k.updateTo=function(a,b){var d,e=this.ratio,f=this.vars.immediateRender||a.immediateRender;b&&this._startTime<this._timeline._time&&(this._startTime=this._timeline._time,this._uncache(!1),this._gc?this._enabled(!0,!1):this._timeline.insert(this,this._startTime-this._delay));for(d in a)this.vars[d]=a[d];if(this._initted||f)if(b)this._initted=!1,f&&this.render(0,!0,!0);else if(this._gc&&this._enabled(!0,!1),this._notifyPluginsOfEnabled&&this._firstPT&&c._onPluginEvent("_onDisable",this),this._time/this._duration>.998){var g=this._totalTime;this.render(0,!0,!1),this._initted=!1,this.render(g,!0,!1)}else if(this._initted=!1,this._init(),this._time>0||f)for(var h,i=1/(1-e),j=this._firstPT;j;)h=j.s+j.c,j.c*=i,j.s=h-j.c,j=j._next;return this},k.render=function(a,b,c){this._initted||0===this._duration&&this.vars.repeat&&this.invalidate();var d,e,f,i,j,k,l,m,n=this._dirty?this.totalDuration():this._totalDuration,o=this._time,p=this._totalTime,q=this._cycle,r=this._duration,s=this._rawPrevTime;if(a>=n-1e-7&&a>=0?(this._totalTime=n,this._cycle=this._repeat,this._yoyo&&0!==(1&this._cycle)?(this._time=0,this.ratio=this._ease._calcEnd?this._ease.getRatio(0):0):(this._time=r,this.ratio=this._ease._calcEnd?this._ease.getRatio(1):1),this._reversed||(d=!0,e="onComplete",c=c||this._timeline.autoRemoveChildren),0===r&&(this._initted||!this.vars.lazy||c)&&(this._startTime===this._timeline._duration&&(a=0),(0>s||0>=a&&a>=-1e-7||s===g&&"isPause"!==this.data)&&s!==a&&(c=!0,s>g&&(e="onReverseComplete")),this._rawPrevTime=m=!b||a||s===a?a:g)):1e-7>a?(this._totalTime=this._time=this._cycle=0,this.ratio=this._ease._calcEnd?this._ease.getRatio(0):0,(0!==p||0===r&&s>0)&&(e="onReverseComplete",d=this._reversed),0>a&&(this._active=!1,0===r&&(this._initted||!this.vars.lazy||c)&&(s>=0&&(c=!0),this._rawPrevTime=m=!b||a||s===a?a:g)),this._initted||(c=!0)):(this._totalTime=this._time=a,0!==this._repeat&&(i=r+this._repeatDelay,this._cycle=this._totalTime/i>>0,0!==this._cycle&&this._cycle===this._totalTime/i&&a>=p&&this._cycle--,this._time=this._totalTime-this._cycle*i,this._yoyo&&0!==(1&this._cycle)&&(this._time=r-this._time),this._time>r?this._time=r:this._time<0&&(this._time=0)),this._easeType?(j=this._time/r,k=this._easeType,l=this._easePower,(1===k||3===k&&j>=.5)&&(j=1-j),3===k&&(j*=2),1===l?j*=j:2===l?j*=j*j:3===l?j*=j*j*j:4===l&&(j*=j*j*j*j),1===k?this.ratio=1-j:2===k?this.ratio=j:this._time/r<.5?this.ratio=j/2:this.ratio=1-j/2):this.ratio=this._ease.getRatio(this._time/r)),o===this._time&&!c&&q===this._cycle)return void(p!==this._totalTime&&this._onUpdate&&(b||this._callback("onUpdate")));if(!this._initted){if(this._init(),!this._initted||this._gc)return;if(!c&&this._firstPT&&(this.vars.lazy!==!1&&this._duration||this.vars.lazy&&!this._duration))return this._time=o,this._totalTime=p,this._rawPrevTime=s,this._cycle=q,h.lazyTweens.push(this),void(this._lazy=[a,b]);this._time&&!d?this.ratio=this._ease.getRatio(this._time/r):d&&this._ease._calcEnd&&(this.ratio=this._ease.getRatio(0===this._time?0:1))}for(this._lazy!==!1&&(this._lazy=!1),this._active||!this._paused&&this._time!==o&&a>=0&&(this._active=!0),0===p&&(2===this._initted&&a>0&&this._init(),this._startAt&&(a>=0?this._startAt.render(a,b,c):e||(e="_dummyGS")),this.vars.onStart&&(0!==this._totalTime||0===r)&&(b||this._callback("onStart"))),f=this._firstPT;f;)f.f?f.t[f.p](f.c*this.ratio+f.s):f.t[f.p]=f.c*this.ratio+f.s,f=f._next;this._onUpdate&&(0>a&&this._startAt&&this._startTime&&this._startAt.render(a,b,c),b||(this._totalTime!==p||e)&&this._callback("onUpdate")),this._cycle!==q&&(b||this._gc||this.vars.onRepeat&&this._callback("onRepeat")),e&&(!this._gc||c)&&(0>a&&this._startAt&&!this._onUpdate&&this._startTime&&this._startAt.render(a,b,c),d&&(this._timeline.autoRemoveChildren&&this._enabled(!1,!1),this._active=!1),!b&&this.vars[e]&&this._callback(e),0===r&&this._rawPrevTime===g&&m!==g&&(this._rawPrevTime=0))},f.to=function(a,b,c){return new f(a,b,c)},f.from=function(a,b,c){return c.runBackwards=!0,c.immediateRender=0!=c.immediateRender,new f(a,b,c)},f.fromTo=function(a,b,c,d){return d.startAt=c,d.immediateRender=0!=d.immediateRender&&0!=c.immediateRender,new f(a,b,d)},f.staggerTo=f.allTo=function(a,b,g,h,k,m,n){h=h||0;var o,p,q,r,s=0,t=[],u=function(){g.onComplete&&g.onComplete.apply(g.onCompleteScope||this,arguments),k.apply(n||g.callbackScope||this,m||l)},v=g.cycle,w=g.startAt&&g.startAt.cycle;for(j(a)||("string"==typeof a&&(a=c.selector(a)||a),i(a)&&(a=d(a))),a=a||[],0>h&&(a=d(a),a.reverse(),h*=-1),o=a.length-1,q=0;o>=q;q++){p={};for(r in g)p[r]=g[r];if(v&&(e(p,a,q),null!=p.duration&&(b=p.duration,delete p.duration)),w){w=p.startAt={};for(r in g.startAt)w[r]=g.startAt[r];e(p.startAt,a,q)}p.delay=s+(p.delay||0),q===o&&k&&(p.onComplete=u),t[q]=new f(a[q],b,p),s+=h}return t},f.staggerFrom=f.allFrom=function(a,b,c,d,e,g,h){return c.runBackwards=!0,c.immediateRender=0!=c.immediateRender,f.staggerTo(a,b,c,d,e,g,h)},f.staggerFromTo=f.allFromTo=function(a,b,c,d,e,g,h,i){return d.startAt=c,d.immediateRender=0!=d.immediateRender&&0!=c.immediateRender,f.staggerTo(a,b,d,e,g,h,i)},f.delayedCall=function(a,b,c,d,e){return new f(b,0,{delay:a,onComplete:b,onCompleteParams:c,callbackScope:d,onReverseComplete:b,onReverseCompleteParams:c,immediateRender:!1,useFrames:e,overwrite:0})},f.set=function(a,b){return new f(a,0,b)},f.isTweening=function(a){return c.getTweensOf(a,!0).length>0};var m=function(a,b){for(var d=[],e=0,f=a._first;f;)f instanceof c?d[e++]=f:(b&&(d[e++]=f),d=d.concat(m(f,b)),e=d.length),f=f._next;return d},n=f.getAllTweens=function(b){return m(a._rootTimeline,b).concat(m(a._rootFramesTimeline,b))};f.killAll=function(a,c,d,e){null==c&&(c=!0),null==d&&(d=!0);var f,g,h,i=n(0!=e),j=i.length,k=c&&d&&e;for(h=0;j>h;h++)g=i[h],(k||g instanceof b||(f=g.target===g.vars.onComplete)&&d||c&&!f)&&(a?g.totalTime(g._reversed?0:g.totalDuration()):g._enabled(!1,!1))},f.killChildTweensOf=function(a,b){if(null!=a){var e,g,k,l,m,n=h.tweenLookup;if("string"==typeof a&&(a=c.selector(a)||a),i(a)&&(a=d(a)),j(a))for(l=a.length;--l>-1;)f.killChildTweensOf(a[l],b);else{e=[];for(k in n)for(g=n[k].target.parentNode;g;)g===a&&(e=e.concat(n[k].tweens)),g=g.parentNode;for(m=e.length,l=0;m>l;l++)b&&e[l].totalTime(e[l].totalDuration()),e[l]._enabled(!1,!1)}}};var o=function(a,c,d,e){c=c!==!1,d=d!==!1,e=e!==!1;for(var f,g,h=n(e),i=c&&d&&e,j=h.length;--j>-1;)g=h[j],(i||g instanceof b||(f=g.target===g.vars.onComplete)&&d||c&&!f)&&g.paused(a)};return f.pauseAll=function(a,b,c){o(!0,a,b,c)},f.resumeAll=function(a,b,c){o(!1,a,b,c)},f.globalTimeScale=function(b){var d=a._rootTimeline,e=c.ticker.time;return arguments.length?(b=b||g,d._startTime=e-(e-d._startTime)*d._timeScale/b,d=a._rootFramesTimeline,e=c.ticker.frame,d._startTime=e-(e-d._startTime)*d._timeScale/b,d._timeScale=a._rootTimeline._timeScale=b,b):d._timeScale},k.progress=function(a,b){return arguments.length?this.totalTime(this.duration()*(this._yoyo&&0!==(1&this._cycle)?1-a:a)+this._cycle*(this._duration+this._repeatDelay),b):this._time/this.duration()},k.totalProgress=function(a,b){return arguments.length?this.totalTime(this.totalDuration()*a,b):this._totalTime/this.totalDuration()},k.time=function(a,b){return arguments.length?(this._dirty&&this.totalDuration(),a>this._duration&&(a=this._duration),this._yoyo&&0!==(1&this._cycle)?a=this._duration-a+this._cycle*(this._duration+this._repeatDelay):0!==this._repeat&&(a+=this._cycle*(this._duration+this._repeatDelay)),this.totalTime(a,b)):this._time},k.duration=function(b){return arguments.length?a.prototype.duration.call(this,b):this._duration},k.totalDuration=function(a){return arguments.length?-1===this._repeat?this:this.duration((a-this._repeat*this._repeatDelay)/(this._repeat+1)):(this._dirty&&(this._totalDuration=-1===this._repeat?999999999999:this._duration*(this._repeat+1)+this._repeatDelay*this._repeat,this._dirty=!1),this._totalDuration)},k.repeat=function(a){return arguments.length?(this._repeat=a,this._uncache(!0)):this._repeat},k.repeatDelay=function(a){return arguments.length?(this._repeatDelay=a,this._uncache(!0)):this._repeatDelay},k.yoyo=function(a){return arguments.length?(this._yoyo=a,this):this._yoyo},f},!0),_gsScope._gsDefine("TimelineLite",["core.Animation","core.SimpleTimeline","TweenLite"],function(a,b,c){var d=function(a){b.call(this,a),this._labels={},this.autoRemoveChildren=this.vars.autoRemoveChildren===!0,this.smoothChildTiming=this.vars.smoothChildTiming===!0,this._sortChildren=!0,this._onUpdate=this.vars.onUpdate;var c,d,e=this.vars;for(d in e)c=e[d],i(c)&&-1!==c.join("").indexOf("{self}")&&(e[d]=this._swapSelfInParams(c));i(e.tweens)&&this.add(e.tweens,0,e.align,e.stagger)},e=1e-10,f=c._internals,g=d._internals={},h=f.isSelector,i=f.isArray,j=f.lazyTweens,k=f.lazyRender,l=_gsScope._gsDefine.globals,m=function(a){var b,c={};for(b in a)c[b]=a[b];return c},n=function(a,b,c){var d,e,f=a.cycle;for(d in f)e=f[d],a[d]="function"==typeof e?e(c,b[c]):e[c%e.length];delete a.cycle},o=g.pauseCallback=function(){},p=function(a){var b,c=[],d=a.length;for(b=0;b!==d;c.push(a[b++]));return c},q=d.prototype=new b;return d.version="1.19.1",q.constructor=d,q.kill()._gc=q._forcingPlayhead=q._hasPause=!1,q.to=function(a,b,d,e){var f=d.repeat&&l.TweenMax||c;return b?this.add(new f(a,b,d),e):this.set(a,d,e)},q.from=function(a,b,d,e){return this.add((d.repeat&&l.TweenMax||c).from(a,b,d),e)},q.fromTo=function(a,b,d,e,f){var g=e.repeat&&l.TweenMax||c;return b?this.add(g.fromTo(a,b,d,e),f):this.set(a,e,f)},q.staggerTo=function(a,b,e,f,g,i,j,k){var l,o,q=new d({onComplete:i,onCompleteParams:j,callbackScope:k,smoothChildTiming:this.smoothChildTiming}),r=e.cycle;for("string"==typeof a&&(a=c.selector(a)||a),a=a||[],h(a)&&(a=p(a)),f=f||0,0>f&&(a=p(a),a.reverse(),f*=-1),o=0;o<a.length;o++)l=m(e),l.startAt&&(l.startAt=m(l.startAt),l.startAt.cycle&&n(l.startAt,a,o)),r&&(n(l,a,o),null!=l.duration&&(b=l.duration,delete l.duration)),q.to(a[o],b,l,o*f);return this.add(q,g)},q.staggerFrom=function(a,b,c,d,e,f,g,h){return c.immediateRender=0!=c.immediateRender,c.runBackwards=!0,this.staggerTo(a,b,c,d,e,f,g,h)},q.staggerFromTo=function(a,b,c,d,e,f,g,h,i){return d.startAt=c,d.immediateRender=0!=d.immediateRender&&0!=c.immediateRender,this.staggerTo(a,b,d,e,f,g,h,i)},q.call=function(a,b,d,e){return this.add(c.delayedCall(0,a,b,d),e)},q.set=function(a,b,d){return d=this._parseTimeOrLabel(d,0,!0),null==b.immediateRender&&(b.immediateRender=d===this._time&&!this._paused),this.add(new c(a,0,b),d)},d.exportRoot=function(a,b){a=a||{},null==a.smoothChildTiming&&(a.smoothChildTiming=!0);var e,f,g=new d(a),h=g._timeline;for(null==b&&(b=!0),h._remove(g,!0),g._startTime=0,g._rawPrevTime=g._time=g._totalTime=h._time,e=h._first;e;)f=e._next,b&&e instanceof c&&e.target===e.vars.onComplete||g.add(e,e._startTime-e._delay),e=f;return h.add(g,0),g},q.add=function(e,f,g,h){var j,k,l,m,n,o;if("number"!=typeof f&&(f=this._parseTimeOrLabel(f,0,!0,e)),!(e instanceof a)){if(e instanceof Array||e&&e.push&&i(e)){for(g=g||"normal",h=h||0,j=f,k=e.length,l=0;k>l;l++)i(m=e[l])&&(m=new d({tweens:m})),this.add(m,j),"string"!=typeof m&&"function"!=typeof m&&("sequence"===g?j=m._startTime+m.totalDuration()/m._timeScale:"start"===g&&(m._startTime-=m.delay())),j+=h;return this._uncache(!0)}if("string"==typeof e)return this.addLabel(e,f);if("function"!=typeof e)throw"Cannot add "+e+" into the timeline; it is not a tween, timeline, function, or string.";e=c.delayedCall(0,e)}if(b.prototype.add.call(this,e,f),(this._gc||this._time===this._duration)&&!this._paused&&this._duration<this.duration())for(n=this,o=n.rawTime()>e._startTime;n._timeline;)o&&n._timeline.smoothChildTiming?n.totalTime(n._totalTime,!0):n._gc&&n._enabled(!0,!1),n=n._timeline;return this},q.remove=function(b){if(b instanceof a){this._remove(b,!1);var c=b._timeline=b.vars.useFrames?a._rootFramesTimeline:a._rootTimeline;return b._startTime=(b._paused?b._pauseTime:c._time)-(b._reversed?b.totalDuration()-b._totalTime:b._totalTime)/b._timeScale,this}if(b instanceof Array||b&&b.push&&i(b)){for(var d=b.length;--d>-1;)this.remove(b[d]);return this}return"string"==typeof b?this.removeLabel(b):this.kill(null,b)},q._remove=function(a,c){b.prototype._remove.call(this,a,c);var d=this._last;return d?this._time>this.duration()&&(this._time=this._duration,this._totalTime=this._totalDuration):this._time=this._totalTime=this._duration=this._totalDuration=0,this},q.append=function(a,b){return this.add(a,this._parseTimeOrLabel(null,b,!0,a))},q.insert=q.insertMultiple=function(a,b,c,d){return this.add(a,b||0,c,d)},q.appendMultiple=function(a,b,c,d){return this.add(a,this._parseTimeOrLabel(null,b,!0,a),c,d)},q.addLabel=function(a,b){return this._labels[a]=this._parseTimeOrLabel(b),this},q.addPause=function(a,b,d,e){var f=c.delayedCall(0,o,d,e||this);return f.vars.onComplete=f.vars.onReverseComplete=b,f.data="isPause",this._hasPause=!0,this.add(f,a)},q.removeLabel=function(a){return delete this._labels[a],this},q.getLabelTime=function(a){return null!=this._labels[a]?this._labels[a]:-1},q._parseTimeOrLabel=function(b,c,d,e){var f;if(e instanceof a&&e.timeline===this)this.remove(e);else if(e&&(e instanceof Array||e.push&&i(e)))for(f=e.length;--f>-1;)e[f]instanceof a&&e[f].timeline===this&&this.remove(e[f]);if("string"==typeof c)return this._parseTimeOrLabel(c,d&&"number"==typeof b&&null==this._labels[c]?b-this.duration():0,d);if(c=c||0,"string"!=typeof b||!isNaN(b)&&null==this._labels[b])null==b&&(b=this.duration());else{if(f=b.indexOf("="),-1===f)return null==this._labels[b]?d?this._labels[b]=this.duration()+c:c:this._labels[b]+c;c=parseInt(b.charAt(f-1)+"1",10)*Number(b.substr(f+1)),b=f>1?this._parseTimeOrLabel(b.substr(0,f-1),0,d):this.duration()}return Number(b)+c},q.seek=function(a,b){return this.totalTime("number"==typeof a?a:this._parseTimeOrLabel(a),b!==!1)},q.stop=function(){return this.paused(!0)},q.gotoAndPlay=function(a,b){return this.play(a,b)},q.gotoAndStop=function(a,b){return this.pause(a,b)},q.render=function(a,b,c){this._gc&&this._enabled(!0,!1);var d,f,g,h,i,l,m,n=this._dirty?this.totalDuration():this._totalDuration,o=this._time,p=this._startTime,q=this._timeScale,r=this._paused;if(a>=n-1e-7&&a>=0)this._totalTime=this._time=n,this._reversed||this._hasPausedChild()||(f=!0,h="onComplete",i=!!this._timeline.autoRemoveChildren,0===this._duration&&(0>=a&&a>=-1e-7||this._rawPrevTime<0||this._rawPrevTime===e)&&this._rawPrevTime!==a&&this._first&&(i=!0,this._rawPrevTime>e&&(h="onReverseComplete"))),this._rawPrevTime=this._duration||!b||a||this._rawPrevTime===a?a:e,a=n+1e-4;else if(1e-7>a)if(this._totalTime=this._time=0,(0!==o||0===this._duration&&this._rawPrevTime!==e&&(this._rawPrevTime>0||0>a&&this._rawPrevTime>=0))&&(h="onReverseComplete",f=this._reversed),0>a)this._active=!1,this._timeline.autoRemoveChildren&&this._reversed?(i=f=!0,h="onReverseComplete"):this._rawPrevTime>=0&&this._first&&(i=!0),this._rawPrevTime=a;else{if(this._rawPrevTime=this._duration||!b||a||this._rawPrevTime===a?a:e,0===a&&f)for(d=this._first;d&&0===d._startTime;)d._duration||(f=!1),d=d._next;a=0,this._initted||(i=!0)}else{if(this._hasPause&&!this._forcingPlayhead&&!b){if(a>=o)for(d=this._first;d&&d._startTime<=a&&!l;)d._duration||"isPause"!==d.data||d.ratio||0===d._startTime&&0===this._rawPrevTime||(l=d),d=d._next;else for(d=this._last;d&&d._startTime>=a&&!l;)d._duration||"isPause"===d.data&&d._rawPrevTime>0&&(l=d),d=d._prev;l&&(this._time=a=l._startTime,this._totalTime=a+this._cycle*(this._totalDuration+this._repeatDelay))}this._totalTime=this._time=this._rawPrevTime=a}if(this._time!==o&&this._first||c||i||l){if(this._initted||(this._initted=!0),this._active||!this._paused&&this._time!==o&&a>0&&(this._active=!0),0===o&&this.vars.onStart&&(0===this._time&&this._duration||b||this._callback("onStart")),m=this._time,m>=o)for(d=this._first;d&&(g=d._next,m===this._time&&(!this._paused||r));)(d._active||d._startTime<=m&&!d._paused&&!d._gc)&&(l===d&&this.pause(),d._reversed?d.render((d._dirty?d.totalDuration():d._totalDuration)-(a-d._startTime)*d._timeScale,b,c):d.render((a-d._startTime)*d._timeScale,b,c)),d=g;else for(d=this._last;d&&(g=d._prev,m===this._time&&(!this._paused||r));){if(d._active||d._startTime<=o&&!d._paused&&!d._gc){if(l===d){for(l=d._prev;l&&l.endTime()>this._time;)l.render(l._reversed?l.totalDuration()-(a-l._startTime)*l._timeScale:(a-l._startTime)*l._timeScale,b,c),l=l._prev;l=null,this.pause()}d._reversed?d.render((d._dirty?d.totalDuration():d._totalDuration)-(a-d._startTime)*d._timeScale,b,c):d.render((a-d._startTime)*d._timeScale,b,c)}d=g}this._onUpdate&&(b||(j.length&&k(),this._callback("onUpdate"))),h&&(this._gc||(p===this._startTime||q!==this._timeScale)&&(0===this._time||n>=this.totalDuration())&&(f&&(j.length&&k(),this._timeline.autoRemoveChildren&&this._enabled(!1,!1),this._active=!1),!b&&this.vars[h]&&this._callback(h)))}},q._hasPausedChild=function(){for(var a=this._first;a;){if(a._paused||a instanceof d&&a._hasPausedChild())return!0;a=a._next}return!1},q.getChildren=function(a,b,d,e){e=e||-9999999999;for(var f=[],g=this._first,h=0;g;)g._startTime<e||(g instanceof c?b!==!1&&(f[h++]=g):(d!==!1&&(f[h++]=g),a!==!1&&(f=f.concat(g.getChildren(!0,b,d)),h=f.length))),g=g._next;return f},q.getTweensOf=function(a,b){var d,e,f=this._gc,g=[],h=0;for(f&&this._enabled(!0,!0),d=c.getTweensOf(a),e=d.length;--e>-1;)(d[e].timeline===this||b&&this._contains(d[e]))&&(g[h++]=d[e]);return f&&this._enabled(!1,!0),g},q.recent=function(){return this._recent},q._contains=function(a){for(var b=a.timeline;b;){if(b===this)return!0;b=b.timeline}return!1},q.shiftChildren=function(a,b,c){c=c||0;for(var d,e=this._first,f=this._labels;e;)e._startTime>=c&&(e._startTime+=a),e=e._next;if(b)for(d in f)f[d]>=c&&(f[d]+=a);return this._uncache(!0)},q._kill=function(a,b){if(!a&&!b)return this._enabled(!1,!1);for(var c=b?this.getTweensOf(b):this.getChildren(!0,!0,!1),d=c.length,e=!1;--d>-1;)c[d]._kill(a,b)&&(e=!0);return e},q.clear=function(a){var b=this.getChildren(!1,!0,!0),c=b.length;for(this._time=this._totalTime=0;--c>-1;)b[c]._enabled(!1,!1);return a!==!1&&(this._labels={}),this._uncache(!0)},q.invalidate=function(){for(var b=this._first;b;)b.invalidate(),b=b._next;return a.prototype.invalidate.call(this)},q._enabled=function(a,c){if(a===this._gc)for(var d=this._first;d;)d._enabled(a,!0),d=d._next;return b.prototype._enabled.call(this,a,c)},q.totalTime=function(b,c,d){this._forcingPlayhead=!0;var e=a.prototype.totalTime.apply(this,arguments);return this._forcingPlayhead=!1,e},q.duration=function(a){return arguments.length?(0!==this.duration()&&0!==a&&this.timeScale(this._duration/a),this):(this._dirty&&this.totalDuration(),this._duration)},q.totalDuration=function(a){if(!arguments.length){if(this._dirty){for(var b,c,d=0,e=this._last,f=999999999999;e;)b=e._prev,e._dirty&&e.totalDuration(),e._startTime>f&&this._sortChildren&&!e._paused?this.add(e,e._startTime-e._delay):f=e._startTime,e._startTime<0&&!e._paused&&(d-=e._startTime,this._timeline.smoothChildTiming&&(this._startTime+=e._startTime/this._timeScale),this.shiftChildren(-e._startTime,!1,-9999999999),f=0),c=e._startTime+e._totalDuration/e._timeScale,c>d&&(d=c),e=b;this._duration=this._totalDuration=d,this._dirty=!1}return this._totalDuration}return a&&this.totalDuration()?this.timeScale(this._totalDuration/a):this},q.paused=function(b){if(!b)for(var c=this._first,d=this._time;c;)c._startTime===d&&"isPause"===c.data&&(c._rawPrevTime=0),c=c._next;return a.prototype.paused.apply(this,arguments)},q.usesFrames=function(){for(var b=this._timeline;b._timeline;)b=b._timeline;return b===a._rootFramesTimeline},q.rawTime=function(a){return a&&(this._paused||this._repeat&&this.time()>0&&this.totalProgress()<1)?this._totalTime%(this._duration+this._repeatDelay):this._paused?this._totalTime:(this._timeline.rawTime(a)-this._startTime)*this._timeScale},d},!0),_gsScope._gsDefine("TimelineMax",["TimelineLite","TweenLite","easing.Ease"],function(a,b,c){var d=function(b){a.call(this,b),this._repeat=this.vars.repeat||0,this._repeatDelay=this.vars.repeatDelay||0,this._cycle=0,this._yoyo=this.vars.yoyo===!0,this._dirty=!0},e=1e-10,f=b._internals,g=f.lazyTweens,h=f.lazyRender,i=_gsScope._gsDefine.globals,j=new c(null,null,1,0),k=d.prototype=new a;return k.constructor=d,k.kill()._gc=!1,d.version="1.19.1",k.invalidate=function(){return this._yoyo=this.vars.yoyo===!0,this._repeat=this.vars.repeat||0,this._repeatDelay=this.vars.repeatDelay||0,this._uncache(!0),a.prototype.invalidate.call(this)},k.addCallback=function(a,c,d,e){return this.add(b.delayedCall(0,a,d,e),c)},k.removeCallback=function(a,b){if(a)if(null==b)this._kill(null,a);else for(var c=this.getTweensOf(a,!1),d=c.length,e=this._parseTimeOrLabel(b);--d>-1;)c[d]._startTime===e&&c[d]._enabled(!1,!1);return this},k.removePause=function(b){return this.removeCallback(a._internals.pauseCallback,b)},k.tweenTo=function(a,c){c=c||{};var d,e,f,g={ease:j,useFrames:this.usesFrames(),immediateRender:!1},h=c.repeat&&i.TweenMax||b;for(e in c)g[e]=c[e];return g.time=this._parseTimeOrLabel(a),d=Math.abs(Number(g.time)-this._time)/this._timeScale||.001,f=new h(this,d,g),g.onStart=function(){f.target.paused(!0),f.vars.time!==f.target.time()&&d===f.duration()&&f.duration(Math.abs(f.vars.time-f.target.time())/f.target._timeScale),c.onStart&&c.onStart.apply(c.onStartScope||c.callbackScope||f,c.onStartParams||[])},f},k.tweenFromTo=function(a,b,c){c=c||{},a=this._parseTimeOrLabel(a),c.startAt={onComplete:this.seek,onCompleteParams:[a],callbackScope:this},c.immediateRender=c.immediateRender!==!1;var d=this.tweenTo(b,c);return d.duration(Math.abs(d.vars.time-a)/this._timeScale||.001)},k.render=function(a,b,c){this._gc&&this._enabled(!0,!1);var d,f,i,j,k,l,m,n,o=this._dirty?this.totalDuration():this._totalDuration,p=this._duration,q=this._time,r=this._totalTime,s=this._startTime,t=this._timeScale,u=this._rawPrevTime,v=this._paused,w=this._cycle;if(a>=o-1e-7&&a>=0)this._locked||(this._totalTime=o,this._cycle=this._repeat),this._reversed||this._hasPausedChild()||(f=!0,j="onComplete",k=!!this._timeline.autoRemoveChildren,0===this._duration&&(0>=a&&a>=-1e-7||0>u||u===e)&&u!==a&&this._first&&(k=!0,u>e&&(j="onReverseComplete"))),this._rawPrevTime=this._duration||!b||a||this._rawPrevTime===a?a:e,this._yoyo&&0!==(1&this._cycle)?this._time=a=0:(this._time=p,a=p+1e-4);else if(1e-7>a)if(this._locked||(this._totalTime=this._cycle=0),this._time=0,(0!==q||0===p&&u!==e&&(u>0||0>a&&u>=0)&&!this._locked)&&(j="onReverseComplete",f=this._reversed),0>a)this._active=!1,this._timeline.autoRemoveChildren&&this._reversed?(k=f=!0,j="onReverseComplete"):u>=0&&this._first&&(k=!0),this._rawPrevTime=a;else{if(this._rawPrevTime=p||!b||a||this._rawPrevTime===a?a:e,0===a&&f)for(d=this._first;d&&0===d._startTime;)d._duration||(f=!1),d=d._next;a=0,this._initted||(k=!0)}else if(0===p&&0>u&&(k=!0),this._time=this._rawPrevTime=a,this._locked||(this._totalTime=a,0!==this._repeat&&(l=p+this._repeatDelay,this._cycle=this._totalTime/l>>0,0!==this._cycle&&this._cycle===this._totalTime/l&&a>=r&&this._cycle--,this._time=this._totalTime-this._cycle*l,this._yoyo&&0!==(1&this._cycle)&&(this._time=p-this._time),this._time>p?(this._time=p,a=p+1e-4):this._time<0?this._time=a=0:a=this._time)),this._hasPause&&!this._forcingPlayhead&&!b&&p>a){if(a=this._time,a>=q||this._repeat&&w!==this._cycle)for(d=this._first;d&&d._startTime<=a&&!m;)d._duration||"isPause"!==d.data||d.ratio||0===d._startTime&&0===this._rawPrevTime||(m=d),d=d._next;else for(d=this._last;d&&d._startTime>=a&&!m;)d._duration||"isPause"===d.data&&d._rawPrevTime>0&&(m=d),d=d._prev;m&&(this._time=a=m._startTime,this._totalTime=a+this._cycle*(this._totalDuration+this._repeatDelay))}if(this._cycle!==w&&!this._locked){var x=this._yoyo&&0!==(1&w),y=x===(this._yoyo&&0!==(1&this._cycle)),z=this._totalTime,A=this._cycle,B=this._rawPrevTime,C=this._time;if(this._totalTime=w*p,this._cycle<w?x=!x:this._totalTime+=p,this._time=q,this._rawPrevTime=0===p?u-1e-4:u,this._cycle=w,this._locked=!0,q=x?0:p,this.render(q,b,0===p),b||this._gc||this.vars.onRepeat&&(this._cycle=A,this._locked=!1,this._callback("onRepeat")),q!==this._time)return;if(y&&(this._cycle=w,this._locked=!0,q=x?p+1e-4:-1e-4,this.render(q,!0,!1)),this._locked=!1,this._paused&&!v)return;this._time=C,this._totalTime=z,this._cycle=A,this._rawPrevTime=B}if(!(this._time!==q&&this._first||c||k||m))return void(r!==this._totalTime&&this._onUpdate&&(b||this._callback("onUpdate")));if(this._initted||(this._initted=!0),this._active||!this._paused&&this._totalTime!==r&&a>0&&(this._active=!0),0===r&&this.vars.onStart&&(0===this._totalTime&&this._totalDuration||b||this._callback("onStart")),n=this._time,n>=q)for(d=this._first;d&&(i=d._next,n===this._time&&(!this._paused||v));)(d._active||d._startTime<=this._time&&!d._paused&&!d._gc)&&(m===d&&this.pause(),d._reversed?d.render((d._dirty?d.totalDuration():d._totalDuration)-(a-d._startTime)*d._timeScale,b,c):d.render((a-d._startTime)*d._timeScale,b,c)),d=i;else for(d=this._last;d&&(i=d._prev,n===this._time&&(!this._paused||v));){if(d._active||d._startTime<=q&&!d._paused&&!d._gc){if(m===d){for(m=d._prev;m&&m.endTime()>this._time;)m.render(m._reversed?m.totalDuration()-(a-m._startTime)*m._timeScale:(a-m._startTime)*m._timeScale,b,c),m=m._prev;m=null,this.pause()}d._reversed?d.render((d._dirty?d.totalDuration():d._totalDuration)-(a-d._startTime)*d._timeScale,b,c):d.render((a-d._startTime)*d._timeScale,b,c)}d=i}this._onUpdate&&(b||(g.length&&h(),this._callback("onUpdate"))),j&&(this._locked||this._gc||(s===this._startTime||t!==this._timeScale)&&(0===this._time||o>=this.totalDuration())&&(f&&(g.length&&h(),this._timeline.autoRemoveChildren&&this._enabled(!1,!1),this._active=!1),!b&&this.vars[j]&&this._callback(j)))},k.getActive=function(a,b,c){null==a&&(a=!0),null==b&&(b=!0),null==c&&(c=!1);var d,e,f=[],g=this.getChildren(a,b,c),h=0,i=g.length;for(d=0;i>d;d++)e=g[d],e.isActive()&&(f[h++]=e);return f},k.getLabelAfter=function(a){a||0!==a&&(a=this._time);var b,c=this.getLabelsArray(),d=c.length;for(b=0;d>b;b++)if(c[b].time>a)return c[b].name;return null},k.getLabelBefore=function(a){null==a&&(a=this._time);for(var b=this.getLabelsArray(),c=b.length;--c>-1;)if(b[c].time<a)return b[c].name;return null},k.getLabelsArray=function(){var a,b=[],c=0;for(a in this._labels)b[c++]={time:this._labels[a],name:a};return b.sort(function(a,b){return a.time-b.time}),b},k.invalidate=function(){return this._locked=!1,a.prototype.invalidate.call(this)},k.progress=function(a,b){return arguments.length?this.totalTime(this.duration()*(this._yoyo&&0!==(1&this._cycle)?1-a:a)+this._cycle*(this._duration+this._repeatDelay),b):this._time/this.duration()},k.totalProgress=function(a,b){return arguments.length?this.totalTime(this.totalDuration()*a,b):this._totalTime/this.totalDuration()},k.totalDuration=function(b){return arguments.length?-1!==this._repeat&&b?this.timeScale(this.totalDuration()/b):this:(this._dirty&&(a.prototype.totalDuration.call(this),this._totalDuration=-1===this._repeat?999999999999:this._duration*(this._repeat+1)+this._repeatDelay*this._repeat),this._totalDuration)},k.time=function(a,b){return arguments.length?(this._dirty&&this.totalDuration(),a>this._duration&&(a=this._duration),this._yoyo&&0!==(1&this._cycle)?a=this._duration-a+this._cycle*(this._duration+this._repeatDelay):0!==this._repeat&&(a+=this._cycle*(this._duration+this._repeatDelay)),this.totalTime(a,b)):this._time},k.repeat=function(a){return arguments.length?(this._repeat=a,this._uncache(!0)):this._repeat},k.repeatDelay=function(a){return arguments.length?(this._repeatDelay=a,this._uncache(!0)):this._repeatDelay},k.yoyo=function(a){return arguments.length?(this._yoyo=a,this):this._yoyo},k.currentLabel=function(a){return arguments.length?this.seek(a,!0):this.getLabelBefore(this._time+1e-8)},d},!0),function(){var a=180/Math.PI,b=[],c=[],d=[],e={},f=_gsScope._gsDefine.globals,g=function(a,b,c,d){c===d&&(c=d-(d-b)/1e6),a===b&&(b=a+(c-a)/1e6),this.a=a,this.b=b,this.c=c,this.d=d,this.da=d-a,this.ca=c-a,this.ba=b-a},h=",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",i=function(a,b,c,d){var e={a:a},f={},g={},h={c:d},i=(a+b)/2,j=(b+c)/2,k=(c+d)/2,l=(i+j)/2,m=(j+k)/2,n=(m-l)/8;return e.b=i+(a-i)/4,f.b=l+n,e.c=f.a=(e.b+f.b)/2,f.c=g.a=(l+m)/2,g.b=m-n,h.b=k+(d-k)/4,g.c=h.a=(g.b+h.b)/2,[e,f,g,h]},j=function(a,e,f,g,h){var j,k,l,m,n,o,p,q,r,s,t,u,v,w=a.length-1,x=0,y=a[0].a;for(j=0;w>j;j++)n=a[x],k=n.a,l=n.d,m=a[x+1].d,h?(t=b[j],u=c[j],v=(u+t)*e*.25/(g?.5:d[j]||.5),o=l-(l-k)*(g?.5*e:0!==t?v/t:0),p=l+(m-l)*(g?.5*e:0!==u?v/u:0),q=l-(o+((p-o)*(3*t/(t+u)+.5)/4||0))):(o=l-(l-k)*e*.5,p=l+(m-l)*e*.5,q=l-(o+p)/2),o+=q,p+=q,n.c=r=o,0!==j?n.b=y:n.b=y=n.a+.6*(n.c-n.a),n.da=l-k,n.ca=r-k,n.ba=y-k,f?(s=i(k,y,r,l),a.splice(x,1,s[0],s[1],s[2],s[3]),x+=4):x++,y=p;n=a[x],n.b=y,n.c=y+.4*(n.d-y),n.da=n.d-n.a,n.ca=n.c-n.a,n.ba=y-n.a,f&&(s=i(n.a,y,n.c,n.d),a.splice(x,1,s[0],s[1],s[2],s[3]))},k=function(a,d,e,f){var h,i,j,k,l,m,n=[];if(f)for(a=[f].concat(a),i=a.length;--i>-1;)"string"==typeof(m=a[i][d])&&"="===m.charAt(1)&&(a[i][d]=f[d]+Number(m.charAt(0)+m.substr(2)));if(h=a.length-2,0>h)return n[0]=new g(a[0][d],0,0,a[-1>h?0:1][d]),n;for(i=0;h>i;i++)j=a[i][d],k=a[i+1][d],n[i]=new g(j,0,0,k),e&&(l=a[i+2][d],b[i]=(b[i]||0)+(k-j)*(k-j),c[i]=(c[i]||0)+(l-k)*(l-k));return n[i]=new g(a[i][d],0,0,a[i+1][d]),n},l=function(a,f,g,i,l,m){var n,o,p,q,r,s,t,u,v={},w=[],x=m||a[0];l="string"==typeof l?","+l+",":h,null==f&&(f=1);for(o in a[0])w.push(o);if(a.length>1){for(u=a[a.length-1],t=!0,n=w.length;--n>-1;)if(o=w[n],Math.abs(x[o]-u[o])>.05){t=!1;break}t&&(a=a.concat(),m&&a.unshift(m),a.push(a[1]),m=a[a.length-3])}for(b.length=c.length=d.length=0,n=w.length;--n>-1;)o=w[n],e[o]=-1!==l.indexOf(","+o+","),v[o]=k(a,o,e[o],m);for(n=b.length;--n>-1;)b[n]=Math.sqrt(b[n]),c[n]=Math.sqrt(c[n]);if(!i){for(n=w.length;--n>-1;)if(e[o])for(p=v[w[n]],s=p.length-1,q=0;s>q;q++)r=p[q+1].da/c[q]+p[q].da/b[q]||0,d[q]=(d[q]||0)+r*r;for(n=d.length;--n>-1;)d[n]=Math.sqrt(d[n])}for(n=w.length,q=g?4:1;--n>-1;)o=w[n],p=v[o],j(p,f,g,i,e[o]),t&&(p.splice(0,q),p.splice(p.length-q,q));return v},m=function(a,b,c){b=b||"soft";var d,e,f,h,i,j,k,l,m,n,o,p={},q="cubic"===b?3:2,r="soft"===b,s=[];if(r&&c&&(a=[c].concat(a)),null==a||a.length<q+1)throw"invalid Bezier data";for(m in a[0])s.push(m);for(j=s.length;--j>-1;){for(m=s[j],p[m]=i=[],n=0,l=a.length,k=0;l>k;k++)d=null==c?a[k][m]:"string"==typeof(o=a[k][m])&&"="===o.charAt(1)?c[m]+Number(o.charAt(0)+o.substr(2)):Number(o),r&&k>1&&l-1>k&&(i[n++]=(d+i[n-2])/2),i[n++]=d;for(l=n-q+1,n=0,k=0;l>k;k+=q)d=i[k],e=i[k+1],f=i[k+2],h=2===q?0:i[k+3],i[n++]=o=3===q?new g(d,e,f,h):new g(d,(2*e+d)/3,(2*e+f)/3,f);i.length=n}return p},n=function(a,b,c){for(var d,e,f,g,h,i,j,k,l,m,n,o=1/c,p=a.length;--p>-1;)for(m=a[p],f=m.a,g=m.d-f,
h=m.c-f,i=m.b-f,d=e=0,k=1;c>=k;k++)j=o*k,l=1-j,d=e-(e=(j*j*g+3*l*(j*h+l*i))*j),n=p*c+k-1,b[n]=(b[n]||0)+d*d},o=function(a,b){b=b>>0||6;var c,d,e,f,g=[],h=[],i=0,j=0,k=b-1,l=[],m=[];for(c in a)n(a[c],g,b);for(e=g.length,d=0;e>d;d++)i+=Math.sqrt(g[d]),f=d%b,m[f]=i,f===k&&(j+=i,f=d/b>>0,l[f]=m,h[f]=j,i=0,m=[]);return{length:j,lengths:h,segments:l}},p=_gsScope._gsDefine.plugin({propName:"bezier",priority:-1,version:"1.3.7",API:2,global:!0,init:function(a,b,c){this._target=a,b instanceof Array&&(b={values:b}),this._func={},this._mod={},this._props=[],this._timeRes=null==b.timeResolution?6:parseInt(b.timeResolution,10);var d,e,f,g,h,i=b.values||[],j={},k=i[0],n=b.autoRotate||c.vars.orientToBezier;this._autoRotate=n?n instanceof Array?n:[["x","y","rotation",n===!0?0:Number(n)||0]]:null;for(d in k)this._props.push(d);for(f=this._props.length;--f>-1;)d=this._props[f],this._overwriteProps.push(d),e=this._func[d]="function"==typeof a[d],j[d]=e?a[d.indexOf("set")||"function"!=typeof a["get"+d.substr(3)]?d:"get"+d.substr(3)]():parseFloat(a[d]),h||j[d]!==i[0][d]&&(h=j);if(this._beziers="cubic"!==b.type&&"quadratic"!==b.type&&"soft"!==b.type?l(i,isNaN(b.curviness)?1:b.curviness,!1,"thruBasic"===b.type,b.correlate,h):m(i,b.type,j),this._segCount=this._beziers[d].length,this._timeRes){var p=o(this._beziers,this._timeRes);this._length=p.length,this._lengths=p.lengths,this._segments=p.segments,this._l1=this._li=this._s1=this._si=0,this._l2=this._lengths[0],this._curSeg=this._segments[0],this._s2=this._curSeg[0],this._prec=1/this._curSeg.length}if(n=this._autoRotate)for(this._initialRotations=[],n[0]instanceof Array||(this._autoRotate=n=[n]),f=n.length;--f>-1;){for(g=0;3>g;g++)d=n[f][g],this._func[d]="function"==typeof a[d]?a[d.indexOf("set")||"function"!=typeof a["get"+d.substr(3)]?d:"get"+d.substr(3)]:!1;d=n[f][2],this._initialRotations[f]=(this._func[d]?this._func[d].call(this._target):this._target[d])||0,this._overwriteProps.push(d)}return this._startRatio=c.vars.runBackwards?1:0,!0},set:function(b){var c,d,e,f,g,h,i,j,k,l,m=this._segCount,n=this._func,o=this._target,p=b!==this._startRatio;if(this._timeRes){if(k=this._lengths,l=this._curSeg,b*=this._length,e=this._li,b>this._l2&&m-1>e){for(j=m-1;j>e&&(this._l2=k[++e])<=b;);this._l1=k[e-1],this._li=e,this._curSeg=l=this._segments[e],this._s2=l[this._s1=this._si=0]}else if(b<this._l1&&e>0){for(;e>0&&(this._l1=k[--e])>=b;);0===e&&b<this._l1?this._l1=0:e++,this._l2=k[e],this._li=e,this._curSeg=l=this._segments[e],this._s1=l[(this._si=l.length-1)-1]||0,this._s2=l[this._si]}if(c=e,b-=this._l1,e=this._si,b>this._s2&&e<l.length-1){for(j=l.length-1;j>e&&(this._s2=l[++e])<=b;);this._s1=l[e-1],this._si=e}else if(b<this._s1&&e>0){for(;e>0&&(this._s1=l[--e])>=b;);0===e&&b<this._s1?this._s1=0:e++,this._s2=l[e],this._si=e}h=(e+(b-this._s1)/(this._s2-this._s1))*this._prec||0}else c=0>b?0:b>=1?m-1:m*b>>0,h=(b-c*(1/m))*m;for(d=1-h,e=this._props.length;--e>-1;)f=this._props[e],g=this._beziers[f][c],i=(h*h*g.da+3*d*(h*g.ca+d*g.ba))*h+g.a,this._mod[f]&&(i=this._mod[f](i,o)),n[f]?o[f](i):o[f]=i;if(this._autoRotate){var q,r,s,t,u,v,w,x=this._autoRotate;for(e=x.length;--e>-1;)f=x[e][2],v=x[e][3]||0,w=x[e][4]===!0?1:a,g=this._beziers[x[e][0]],q=this._beziers[x[e][1]],g&&q&&(g=g[c],q=q[c],r=g.a+(g.b-g.a)*h,t=g.b+(g.c-g.b)*h,r+=(t-r)*h,t+=(g.c+(g.d-g.c)*h-t)*h,s=q.a+(q.b-q.a)*h,u=q.b+(q.c-q.b)*h,s+=(u-s)*h,u+=(q.c+(q.d-q.c)*h-u)*h,i=p?Math.atan2(u-s,t-r)*w+v:this._initialRotations[e],this._mod[f]&&(i=this._mod[f](i,o)),n[f]?o[f](i):o[f]=i)}}}),q=p.prototype;p.bezierThrough=l,p.cubicToQuadratic=i,p._autoCSS=!0,p.quadraticToCubic=function(a,b,c){return new g(a,(2*b+a)/3,(2*b+c)/3,c)},p._cssRegister=function(){var a=f.CSSPlugin;if(a){var b=a._internals,c=b._parseToProxy,d=b._setPluginRatio,e=b.CSSPropTween;b._registerComplexSpecialProp("bezier",{parser:function(a,b,f,g,h,i){b instanceof Array&&(b={values:b}),i=new p;var j,k,l,m=b.values,n=m.length-1,o=[],q={};if(0>n)return h;for(j=0;n>=j;j++)l=c(a,m[j],g,h,i,n!==j),o[j]=l.end;for(k in b)q[k]=b[k];return q.values=o,h=new e(a,"bezier",0,0,l.pt,2),h.data=l,h.plugin=i,h.setRatio=d,0===q.autoRotate&&(q.autoRotate=!0),!q.autoRotate||q.autoRotate instanceof Array||(j=q.autoRotate===!0?0:Number(q.autoRotate),q.autoRotate=null!=l.end.left?[["left","top","rotation",j,!1]]:null!=l.end.x?[["x","y","rotation",j,!1]]:!1),q.autoRotate&&(g._transform||g._enableTransforms(!1),l.autoRotate=g._target._gsTransform,l.proxy.rotation=l.autoRotate.rotation||0,g._overwriteProps.push("rotation")),i._onInitTween(l.proxy,q,g._tween),h}})}},q._mod=function(a){for(var b,c=this._overwriteProps,d=c.length;--d>-1;)b=a[c[d]],b&&"function"==typeof b&&(this._mod[c[d]]=b)},q._kill=function(a){var b,c,d=this._props;for(b in this._beziers)if(b in a)for(delete this._beziers[b],delete this._func[b],c=d.length;--c>-1;)d[c]===b&&d.splice(c,1);if(d=this._autoRotate)for(c=d.length;--c>-1;)a[d[c][2]]&&d.splice(c,1);return this._super._kill.call(this,a)}}(),_gsScope._gsDefine("plugins.CSSPlugin",["plugins.TweenPlugin","TweenLite"],function(a,b){var c,d,e,f,g=function(){a.call(this,"css"),this._overwriteProps.length=0,this.setRatio=g.prototype.setRatio},h=_gsScope._gsDefine.globals,i={},j=g.prototype=new a("css");j.constructor=g,g.version="1.19.1",g.API=2,g.defaultTransformPerspective=0,g.defaultSkewType="compensated",g.defaultSmoothOrigin=!0,j="px",g.suffixMap={top:j,right:j,bottom:j,left:j,width:j,height:j,fontSize:j,padding:j,margin:j,perspective:j,lineHeight:""};var k,l,m,n,o,p,q,r,s=/(?:\-|\.|\b)(\d|\.|e\-)+/g,t=/(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,u=/(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,v=/(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g,w=/(?:\d|\-|\+|=|#|\.)*/g,x=/opacity *= *([^)]*)/i,y=/opacity:([^;]*)/i,z=/alpha\(opacity *=.+?\)/i,A=/^(rgb|hsl)/,B=/([A-Z])/g,C=/-([a-z])/gi,D=/(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi,E=function(a,b){return b.toUpperCase()},F=/(?:Left|Right|Width)/i,G=/(M11|M12|M21|M22)=[\d\-\.e]+/gi,H=/progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,I=/,(?=[^\)]*(?:\(|$))/gi,J=/[\s,\(]/i,K=Math.PI/180,L=180/Math.PI,M={},N={style:{}},O=_gsScope.document||{createElement:function(){return N}},P=function(a,b){return O.createElementNS?O.createElementNS(b||"http://www.w3.org/1999/xhtml",a):O.createElement(a)},Q=P("div"),R=P("img"),S=g._internals={_specialProps:i},T=(_gsScope.navigator||{}).userAgent||"",U=function(){var a=T.indexOf("Android"),b=P("a");return m=-1!==T.indexOf("Safari")&&-1===T.indexOf("Chrome")&&(-1===a||parseFloat(T.substr(a+8,2))>3),o=m&&parseFloat(T.substr(T.indexOf("Version/")+8,2))<6,n=-1!==T.indexOf("Firefox"),(/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(T)||/Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(T))&&(p=parseFloat(RegExp.$1)),b?(b.style.cssText="top:1px;opacity:.55;",/^0.55/.test(b.style.opacity)):!1}(),V=function(a){return x.test("string"==typeof a?a:(a.currentStyle?a.currentStyle.filter:a.style.filter)||"")?parseFloat(RegExp.$1)/100:1},W=function(a){_gsScope.console&&console.log(a)},X="",Y="",Z=function(a,b){b=b||Q;var c,d,e=b.style;if(void 0!==e[a])return a;for(a=a.charAt(0).toUpperCase()+a.substr(1),c=["O","Moz","ms","Ms","Webkit"],d=5;--d>-1&&void 0===e[c[d]+a];);return d>=0?(Y=3===d?"ms":c[d],X="-"+Y.toLowerCase()+"-",Y+a):null},$=O.defaultView?O.defaultView.getComputedStyle:function(){},_=g.getStyle=function(a,b,c,d,e){var f;return U||"opacity"!==b?(!d&&a.style[b]?f=a.style[b]:(c=c||$(a))?f=c[b]||c.getPropertyValue(b)||c.getPropertyValue(b.replace(B,"-$1").toLowerCase()):a.currentStyle&&(f=a.currentStyle[b]),null==e||f&&"none"!==f&&"auto"!==f&&"auto auto"!==f?f:e):V(a)},aa=S.convertToPixels=function(a,c,d,e,f){if("px"===e||!e)return d;if("auto"===e||!d)return 0;var h,i,j,k=F.test(c),l=a,m=Q.style,n=0>d,o=1===d;if(n&&(d=-d),o&&(d*=100),"%"===e&&-1!==c.indexOf("border"))h=d/100*(k?a.clientWidth:a.clientHeight);else{if(m.cssText="border:0 solid red;position:"+_(a,"position")+";line-height:0;","%"!==e&&l.appendChild&&"v"!==e.charAt(0)&&"rem"!==e)m[k?"borderLeftWidth":"borderTopWidth"]=d+e;else{if(l=a.parentNode||O.body,i=l._gsCache,j=b.ticker.frame,i&&k&&i.time===j)return i.width*d/100;m[k?"width":"height"]=d+e}l.appendChild(Q),h=parseFloat(Q[k?"offsetWidth":"offsetHeight"]),l.removeChild(Q),k&&"%"===e&&g.cacheWidths!==!1&&(i=l._gsCache=l._gsCache||{},i.time=j,i.width=h/d*100),0!==h||f||(h=aa(a,c,d,e,!0))}return o&&(h/=100),n?-h:h},ba=S.calculateOffset=function(a,b,c){if("absolute"!==_(a,"position",c))return 0;var d="left"===b?"Left":"Top",e=_(a,"margin"+d,c);return a["offset"+d]-(aa(a,b,parseFloat(e),e.replace(w,""))||0)},ca=function(a,b){var c,d,e,f={};if(b=b||$(a,null))if(c=b.length)for(;--c>-1;)e=b[c],(-1===e.indexOf("-transform")||Da===e)&&(f[e.replace(C,E)]=b.getPropertyValue(e));else for(c in b)(-1===c.indexOf("Transform")||Ca===c)&&(f[c]=b[c]);else if(b=a.currentStyle||a.style)for(c in b)"string"==typeof c&&void 0===f[c]&&(f[c.replace(C,E)]=b[c]);return U||(f.opacity=V(a)),d=Ra(a,b,!1),f.rotation=d.rotation,f.skewX=d.skewX,f.scaleX=d.scaleX,f.scaleY=d.scaleY,f.x=d.x,f.y=d.y,Fa&&(f.z=d.z,f.rotationX=d.rotationX,f.rotationY=d.rotationY,f.scaleZ=d.scaleZ),f.filters&&delete f.filters,f},da=function(a,b,c,d,e){var f,g,h,i={},j=a.style;for(g in c)"cssText"!==g&&"length"!==g&&isNaN(g)&&(b[g]!==(f=c[g])||e&&e[g])&&-1===g.indexOf("Origin")&&("number"==typeof f||"string"==typeof f)&&(i[g]="auto"!==f||"left"!==g&&"top"!==g?""!==f&&"auto"!==f&&"none"!==f||"string"!=typeof b[g]||""===b[g].replace(v,"")?f:0:ba(a,g),void 0!==j[g]&&(h=new sa(j,g,j[g],h)));if(d)for(g in d)"className"!==g&&(i[g]=d[g]);return{difs:i,firstMPT:h}},ea={width:["Left","Right"],height:["Top","Bottom"]},fa=["marginLeft","marginRight","marginTop","marginBottom"],ga=function(a,b,c){if("svg"===(a.nodeName+"").toLowerCase())return(c||$(a))[b]||0;if(a.getCTM&&Oa(a))return a.getBBox()[b]||0;var d=parseFloat("width"===b?a.offsetWidth:a.offsetHeight),e=ea[b],f=e.length;for(c=c||$(a,null);--f>-1;)d-=parseFloat(_(a,"padding"+e[f],c,!0))||0,d-=parseFloat(_(a,"border"+e[f]+"Width",c,!0))||0;return d},ha=function(a,b){if("contain"===a||"auto"===a||"auto auto"===a)return a+" ";(null==a||""===a)&&(a="0 0");var c,d=a.split(" "),e=-1!==a.indexOf("left")?"0%":-1!==a.indexOf("right")?"100%":d[0],f=-1!==a.indexOf("top")?"0%":-1!==a.indexOf("bottom")?"100%":d[1];if(d.length>3&&!b){for(d=a.split(", ").join(",").split(","),a=[],c=0;c<d.length;c++)a.push(ha(d[c]));return a.join(",")}return null==f?f="center"===e?"50%":"0":"center"===f&&(f="50%"),("center"===e||isNaN(parseFloat(e))&&-1===(e+"").indexOf("="))&&(e="50%"),a=e+" "+f+(d.length>2?" "+d[2]:""),b&&(b.oxp=-1!==e.indexOf("%"),b.oyp=-1!==f.indexOf("%"),b.oxr="="===e.charAt(1),b.oyr="="===f.charAt(1),b.ox=parseFloat(e.replace(v,"")),b.oy=parseFloat(f.replace(v,"")),b.v=a),b||a},ia=function(a,b){return"function"==typeof a&&(a=a(r,q)),"string"==typeof a&&"="===a.charAt(1)?parseInt(a.charAt(0)+"1",10)*parseFloat(a.substr(2)):parseFloat(a)-parseFloat(b)||0},ja=function(a,b){return"function"==typeof a&&(a=a(r,q)),null==a?b:"string"==typeof a&&"="===a.charAt(1)?parseInt(a.charAt(0)+"1",10)*parseFloat(a.substr(2))+b:parseFloat(a)||0},ka=function(a,b,c,d){var e,f,g,h,i,j=1e-6;return"function"==typeof a&&(a=a(r,q)),null==a?h=b:"number"==typeof a?h=a:(e=360,f=a.split("_"),i="="===a.charAt(1),g=(i?parseInt(a.charAt(0)+"1",10)*parseFloat(f[0].substr(2)):parseFloat(f[0]))*(-1===a.indexOf("rad")?1:L)-(i?0:b),f.length&&(d&&(d[c]=b+g),-1!==a.indexOf("short")&&(g%=e,g!==g%(e/2)&&(g=0>g?g+e:g-e)),-1!==a.indexOf("_cw")&&0>g?g=(g+9999999999*e)%e-(g/e|0)*e:-1!==a.indexOf("ccw")&&g>0&&(g=(g-9999999999*e)%e-(g/e|0)*e)),h=b+g),j>h&&h>-j&&(h=0),h},la={aqua:[0,255,255],lime:[0,255,0],silver:[192,192,192],black:[0,0,0],maroon:[128,0,0],teal:[0,128,128],blue:[0,0,255],navy:[0,0,128],white:[255,255,255],fuchsia:[255,0,255],olive:[128,128,0],yellow:[255,255,0],orange:[255,165,0],gray:[128,128,128],purple:[128,0,128],green:[0,128,0],red:[255,0,0],pink:[255,192,203],cyan:[0,255,255],transparent:[255,255,255,0]},ma=function(a,b,c){return a=0>a?a+1:a>1?a-1:a,255*(1>6*a?b+(c-b)*a*6:.5>a?c:2>3*a?b+(c-b)*(2/3-a)*6:b)+.5|0},na=g.parseColor=function(a,b){var c,d,e,f,g,h,i,j,k,l,m;if(a)if("number"==typeof a)c=[a>>16,a>>8&255,255&a];else{if(","===a.charAt(a.length-1)&&(a=a.substr(0,a.length-1)),la[a])c=la[a];else if("#"===a.charAt(0))4===a.length&&(d=a.charAt(1),e=a.charAt(2),f=a.charAt(3),a="#"+d+d+e+e+f+f),a=parseInt(a.substr(1),16),c=[a>>16,a>>8&255,255&a];else if("hsl"===a.substr(0,3))if(c=m=a.match(s),b){if(-1!==a.indexOf("="))return a.match(t)}else g=Number(c[0])%360/360,h=Number(c[1])/100,i=Number(c[2])/100,e=.5>=i?i*(h+1):i+h-i*h,d=2*i-e,c.length>3&&(c[3]=Number(a[3])),c[0]=ma(g+1/3,d,e),c[1]=ma(g,d,e),c[2]=ma(g-1/3,d,e);else c=a.match(s)||la.transparent;c[0]=Number(c[0]),c[1]=Number(c[1]),c[2]=Number(c[2]),c.length>3&&(c[3]=Number(c[3]))}else c=la.black;return b&&!m&&(d=c[0]/255,e=c[1]/255,f=c[2]/255,j=Math.max(d,e,f),k=Math.min(d,e,f),i=(j+k)/2,j===k?g=h=0:(l=j-k,h=i>.5?l/(2-j-k):l/(j+k),g=j===d?(e-f)/l+(f>e?6:0):j===e?(f-d)/l+2:(d-e)/l+4,g*=60),c[0]=g+.5|0,c[1]=100*h+.5|0,c[2]=100*i+.5|0),c},oa=function(a,b){var c,d,e,f=a.match(pa)||[],g=0,h=f.length?"":a;for(c=0;c<f.length;c++)d=f[c],e=a.substr(g,a.indexOf(d,g)-g),g+=e.length+d.length,d=na(d,b),3===d.length&&d.push(1),h+=e+(b?"hsla("+d[0]+","+d[1]+"%,"+d[2]+"%,"+d[3]:"rgba("+d.join(","))+")";return h+a.substr(g)},pa="(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";for(j in la)pa+="|"+j+"\\b";pa=new RegExp(pa+")","gi"),g.colorStringFilter=function(a){var b,c=a[0]+a[1];pa.test(c)&&(b=-1!==c.indexOf("hsl(")||-1!==c.indexOf("hsla("),a[0]=oa(a[0],b),a[1]=oa(a[1],b)),pa.lastIndex=0},b.defaultStringFilter||(b.defaultStringFilter=g.colorStringFilter);var qa=function(a,b,c,d){if(null==a)return function(a){return a};var e,f=b?(a.match(pa)||[""])[0]:"",g=a.split(f).join("").match(u)||[],h=a.substr(0,a.indexOf(g[0])),i=")"===a.charAt(a.length-1)?")":"",j=-1!==a.indexOf(" ")?" ":",",k=g.length,l=k>0?g[0].replace(s,""):"";return k?e=b?function(a){var b,m,n,o;if("number"==typeof a)a+=l;else if(d&&I.test(a)){for(o=a.replace(I,"|").split("|"),n=0;n<o.length;n++)o[n]=e(o[n]);return o.join(",")}if(b=(a.match(pa)||[f])[0],m=a.split(b).join("").match(u)||[],n=m.length,k>n--)for(;++n<k;)m[n]=c?m[(n-1)/2|0]:g[n];return h+m.join(j)+j+b+i+(-1!==a.indexOf("inset")?" inset":"")}:function(a){var b,f,m;if("number"==typeof a)a+=l;else if(d&&I.test(a)){for(f=a.replace(I,"|").split("|"),m=0;m<f.length;m++)f[m]=e(f[m]);return f.join(",")}if(b=a.match(u)||[],m=b.length,k>m--)for(;++m<k;)b[m]=c?b[(m-1)/2|0]:g[m];return h+b.join(j)+i}:function(a){return a}},ra=function(a){return a=a.split(","),function(b,c,d,e,f,g,h){var i,j=(c+"").split(" ");for(h={},i=0;4>i;i++)h[a[i]]=j[i]=j[i]||j[(i-1)/2>>0];return e.parse(b,h,f,g)}},sa=(S._setPluginRatio=function(a){this.plugin.setRatio(a);for(var b,c,d,e,f,g=this.data,h=g.proxy,i=g.firstMPT,j=1e-6;i;)b=h[i.v],i.r?b=Math.round(b):j>b&&b>-j&&(b=0),i.t[i.p]=b,i=i._next;if(g.autoRotate&&(g.autoRotate.rotation=g.mod?g.mod(h.rotation,this.t):h.rotation),1===a||0===a)for(i=g.firstMPT,f=1===a?"e":"b";i;){if(c=i.t,c.type){if(1===c.type){for(e=c.xs0+c.s+c.xs1,d=1;d<c.l;d++)e+=c["xn"+d]+c["xs"+(d+1)];c[f]=e}}else c[f]=c.s+c.xs0;i=i._next}},function(a,b,c,d,e){this.t=a,this.p=b,this.v=c,this.r=e,d&&(d._prev=this,this._next=d)}),ta=(S._parseToProxy=function(a,b,c,d,e,f){var g,h,i,j,k,l=d,m={},n={},o=c._transform,p=M;for(c._transform=null,M=b,d=k=c.parse(a,b,d,e),M=p,f&&(c._transform=o,l&&(l._prev=null,l._prev&&(l._prev._next=null)));d&&d!==l;){if(d.type<=1&&(h=d.p,n[h]=d.s+d.c,m[h]=d.s,f||(j=new sa(d,"s",h,j,d.r),d.c=0),1===d.type))for(g=d.l;--g>0;)i="xn"+g,h=d.p+"_"+i,n[h]=d.data[i],m[h]=d[i],f||(j=new sa(d,i,h,j,d.rxp[i]));d=d._next}return{proxy:m,end:n,firstMPT:j,pt:k}},S.CSSPropTween=function(a,b,d,e,g,h,i,j,k,l,m){this.t=a,this.p=b,this.s=d,this.c=e,this.n=i||b,a instanceof ta||f.push(this.n),this.r=j,this.type=h||0,k&&(this.pr=k,c=!0),this.b=void 0===l?d:l,this.e=void 0===m?d+e:m,g&&(this._next=g,g._prev=this)}),ua=function(a,b,c,d,e,f){var g=new ta(a,b,c,d-c,e,-1,f);return g.b=c,g.e=g.xs0=d,g},va=g.parseComplex=function(a,b,c,d,e,f,h,i,j,l){c=c||f||"","function"==typeof d&&(d=d(r,q)),h=new ta(a,b,0,0,h,l?2:1,null,!1,i,c,d),d+="",e&&pa.test(d+c)&&(d=[c,d],g.colorStringFilter(d),c=d[0],d=d[1]);var m,n,o,p,u,v,w,x,y,z,A,B,C,D=c.split(", ").join(",").split(" "),E=d.split(", ").join(",").split(" "),F=D.length,G=k!==!1;for((-1!==d.indexOf(",")||-1!==c.indexOf(","))&&(D=D.join(" ").replace(I,", ").split(" "),E=E.join(" ").replace(I,", ").split(" "),F=D.length),F!==E.length&&(D=(f||"").split(" "),F=D.length),h.plugin=j,h.setRatio=l,pa.lastIndex=0,m=0;F>m;m++)if(p=D[m],u=E[m],x=parseFloat(p),x||0===x)h.appendXtra("",x,ia(u,x),u.replace(t,""),G&&-1!==u.indexOf("px"),!0);else if(e&&pa.test(p))B=u.indexOf(")")+1,B=")"+(B?u.substr(B):""),C=-1!==u.indexOf("hsl")&&U,p=na(p,C),u=na(u,C),y=p.length+u.length>6,y&&!U&&0===u[3]?(h["xs"+h.l]+=h.l?" transparent":"transparent",h.e=h.e.split(E[m]).join("transparent")):(U||(y=!1),C?h.appendXtra(y?"hsla(":"hsl(",p[0],ia(u[0],p[0]),",",!1,!0).appendXtra("",p[1],ia(u[1],p[1]),"%,",!1).appendXtra("",p[2],ia(u[2],p[2]),y?"%,":"%"+B,!1):h.appendXtra(y?"rgba(":"rgb(",p[0],u[0]-p[0],",",!0,!0).appendXtra("",p[1],u[1]-p[1],",",!0).appendXtra("",p[2],u[2]-p[2],y?",":B,!0),y&&(p=p.length<4?1:p[3],h.appendXtra("",p,(u.length<4?1:u[3])-p,B,!1))),pa.lastIndex=0;else if(v=p.match(s)){if(w=u.match(t),!w||w.length!==v.length)return h;for(o=0,n=0;n<v.length;n++)A=v[n],z=p.indexOf(A,o),h.appendXtra(p.substr(o,z-o),Number(A),ia(w[n],A),"",G&&"px"===p.substr(z+A.length,2),0===n),o=z+A.length;h["xs"+h.l]+=p.substr(o)}else h["xs"+h.l]+=h.l||h["xs"+h.l]?" "+u:u;if(-1!==d.indexOf("=")&&h.data){for(B=h.xs0+h.data.s,m=1;m<h.l;m++)B+=h["xs"+m]+h.data["xn"+m];h.e=B+h["xs"+m]}return h.l||(h.type=-1,h.xs0=h.e),h.xfirst||h},wa=9;for(j=ta.prototype,j.l=j.pr=0;--wa>0;)j["xn"+wa]=0,j["xs"+wa]="";j.xs0="",j._next=j._prev=j.xfirst=j.data=j.plugin=j.setRatio=j.rxp=null,j.appendXtra=function(a,b,c,d,e,f){var g=this,h=g.l;return g["xs"+h]+=f&&(h||g["xs"+h])?" "+a:a||"",c||0===h||g.plugin?(g.l++,g.type=g.setRatio?2:1,g["xs"+g.l]=d||"",h>0?(g.data["xn"+h]=b+c,g.rxp["xn"+h]=e,g["xn"+h]=b,g.plugin||(g.xfirst=new ta(g,"xn"+h,b,c,g.xfirst||g,0,g.n,e,g.pr),g.xfirst.xs0=0),g):(g.data={s:b+c},g.rxp={},g.s=b,g.c=c,g.r=e,g)):(g["xs"+h]+=b+(d||""),g)};var xa=function(a,b){b=b||{},this.p=b.prefix?Z(a)||a:a,i[a]=i[this.p]=this,this.format=b.formatter||qa(b.defaultValue,b.color,b.collapsible,b.multi),b.parser&&(this.parse=b.parser),this.clrs=b.color,this.multi=b.multi,this.keyword=b.keyword,this.dflt=b.defaultValue,this.pr=b.priority||0},ya=S._registerComplexSpecialProp=function(a,b,c){"object"!=typeof b&&(b={parser:c});var d,e,f=a.split(","),g=b.defaultValue;for(c=c||[g],d=0;d<f.length;d++)b.prefix=0===d&&b.prefix,b.defaultValue=c[d]||g,e=new xa(f[d],b)},za=S._registerPluginProp=function(a){if(!i[a]){var b=a.charAt(0).toUpperCase()+a.substr(1)+"Plugin";ya(a,{parser:function(a,c,d,e,f,g,j){var k=h.com.greensock.plugins[b];return k?(k._cssRegister(),i[d].parse(a,c,d,e,f,g,j)):(W("Error: "+b+" js file not loaded."),f)}})}};j=xa.prototype,j.parseComplex=function(a,b,c,d,e,f){var g,h,i,j,k,l,m=this.keyword;if(this.multi&&(I.test(c)||I.test(b)?(h=b.replace(I,"|").split("|"),i=c.replace(I,"|").split("|")):m&&(h=[b],i=[c])),i){for(j=i.length>h.length?i.length:h.length,g=0;j>g;g++)b=h[g]=h[g]||this.dflt,c=i[g]=i[g]||this.dflt,m&&(k=b.indexOf(m),l=c.indexOf(m),k!==l&&(-1===l?h[g]=h[g].split(m).join(""):-1===k&&(h[g]+=" "+m)));b=h.join(", "),c=i.join(", ")}return va(a,this.p,b,c,this.clrs,this.dflt,d,this.pr,e,f)},j.parse=function(a,b,c,d,f,g,h){return this.parseComplex(a.style,this.format(_(a,this.p,e,!1,this.dflt)),this.format(b),f,g)},g.registerSpecialProp=function(a,b,c){ya(a,{parser:function(a,d,e,f,g,h,i){var j=new ta(a,e,0,0,g,2,e,!1,c);return j.plugin=h,j.setRatio=b(a,d,f._tween,e),j},priority:c})},g.useSVGTransformAttr=!0;var Aa,Ba="scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","),Ca=Z("transform"),Da=X+"transform",Ea=Z("transformOrigin"),Fa=null!==Z("perspective"),Ga=S.Transform=function(){this.perspective=parseFloat(g.defaultTransformPerspective)||0,this.force3D=g.defaultForce3D!==!1&&Fa?g.defaultForce3D||"auto":!1},Ha=_gsScope.SVGElement,Ia=function(a,b,c){var d,e=O.createElementNS("http://www.w3.org/2000/svg",a),f=/([a-z])([A-Z])/g;for(d in c)e.setAttributeNS(null,d.replace(f,"$1-$2").toLowerCase(),c[d]);return b.appendChild(e),e},Ja=O.documentElement||{},Ka=function(){var a,b,c,d=p||/Android/i.test(T)&&!_gsScope.chrome;return O.createElementNS&&!d&&(a=Ia("svg",Ja),b=Ia("rect",a,{width:100,height:50,x:100}),c=b.getBoundingClientRect().width,b.style[Ea]="50% 50%",b.style[Ca]="scaleX(0.5)",d=c===b.getBoundingClientRect().width&&!(n&&Fa),Ja.removeChild(a)),d}(),La=function(a,b,c,d,e,f){var h,i,j,k,l,m,n,o,p,q,r,s,t,u,v=a._gsTransform,w=Qa(a,!0);v&&(t=v.xOrigin,u=v.yOrigin),(!d||(h=d.split(" ")).length<2)&&(n=a.getBBox(),0===n.x&&0===n.y&&n.width+n.height===0&&(n={x:parseFloat(a.hasAttribute("x")?a.getAttribute("x"):a.hasAttribute("cx")?a.getAttribute("cx"):0)||0,y:parseFloat(a.hasAttribute("y")?a.getAttribute("y"):a.hasAttribute("cy")?a.getAttribute("cy"):0)||0,width:0,height:0}),b=ha(b).split(" "),h=[(-1!==b[0].indexOf("%")?parseFloat(b[0])/100*n.width:parseFloat(b[0]))+n.x,(-1!==b[1].indexOf("%")?parseFloat(b[1])/100*n.height:parseFloat(b[1]))+n.y]),c.xOrigin=k=parseFloat(h[0]),c.yOrigin=l=parseFloat(h[1]),d&&w!==Pa&&(m=w[0],n=w[1],o=w[2],p=w[3],q=w[4],r=w[5],s=m*p-n*o,s&&(i=k*(p/s)+l*(-o/s)+(o*r-p*q)/s,j=k*(-n/s)+l*(m/s)-(m*r-n*q)/s,k=c.xOrigin=h[0]=i,l=c.yOrigin=h[1]=j)),v&&(f&&(c.xOffset=v.xOffset,c.yOffset=v.yOffset,v=c),e||e!==!1&&g.defaultSmoothOrigin!==!1?(i=k-t,j=l-u,v.xOffset+=i*w[0]+j*w[2]-i,v.yOffset+=i*w[1]+j*w[3]-j):v.xOffset=v.yOffset=0),f||a.setAttribute("data-svg-origin",h.join(" "))},Ma=function(a){var b,c=P("svg",this.ownerSVGElement.getAttribute("xmlns")||"http://www.w3.org/2000/svg"),d=this.parentNode,e=this.nextSibling,f=this.style.cssText;if(Ja.appendChild(c),c.appendChild(this),this.style.display="block",a)try{b=this.getBBox(),this._originalGetBBox=this.getBBox,this.getBBox=Ma}catch(g){}else this._originalGetBBox&&(b=this._originalGetBBox());return e?d.insertBefore(this,e):d.appendChild(this),Ja.removeChild(c),this.style.cssText=f,b},Na=function(a){try{return a.getBBox()}catch(b){return Ma.call(a,!0)}},Oa=function(a){return!(!(Ha&&a.getCTM&&Na(a))||a.parentNode&&!a.ownerSVGElement)},Pa=[1,0,0,1,0,0],Qa=function(a,b){var c,d,e,f,g,h,i=a._gsTransform||new Ga,j=1e5,k=a.style;if(Ca?d=_(a,Da,null,!0):a.currentStyle&&(d=a.currentStyle.filter.match(G),d=d&&4===d.length?[d[0].substr(4),Number(d[2].substr(4)),Number(d[1].substr(4)),d[3].substr(4),i.x||0,i.y||0].join(","):""),c=!d||"none"===d||"matrix(1, 0, 0, 1, 0, 0)"===d,c&&Ca&&((h="none"===$(a).display)||!a.parentNode)&&(h&&(f=k.display,k.display="block"),a.parentNode||(g=1,Ja.appendChild(a)),d=_(a,Da,null,!0),c=!d||"none"===d||"matrix(1, 0, 0, 1, 0, 0)"===d,f?k.display=f:h&&Va(k,"display"),g&&Ja.removeChild(a)),(i.svg||a.getCTM&&Oa(a))&&(c&&-1!==(k[Ca]+"").indexOf("matrix")&&(d=k[Ca],c=0),e=a.getAttribute("transform"),c&&e&&(-1!==e.indexOf("matrix")?(d=e,c=0):-1!==e.indexOf("translate")&&(d="matrix(1,0,0,1,"+e.match(/(?:\-|\b)[\d\-\.e]+\b/gi).join(",")+")",c=0))),c)return Pa;for(e=(d||"").match(s)||[],wa=e.length;--wa>-1;)f=Number(e[wa]),e[wa]=(g=f-(f|=0))?(g*j+(0>g?-.5:.5)|0)/j+f:f;return b&&e.length>6?[e[0],e[1],e[4],e[5],e[12],e[13]]:e},Ra=S.getTransform=function(a,c,d,e){if(a._gsTransform&&d&&!e)return a._gsTransform;var f,h,i,j,k,l,m=d?a._gsTransform||new Ga:new Ga,n=m.scaleX<0,o=2e-5,p=1e5,q=Fa?parseFloat(_(a,Ea,c,!1,"0 0 0").split(" ")[2])||m.zOrigin||0:0,r=parseFloat(g.defaultTransformPerspective)||0;if(m.svg=!(!a.getCTM||!Oa(a)),m.svg&&(La(a,_(a,Ea,c,!1,"50% 50%")+"",m,a.getAttribute("data-svg-origin")),Aa=g.useSVGTransformAttr||Ka),f=Qa(a),f!==Pa){if(16===f.length){var s,t,u,v,w,x=f[0],y=f[1],z=f[2],A=f[3],B=f[4],C=f[5],D=f[6],E=f[7],F=f[8],G=f[9],H=f[10],I=f[12],J=f[13],K=f[14],M=f[11],N=Math.atan2(D,H);m.zOrigin&&(K=-m.zOrigin,I=F*K-f[12],J=G*K-f[13],K=H*K+m.zOrigin-f[14]),m.rotationX=N*L,N&&(v=Math.cos(-N),w=Math.sin(-N),s=B*v+F*w,t=C*v+G*w,u=D*v+H*w,F=B*-w+F*v,G=C*-w+G*v,H=D*-w+H*v,M=E*-w+M*v,B=s,C=t,D=u),N=Math.atan2(-z,H),m.rotationY=N*L,N&&(v=Math.cos(-N),w=Math.sin(-N),s=x*v-F*w,t=y*v-G*w,u=z*v-H*w,G=y*w+G*v,H=z*w+H*v,M=A*w+M*v,x=s,y=t,z=u),N=Math.atan2(y,x),m.rotation=N*L,N&&(v=Math.cos(-N),w=Math.sin(-N),x=x*v+B*w,t=y*v+C*w,C=y*-w+C*v,D=z*-w+D*v,y=t),m.rotationX&&Math.abs(m.rotationX)+Math.abs(m.rotation)>359.9&&(m.rotationX=m.rotation=0,m.rotationY=180-m.rotationY),m.scaleX=(Math.sqrt(x*x+y*y)*p+.5|0)/p,m.scaleY=(Math.sqrt(C*C+G*G)*p+.5|0)/p,m.scaleZ=(Math.sqrt(D*D+H*H)*p+.5|0)/p,m.rotationX||m.rotationY?m.skewX=0:(m.skewX=B||C?Math.atan2(B,C)*L+m.rotation:m.skewX||0,Math.abs(m.skewX)>90&&Math.abs(m.skewX)<270&&(n?(m.scaleX*=-1,m.skewX+=m.rotation<=0?180:-180,m.rotation+=m.rotation<=0?180:-180):(m.scaleY*=-1,m.skewX+=m.skewX<=0?180:-180))),m.perspective=M?1/(0>M?-M:M):0,m.x=I,m.y=J,m.z=K,m.svg&&(m.x-=m.xOrigin-(m.xOrigin*x-m.yOrigin*B),m.y-=m.yOrigin-(m.yOrigin*y-m.xOrigin*C))}else if(!Fa||e||!f.length||m.x!==f[4]||m.y!==f[5]||!m.rotationX&&!m.rotationY){var O=f.length>=6,P=O?f[0]:1,Q=f[1]||0,R=f[2]||0,S=O?f[3]:1;m.x=f[4]||0,m.y=f[5]||0,i=Math.sqrt(P*P+Q*Q),j=Math.sqrt(S*S+R*R),k=P||Q?Math.atan2(Q,P)*L:m.rotation||0,l=R||S?Math.atan2(R,S)*L+k:m.skewX||0,Math.abs(l)>90&&Math.abs(l)<270&&(n?(i*=-1,l+=0>=k?180:-180,k+=0>=k?180:-180):(j*=-1,l+=0>=l?180:-180)),m.scaleX=i,m.scaleY=j,m.rotation=k,m.skewX=l,Fa&&(m.rotationX=m.rotationY=m.z=0,m.perspective=r,m.scaleZ=1),m.svg&&(m.x-=m.xOrigin-(m.xOrigin*P+m.yOrigin*R),m.y-=m.yOrigin-(m.xOrigin*Q+m.yOrigin*S))}m.zOrigin=q;for(h in m)m[h]<o&&m[h]>-o&&(m[h]=0)}return d&&(a._gsTransform=m,m.svg&&(Aa&&a.style[Ca]?b.delayedCall(.001,function(){Va(a.style,Ca)}):!Aa&&a.getAttribute("transform")&&b.delayedCall(.001,function(){a.removeAttribute("transform")}))),m},Sa=function(a){var b,c,d=this.data,e=-d.rotation*K,f=e+d.skewX*K,g=1e5,h=(Math.cos(e)*d.scaleX*g|0)/g,i=(Math.sin(e)*d.scaleX*g|0)/g,j=(Math.sin(f)*-d.scaleY*g|0)/g,k=(Math.cos(f)*d.scaleY*g|0)/g,l=this.t.style,m=this.t.currentStyle;if(m){c=i,i=-j,j=-c,b=m.filter,l.filter="";var n,o,q=this.t.offsetWidth,r=this.t.offsetHeight,s="absolute"!==m.position,t="progid:DXImageTransform.Microsoft.Matrix(M11="+h+", M12="+i+", M21="+j+", M22="+k,u=d.x+q*d.xPercent/100,v=d.y+r*d.yPercent/100;if(null!=d.ox&&(n=(d.oxp?q*d.ox*.01:d.ox)-q/2,o=(d.oyp?r*d.oy*.01:d.oy)-r/2,u+=n-(n*h+o*i),v+=o-(n*j+o*k)),s?(n=q/2,o=r/2,t+=", Dx="+(n-(n*h+o*i)+u)+", Dy="+(o-(n*j+o*k)+v)+")"):t+=", sizingMethod='auto expand')",-1!==b.indexOf("DXImageTransform.Microsoft.Matrix(")?l.filter=b.replace(H,t):l.filter=t+" "+b,(0===a||1===a)&&1===h&&0===i&&0===j&&1===k&&(s&&-1===t.indexOf("Dx=0, Dy=0")||x.test(b)&&100!==parseFloat(RegExp.$1)||-1===b.indexOf(b.indexOf("Alpha"))&&l.removeAttribute("filter")),!s){var y,z,A,B=8>p?1:-1;for(n=d.ieOffsetX||0,o=d.ieOffsetY||0,d.ieOffsetX=Math.round((q-((0>h?-h:h)*q+(0>i?-i:i)*r))/2+u),d.ieOffsetY=Math.round((r-((0>k?-k:k)*r+(0>j?-j:j)*q))/2+v),wa=0;4>wa;wa++)z=fa[wa],y=m[z],c=-1!==y.indexOf("px")?parseFloat(y):aa(this.t,z,parseFloat(y),y.replace(w,""))||0,A=c!==d[z]?2>wa?-d.ieOffsetX:-d.ieOffsetY:2>wa?n-d.ieOffsetX:o-d.ieOffsetY,l[z]=(d[z]=Math.round(c-A*(0===wa||2===wa?1:B)))+"px"}}},Ta=S.set3DTransformRatio=S.setTransformRatio=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,o,p,q,r,s,t,u,v,w,x,y,z=this.data,A=this.t.style,B=z.rotation,C=z.rotationX,D=z.rotationY,E=z.scaleX,F=z.scaleY,G=z.scaleZ,H=z.x,I=z.y,J=z.z,L=z.svg,M=z.perspective,N=z.force3D,O=z.skewY,P=z.skewX;if(O&&(P+=O,B+=O),((1===a||0===a)&&"auto"===N&&(this.tween._totalTime===this.tween._totalDuration||!this.tween._totalTime)||!N)&&!J&&!M&&!D&&!C&&1===G||Aa&&L||!Fa)return void(B||P||L?(B*=K,x=P*K,y=1e5,c=Math.cos(B)*E,f=Math.sin(B)*E,d=Math.sin(B-x)*-F,g=Math.cos(B-x)*F,x&&"simple"===z.skewType&&(b=Math.tan(x-O*K),b=Math.sqrt(1+b*b),d*=b,g*=b,O&&(b=Math.tan(O*K),b=Math.sqrt(1+b*b),c*=b,f*=b)),L&&(H+=z.xOrigin-(z.xOrigin*c+z.yOrigin*d)+z.xOffset,I+=z.yOrigin-(z.xOrigin*f+z.yOrigin*g)+z.yOffset,Aa&&(z.xPercent||z.yPercent)&&(q=this.t.getBBox(),H+=.01*z.xPercent*q.width,I+=.01*z.yPercent*q.height),q=1e-6,q>H&&H>-q&&(H=0),q>I&&I>-q&&(I=0)),u=(c*y|0)/y+","+(f*y|0)/y+","+(d*y|0)/y+","+(g*y|0)/y+","+H+","+I+")",L&&Aa?this.t.setAttribute("transform","matrix("+u):A[Ca]=(z.xPercent||z.yPercent?"translate("+z.xPercent+"%,"+z.yPercent+"%) matrix(":"matrix(")+u):A[Ca]=(z.xPercent||z.yPercent?"translate("+z.xPercent+"%,"+z.yPercent+"%) matrix(":"matrix(")+E+",0,0,"+F+","+H+","+I+")");if(n&&(q=1e-4,q>E&&E>-q&&(E=G=2e-5),q>F&&F>-q&&(F=G=2e-5),!M||z.z||z.rotationX||z.rotationY||(M=0)),B||P)B*=K,r=c=Math.cos(B),s=f=Math.sin(B),P&&(B-=P*K,r=Math.cos(B),s=Math.sin(B),"simple"===z.skewType&&(b=Math.tan((P-O)*K),b=Math.sqrt(1+b*b),r*=b,s*=b,z.skewY&&(b=Math.tan(O*K),b=Math.sqrt(1+b*b),c*=b,f*=b))),d=-s,g=r;else{if(!(D||C||1!==G||M||L))return void(A[Ca]=(z.xPercent||z.yPercent?"translate("+z.xPercent+"%,"+z.yPercent+"%) translate3d(":"translate3d(")+H+"px,"+I+"px,"+J+"px)"+(1!==E||1!==F?" scale("+E+","+F+")":""));c=g=1,d=f=0}k=1,e=h=i=j=l=m=0,o=M?-1/M:0,p=z.zOrigin,q=1e-6,v=",",w="0",B=D*K,B&&(r=Math.cos(B),s=Math.sin(B),i=-s,l=o*-s,e=c*s,h=f*s,k=r,o*=r,c*=r,f*=r),B=C*K,B&&(r=Math.cos(B),s=Math.sin(B),b=d*r+e*s,t=g*r+h*s,j=k*s,m=o*s,e=d*-s+e*r,h=g*-s+h*r,k*=r,o*=r,d=b,g=t),1!==G&&(e*=G,h*=G,k*=G,o*=G),1!==F&&(d*=F,g*=F,j*=F,m*=F),1!==E&&(c*=E,f*=E,i*=E,l*=E),(p||L)&&(p&&(H+=e*-p,I+=h*-p,J+=k*-p+p),L&&(H+=z.xOrigin-(z.xOrigin*c+z.yOrigin*d)+z.xOffset,I+=z.yOrigin-(z.xOrigin*f+z.yOrigin*g)+z.yOffset),q>H&&H>-q&&(H=w),q>I&&I>-q&&(I=w),q>J&&J>-q&&(J=0)),u=z.xPercent||z.yPercent?"translate("+z.xPercent+"%,"+z.yPercent+"%) matrix3d(":"matrix3d(",u+=(q>c&&c>-q?w:c)+v+(q>f&&f>-q?w:f)+v+(q>i&&i>-q?w:i),u+=v+(q>l&&l>-q?w:l)+v+(q>d&&d>-q?w:d)+v+(q>g&&g>-q?w:g),C||D||1!==G?(u+=v+(q>j&&j>-q?w:j)+v+(q>m&&m>-q?w:m)+v+(q>e&&e>-q?w:e),u+=v+(q>h&&h>-q?w:h)+v+(q>k&&k>-q?w:k)+v+(q>o&&o>-q?w:o)+v):u+=",0,0,0,0,1,0,",u+=H+v+I+v+J+v+(M?1+-J/M:1)+")",A[Ca]=u};j=Ga.prototype,j.x=j.y=j.z=j.skewX=j.skewY=j.rotation=j.rotationX=j.rotationY=j.zOrigin=j.xPercent=j.yPercent=j.xOffset=j.yOffset=0,j.scaleX=j.scaleY=j.scaleZ=1,ya("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin",{parser:function(a,b,c,d,f,h,i){if(d._lastParsedTransform===i)return f;d._lastParsedTransform=i;var j,k=i.scale&&"function"==typeof i.scale?i.scale:0;"function"==typeof i[c]&&(j=i[c],i[c]=b),k&&(i.scale=k(r,a));var l,m,n,o,p,s,t,u,v,w=a._gsTransform,x=a.style,y=1e-6,z=Ba.length,A=i,B={},C="transformOrigin",D=Ra(a,e,!0,A.parseTransform),E=A.transform&&("function"==typeof A.transform?A.transform(r,q):A.transform);if(d._transform=D,E&&"string"==typeof E&&Ca)m=Q.style,m[Ca]=E,m.display="block",m.position="absolute",O.body.appendChild(Q),l=Ra(Q,null,!1),D.svg&&(s=D.xOrigin,t=D.yOrigin,l.x-=D.xOffset,l.y-=D.yOffset,(A.transformOrigin||A.svgOrigin)&&(E={},La(a,ha(A.transformOrigin),E,A.svgOrigin,A.smoothOrigin,!0),s=E.xOrigin,t=E.yOrigin,l.x-=E.xOffset-D.xOffset,l.y-=E.yOffset-D.yOffset),(s||t)&&(u=Qa(Q,!0),l.x-=s-(s*u[0]+t*u[2]),l.y-=t-(s*u[1]+t*u[3]))),O.body.removeChild(Q),l.perspective||(l.perspective=D.perspective),null!=A.xPercent&&(l.xPercent=ja(A.xPercent,D.xPercent)),null!=A.yPercent&&(l.yPercent=ja(A.yPercent,D.yPercent));else if("object"==typeof A){if(l={scaleX:ja(null!=A.scaleX?A.scaleX:A.scale,D.scaleX),scaleY:ja(null!=A.scaleY?A.scaleY:A.scale,D.scaleY),scaleZ:ja(A.scaleZ,D.scaleZ),x:ja(A.x,D.x),y:ja(A.y,D.y),z:ja(A.z,D.z),xPercent:ja(A.xPercent,D.xPercent),
yPercent:ja(A.yPercent,D.yPercent),perspective:ja(A.transformPerspective,D.perspective)},p=A.directionalRotation,null!=p)if("object"==typeof p)for(m in p)A[m]=p[m];else A.rotation=p;"string"==typeof A.x&&-1!==A.x.indexOf("%")&&(l.x=0,l.xPercent=ja(A.x,D.xPercent)),"string"==typeof A.y&&-1!==A.y.indexOf("%")&&(l.y=0,l.yPercent=ja(A.y,D.yPercent)),l.rotation=ka("rotation"in A?A.rotation:"shortRotation"in A?A.shortRotation+"_short":"rotationZ"in A?A.rotationZ:D.rotation,D.rotation,"rotation",B),Fa&&(l.rotationX=ka("rotationX"in A?A.rotationX:"shortRotationX"in A?A.shortRotationX+"_short":D.rotationX||0,D.rotationX,"rotationX",B),l.rotationY=ka("rotationY"in A?A.rotationY:"shortRotationY"in A?A.shortRotationY+"_short":D.rotationY||0,D.rotationY,"rotationY",B)),l.skewX=ka(A.skewX,D.skewX),l.skewY=ka(A.skewY,D.skewY)}for(Fa&&null!=A.force3D&&(D.force3D=A.force3D,o=!0),D.skewType=A.skewType||D.skewType||g.defaultSkewType,n=D.force3D||D.z||D.rotationX||D.rotationY||l.z||l.rotationX||l.rotationY||l.perspective,n||null==A.scale||(l.scaleZ=1);--z>-1;)v=Ba[z],E=l[v]-D[v],(E>y||-y>E||null!=A[v]||null!=M[v])&&(o=!0,f=new ta(D,v,D[v],E,f),v in B&&(f.e=B[v]),f.xs0=0,f.plugin=h,d._overwriteProps.push(f.n));return E=A.transformOrigin,D.svg&&(E||A.svgOrigin)&&(s=D.xOffset,t=D.yOffset,La(a,ha(E),l,A.svgOrigin,A.smoothOrigin),f=ua(D,"xOrigin",(w?D:l).xOrigin,l.xOrigin,f,C),f=ua(D,"yOrigin",(w?D:l).yOrigin,l.yOrigin,f,C),(s!==D.xOffset||t!==D.yOffset)&&(f=ua(D,"xOffset",w?s:D.xOffset,D.xOffset,f,C),f=ua(D,"yOffset",w?t:D.yOffset,D.yOffset,f,C)),E="0px 0px"),(E||Fa&&n&&D.zOrigin)&&(Ca?(o=!0,v=Ea,E=(E||_(a,v,e,!1,"50% 50%"))+"",f=new ta(x,v,0,0,f,-1,C),f.b=x[v],f.plugin=h,Fa?(m=D.zOrigin,E=E.split(" "),D.zOrigin=(E.length>2&&(0===m||"0px"!==E[2])?parseFloat(E[2]):m)||0,f.xs0=f.e=E[0]+" "+(E[1]||"50%")+" 0px",f=new ta(D,"zOrigin",0,0,f,-1,f.n),f.b=m,f.xs0=f.e=D.zOrigin):f.xs0=f.e=E):ha(E+"",D)),o&&(d._transformType=D.svg&&Aa||!n&&3!==this._transformType?2:3),j&&(i[c]=j),k&&(i.scale=k),f},prefix:!0}),ya("boxShadow",{defaultValue:"0px 0px 0px 0px #999",prefix:!0,color:!0,multi:!0,keyword:"inset"}),ya("borderRadius",{defaultValue:"0px",parser:function(a,b,c,f,g,h){b=this.format(b);var i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y=["borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius"],z=a.style;for(q=parseFloat(a.offsetWidth),r=parseFloat(a.offsetHeight),i=b.split(" "),j=0;j<y.length;j++)this.p.indexOf("border")&&(y[j]=Z(y[j])),m=l=_(a,y[j],e,!1,"0px"),-1!==m.indexOf(" ")&&(l=m.split(" "),m=l[0],l=l[1]),n=k=i[j],o=parseFloat(m),t=m.substr((o+"").length),u="="===n.charAt(1),u?(p=parseInt(n.charAt(0)+"1",10),n=n.substr(2),p*=parseFloat(n),s=n.substr((p+"").length-(0>p?1:0))||""):(p=parseFloat(n),s=n.substr((p+"").length)),""===s&&(s=d[c]||t),s!==t&&(v=aa(a,"borderLeft",o,t),w=aa(a,"borderTop",o,t),"%"===s?(m=v/q*100+"%",l=w/r*100+"%"):"em"===s?(x=aa(a,"borderLeft",1,"em"),m=v/x+"em",l=w/x+"em"):(m=v+"px",l=w+"px"),u&&(n=parseFloat(m)+p+s,k=parseFloat(l)+p+s)),g=va(z,y[j],m+" "+l,n+" "+k,!1,"0px",g);return g},prefix:!0,formatter:qa("0px 0px 0px 0px",!1,!0)}),ya("borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius",{defaultValue:"0px",parser:function(a,b,c,d,f,g){return va(a.style,c,this.format(_(a,c,e,!1,"0px 0px")),this.format(b),!1,"0px",f)},prefix:!0,formatter:qa("0px 0px",!1,!0)}),ya("backgroundPosition",{defaultValue:"0 0",parser:function(a,b,c,d,f,g){var h,i,j,k,l,m,n="background-position",o=e||$(a,null),q=this.format((o?p?o.getPropertyValue(n+"-x")+" "+o.getPropertyValue(n+"-y"):o.getPropertyValue(n):a.currentStyle.backgroundPositionX+" "+a.currentStyle.backgroundPositionY)||"0 0"),r=this.format(b);if(-1!==q.indexOf("%")!=(-1!==r.indexOf("%"))&&r.split(",").length<2&&(m=_(a,"backgroundImage").replace(D,""),m&&"none"!==m)){for(h=q.split(" "),i=r.split(" "),R.setAttribute("src",m),j=2;--j>-1;)q=h[j],k=-1!==q.indexOf("%"),k!==(-1!==i[j].indexOf("%"))&&(l=0===j?a.offsetWidth-R.width:a.offsetHeight-R.height,h[j]=k?parseFloat(q)/100*l+"px":parseFloat(q)/l*100+"%");q=h.join(" ")}return this.parseComplex(a.style,q,r,f,g)},formatter:ha}),ya("backgroundSize",{defaultValue:"0 0",formatter:function(a){return a+="",ha(-1===a.indexOf(" ")?a+" "+a:a)}}),ya("perspective",{defaultValue:"0px",prefix:!0}),ya("perspectiveOrigin",{defaultValue:"50% 50%",prefix:!0}),ya("transformStyle",{prefix:!0}),ya("backfaceVisibility",{prefix:!0}),ya("userSelect",{prefix:!0}),ya("margin",{parser:ra("marginTop,marginRight,marginBottom,marginLeft")}),ya("padding",{parser:ra("paddingTop,paddingRight,paddingBottom,paddingLeft")}),ya("clip",{defaultValue:"rect(0px,0px,0px,0px)",parser:function(a,b,c,d,f,g){var h,i,j;return 9>p?(i=a.currentStyle,j=8>p?" ":",",h="rect("+i.clipTop+j+i.clipRight+j+i.clipBottom+j+i.clipLeft+")",b=this.format(b).split(",").join(j)):(h=this.format(_(a,this.p,e,!1,this.dflt)),b=this.format(b)),this.parseComplex(a.style,h,b,f,g)}}),ya("textShadow",{defaultValue:"0px 0px 0px #999",color:!0,multi:!0}),ya("autoRound,strictUnits",{parser:function(a,b,c,d,e){return e}}),ya("border",{defaultValue:"0px solid #000",parser:function(a,b,c,d,f,g){var h=_(a,"borderTopWidth",e,!1,"0px"),i=this.format(b).split(" "),j=i[0].replace(w,"");return"px"!==j&&(h=parseFloat(h)/aa(a,"borderTopWidth",1,j)+j),this.parseComplex(a.style,this.format(h+" "+_(a,"borderTopStyle",e,!1,"solid")+" "+_(a,"borderTopColor",e,!1,"#000")),i.join(" "),f,g)},color:!0,formatter:function(a){var b=a.split(" ");return b[0]+" "+(b[1]||"solid")+" "+(a.match(pa)||["#000"])[0]}}),ya("borderWidth",{parser:ra("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")}),ya("float,cssFloat,styleFloat",{parser:function(a,b,c,d,e,f){var g=a.style,h="cssFloat"in g?"cssFloat":"styleFloat";return new ta(g,h,0,0,e,-1,c,!1,0,g[h],b)}});var Ua=function(a){var b,c=this.t,d=c.filter||_(this.data,"filter")||"",e=this.s+this.c*a|0;100===e&&(-1===d.indexOf("atrix(")&&-1===d.indexOf("radient(")&&-1===d.indexOf("oader(")?(c.removeAttribute("filter"),b=!_(this.data,"filter")):(c.filter=d.replace(z,""),b=!0)),b||(this.xn1&&(c.filter=d=d||"alpha(opacity="+e+")"),-1===d.indexOf("pacity")?0===e&&this.xn1||(c.filter=d+" alpha(opacity="+e+")"):c.filter=d.replace(x,"opacity="+e))};ya("opacity,alpha,autoAlpha",{defaultValue:"1",parser:function(a,b,c,d,f,g){var h=parseFloat(_(a,"opacity",e,!1,"1")),i=a.style,j="autoAlpha"===c;return"string"==typeof b&&"="===b.charAt(1)&&(b=("-"===b.charAt(0)?-1:1)*parseFloat(b.substr(2))+h),j&&1===h&&"hidden"===_(a,"visibility",e)&&0!==b&&(h=0),U?f=new ta(i,"opacity",h,b-h,f):(f=new ta(i,"opacity",100*h,100*(b-h),f),f.xn1=j?1:0,i.zoom=1,f.type=2,f.b="alpha(opacity="+f.s+")",f.e="alpha(opacity="+(f.s+f.c)+")",f.data=a,f.plugin=g,f.setRatio=Ua),j&&(f=new ta(i,"visibility",0,0,f,-1,null,!1,0,0!==h?"inherit":"hidden",0===b?"hidden":"inherit"),f.xs0="inherit",d._overwriteProps.push(f.n),d._overwriteProps.push(c)),f}});var Va=function(a,b){b&&(a.removeProperty?(("ms"===b.substr(0,2)||"webkit"===b.substr(0,6))&&(b="-"+b),a.removeProperty(b.replace(B,"-$1").toLowerCase())):a.removeAttribute(b))},Wa=function(a){if(this.t._gsClassPT=this,1===a||0===a){this.t.setAttribute("class",0===a?this.b:this.e);for(var b=this.data,c=this.t.style;b;)b.v?c[b.p]=b.v:Va(c,b.p),b=b._next;1===a&&this.t._gsClassPT===this&&(this.t._gsClassPT=null)}else this.t.getAttribute("class")!==this.e&&this.t.setAttribute("class",this.e)};ya("className",{parser:function(a,b,d,f,g,h,i){var j,k,l,m,n,o=a.getAttribute("class")||"",p=a.style.cssText;if(g=f._classNamePT=new ta(a,d,0,0,g,2),g.setRatio=Wa,g.pr=-11,c=!0,g.b=o,k=ca(a,e),l=a._gsClassPT){for(m={},n=l.data;n;)m[n.p]=1,n=n._next;l.setRatio(1)}return a._gsClassPT=g,g.e="="!==b.charAt(1)?b:o.replace(new RegExp("(?:\\s|^)"+b.substr(2)+"(?![\\w-])"),"")+("+"===b.charAt(0)?" "+b.substr(2):""),a.setAttribute("class",g.e),j=da(a,k,ca(a),i,m),a.setAttribute("class",o),g.data=j.firstMPT,a.style.cssText=p,g=g.xfirst=f.parse(a,j.difs,g,h)}});var Xa=function(a){if((1===a||0===a)&&this.data._totalTime===this.data._totalDuration&&"isFromStart"!==this.data.data){var b,c,d,e,f,g=this.t.style,h=i.transform.parse;if("all"===this.e)g.cssText="",e=!0;else for(b=this.e.split(" ").join("").split(","),d=b.length;--d>-1;)c=b[d],i[c]&&(i[c].parse===h?e=!0:c="transformOrigin"===c?Ea:i[c].p),Va(g,c);e&&(Va(g,Ca),f=this.t._gsTransform,f&&(f.svg&&(this.t.removeAttribute("data-svg-origin"),this.t.removeAttribute("transform")),delete this.t._gsTransform))}};for(ya("clearProps",{parser:function(a,b,d,e,f){return f=new ta(a,d,0,0,f,2),f.setRatio=Xa,f.e=b,f.pr=-10,f.data=e._tween,c=!0,f}}),j="bezier,throwProps,physicsProps,physics2D".split(","),wa=j.length;wa--;)za(j[wa]);j=g.prototype,j._firstPT=j._lastParsedTransform=j._transform=null,j._onInitTween=function(a,b,h,j){if(!a.nodeType)return!1;this._target=q=a,this._tween=h,this._vars=b,r=j,k=b.autoRound,c=!1,d=b.suffixMap||g.suffixMap,e=$(a,""),f=this._overwriteProps;var n,p,s,t,u,v,w,x,z,A=a.style;if(l&&""===A.zIndex&&(n=_(a,"zIndex",e),("auto"===n||""===n)&&this._addLazySet(A,"zIndex",0)),"string"==typeof b&&(t=A.cssText,n=ca(a,e),A.cssText=t+";"+b,n=da(a,n,ca(a)).difs,!U&&y.test(b)&&(n.opacity=parseFloat(RegExp.$1)),b=n,A.cssText=t),b.className?this._firstPT=p=i.className.parse(a,b.className,"className",this,null,null,b):this._firstPT=p=this.parse(a,b,null),this._transformType){for(z=3===this._transformType,Ca?m&&(l=!0,""===A.zIndex&&(w=_(a,"zIndex",e),("auto"===w||""===w)&&this._addLazySet(A,"zIndex",0)),o&&this._addLazySet(A,"WebkitBackfaceVisibility",this._vars.WebkitBackfaceVisibility||(z?"visible":"hidden"))):A.zoom=1,s=p;s&&s._next;)s=s._next;x=new ta(a,"transform",0,0,null,2),this._linkCSSP(x,null,s),x.setRatio=Ca?Ta:Sa,x.data=this._transform||Ra(a,e,!0),x.tween=h,x.pr=-1,f.pop()}if(c){for(;p;){for(v=p._next,s=t;s&&s.pr>p.pr;)s=s._next;(p._prev=s?s._prev:u)?p._prev._next=p:t=p,(p._next=s)?s._prev=p:u=p,p=v}this._firstPT=t}return!0},j.parse=function(a,b,c,f){var g,h,j,l,m,n,o,p,s,t,u=a.style;for(g in b)n=b[g],"function"==typeof n&&(n=n(r,q)),h=i[g],h?c=h.parse(a,n,g,this,c,f,b):(m=_(a,g,e)+"",s="string"==typeof n,"color"===g||"fill"===g||"stroke"===g||-1!==g.indexOf("Color")||s&&A.test(n)?(s||(n=na(n),n=(n.length>3?"rgba(":"rgb(")+n.join(",")+")"),c=va(u,g,m,n,!0,"transparent",c,0,f)):s&&J.test(n)?c=va(u,g,m,n,!0,null,c,0,f):(j=parseFloat(m),o=j||0===j?m.substr((j+"").length):"",(""===m||"auto"===m)&&("width"===g||"height"===g?(j=ga(a,g,e),o="px"):"left"===g||"top"===g?(j=ba(a,g,e),o="px"):(j="opacity"!==g?0:1,o="")),t=s&&"="===n.charAt(1),t?(l=parseInt(n.charAt(0)+"1",10),n=n.substr(2),l*=parseFloat(n),p=n.replace(w,"")):(l=parseFloat(n),p=s?n.replace(w,""):""),""===p&&(p=g in d?d[g]:o),n=l||0===l?(t?l+j:l)+p:b[g],o!==p&&""!==p&&(l||0===l)&&j&&(j=aa(a,g,j,o),"%"===p?(j/=aa(a,g,100,"%")/100,b.strictUnits!==!0&&(m=j+"%")):"em"===p||"rem"===p||"vw"===p||"vh"===p?j/=aa(a,g,1,p):"px"!==p&&(l=aa(a,g,l,p),p="px"),t&&(l||0===l)&&(n=l+j+p)),t&&(l+=j),!j&&0!==j||!l&&0!==l?void 0!==u[g]&&(n||n+""!="NaN"&&null!=n)?(c=new ta(u,g,l||j||0,0,c,-1,g,!1,0,m,n),c.xs0="none"!==n||"display"!==g&&-1===g.indexOf("Style")?n:m):W("invalid "+g+" tween value: "+b[g]):(c=new ta(u,g,j,l-j,c,0,g,k!==!1&&("px"===p||"zIndex"===g),0,m,n),c.xs0=p))),f&&c&&!c.plugin&&(c.plugin=f);return c},j.setRatio=function(a){var b,c,d,e=this._firstPT,f=1e-6;if(1!==a||this._tween._time!==this._tween._duration&&0!==this._tween._time)if(a||this._tween._time!==this._tween._duration&&0!==this._tween._time||this._tween._rawPrevTime===-1e-6)for(;e;){if(b=e.c*a+e.s,e.r?b=Math.round(b):f>b&&b>-f&&(b=0),e.type)if(1===e.type)if(d=e.l,2===d)e.t[e.p]=e.xs0+b+e.xs1+e.xn1+e.xs2;else if(3===d)e.t[e.p]=e.xs0+b+e.xs1+e.xn1+e.xs2+e.xn2+e.xs3;else if(4===d)e.t[e.p]=e.xs0+b+e.xs1+e.xn1+e.xs2+e.xn2+e.xs3+e.xn3+e.xs4;else if(5===d)e.t[e.p]=e.xs0+b+e.xs1+e.xn1+e.xs2+e.xn2+e.xs3+e.xn3+e.xs4+e.xn4+e.xs5;else{for(c=e.xs0+b+e.xs1,d=1;d<e.l;d++)c+=e["xn"+d]+e["xs"+(d+1)];e.t[e.p]=c}else-1===e.type?e.t[e.p]=e.xs0:e.setRatio&&e.setRatio(a);else e.t[e.p]=b+e.xs0;e=e._next}else for(;e;)2!==e.type?e.t[e.p]=e.b:e.setRatio(a),e=e._next;else for(;e;){if(2!==e.type)if(e.r&&-1!==e.type)if(b=Math.round(e.s+e.c),e.type){if(1===e.type){for(d=e.l,c=e.xs0+b+e.xs1,d=1;d<e.l;d++)c+=e["xn"+d]+e["xs"+(d+1)];e.t[e.p]=c}}else e.t[e.p]=b+e.xs0;else e.t[e.p]=e.e;else e.setRatio(a);e=e._next}},j._enableTransforms=function(a){this._transform=this._transform||Ra(this._target,e,!0),this._transformType=this._transform.svg&&Aa||!a&&3!==this._transformType?2:3};var Ya=function(a){this.t[this.p]=this.e,this.data._linkCSSP(this,this._next,null,!0)};j._addLazySet=function(a,b,c){var d=this._firstPT=new ta(a,b,0,0,this._firstPT,2);d.e=c,d.setRatio=Ya,d.data=this},j._linkCSSP=function(a,b,c,d){return a&&(b&&(b._prev=a),a._next&&(a._next._prev=a._prev),a._prev?a._prev._next=a._next:this._firstPT===a&&(this._firstPT=a._next,d=!0),c?c._next=a:d||null!==this._firstPT||(this._firstPT=a),a._next=b,a._prev=c),a},j._mod=function(a){for(var b=this._firstPT;b;)"function"==typeof a[b.p]&&a[b.p]===Math.round&&(b.r=1),b=b._next},j._kill=function(b){var c,d,e,f=b;if(b.autoAlpha||b.alpha){f={};for(d in b)f[d]=b[d];f.opacity=1,f.autoAlpha&&(f.visibility=1)}for(b.className&&(c=this._classNamePT)&&(e=c.xfirst,e&&e._prev?this._linkCSSP(e._prev,c._next,e._prev._prev):e===this._firstPT&&(this._firstPT=c._next),c._next&&this._linkCSSP(c._next,c._next._next,e._prev),this._classNamePT=null),c=this._firstPT;c;)c.plugin&&c.plugin!==d&&c.plugin._kill&&(c.plugin._kill(b),d=c.plugin),c=c._next;return a.prototype._kill.call(this,f)};var Za=function(a,b,c){var d,e,f,g;if(a.slice)for(e=a.length;--e>-1;)Za(a[e],b,c);else for(d=a.childNodes,e=d.length;--e>-1;)f=d[e],g=f.type,f.style&&(b.push(ca(f)),c&&c.push(f)),1!==g&&9!==g&&11!==g||!f.childNodes.length||Za(f,b,c)};return g.cascadeTo=function(a,c,d){var e,f,g,h,i=b.to(a,c,d),j=[i],k=[],l=[],m=[],n=b._internals.reservedProps;for(a=i._targets||i.target,Za(a,k,m),i.render(c,!0,!0),Za(a,l),i.render(0,!0,!0),i._enabled(!0),e=m.length;--e>-1;)if(f=da(m[e],k[e],l[e]),f.firstMPT){f=f.difs;for(g in d)n[g]&&(f[g]=d[g]);h={};for(g in f)h[g]=k[e][g];j.push(b.fromTo(m[e],c,h,f))}return j},a.activate([g]),g},!0),function(){var a=_gsScope._gsDefine.plugin({propName:"roundProps",version:"1.6.0",priority:-1,API:2,init:function(a,b,c){return this._tween=c,!0}}),b=function(a){for(;a;)a.f||a.blob||(a.m=Math.round),a=a._next},c=a.prototype;c._onInitAllProps=function(){for(var a,c,d,e=this._tween,f=e.vars.roundProps.join?e.vars.roundProps:e.vars.roundProps.split(","),g=f.length,h={},i=e._propLookup.roundProps;--g>-1;)h[f[g]]=Math.round;for(g=f.length;--g>-1;)for(a=f[g],c=e._firstPT;c;)d=c._next,c.pg?c.t._mod(h):c.n===a&&(2===c.f&&c.t?b(c.t._firstPT):(this._add(c.t,a,c.s,c.c),d&&(d._prev=c._prev),c._prev?c._prev._next=d:e._firstPT===c&&(e._firstPT=d),c._next=c._prev=null,e._propLookup[a]=i)),c=d;return!1},c._add=function(a,b,c,d){this._addTween(a,b,c,c+d,b,Math.round),this._overwriteProps.push(b)}}(),function(){_gsScope._gsDefine.plugin({propName:"attr",API:2,version:"0.6.0",init:function(a,b,c,d){var e,f;if("function"!=typeof a.setAttribute)return!1;for(e in b)f=b[e],"function"==typeof f&&(f=f(d,a)),this._addTween(a,"setAttribute",a.getAttribute(e)+"",f+"",e,!1,e),this._overwriteProps.push(e);return!0}})}(),_gsScope._gsDefine.plugin({propName:"directionalRotation",version:"0.3.0",API:2,init:function(a,b,c,d){"object"!=typeof b&&(b={rotation:b}),this.finals={};var e,f,g,h,i,j,k=b.useRadians===!0?2*Math.PI:360,l=1e-6;for(e in b)"useRadians"!==e&&(h=b[e],"function"==typeof h&&(h=h(d,a)),j=(h+"").split("_"),f=j[0],g=parseFloat("function"!=typeof a[e]?a[e]:a[e.indexOf("set")||"function"!=typeof a["get"+e.substr(3)]?e:"get"+e.substr(3)]()),h=this.finals[e]="string"==typeof f&&"="===f.charAt(1)?g+parseInt(f.charAt(0)+"1",10)*Number(f.substr(2)):Number(f)||0,i=h-g,j.length&&(f=j.join("_"),-1!==f.indexOf("short")&&(i%=k,i!==i%(k/2)&&(i=0>i?i+k:i-k)),-1!==f.indexOf("_cw")&&0>i?i=(i+9999999999*k)%k-(i/k|0)*k:-1!==f.indexOf("ccw")&&i>0&&(i=(i-9999999999*k)%k-(i/k|0)*k)),(i>l||-l>i)&&(this._addTween(a,e,g,g+i,e),this._overwriteProps.push(e)));return!0},set:function(a){var b;if(1!==a)this._super.setRatio.call(this,a);else for(b=this._firstPT;b;)b.f?b.t[b.p](this.finals[b.p]):b.t[b.p]=this.finals[b.p],b=b._next}})._autoCSS=!0,_gsScope._gsDefine("easing.Back",["easing.Ease"],function(a){var b,c,d,e=_gsScope.GreenSockGlobals||_gsScope,f=e.com.greensock,g=2*Math.PI,h=Math.PI/2,i=f._class,j=function(b,c){var d=i("easing."+b,function(){},!0),e=d.prototype=new a;return e.constructor=d,e.getRatio=c,d},k=a.register||function(){},l=function(a,b,c,d,e){var f=i("easing."+a,{easeOut:new b,easeIn:new c,easeInOut:new d},!0);return k(f,a),f},m=function(a,b,c){this.t=a,this.v=b,c&&(this.next=c,c.prev=this,this.c=c.v-b,this.gap=c.t-a)},n=function(b,c){var d=i("easing."+b,function(a){this._p1=a||0===a?a:1.70158,this._p2=1.525*this._p1},!0),e=d.prototype=new a;return e.constructor=d,e.getRatio=c,e.config=function(a){return new d(a)},d},o=l("Back",n("BackOut",function(a){return(a-=1)*a*((this._p1+1)*a+this._p1)+1}),n("BackIn",function(a){return a*a*((this._p1+1)*a-this._p1)}),n("BackInOut",function(a){return(a*=2)<1?.5*a*a*((this._p2+1)*a-this._p2):.5*((a-=2)*a*((this._p2+1)*a+this._p2)+2)})),p=i("easing.SlowMo",function(a,b,c){b=b||0===b?b:.7,null==a?a=.7:a>1&&(a=1),this._p=1!==a?b:0,this._p1=(1-a)/2,this._p2=a,this._p3=this._p1+this._p2,this._calcEnd=c===!0},!0),q=p.prototype=new a;return q.constructor=p,q.getRatio=function(a){var b=a+(.5-a)*this._p;return a<this._p1?this._calcEnd?1-(a=1-a/this._p1)*a:b-(a=1-a/this._p1)*a*a*a*b:a>this._p3?this._calcEnd?1-(a=(a-this._p3)/this._p1)*a:b+(a-b)*(a=(a-this._p3)/this._p1)*a*a*a:this._calcEnd?1:b},p.ease=new p(.7,.7),q.config=p.config=function(a,b,c){return new p(a,b,c)},b=i("easing.SteppedEase",function(a){a=a||1,this._p1=1/a,this._p2=a+1},!0),q=b.prototype=new a,q.constructor=b,q.getRatio=function(a){return 0>a?a=0:a>=1&&(a=.999999999),(this._p2*a>>0)*this._p1},q.config=b.config=function(a){return new b(a)},c=i("easing.RoughEase",function(b){b=b||{};for(var c,d,e,f,g,h,i=b.taper||"none",j=[],k=0,l=0|(b.points||20),n=l,o=b.randomize!==!1,p=b.clamp===!0,q=b.template instanceof a?b.template:null,r="number"==typeof b.strength?.4*b.strength:.4;--n>-1;)c=o?Math.random():1/l*n,d=q?q.getRatio(c):c,"none"===i?e=r:"out"===i?(f=1-c,e=f*f*r):"in"===i?e=c*c*r:.5>c?(f=2*c,e=f*f*.5*r):(f=2*(1-c),e=f*f*.5*r),o?d+=Math.random()*e-.5*e:n%2?d+=.5*e:d-=.5*e,p&&(d>1?d=1:0>d&&(d=0)),j[k++]={x:c,y:d};for(j.sort(function(a,b){return a.x-b.x}),h=new m(1,1,null),n=l;--n>-1;)g=j[n],h=new m(g.x,g.y,h);this._prev=new m(0,0,0!==h.t?h:h.next)},!0),q=c.prototype=new a,q.constructor=c,q.getRatio=function(a){var b=this._prev;if(a>b.t){for(;b.next&&a>=b.t;)b=b.next;b=b.prev}else for(;b.prev&&a<=b.t;)b=b.prev;return this._prev=b,b.v+(a-b.t)/b.gap*b.c},q.config=function(a){return new c(a)},c.ease=new c,l("Bounce",j("BounceOut",function(a){return 1/2.75>a?7.5625*a*a:2/2.75>a?7.5625*(a-=1.5/2.75)*a+.75:2.5/2.75>a?7.5625*(a-=2.25/2.75)*a+.9375:7.5625*(a-=2.625/2.75)*a+.984375}),j("BounceIn",function(a){return(a=1-a)<1/2.75?1-7.5625*a*a:2/2.75>a?1-(7.5625*(a-=1.5/2.75)*a+.75):2.5/2.75>a?1-(7.5625*(a-=2.25/2.75)*a+.9375):1-(7.5625*(a-=2.625/2.75)*a+.984375)}),j("BounceInOut",function(a){var b=.5>a;return a=b?1-2*a:2*a-1,a=1/2.75>a?7.5625*a*a:2/2.75>a?7.5625*(a-=1.5/2.75)*a+.75:2.5/2.75>a?7.5625*(a-=2.25/2.75)*a+.9375:7.5625*(a-=2.625/2.75)*a+.984375,b?.5*(1-a):.5*a+.5})),l("Circ",j("CircOut",function(a){return Math.sqrt(1-(a-=1)*a)}),j("CircIn",function(a){return-(Math.sqrt(1-a*a)-1)}),j("CircInOut",function(a){return(a*=2)<1?-.5*(Math.sqrt(1-a*a)-1):.5*(Math.sqrt(1-(a-=2)*a)+1)})),d=function(b,c,d){var e=i("easing."+b,function(a,b){this._p1=a>=1?a:1,this._p2=(b||d)/(1>a?a:1),this._p3=this._p2/g*(Math.asin(1/this._p1)||0),this._p2=g/this._p2},!0),f=e.prototype=new a;return f.constructor=e,f.getRatio=c,f.config=function(a,b){return new e(a,b)},e},l("Elastic",d("ElasticOut",function(a){return this._p1*Math.pow(2,-10*a)*Math.sin((a-this._p3)*this._p2)+1},.3),d("ElasticIn",function(a){return-(this._p1*Math.pow(2,10*(a-=1))*Math.sin((a-this._p3)*this._p2))},.3),d("ElasticInOut",function(a){return(a*=2)<1?-.5*(this._p1*Math.pow(2,10*(a-=1))*Math.sin((a-this._p3)*this._p2)):this._p1*Math.pow(2,-10*(a-=1))*Math.sin((a-this._p3)*this._p2)*.5+1},.45)),l("Expo",j("ExpoOut",function(a){return 1-Math.pow(2,-10*a)}),j("ExpoIn",function(a){return Math.pow(2,10*(a-1))-.001}),j("ExpoInOut",function(a){return(a*=2)<1?.5*Math.pow(2,10*(a-1)):.5*(2-Math.pow(2,-10*(a-1)))})),l("Sine",j("SineOut",function(a){return Math.sin(a*h)}),j("SineIn",function(a){return-Math.cos(a*h)+1}),j("SineInOut",function(a){return-.5*(Math.cos(Math.PI*a)-1)})),i("easing.EaseLookup",{find:function(b){return a.map[b]}},!0),k(e.SlowMo,"SlowMo","ease,"),k(c,"RoughEase","ease,"),k(b,"SteppedEase","ease,"),o},!0)}),_gsScope._gsDefine&&_gsScope._gsQueue.pop()(),function(a,b){"use strict";var c={},d=a.document,e=a.GreenSockGlobals=a.GreenSockGlobals||a;if(!e.TweenLite){var f,g,h,i,j,k=function(a){var b,c=a.split("."),d=e;for(b=0;b<c.length;b++)d[c[b]]=d=d[c[b]]||{};return d},l=k("com.greensock"),m=1e-10,n=function(a){var b,c=[],d=a.length;for(b=0;b!==d;c.push(a[b++]));return c},o=function(){},p=function(){var a=Object.prototype.toString,b=a.call([]);return function(c){return null!=c&&(c instanceof Array||"object"==typeof c&&!!c.push&&a.call(c)===b)}}(),q={},r=function(d,f,g,h){this.sc=q[d]?q[d].sc:[],q[d]=this,this.gsClass=null,this.func=g;var i=[];this.check=function(j){for(var l,m,n,o,p,s=f.length,t=s;--s>-1;)(l=q[f[s]]||new r(f[s],[])).gsClass?(i[s]=l.gsClass,t--):j&&l.sc.push(this);if(0===t&&g){if(m=("com.greensock."+d).split("."),n=m.pop(),o=k(m.join("."))[n]=this.gsClass=g.apply(g,i),h)if(e[n]=c[n]=o,p="undefined"!=typeof module&&module.exports,!p&&"function"==typeof define&&define.amd)define((a.GreenSockAMDPath?a.GreenSockAMDPath+"/":"")+d.split(".").pop(),[],function(){return o});else if(p)if(d===b){module.exports=c[b]=o;for(s in c)o[s]=c[s]}else c[b]&&(c[b][n]=o);for(s=0;s<this.sc.length;s++)this.sc[s].check()}},this.check(!0)},s=a._gsDefine=function(a,b,c,d){return new r(a,b,c,d)},t=l._class=function(a,b,c){return b=b||function(){},s(a,[],function(){return b},c),b};s.globals=e;var u=[0,0,1,1],v=t("easing.Ease",function(a,b,c,d){this._func=a,this._type=c||0,this._power=d||0,this._params=b?u.concat(b):u},!0),w=v.map={},x=v.register=function(a,b,c,d){for(var e,f,g,h,i=b.split(","),j=i.length,k=(c||"easeIn,easeOut,easeInOut").split(",");--j>-1;)for(f=i[j],e=d?t("easing."+f,null,!0):l.easing[f]||{},g=k.length;--g>-1;)h=k[g],w[f+"."+h]=w[h+f]=e[h]=a.getRatio?a:a[h]||new a};for(h=v.prototype,h._calcEnd=!1,h.getRatio=function(a){if(this._func)return this._params[0]=a,this._func.apply(null,this._params);var b=this._type,c=this._power,d=1===b?1-a:2===b?a:.5>a?2*a:2*(1-a);return 1===c?d*=d:2===c?d*=d*d:3===c?d*=d*d*d:4===c&&(d*=d*d*d*d),1===b?1-d:2===b?d:.5>a?d/2:1-d/2},f=["Linear","Quad","Cubic","Quart","Quint,Strong"],g=f.length;--g>-1;)h=f[g]+",Power"+g,x(new v(null,null,1,g),h,"easeOut",!0),x(new v(null,null,2,g),h,"easeIn"+(0===g?",easeNone":"")),x(new v(null,null,3,g),h,"easeInOut");w.linear=l.easing.Linear.easeIn,w.swing=l.easing.Quad.easeInOut;var y=t("events.EventDispatcher",function(a){this._listeners={},this._eventTarget=a||this});h=y.prototype,h.addEventListener=function(a,b,c,d,e){e=e||0;var f,g,h=this._listeners[a],k=0;for(this!==i||j||i.wake(),null==h&&(this._listeners[a]=h=[]),g=h.length;--g>-1;)f=h[g],f.c===b&&f.s===c?h.splice(g,1):0===k&&f.pr<e&&(k=g+1);h.splice(k,0,{c:b,s:c,up:d,pr:e})},h.removeEventListener=function(a,b){var c,d=this._listeners[a];if(d)for(c=d.length;--c>-1;)if(d[c].c===b)return void d.splice(c,1)},h.dispatchEvent=function(a){var b,c,d,e=this._listeners[a];if(e)for(b=e.length,b>1&&(e=e.slice(0)),c=this._eventTarget;--b>-1;)d=e[b],d&&(d.up?d.c.call(d.s||c,{type:a,target:c}):d.c.call(d.s||c))};var z=a.requestAnimationFrame,A=a.cancelAnimationFrame,B=Date.now||function(){return(new Date).getTime()},C=B();for(f=["ms","moz","webkit","o"],g=f.length;--g>-1&&!z;)z=a[f[g]+"RequestAnimationFrame"],A=a[f[g]+"CancelAnimationFrame"]||a[f[g]+"CancelRequestAnimationFrame"];t("Ticker",function(a,b){var c,e,f,g,h,k=this,l=B(),n=b!==!1&&z?"auto":!1,p=500,q=33,r="tick",s=function(a){var b,d,i=B()-C;i>p&&(l+=i-q),C+=i,k.time=(C-l)/1e3,b=k.time-h,(!c||b>0||a===!0)&&(k.frame++,h+=b+(b>=g?.004:g-b),d=!0),a!==!0&&(f=e(s)),d&&k.dispatchEvent(r)};y.call(k),k.time=k.frame=0,k.tick=function(){s(!0)},k.lagSmoothing=function(a,b){p=a||1/m,q=Math.min(b,p,0)},k.sleep=function(){null!=f&&(n&&A?A(f):clearTimeout(f),e=o,f=null,k===i&&(j=!1))},k.wake=function(a){null!==f?k.sleep():a?l+=-C+(C=B()):k.frame>10&&(C=B()-p+5),e=0===c?o:n&&z?z:function(a){return setTimeout(a,1e3*(h-k.time)+1|0)},k===i&&(j=!0),s(2)},k.fps=function(a){return arguments.length?(c=a,g=1/(c||60),h=this.time+g,void k.wake()):c},k.useRAF=function(a){return arguments.length?(k.sleep(),n=a,void k.fps(c)):n},k.fps(a),setTimeout(function(){"auto"===n&&k.frame<5&&"hidden"!==d.visibilityState&&k.useRAF(!1)},1500)}),h=l.Ticker.prototype=new l.events.EventDispatcher,h.constructor=l.Ticker;var D=t("core.Animation",function(a,b){if(this.vars=b=b||{},this._duration=this._totalDuration=a||0,this._delay=Number(b.delay)||0,this._timeScale=1,this._active=b.immediateRender===!0,this.data=b.data,this._reversed=b.reversed===!0,W){j||i.wake();var c=this.vars.useFrames?V:W;c.add(this,c._time),this.vars.paused&&this.paused(!0)}});i=D.ticker=new l.Ticker,h=D.prototype,h._dirty=h._gc=h._initted=h._paused=!1,h._totalTime=h._time=0,h._rawPrevTime=-1,h._next=h._last=h._onUpdate=h._timeline=h.timeline=null,h._paused=!1;var E=function(){j&&B()-C>2e3&&i.wake(),setTimeout(E,2e3)};E(),h.play=function(a,b){return null!=a&&this.seek(a,b),this.reversed(!1).paused(!1)},h.pause=function(a,b){return null!=a&&this.seek(a,b),this.paused(!0)},h.resume=function(a,b){return null!=a&&this.seek(a,b),this.paused(!1)},h.seek=function(a,b){return this.totalTime(Number(a),b!==!1)},h.restart=function(a,b){return this.reversed(!1).paused(!1).totalTime(a?-this._delay:0,b!==!1,!0)},h.reverse=function(a,b){return null!=a&&this.seek(a||this.totalDuration(),b),this.reversed(!0).paused(!1)},h.render=function(a,b,c){},h.invalidate=function(){return this._time=this._totalTime=0,this._initted=this._gc=!1,this._rawPrevTime=-1,(this._gc||!this.timeline)&&this._enabled(!0),this},h.isActive=function(){var a,b=this._timeline,c=this._startTime;return!b||!this._gc&&!this._paused&&b.isActive()&&(a=b.rawTime(!0))>=c&&a<c+this.totalDuration()/this._timeScale},h._enabled=function(a,b){return j||i.wake(),this._gc=!a,this._active=this.isActive(),b!==!0&&(a&&!this.timeline?this._timeline.add(this,this._startTime-this._delay):!a&&this.timeline&&this._timeline._remove(this,!0)),!1},h._kill=function(a,b){return this._enabled(!1,!1)},h.kill=function(a,b){return this._kill(a,b),this},h._uncache=function(a){for(var b=a?this:this.timeline;b;)b._dirty=!0,b=b.timeline;return this},h._swapSelfInParams=function(a){for(var b=a.length,c=a.concat();--b>-1;)"{self}"===a[b]&&(c[b]=this);return c},h._callback=function(a){var b=this.vars,c=b[a],d=b[a+"Params"],e=b[a+"Scope"]||b.callbackScope||this,f=d?d.length:0;switch(f){case 0:c.call(e);break;case 1:c.call(e,d[0]);break;case 2:c.call(e,d[0],d[1]);break;default:c.apply(e,d)}},h.eventCallback=function(a,b,c,d){if("on"===(a||"").substr(0,2)){var e=this.vars;if(1===arguments.length)return e[a];null==b?delete e[a]:(e[a]=b,e[a+"Params"]=p(c)&&-1!==c.join("").indexOf("{self}")?this._swapSelfInParams(c):c,e[a+"Scope"]=d),"onUpdate"===a&&(this._onUpdate=b)}return this},h.delay=function(a){return arguments.length?(this._timeline.smoothChildTiming&&this.startTime(this._startTime+a-this._delay),this._delay=a,this):this._delay},h.duration=function(a){return arguments.length?(this._duration=this._totalDuration=a,this._uncache(!0),this._timeline.smoothChildTiming&&this._time>0&&this._time<this._duration&&0!==a&&this.totalTime(this._totalTime*(a/this._duration),!0),this):(this._dirty=!1,this._duration)},h.totalDuration=function(a){return this._dirty=!1,arguments.length?this.duration(a):this._totalDuration},h.time=function(a,b){return arguments.length?(this._dirty&&this.totalDuration(),this.totalTime(a>this._duration?this._duration:a,b)):this._time},h.totalTime=function(a,b,c){if(j||i.wake(),!arguments.length)return this._totalTime;if(this._timeline){if(0>a&&!c&&(a+=this.totalDuration()),this._timeline.smoothChildTiming){this._dirty&&this.totalDuration();var d=this._totalDuration,e=this._timeline;if(a>d&&!c&&(a=d),this._startTime=(this._paused?this._pauseTime:e._time)-(this._reversed?d-a:a)/this._timeScale,e._dirty||this._uncache(!1),e._timeline)for(;e._timeline;)e._timeline._time!==(e._startTime+e._totalTime)/e._timeScale&&e.totalTime(e._totalTime,!0),e=e._timeline}this._gc&&this._enabled(!0,!1),(this._totalTime!==a||0===this._duration)&&(J.length&&Y(),this.render(a,b,!1),J.length&&Y())}return this},h.progress=h.totalProgress=function(a,b){var c=this.duration();return arguments.length?this.totalTime(c*a,b):c?this._time/c:this.ratio},h.startTime=function(a){return arguments.length?(a!==this._startTime&&(this._startTime=a,this.timeline&&this.timeline._sortChildren&&this.timeline.add(this,a-this._delay)),this):this._startTime},h.endTime=function(a){return this._startTime+(0!=a?this.totalDuration():this.duration())/this._timeScale},h.timeScale=function(a){if(!arguments.length)return this._timeScale;if(a=a||m,this._timeline&&this._timeline.smoothChildTiming){var b=this._pauseTime,c=b||0===b?b:this._timeline.totalTime();this._startTime=c-(c-this._startTime)*this._timeScale/a}return this._timeScale=a,this._uncache(!1)},h.reversed=function(a){return arguments.length?(a!=this._reversed&&(this._reversed=a,this.totalTime(this._timeline&&!this._timeline.smoothChildTiming?this.totalDuration()-this._totalTime:this._totalTime,!0)),this):this._reversed},h.paused=function(a){if(!arguments.length)return this._paused;var b,c,d=this._timeline;return a!=this._paused&&d&&(j||a||i.wake(),b=d.rawTime(),c=b-this._pauseTime,!a&&d.smoothChildTiming&&(this._startTime+=c,this._uncache(!1)),this._pauseTime=a?b:null,this._paused=a,this._active=this.isActive(),!a&&0!==c&&this._initted&&this.duration()&&(b=d.smoothChildTiming?this._totalTime:(b-this._startTime)/this._timeScale,this.render(b,b===this._totalTime,!0))),this._gc&&!a&&this._enabled(!0,!1),this};var F=t("core.SimpleTimeline",function(a){D.call(this,0,a),this.autoRemoveChildren=this.smoothChildTiming=!0});h=F.prototype=new D,h.constructor=F,h.kill()._gc=!1,h._first=h._last=h._recent=null,h._sortChildren=!1,h.add=h.insert=function(a,b,c,d){var e,f;if(a._startTime=Number(b||0)+a._delay,a._paused&&this!==a._timeline&&(a._pauseTime=a._startTime+(this.rawTime()-a._startTime)/a._timeScale),a.timeline&&a.timeline._remove(a,!0),a.timeline=a._timeline=this,a._gc&&a._enabled(!0,!0),e=this._last,this._sortChildren)for(f=a._startTime;e&&e._startTime>f;)e=e._prev;return e?(a._next=e._next,e._next=a):(a._next=this._first,this._first=a),a._next?a._next._prev=a:this._last=a,a._prev=e,this._recent=a,this._timeline&&this._uncache(!0),this},h._remove=function(a,b){return a.timeline===this&&(b||a._enabled(!1,!0),a._prev?a._prev._next=a._next:this._first===a&&(this._first=a._next),a._next?a._next._prev=a._prev:this._last===a&&(this._last=a._prev),a._next=a._prev=a.timeline=null,a===this._recent&&(this._recent=this._last),this._timeline&&this._uncache(!0)),this},h.render=function(a,b,c){var d,e=this._first;for(this._totalTime=this._time=this._rawPrevTime=a;e;)d=e._next,(e._active||a>=e._startTime&&!e._paused)&&(e._reversed?e.render((e._dirty?e.totalDuration():e._totalDuration)-(a-e._startTime)*e._timeScale,b,c):e.render((a-e._startTime)*e._timeScale,b,c)),e=d},h.rawTime=function(){return j||i.wake(),this._totalTime};var G=t("TweenLite",function(b,c,d){
if(D.call(this,c,d),this.render=G.prototype.render,null==b)throw"Cannot tween a null target.";this.target=b="string"!=typeof b?b:G.selector(b)||b;var e,f,g,h=b.jquery||b.length&&b!==a&&b[0]&&(b[0]===a||b[0].nodeType&&b[0].style&&!b.nodeType),i=this.vars.overwrite;if(this._overwrite=i=null==i?U[G.defaultOverwrite]:"number"==typeof i?i>>0:U[i],(h||b instanceof Array||b.push&&p(b))&&"number"!=typeof b[0])for(this._targets=g=n(b),this._propLookup=[],this._siblings=[],e=0;e<g.length;e++)f=g[e],f?"string"!=typeof f?f.length&&f!==a&&f[0]&&(f[0]===a||f[0].nodeType&&f[0].style&&!f.nodeType)?(g.splice(e--,1),this._targets=g=g.concat(n(f))):(this._siblings[e]=Z(f,this,!1),1===i&&this._siblings[e].length>1&&_(f,this,null,1,this._siblings[e])):(f=g[e--]=G.selector(f),"string"==typeof f&&g.splice(e+1,1)):g.splice(e--,1);else this._propLookup={},this._siblings=Z(b,this,!1),1===i&&this._siblings.length>1&&_(b,this,null,1,this._siblings);(this.vars.immediateRender||0===c&&0===this._delay&&this.vars.immediateRender!==!1)&&(this._time=-m,this.render(Math.min(0,-this._delay)))},!0),H=function(b){return b&&b.length&&b!==a&&b[0]&&(b[0]===a||b[0].nodeType&&b[0].style&&!b.nodeType)},I=function(a,b){var c,d={};for(c in a)T[c]||c in b&&"transform"!==c&&"x"!==c&&"y"!==c&&"width"!==c&&"height"!==c&&"className"!==c&&"border"!==c||!(!Q[c]||Q[c]&&Q[c]._autoCSS)||(d[c]=a[c],delete a[c]);a.css=d};h=G.prototype=new D,h.constructor=G,h.kill()._gc=!1,h.ratio=0,h._firstPT=h._targets=h._overwrittenProps=h._startAt=null,h._notifyPluginsOfEnabled=h._lazy=!1,G.version="1.19.1",G.defaultEase=h._ease=new v(null,null,1,1),G.defaultOverwrite="auto",G.ticker=i,G.autoSleep=120,G.lagSmoothing=function(a,b){i.lagSmoothing(a,b)},G.selector=a.$||a.jQuery||function(b){var c=a.$||a.jQuery;return c?(G.selector=c,c(b)):"undefined"==typeof d?b:d.querySelectorAll?d.querySelectorAll(b):d.getElementById("#"===b.charAt(0)?b.substr(1):b)};var J=[],K={},L=/(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,M=function(a){for(var b,c=this._firstPT,d=1e-6;c;)b=c.blob?1===a?this.end:a?this.join(""):this.start:c.c*a+c.s,c.m?b=c.m(b,this._target||c.t):d>b&&b>-d&&!c.blob&&(b=0),c.f?c.fp?c.t[c.p](c.fp,b):c.t[c.p](b):c.t[c.p]=b,c=c._next},N=function(a,b,c,d){var e,f,g,h,i,j,k,l=[],m=0,n="",o=0;for(l.start=a,l.end=b,a=l[0]=a+"",b=l[1]=b+"",c&&(c(l),a=l[0],b=l[1]),l.length=0,e=a.match(L)||[],f=b.match(L)||[],d&&(d._next=null,d.blob=1,l._firstPT=l._applyPT=d),i=f.length,h=0;i>h;h++)k=f[h],j=b.substr(m,b.indexOf(k,m)-m),n+=j||!h?j:",",m+=j.length,o?o=(o+1)%5:"rgba("===j.substr(-5)&&(o=1),k===e[h]||e.length<=h?n+=k:(n&&(l.push(n),n=""),g=parseFloat(e[h]),l.push(g),l._firstPT={_next:l._firstPT,t:l,p:l.length-1,s:g,c:("="===k.charAt(1)?parseInt(k.charAt(0)+"1",10)*parseFloat(k.substr(2)):parseFloat(k)-g)||0,f:0,m:o&&4>o?Math.round:0}),m+=k.length;return n+=b.substr(m),n&&l.push(n),l.setRatio=M,l},O=function(a,b,c,d,e,f,g,h,i){"function"==typeof d&&(d=d(i||0,a));var j,k=typeof a[b],l="function"!==k?"":b.indexOf("set")||"function"!=typeof a["get"+b.substr(3)]?b:"get"+b.substr(3),m="get"!==c?c:l?g?a[l](g):a[l]():a[b],n="string"==typeof d&&"="===d.charAt(1),o={t:a,p:b,s:m,f:"function"===k,pg:0,n:e||b,m:f?"function"==typeof f?f:Math.round:0,pr:0,c:n?parseInt(d.charAt(0)+"1",10)*parseFloat(d.substr(2)):parseFloat(d)-m||0};return("number"!=typeof m||"number"!=typeof d&&!n)&&(g||isNaN(m)||!n&&isNaN(d)||"boolean"==typeof m||"boolean"==typeof d?(o.fp=g,j=N(m,n?o.s+o.c:d,h||G.defaultStringFilter,o),o={t:j,p:"setRatio",s:0,c:1,f:2,pg:0,n:e||b,pr:0,m:0}):(o.s=parseFloat(m),n||(o.c=parseFloat(d)-o.s||0))),o.c?((o._next=this._firstPT)&&(o._next._prev=o),this._firstPT=o,o):void 0},P=G._internals={isArray:p,isSelector:H,lazyTweens:J,blobDif:N},Q=G._plugins={},R=P.tweenLookup={},S=0,T=P.reservedProps={ease:1,delay:1,overwrite:1,onComplete:1,onCompleteParams:1,onCompleteScope:1,useFrames:1,runBackwards:1,startAt:1,onUpdate:1,onUpdateParams:1,onUpdateScope:1,onStart:1,onStartParams:1,onStartScope:1,onReverseComplete:1,onReverseCompleteParams:1,onReverseCompleteScope:1,onRepeat:1,onRepeatParams:1,onRepeatScope:1,easeParams:1,yoyo:1,immediateRender:1,repeat:1,repeatDelay:1,data:1,paused:1,reversed:1,autoCSS:1,lazy:1,onOverwrite:1,callbackScope:1,stringFilter:1,id:1},U={none:0,all:1,auto:2,concurrent:3,allOnStart:4,preexisting:5,"true":1,"false":0},V=D._rootFramesTimeline=new F,W=D._rootTimeline=new F,X=30,Y=P.lazyRender=function(){var a,b=J.length;for(K={};--b>-1;)a=J[b],a&&a._lazy!==!1&&(a.render(a._lazy[0],a._lazy[1],!0),a._lazy=!1);J.length=0};W._startTime=i.time,V._startTime=i.frame,W._active=V._active=!0,setTimeout(Y,1),D._updateRoot=G.render=function(){var a,b,c;if(J.length&&Y(),W.render((i.time-W._startTime)*W._timeScale,!1,!1),V.render((i.frame-V._startTime)*V._timeScale,!1,!1),J.length&&Y(),i.frame>=X){X=i.frame+(parseInt(G.autoSleep,10)||120);for(c in R){for(b=R[c].tweens,a=b.length;--a>-1;)b[a]._gc&&b.splice(a,1);0===b.length&&delete R[c]}if(c=W._first,(!c||c._paused)&&G.autoSleep&&!V._first&&1===i._listeners.tick.length){for(;c&&c._paused;)c=c._next;c||i.sleep()}}},i.addEventListener("tick",D._updateRoot);var Z=function(a,b,c){var d,e,f=a._gsTweenID;if(R[f||(a._gsTweenID=f="t"+S++)]||(R[f]={target:a,tweens:[]}),b&&(d=R[f].tweens,d[e=d.length]=b,c))for(;--e>-1;)d[e]===b&&d.splice(e,1);return R[f].tweens},$=function(a,b,c,d){var e,f,g=a.vars.onOverwrite;return g&&(e=g(a,b,c,d)),g=G.onOverwrite,g&&(f=g(a,b,c,d)),e!==!1&&f!==!1},_=function(a,b,c,d,e){var f,g,h,i;if(1===d||d>=4){for(i=e.length,f=0;i>f;f++)if((h=e[f])!==b)h._gc||h._kill(null,a,b)&&(g=!0);else if(5===d)break;return g}var j,k=b._startTime+m,l=[],n=0,o=0===b._duration;for(f=e.length;--f>-1;)(h=e[f])===b||h._gc||h._paused||(h._timeline!==b._timeline?(j=j||aa(b,0,o),0===aa(h,j,o)&&(l[n++]=h)):h._startTime<=k&&h._startTime+h.totalDuration()/h._timeScale>k&&((o||!h._initted)&&k-h._startTime<=2e-10||(l[n++]=h)));for(f=n;--f>-1;)if(h=l[f],2===d&&h._kill(c,a,b)&&(g=!0),2!==d||!h._firstPT&&h._initted){if(2!==d&&!$(h,b))continue;h._enabled(!1,!1)&&(g=!0)}return g},aa=function(a,b,c){for(var d=a._timeline,e=d._timeScale,f=a._startTime;d._timeline;){if(f+=d._startTime,e*=d._timeScale,d._paused)return-100;d=d._timeline}return f/=e,f>b?f-b:c&&f===b||!a._initted&&2*m>f-b?m:(f+=a.totalDuration()/a._timeScale/e)>b+m?0:f-b-m};h._init=function(){var a,b,c,d,e,f,g=this.vars,h=this._overwrittenProps,i=this._duration,j=!!g.immediateRender,k=g.ease;if(g.startAt){this._startAt&&(this._startAt.render(-1,!0),this._startAt.kill()),e={};for(d in g.startAt)e[d]=g.startAt[d];if(e.overwrite=!1,e.immediateRender=!0,e.lazy=j&&g.lazy!==!1,e.startAt=e.delay=null,this._startAt=G.to(this.target,0,e),j)if(this._time>0)this._startAt=null;else if(0!==i)return}else if(g.runBackwards&&0!==i)if(this._startAt)this._startAt.render(-1,!0),this._startAt.kill(),this._startAt=null;else{0!==this._time&&(j=!1),c={};for(d in g)T[d]&&"autoCSS"!==d||(c[d]=g[d]);if(c.overwrite=0,c.data="isFromStart",c.lazy=j&&g.lazy!==!1,c.immediateRender=j,this._startAt=G.to(this.target,0,c),j){if(0===this._time)return}else this._startAt._init(),this._startAt._enabled(!1),this.vars.immediateRender&&(this._startAt=null)}if(this._ease=k=k?k instanceof v?k:"function"==typeof k?new v(k,g.easeParams):w[k]||G.defaultEase:G.defaultEase,g.easeParams instanceof Array&&k.config&&(this._ease=k.config.apply(k,g.easeParams)),this._easeType=this._ease._type,this._easePower=this._ease._power,this._firstPT=null,this._targets)for(f=this._targets.length,a=0;f>a;a++)this._initProps(this._targets[a],this._propLookup[a]={},this._siblings[a],h?h[a]:null,a)&&(b=!0);else b=this._initProps(this.target,this._propLookup,this._siblings,h,0);if(b&&G._onPluginEvent("_onInitAllProps",this),h&&(this._firstPT||"function"!=typeof this.target&&this._enabled(!1,!1)),g.runBackwards)for(c=this._firstPT;c;)c.s+=c.c,c.c=-c.c,c=c._next;this._onUpdate=g.onUpdate,this._initted=!0},h._initProps=function(b,c,d,e,f){var g,h,i,j,k,l;if(null==b)return!1;K[b._gsTweenID]&&Y(),this.vars.css||b.style&&b!==a&&b.nodeType&&Q.css&&this.vars.autoCSS!==!1&&I(this.vars,b);for(g in this.vars)if(l=this.vars[g],T[g])l&&(l instanceof Array||l.push&&p(l))&&-1!==l.join("").indexOf("{self}")&&(this.vars[g]=l=this._swapSelfInParams(l,this));else if(Q[g]&&(j=new Q[g])._onInitTween(b,this.vars[g],this,f)){for(this._firstPT=k={_next:this._firstPT,t:j,p:"setRatio",s:0,c:1,f:1,n:g,pg:1,pr:j._priority,m:0},h=j._overwriteProps.length;--h>-1;)c[j._overwriteProps[h]]=this._firstPT;(j._priority||j._onInitAllProps)&&(i=!0),(j._onDisable||j._onEnable)&&(this._notifyPluginsOfEnabled=!0),k._next&&(k._next._prev=k)}else c[g]=O.call(this,b,g,"get",l,g,0,null,this.vars.stringFilter,f);return e&&this._kill(e,b)?this._initProps(b,c,d,e,f):this._overwrite>1&&this._firstPT&&d.length>1&&_(b,this,c,this._overwrite,d)?(this._kill(c,b),this._initProps(b,c,d,e,f)):(this._firstPT&&(this.vars.lazy!==!1&&this._duration||this.vars.lazy&&!this._duration)&&(K[b._gsTweenID]=!0),i)},h.render=function(a,b,c){var d,e,f,g,h=this._time,i=this._duration,j=this._rawPrevTime;if(a>=i-1e-7&&a>=0)this._totalTime=this._time=i,this.ratio=this._ease._calcEnd?this._ease.getRatio(1):1,this._reversed||(d=!0,e="onComplete",c=c||this._timeline.autoRemoveChildren),0===i&&(this._initted||!this.vars.lazy||c)&&(this._startTime===this._timeline._duration&&(a=0),(0>j||0>=a&&a>=-1e-7||j===m&&"isPause"!==this.data)&&j!==a&&(c=!0,j>m&&(e="onReverseComplete")),this._rawPrevTime=g=!b||a||j===a?a:m);else if(1e-7>a)this._totalTime=this._time=0,this.ratio=this._ease._calcEnd?this._ease.getRatio(0):0,(0!==h||0===i&&j>0)&&(e="onReverseComplete",d=this._reversed),0>a&&(this._active=!1,0===i&&(this._initted||!this.vars.lazy||c)&&(j>=0&&(j!==m||"isPause"!==this.data)&&(c=!0),this._rawPrevTime=g=!b||a||j===a?a:m)),this._initted||(c=!0);else if(this._totalTime=this._time=a,this._easeType){var k=a/i,l=this._easeType,n=this._easePower;(1===l||3===l&&k>=.5)&&(k=1-k),3===l&&(k*=2),1===n?k*=k:2===n?k*=k*k:3===n?k*=k*k*k:4===n&&(k*=k*k*k*k),1===l?this.ratio=1-k:2===l?this.ratio=k:.5>a/i?this.ratio=k/2:this.ratio=1-k/2}else this.ratio=this._ease.getRatio(a/i);if(this._time!==h||c){if(!this._initted){if(this._init(),!this._initted||this._gc)return;if(!c&&this._firstPT&&(this.vars.lazy!==!1&&this._duration||this.vars.lazy&&!this._duration))return this._time=this._totalTime=h,this._rawPrevTime=j,J.push(this),void(this._lazy=[a,b]);this._time&&!d?this.ratio=this._ease.getRatio(this._time/i):d&&this._ease._calcEnd&&(this.ratio=this._ease.getRatio(0===this._time?0:1))}for(this._lazy!==!1&&(this._lazy=!1),this._active||!this._paused&&this._time!==h&&a>=0&&(this._active=!0),0===h&&(this._startAt&&(a>=0?this._startAt.render(a,b,c):e||(e="_dummyGS")),this.vars.onStart&&(0!==this._time||0===i)&&(b||this._callback("onStart"))),f=this._firstPT;f;)f.f?f.t[f.p](f.c*this.ratio+f.s):f.t[f.p]=f.c*this.ratio+f.s,f=f._next;this._onUpdate&&(0>a&&this._startAt&&a!==-1e-4&&this._startAt.render(a,b,c),b||(this._time!==h||d||c)&&this._callback("onUpdate")),e&&(!this._gc||c)&&(0>a&&this._startAt&&!this._onUpdate&&a!==-1e-4&&this._startAt.render(a,b,c),d&&(this._timeline.autoRemoveChildren&&this._enabled(!1,!1),this._active=!1),!b&&this.vars[e]&&this._callback(e),0===i&&this._rawPrevTime===m&&g!==m&&(this._rawPrevTime=0))}},h._kill=function(a,b,c){if("all"===a&&(a=null),null==a&&(null==b||b===this.target))return this._lazy=!1,this._enabled(!1,!1);b="string"!=typeof b?b||this._targets||this.target:G.selector(b)||b;var d,e,f,g,h,i,j,k,l,m=c&&this._time&&c._startTime===this._startTime&&this._timeline===c._timeline;if((p(b)||H(b))&&"number"!=typeof b[0])for(d=b.length;--d>-1;)this._kill(a,b[d],c)&&(i=!0);else{if(this._targets){for(d=this._targets.length;--d>-1;)if(b===this._targets[d]){h=this._propLookup[d]||{},this._overwrittenProps=this._overwrittenProps||[],e=this._overwrittenProps[d]=a?this._overwrittenProps[d]||{}:"all";break}}else{if(b!==this.target)return!1;h=this._propLookup,e=this._overwrittenProps=a?this._overwrittenProps||{}:"all"}if(h){if(j=a||h,k=a!==e&&"all"!==e&&a!==h&&("object"!=typeof a||!a._tempKill),c&&(G.onOverwrite||this.vars.onOverwrite)){for(f in j)h[f]&&(l||(l=[]),l.push(f));if((l||!a)&&!$(this,c,b,l))return!1}for(f in j)(g=h[f])&&(m&&(g.f?g.t[g.p](g.s):g.t[g.p]=g.s,i=!0),g.pg&&g.t._kill(j)&&(i=!0),g.pg&&0!==g.t._overwriteProps.length||(g._prev?g._prev._next=g._next:g===this._firstPT&&(this._firstPT=g._next),g._next&&(g._next._prev=g._prev),g._next=g._prev=null),delete h[f]),k&&(e[f]=1);!this._firstPT&&this._initted&&this._enabled(!1,!1)}}return i},h.invalidate=function(){return this._notifyPluginsOfEnabled&&G._onPluginEvent("_onDisable",this),this._firstPT=this._overwrittenProps=this._startAt=this._onUpdate=null,this._notifyPluginsOfEnabled=this._active=this._lazy=!1,this._propLookup=this._targets?{}:[],D.prototype.invalidate.call(this),this.vars.immediateRender&&(this._time=-m,this.render(Math.min(0,-this._delay))),this},h._enabled=function(a,b){if(j||i.wake(),a&&this._gc){var c,d=this._targets;if(d)for(c=d.length;--c>-1;)this._siblings[c]=Z(d[c],this,!0);else this._siblings=Z(this.target,this,!0)}return D.prototype._enabled.call(this,a,b),this._notifyPluginsOfEnabled&&this._firstPT?G._onPluginEvent(a?"_onEnable":"_onDisable",this):!1},G.to=function(a,b,c){return new G(a,b,c)},G.from=function(a,b,c){return c.runBackwards=!0,c.immediateRender=0!=c.immediateRender,new G(a,b,c)},G.fromTo=function(a,b,c,d){return d.startAt=c,d.immediateRender=0!=d.immediateRender&&0!=c.immediateRender,new G(a,b,d)},G.delayedCall=function(a,b,c,d,e){return new G(b,0,{delay:a,onComplete:b,onCompleteParams:c,callbackScope:d,onReverseComplete:b,onReverseCompleteParams:c,immediateRender:!1,lazy:!1,useFrames:e,overwrite:0})},G.set=function(a,b){return new G(a,0,b)},G.getTweensOf=function(a,b){if(null==a)return[];a="string"!=typeof a?a:G.selector(a)||a;var c,d,e,f;if((p(a)||H(a))&&"number"!=typeof a[0]){for(c=a.length,d=[];--c>-1;)d=d.concat(G.getTweensOf(a[c],b));for(c=d.length;--c>-1;)for(f=d[c],e=c;--e>-1;)f===d[e]&&d.splice(c,1)}else for(d=Z(a).concat(),c=d.length;--c>-1;)(d[c]._gc||b&&!d[c].isActive())&&d.splice(c,1);return d},G.killTweensOf=G.killDelayedCallsTo=function(a,b,c){"object"==typeof b&&(c=b,b=!1);for(var d=G.getTweensOf(a,b),e=d.length;--e>-1;)d[e]._kill(c,a)};var ba=t("plugins.TweenPlugin",function(a,b){this._overwriteProps=(a||"").split(","),this._propName=this._overwriteProps[0],this._priority=b||0,this._super=ba.prototype},!0);if(h=ba.prototype,ba.version="1.19.0",ba.API=2,h._firstPT=null,h._addTween=O,h.setRatio=M,h._kill=function(a){var b,c=this._overwriteProps,d=this._firstPT;if(null!=a[this._propName])this._overwriteProps=[];else for(b=c.length;--b>-1;)null!=a[c[b]]&&c.splice(b,1);for(;d;)null!=a[d.n]&&(d._next&&(d._next._prev=d._prev),d._prev?(d._prev._next=d._next,d._prev=null):this._firstPT===d&&(this._firstPT=d._next)),d=d._next;return!1},h._mod=h._roundProps=function(a){for(var b,c=this._firstPT;c;)b=a[this._propName]||null!=c.n&&a[c.n.split(this._propName+"_").join("")],b&&"function"==typeof b&&(2===c.f?c.t._applyPT.m=b:c.m=b),c=c._next},G._onPluginEvent=function(a,b){var c,d,e,f,g,h=b._firstPT;if("_onInitAllProps"===a){for(;h;){for(g=h._next,d=e;d&&d.pr>h.pr;)d=d._next;(h._prev=d?d._prev:f)?h._prev._next=h:e=h,(h._next=d)?d._prev=h:f=h,h=g}h=b._firstPT=e}for(;h;)h.pg&&"function"==typeof h.t[a]&&h.t[a]()&&(c=!0),h=h._next;return c},ba.activate=function(a){for(var b=a.length;--b>-1;)a[b].API===ba.API&&(Q[(new a[b])._propName]=a[b]);return!0},s.plugin=function(a){if(!(a&&a.propName&&a.init&&a.API))throw"illegal plugin definition.";var b,c=a.propName,d=a.priority||0,e=a.overwriteProps,f={init:"_onInitTween",set:"setRatio",kill:"_kill",round:"_mod",mod:"_mod",initAll:"_onInitAllProps"},g=t("plugins."+c.charAt(0).toUpperCase()+c.substr(1)+"Plugin",function(){ba.call(this,c,d),this._overwriteProps=e||[]},a.global===!0),h=g.prototype=new ba(c);h.constructor=g,g.API=a.API;for(b in f)"function"==typeof a[b]&&(h[f[b]]=a[b]);return g.version=a.version,ba.activate([g]),g},f=a._gsQueue){for(g=0;g<f.length;g++)f[g]();for(h in q)q[h].func||a.console.log("GSAP encountered missing dependency: "+h)}j=!1}}("undefined"!=typeof module&&module.exports&&"undefined"!=typeof global?global:this||window,"TweenMax");

(function() {
  var GLOBAL = typeof window !== "undefined" ? window :
      typeof global!=="undefined" ? global :
        typeof self!=="undefined" ? self : this;
  var roots;
  (function (exports) {
'use strict';

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var Point2D_1 = createCommonjsModule(function (module) {
/**
 *
 *   Point2D.js
 *
 *   copyright 2001-2002, 2013 Kevin Lindsey
 *
 */

/**
 *  Point2D
 *
 *  @param {Number} x
 *  @param {Number} y
 *  @returns {Point2D}
 */
function Point2D(x, y) {
    Object.defineProperties(this, {
        "x": {
            value: x,
            writable: false,
            enumerable: true,
            configurable: false
        },
        "y": {
            value: y,
            writable: false,
            enumerable: true,
            configurable: false
        }
    });
    // this.x = x;
    // this.y = y;
}

/**
 *  clone
 *
 *  @returns {Point2D}
 */
Point2D.prototype.clone = function() {
    return new Point2D(this.x, this.y);
};

/**
 *  add
 *
 *  @param {Point2D|Vector2D} that
 *  @returns {Point2D}
 */
Point2D.prototype.add = function(that) {
    return new Point2D(this.x+that.x, this.y+that.y);
};

/**
 *  subtract
 *
 *  @param { Vector2D | Point2D } that
 *  @returns {Point2D}
 */
Point2D.prototype.subtract = function(that) {
    return new Point2D(this.x-that.x, this.y-that.y);
};

/**
 *  multiply
 *
 *  @param {Number} scalar
 *  @returns {Point2D}
 */
Point2D.prototype.multiply = function(scalar) {
    return new Point2D(this.x*scalar, this.y*scalar);
};

/**
 *  divide
 *
 *  @param {Number} scalar
 *  @returns {Point2D}
 */
Point2D.prototype.divide = function(scalar) {
    return new Point2D(this.x/scalar, this.y/scalar);
};

/**
 *  equals
 *
 *  @param {Point2D} that
 *  @returns {Boolean}
 */
Point2D.prototype.equals = function(that) {
    return ( this.x == that.x && this.y == that.y );
};

// utility methods

/**
 *  lerp
 *
 *  @param { Vector2D | Point2D } that
 *  @param {Number} t
 @  @returns {Point2D}
 */
Point2D.prototype.lerp = function(that, t) {
    var omt = 1.0 - t;

    return new Point2D(
        this.x * omt + that.x * t,
        this.y * omt + that.y * t
    );
};

/**
 *  distanceFrom
 *
 *  @param {Point2D} that
 *  @returns {Number}
 */
Point2D.prototype.distanceFrom = function(that) {
    var dx = this.x - that.x;
    var dy = this.y - that.y;

    return Math.sqrt(dx*dx + dy*dy);
};

/**
 *  min
 *
 *  @param {Point2D} that
 *  @returns {Number}
 */
Point2D.prototype.min = function(that) {
    return new Point2D(
        Math.min( this.x, that.x ),
        Math.min( this.y, that.y )
    );
};

/**
 *  max
 *
 *  @param {Point2D} that
 *  @returns {Number}
 */
Point2D.prototype.max = function(that) {
    return new Point2D(
        Math.max( this.x, that.x ),
        Math.max( this.y, that.y )
    );
};

/**
 *  transform
 *
 *  @param {Matrix2D}
 *  @result {Point2D}
 */
Point2D.prototype.transform = function(matrix) {
    return new Point2D(
        matrix.a * this.x + matrix.c * this.y + matrix.e,
        matrix.b * this.x + matrix.d * this.y + matrix.f
    );
};

/**
 *  toString
 *
 *  @returns {String}
 */
Point2D.prototype.toString = function() {
    return "point(" + this.x + "," + this.y + ")";
};

{
    module.exports = Point2D;
}
});

var Vector2D_1 = createCommonjsModule(function (module) {
/**
 *
 *   Vector2D.js
 *
 *   copyright 2001-2002, 2013 Kevin Lindsey
 *
 */

/**
 *  Vector2D
 *
 *  @param {Number} x
 *  @param {Number} y
 *  @returns {Vector2D}
 */
function Vector2D(x, y) {
    Object.defineProperties(this, {
        "x": {
            value: x,
            writable: false,
            enumerable: true,
            configurable: false
        },
        "y": {
            value: y,
            writable: false,
            enumerable: true,
            configurable: false
        }
    });
    // this.x = x;
    // this.y = y;
}

/**
 *  fromPoints
 *
 *  @param {Point2D} p1
 *  @param {Point2D} p2
 *  @returns {Vector2D}
 */
Vector2D.fromPoints = function(p1, p2) {
    return new Vector2D(
        p2.x - p1.x,
        p2.y - p1.y
    );
};

/**
 *  length
 *
 *  @returns {Number}
 */
Vector2D.prototype.length = function() {
    return Math.sqrt(this.x*this.x + this.y*this.y);
};

/**
 *  magnitude
 *
 *  @returns {Number}
 */
Vector2D.prototype.magnitude = function() {
    return this.x*this.x + this.y*this.y;
};

/**
 *  dot
 *
 *  @param {Vector2D} that
 *  @returns {Number}
 */
Vector2D.prototype.dot = function(that) {
    return this.x*that.x + this.y*that.y;
};

/**
 *  cross
 *
 *  @param {Vector2D} that
 *  @returns {Number}
 */
Vector2D.prototype.cross = function(that) {
    return this.x*that.y - this.y*that.x;
};

/**
 *  determinant
 *
 *  @param {Vector2D} that
 *  @returns {Number}
 */
Vector2D.prototype.determinant = function(that) {
    return this.x*that.y - this.y*that.x;
};

/**
 *  unit
 *
 *  @returns {Vector2D}
 */
Vector2D.prototype.unit = function() {
    return this.divide( this.length() );
};

/**
 *  add
 *
 *  @param {Vector2D} that
 *  @returns {Vector2D}
 */
Vector2D.prototype.add = function(that) {
    return new Vector2D(this.x + that.x, this.y + that.y);
};

/**
 *  subtract
 *
 *  @param {Vector2D} that
 *  @returns {Vector2D}
 */
Vector2D.prototype.subtract = function(that) {
    return new Vector2D(this.x - that.x, this.y - that.y);
};

/**
 *  multiply
 *
 *  @param {Number} scalar
 *  @returns {Vector2D}
 */
Vector2D.prototype.multiply = function(scalar) {
    return new Vector2D(this.x * scalar, this.y * scalar);
};

/**
 *  divide
 *
 *  @param {Number} scalar
 *  @returns {Vector2D}
 */
Vector2D.prototype.divide = function(scalar) {
    return new Vector2D(this.x / scalar, this.y / scalar);
};

/**
 *  angleBetween
 *
 *  @param {Vector2D} that
 *  @returns {Number}
 */
Vector2D.prototype.angleBetween = function(that) {
    var cos = this.dot(that) / (this.length() * that.length());
    if (cos < -1) {
        cos = -1;
    }
    else if (cos > 1) {
        cos = 1;
    }
    var radians = Math.acos(cos);

    return (this.cross(that) < 0.0) ? -radians : radians;
};

/**
 *  Find a vector is that is perpendicular to this vector
 *
 *  @returns {Vector2D}
 */
Vector2D.prototype.perp = function() {
    return new Vector2D(-this.y, this.x);
};

/**
 *  Find the component of the specified vector that is perpendicular to
 *  this vector
 *
 *  @param {Vector2D} that
 *  @returns {Vector2D}
 */
Vector2D.prototype.perpendicular = function(that) {
    return this.subtract(this.project(that));
};

/**
 *  project
 *
 *  @param {Vector2D} that
 *  @returns {Vector2D}
 */
Vector2D.prototype.project = function(that) {
    var percent = this.dot(that) / that.dot(that);

    return that.multiply(percent);
};

/**
 *  transform
 *
 *  @param {Matrix2D}
 *  @returns {Vector2D}
 */
Vector2D.prototype.transform = function(matrix) {
    return new Vector2D(
        matrix.a * this.x + matrix.c * this.y,
        matrix.b * this.x + matrix.d * this.y
    );
};

/**
 *  equals
 *
 *  @param {Vector2D} that
 *  @returns {Boolean}
 */
Vector2D.prototype.equals = function(that) {
    return (
        this.x === that.x &&
        this.y === that.y
    );
};

/**
 *  toString
 *
 *  @returns {String}
 */
Vector2D.prototype.toString = function() {
    return "vector(" + this.x + "," + this.y + ")";
};

{
    module.exports = Vector2D;
}
});

var Matrix2D_1 = createCommonjsModule(function (module) {
/**
 *
 *   Matrix2D.js
 *
 *   copyright 2001-2002, 2013 Kevin Lindsey
 *
 */

/**
 *  Matrix2D
 *
 *  @param {Number} a
 *  @param {Number} b
 *  @param {Number} c
 *  @param {Number} d
 *  @param {Number} e
 *  @param {Number} f
 *  @returns {Matrix2D}
 */
function Matrix2D(a, b, c, d, e, f) {
    Object.defineProperties(this, {
        "a": {
            value: (a !== undefined) ? a : 1,
            writable: false,
            enumerable: true,
            configurable: false
        },
        "b": {
            value: (b !== undefined) ? b : 0,
            writable: false,
            enumerable: true,
            configurable: false
        },
        "c": {
            value: (c !== undefined) ? c : 0,
            writable: false,
            enumerable: true,
            configurable: false
        },
        "d": {
            value: (d !== undefined) ? d : 1,
            writable: false,
            enumerable: true,
            configurable: false
        },
        "e": {
            value: (e !== undefined) ? e : 0,
            writable: false,
            enumerable: true,
            configurable: false
        },
        "f": {
            value: (f !== undefined) ? f : 0,
            writable: false,
            enumerable: true,
            configurable: false
        }
    });
    // this.a = (a !== undefined) ? a : 1;
    // this.b = (b !== undefined) ? b : 0;
    // this.c = (c !== undefined) ? c : 0;
    // this.d = (d !== undefined) ? d : 1;
    // this.e = (e !== undefined) ? e : 0;
    // this.f = (f !== undefined) ? f : 0;
}

/**
 *  Identity matrix
 *
 *  @returns {Matrix2D}
 */
Matrix2D.IDENTITY = new Matrix2D(1, 0, 0, 1, 0, 0);

// TODO: rotate, skew, etc. matrices as well?

/**
 *  multiply
 *
 *  @pararm {Matrix2D} that
 *  @returns {Matrix2D}
 */
Matrix2D.prototype.multiply = function(that) {
    return new Matrix2D(
        this.a * that.a + this.c * that.b,
        this.b * that.a + this.d * that.b,
        this.a * that.c + this.c * that.d,
        this.b * that.c + this.d * that.d,
        this.a * that.e + this.c * that.f + this.e,
        this.b * that.e + this.d * that.f + this.f
    );
};

/**
 *  inverse
 *
 *  @returns {Matrix2D}
 */
Matrix2D.prototype.inverse = function() {
    var det1 = this.a * this.d - this.b * this.c;

    if ( det1 == 0.0 )
        throw("Matrix is not invertible");

    var idet = 1.0 / det1;
    var det2 = this.f * this.c - this.e * this.d;
    var det3 = this.e * this.b - this.f * this.a;

    return new Matrix2D(
        this.d * idet,
       -this.b * idet,
       -this.c * idet,
        this.a * idet,
          det2 * idet,
          det3 * idet
    );
};

/**
 *  translate
 *
 *  @param {Number} tx
 *  @param {Number} ty
 *  @returns {Matrix2D}
 */
Matrix2D.prototype.translate = function(tx, ty) {
    return new Matrix2D(
        this.a,
        this.b,
        this.c,
        this.d,
        this.a * tx + this.c * ty + this.e,
        this.b * tx + this.d * ty + this.f
    );
};

/**
 *  scale
 *
 *  @param {Number} scale
 *  @returns {Matrix2D}
 */
Matrix2D.prototype.scale = function(scale) {
    return new Matrix2D(
        this.a * scale,
        this.b * scale,
        this.c * scale,
        this.d * scale,
        this.e,
        this.f
    );
};

/**
 *  scaleAt
 *
 *  @param {Number} scale
 *  @param {Point2D} center
 *  @returns {Matrix2D}
 */
Matrix2D.prototype.scaleAt = function(scale, center) {
    var dx = center.x - scale * center.x;
    var dy = center.y - scale * center.y;

    return new Matrix2D(
        this.a * scale,
        this.b * scale,
        this.c * scale,
        this.d * scale,
        this.a * dx + this.c * dy + this.e,
        this.b * dx + this.d * dy + this.f
    );
};

/**
 *  scaleNonUniform
 *
 *  @param {Number} scaleX
 *  @param {Number} scaleY
 *  @returns {Matrix2D}
 */
Matrix2D.prototype.scaleNonUniform = function(scaleX, scaleY) {
    return new Matrix2D(
        this.a * scaleX,
        this.b * scaleX,
        this.c * scaleY,
        this.d * scaleY,
        this.e,
        this.f
    );
};

/**
 *  scaleNonUniformAt
 *
 *  @param {Number} scaleX
 *  @param {Number} scaleY
 *  @param {Point2D} center
 *  @returns {Matrix2D}
 */
Matrix2D.prototype.scaleNonUniformAt = function(scaleX, scaleY, center) {
    var dx = center.x - scaleX * center.x;
    var dy = center.y - scaleY * center.y;

    return new Matrix2D(
        this.a * scaleX,
        this.b * scaleX,
        this.c * scaleY,
        this.d * scaleY,
        this.a * dx + this.c * dy + this.e,
        this.b * dx + this.d * dy + this.f
    );
};

/**
 *  rotate
 *
 *  @param {Number} radians
 *  @returns {Matrix2D}
 */
Matrix2D.prototype.rotate = function(radians) {
    var c = Math.cos(radians);
    var s = Math.sin(radians);

    return new Matrix2D(
        this.a *  c + this.c * s,
        this.b *  c + this.d * s,
        this.a * -s + this.c * c,
        this.b * -s + this.d * c,
        this.e,
        this.f
    );
};

/**
 *  rotateAt
 *
 *  @param {Number} radians
 *  @param {Point2D} center
 *  @result {Matrix2D}
 */
Matrix2D.prototype.rotateAt = function(radians, center) {
    var c = Math.cos(radians);
    var s = Math.sin(radians);
    var t1 = -center.x + center.x * c - center.y * s;
    var t2 = -center.y + center.y * c + center.x * s;

    return new Matrix2D(
        this.a *  c + this.c * s,
        this.b *  c + this.d * s,
        this.a * -s + this.c * c,
        this.b * -s + this.d * c,
        this.a * t1 + this.c * t2 + this.e,
        this.b * t1 + this.d * t2 + this.f
    );
};

/**
 *  rotateFromVector
 *
 *  @param {Vector2D}
 *  @returns {Matrix2D}
 */
Matrix2D.prototype.rotateFromVector = function(vector) {
    var unit = vector.unit();
    var c = unit.x; // cos
    var s = unit.y; // sin

    return new Matrix2D(
        this.a *  c + this.c * s,
        this.b *  c + this.d * s,
        this.a * -s + this.c * c,
        this.b * -s + this.d * c,
        this.e,
        this.f
    );
};

/**
 *  flipX
 *
 *  @returns {Matrix2D}
 */
Matrix2D.prototype.flipX = function() {
    return new Matrix2D(
        -this.a,
        -this.b,
         this.c,
         this.d,
         this.e,
         this.f
    );
};

/**
 *  flipY
 *
 *  @returns {Matrix2D}
 */
Matrix2D.prototype.flipY = function() {
    return new Matrix2D(
         this.a,
         this.b,
        -this.c,
        -this.d,
         this.e,
         this.f
    );
};

/**
 *  skewX
 *
 *  @pararm {Number} radians
 *  @returns {Matrix2D}
 */
Matrix2D.prototype.skewX = function(radians) {
    var t = Math.tan(radians);

    return new Matrix2D(
        this.a,
        this.b,
        this.a * t + this.c,
        this.b * t + this.d,
        this.e,
        this.f
    );
};

// TODO: skewXAt

/**
 *  skewY
 *
 *  @pararm {Number} radians
 *  @returns {Matrix2D}
 */
Matrix2D.prototype.skewY = function(radians) {
    var t = Math.tan(angle);

    return matrix_new(
        this.a + this.c * t,
        this.b + this.d * t,
        this.c,
        this.d,
        this.e,
        this.f
    );
};

// TODO: skewYAt

/**
 *  isIdentity
 *
 *  @returns {Boolean}
 */
Matrix2D.prototype.isIdentity = function() {
    return (
        this.a === 1.0 &&
        this.b === 0.0 &&
        this.c === 0.0 &&
        this.d === 1.0 &&
        this.e === 0.0 &&
        this.f === 0.0
    );
};

/**
 *  isInvertible
 *
 *  @returns {Boolean}
 */
Matrix2D.prototype.isInvertible = function() {
    this.a * this.d - this.b * this.c !== 0.0;
};

/**
 *  getScale
 *
 *  @returns {scaleX: Number, scaleY: Number}
 */
Matrix2D.prototype.getScale = function() {
    return {
        scaleX: Math.sqrt(this.a * this.a + this.c * this.c),
        scaleY: Math.sqrt(this.b * this.b + this.d * this.d)
    };
};

/**
 *  equals
 *
 *  @param {Matrix2D} that
 *  @returns {Boolean}
 */
Matrix2D.prototype.equals = function(that) {
    return (
        this.a === that.a &&
        this.b === that.b &&
        this.c === that.c &&
        this.d === that.d &&
        this.e === that.e &&
        this.f === that.f
    );
};

/**
 *  toString
 *
 *  @returns {String}
 */
Matrix2D.prototype.toString = function() {
    return (
        "matrix(" +
        this.a + "," +
        this.b + "," +
        this.c + "," +
        this.d + "," +
        this.e + "," +
        this.f + ")"
    );
};

{
    module.exports = Matrix2D;
}
});

// expose classes

var Point2D = Point2D_1;
var Vector2D = Vector2D_1;
var Matrix2D = Matrix2D_1;

var index = {
	Point2D: Point2D,
	Vector2D: Vector2D,
	Matrix2D: Matrix2D
};

exports['default'] = index;
exports.Point2D = Point2D;
exports.Vector2D = Vector2D;
exports.Matrix2D = Matrix2D;

}((this.kldAffine = this.kldAffine || {})));

  (function (exports) {
'use strict';

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var Polynomial_1 = createCommonjsModule(function (module) {
/**
 *
 *   Polynomial.js
 *
 *   copyright 2002, 2013 Kevin Lindsey
 * 
 *   contribution {@link http://github.com/Quazistax/kld-polynomial}
 *       @copyright 2015 Robert Benko (Quazistax) <quazistax@gmail.com>
 *       @license MIT
 */

Polynomial.TOLERANCE = 1e-6;
Polynomial.ACCURACY  = 15;


/**
 *  interpolate
 *
 *  @param {Array<Number>} xs
 *  @param {Array<Number>} ys
 *  @param {Number} n
 *  @param {Number} offset
 *  @param {Number} x
 *
 *  @returns {y:Number, dy:Number}
 */
Polynomial.interpolate = function(xs, ys, n, offset, x) {
    if ( xs.constructor !== Array || ys.constructor !== Array )
        throw new Error("Polynomial.interpolate: xs and ys must be arrays");
    if ( isNaN(n) || isNaN(offset) || isNaN(x) )
        throw new Error("Polynomial.interpolate: n, offset, and x must be numbers");

    var y  = 0;
    var dy = 0;
    var c = new Array(n);
    var d = new Array(n);
    var ns = 0;
    var result;

    var diff = Math.abs(x - xs[offset]);
    for ( var i = 0; i < n; i++ ) {
        var dift = Math.abs(x - xs[offset+i]);

        if ( dift < diff ) {
            ns = i;
            diff = dift;
        }
        c[i] = d[i] = ys[offset+i];
    }
    y = ys[offset+ns];
    ns--;

    for ( var m = 1; m < n; m++ ) {
        for ( var i = 0; i < n-m; i++ ) {
            var ho = xs[offset+i] - x;
            var hp = xs[offset+i+m] - x;
            var w = c[i+1]-d[i];
            var den = ho - hp;

            if ( den == 0.0 ) {
                result = { y: 0, dy: 0};
                break;
            }

            den = w / den;
            d[i] = hp*den;
            c[i] = ho*den;
        }
        dy = (2*(ns+1) < (n-m)) ? c[ns+1] : d[ns--];
        y += dy;
    }

    return { y: y, dy: dy };
};


/**
 *  Polynomial
 *
 *  @returns {Polynomial}
 */
function Polynomial() {
    this.init( arguments );
}


/**
 *  init
 */
Polynomial.prototype.init = function(coefs) {
    this.coefs = new Array();

    for ( var i = coefs.length - 1; i >= 0; i-- )
        this.coefs.push( coefs[i] );

    this._variable = "t";
    this._s = 0;
};


/**
 *  eval
 */
Polynomial.prototype.eval = function(x) {
    if ( isNaN(x) )
        throw new Error("Polynomial.eval: parameter must be a number");

    var result = 0;

    for ( var i = this.coefs.length - 1; i >= 0; i-- )
        result = result * x + this.coefs[i];

    return result;
};


/**
 *  add
 */
Polynomial.prototype.add = function(that) {
    var result = new Polynomial();
    var d1 = this.getDegree();
    var d2 = that.getDegree();
    var dmax = Math.max(d1,d2);

    for ( var i = 0; i <= dmax; i++ ) {
        var v1 = (i <= d1) ? this.coefs[i] : 0;
        var v2 = (i <= d2) ? that.coefs[i] : 0;

        result.coefs[i] = v1 + v2;
    }

    return result;
};


/**
 *  multiply
 */
Polynomial.prototype.multiply = function(that) {
    var result = new Polynomial();

    for ( var i = 0; i <= this.getDegree() + that.getDegree(); i++ )
        result.coefs.push(0);

    for ( var i = 0; i <= this.getDegree(); i++ )
        for ( var j = 0; j <= that.getDegree(); j++ )
            result.coefs[i+j] += this.coefs[i] * that.coefs[j];

    return result;
};


/**
 *  divide_scalar
 */
Polynomial.prototype.divide_scalar = function(scalar) {
    for ( var i = 0; i < this.coefs.length; i++ )
        this.coefs[i] /= scalar;
};


/**
 *  simplify
 */
Polynomial.prototype.simplify = function() {
    var TOLERANCE = 1e-15;
    for ( var i = this.getDegree(); i >= 0; i-- ) {
        if ( Math.abs( this.coefs[i] ) <= TOLERANCE )
            this.coefs.pop();
        else
            break;
    }
};


/**
 *  bisection
 */
Polynomial.prototype.bisection = function(min, max) {
    var minValue = this.eval(min);
    var maxValue = this.eval(max);
    var result;

    if ( Math.abs(minValue) <= Polynomial.TOLERANCE )
        result = min;
    else if ( Math.abs(maxValue) <= Polynomial.TOLERANCE )
        result = max;
    else if ( minValue * maxValue <= 0 ) {
        var tmp1  = Math.log(max - min);
        var tmp2  = Math.LN10 * Polynomial.ACCURACY;
        var iters = Math.ceil( (tmp1+tmp2) / Math.LN2 );

        for ( var i = 0; i < iters; i++ ) {
            result = 0.5 * (min + max);
            var value = this.eval(result);

            if ( Math.abs(value) <= Polynomial.TOLERANCE ) {
                break;
            }

            if ( value * minValue < 0 ) {
                max = result;
                maxValue = value;
            } else {
                min = result;
                minValue = value;
            }
        }
    }

    return result;
};


/**
 *  toString
 */
Polynomial.prototype.toString = function() {
    var coefs = new Array();
    var signs = new Array();

    for ( var i = this.coefs.length - 1; i >= 0; i-- ) {
        var value = Math.round(this.coefs[i]*1000)/1000;
        //var value = this.coefs[i];

        if ( value != 0 ) {
            var sign = ( value < 0 ) ? " - " : " + ";

            value = Math.abs(value);
            if ( i > 0 )
                if ( value == 1 )
                    value = this._variable;
                else
                    value += this._variable;
            if ( i > 1 ) value += "^" + i;

            signs.push( sign );
            coefs.push( value );
        }
    }

    signs[0] = ( signs[0] == " + " ) ? "" : "-";

    var result = "";
    for ( var i = 0; i < coefs.length; i++ )
        result += signs[i] + coefs[i];

    return result;
};


/**
 *  trapezoid
 *  Based on trapzd in "Numerical Recipes in C", page 137
 */
Polynomial.prototype.trapezoid = function(min, max, n) {
    if ( isNaN(min) || isNaN(max) || isNaN(n) )
        throw new Error("Polynomial.trapezoid: parameters must be numbers");

    var range = max - min;
    var TOLERANCE = 1e-7;

    if ( n == 1 ) {
        var minValue = this.eval(min);
        var maxValue = this.eval(max);
        this._s = 0.5*range*( minValue + maxValue );
    } else {
        var it = 1 << (n-2);
        var delta = range / it;
        var x = min + 0.5*delta;
        var sum = 0;

        for ( var i = 0; i < it; i++ ) {
            sum += this.eval(x);
            x += delta;
        }
        this._s = 0.5*(this._s + range*sum/it);
    }

    if ( isNaN(this._s) )
        throw new Error("Polynomial.trapezoid: this._s is NaN");

    return this._s;
};


/**
 *  simpson
 *  Based on trapzd in "Numerical Recipes in C", page 139
 */
Polynomial.prototype.simpson = function(min, max) {
    if ( isNaN(min) || isNaN(max) )
        throw new Error("Polynomial.simpson: parameters must be numbers");

    var range = max - min;
    var st = 0.5 * range * ( this.eval(min) + this.eval(max) );
    var t = st;
    var s = 4.0*st/3.0;
    var os = s;
    var ost = st;
    var TOLERANCE = 1e-7;

    var it = 1;
    for ( var n = 2; n <= 20; n++ ) {
        var delta = range / it;
        var x     = min + 0.5*delta;
        var sum   = 0;

        for ( var i = 1; i <= it; i++ ) {
            sum += this.eval(x);
            x += delta;
        }

        t = 0.5 * (t + range * sum / it);
        st = t;
        s = (4.0*st - ost)/3.0;

        if ( Math.abs(s-os) < TOLERANCE*Math.abs(os) )
            break;

        os = s;
        ost = st;
        it <<= 1;
    }

    return s;
};


/**
 *  romberg
 */
Polynomial.prototype.romberg = function(min, max) {
    if ( isNaN(min) || isNaN(max) )
        throw new Error("Polynomial.romberg: parameters must be numbers");

    var MAX = 20;
    var K = 3;
    var TOLERANCE = 1e-6;
    var s = new Array(MAX+1);
    var h = new Array(MAX+1);
    var result = { y: 0, dy: 0 };

    h[0] = 1.0;
    for ( var j = 1; j <= MAX; j++ ) {
        s[j-1] = this.trapezoid(min, max, j);
        if ( j >= K ) {
            result = Polynomial.interpolate(h, s, K, j-K, 0.0);
            if ( Math.abs(result.dy) <= TOLERANCE*result.y) break;
        }
        s[j] = s[j-1];
        h[j] = 0.25 * h[j-1];
    }

    return result.y;
};

// getters and setters

/**
 *  get degree
 */
Polynomial.prototype.getDegree = function() {
    return this.coefs.length - 1;
};


/**
 *  getDerivative
 */
Polynomial.prototype.getDerivative = function() {
    var derivative = new Polynomial();

    for ( var i = 1; i < this.coefs.length; i++ ) {
        derivative.coefs.push(i*this.coefs[i]);
    }

    return derivative;
};


/**
 *  getRoots
 */
Polynomial.prototype.getRoots = function() {
    var result;

    this.simplify();
    switch ( this.getDegree() ) {
        case 0: result = new Array();              break;
        case 1: result = this.getLinearRoot();     break;
        case 2: result = this.getQuadraticRoots(); break;
        case 3: result = this.getCubicRoots();     break;
        case 4: result = this.getQuarticRoots();   break;
        default:
            result = new Array();
            // should try Newton's method and/or bisection
    }

    return result;
};


/**
 *  getRootsInInterval
 */
Polynomial.prototype.getRootsInInterval = function(min, max) {
    var roots = new Array();
    var root;

    if ( this.getDegree() == 1 ) {
        root = this.bisection(min, max);
        if ( root != null ) roots.push(root);
    } else {
        // get roots of derivative
        var deriv  = this.getDerivative();
        var droots = deriv.getRootsInInterval(min, max);

        if ( droots.length > 0 ) {
            // find root on [min, droots[0]]
            root = this.bisection(min, droots[0]);
            if ( root != null ) roots.push(root);

            // find root on [droots[i],droots[i+1]] for 0 <= i <= count-2
            for ( i = 0; i <= droots.length-2; i++ ) {
                root = this.bisection(droots[i], droots[i+1]);
                if ( root != null ) roots.push(root);
            }

            // find root on [droots[count-1],xmax]
            root = this.bisection(droots[droots.length-1], max);
            if ( root != null ) roots.push(root);
        } else {
            // polynomial is monotone on [min,max], has at most one root
            root = this.bisection(min, max);
            if ( root != null ) roots.push(root);
        }
    }

    return roots;
};


/**
 *  getLinearRoot
 */
Polynomial.prototype.getLinearRoot = function() {
    var result = new Array();
    var a = this.coefs[1];

    if ( a != 0 )
        result.push( -this.coefs[0] / a );

    return result;
};


/**
 *  getQuadraticRoots
 */
Polynomial.prototype.getQuadraticRoots = function() {
    var results = new Array();

    if ( this.getDegree() == 2 ) {
        var a = this.coefs[2];
        var b = this.coefs[1] / a;
        var c = this.coefs[0] / a;
        var d = b*b - 4*c;

        if ( d > 0 ) {
            var e = Math.sqrt(d);

            results.push( 0.5 * (-b + e) );
            results.push( 0.5 * (-b - e) );
        } else if ( d == 0 ) {
            // really two roots with same value, but we only return one
            results.push( 0.5 * -b );
        }
    }

    return results;
};


/**
 *  getCubicRoots
 *
 *  This code is based on MgcPolynomial.cpp written by David Eberly.  His
 *  code along with many other excellent examples are avaiable at his site:
 *  http://www.geometrictools.com
 */
Polynomial.prototype.getCubicRoots = function() {
    var results = new Array();

    if ( this.getDegree() == 3 ) {
        var c3 = this.coefs[3];
        var c2 = this.coefs[2] / c3;
        var c1 = this.coefs[1] / c3;
        var c0 = this.coefs[0] / c3;

        var a       = (3*c1 - c2*c2) / 3;
        var b       = (2*c2*c2*c2 - 9*c1*c2 + 27*c0) / 27;
        var offset  = c2 / 3;
        var discrim = b*b/4 + a*a*a/27;
        var halfB   = b / 2;

        var ZEROepsilon = this.zeroErrorEstimate();
        if (Math.abs(discrim) <= ZEROepsilon) discrim = 0;

        if ( discrim > 0 ) {
            var e = Math.sqrt(discrim);
            var tmp;
            var root;

            tmp = -halfB + e;
            if ( tmp >= 0 )
                root = Math.pow(tmp, 1/3);
            else
                root = -Math.pow(-tmp, 1/3);

            tmp = -halfB - e;
            if ( tmp >= 0 )
                root += Math.pow(tmp, 1/3);
            else
                root -= Math.pow(-tmp, 1/3);

            results.push( root - offset );
        } else if ( discrim < 0 ) {
            var distance = Math.sqrt(-a/3);
            var angle    = Math.atan2( Math.sqrt(-discrim), -halfB) / 3;
            var cos      = Math.cos(angle);
            var sin      = Math.sin(angle);
            var sqrt3    = Math.sqrt(3);

            results.push( 2*distance*cos - offset );
            results.push( -distance * (cos + sqrt3 * sin) - offset);
            results.push( -distance * (cos - sqrt3 * sin) - offset);
        } else {
            var tmp;

            if ( halfB >= 0 )
                tmp = -Math.pow(halfB, 1/3);
            else
                tmp = Math.pow(-halfB, 1/3);

            results.push( 2*tmp - offset );
            // really should return next root twice, but we return only one
            results.push( -tmp - offset );
        }
    }

    return results;
};

/**
    Sign of a number (+1, -1, +0, -0).
 */
var sign = function (x) {
    return typeof x === 'number' ? x ? x < 0 ? -1 : 1 : x === x ? x : NaN : NaN;
};


///////////////////////////////////////////////////////////////////
/**
    Calculates roots of quartic polynomial. <br/>
    First, derivative roots are found, then used to split quartic polynomial 
    into segments, each containing one root of quartic polynomial.
    Segments are then passed to newton's method to find roots.

    @returns {Array<Number>} roots
*/
Polynomial.prototype.getQuarticRoots = function () {
    var results = [];

    var n = this.getDegree();
    if (n == 4) {

        var poly = new Polynomial();
        poly.coefs = this.coefs.slice();
        poly.divide_scalar(poly.coefs[n]);
        var ERRF = 1e-15;
        if (Math.abs(poly.coefs[0]) < 10 * ERRF * Math.abs(poly.coefs[3]))
            poly.coefs[0] = 0;
        var poly_d = poly.getDerivative();
        var derrt = poly_d.getRoots().sort(function (a, b) { return a - b; });
        var dery = [];
        var nr = derrt.length - 1;
        var i;
        var rb = this.bounds();
        maxabsX = Math.max(Math.abs(rb.minX), Math.abs(rb.maxX));
        var ZEROepsilon = this.zeroErrorEstimate(maxabsX);
        
        for (i = 0; i <= nr; i++) {
            dery.push(poly.eval(derrt[i]));
        }

        for (i = 0; i <= nr; i++) {
            if (Math.abs(dery[i]) < ZEROepsilon)
                dery[i] = 0;
        }

        i = 0;
        var dx = Math.max(0.1 * (rb.maxX - rb.minX) / n, ERRF);
        var guesses = [];
        var minmax = [];
        if (nr > -1) {
            if (dery[0] != 0) {
                if (sign(dery[0]) != sign(poly.eval(derrt[0] - dx) - dery[0])) {
                    guesses.push(derrt[0] - dx);
                    minmax.push([rb.minX, derrt[0]]);
                }
            }
            else {
                results.push(derrt[0], derrt[0]);
                i++;
            }

            for (; i < nr; i++) {
                if (dery[i + 1] == 0) {
                    results.push(derrt[i + 1], derrt[i + 1]);
                    i++;
                }
                else if (sign(dery[i]) != sign(dery[i + 1])) {
                    guesses.push((derrt[i] + derrt[i + 1]) / 2);
                    minmax.push([derrt[i], derrt[i + 1]]);
                }
            }
            if (dery[nr] != 0 && sign(dery[nr]) != sign(poly.eval(derrt[nr] + dx) - dery[nr])) {
                guesses.push(derrt[nr] + dx);
                minmax.push([derrt[nr], rb.maxX]);
            }
        }

        var f = function (x) { return poly.eval(x); };
        var df = function (x) { return poly_d.eval(x); };
        if (guesses.length > 0) {
            for (i = 0; i < guesses.length; i++) {
                guesses[i] = Polynomial.newton_secant_bisection(guesses[i], f, df, 32, minmax[i][0], minmax[i][1]);
            }
        }

        results = results.concat(guesses);
    }
    return results;
};

///////////////////////////////////////////////////////////////////
/**
    Estimate what is the maximum polynomial evaluation error value under which polynomial evaluation could be in fact 0.
    
    @returns {Number} 
*/
Polynomial.prototype.zeroErrorEstimate = function (maxabsX) {
    var poly = this;
    var ERRF = 1e-15;
    if (typeof maxabsX === 'undefined') {
        var rb = poly.bounds();
        maxabsX = Math.max(Math.abs(rb.minX), Math.abs(rb.maxX));
    }
    if (maxabsX < 0.001) {
        return 2*Math.abs(poly.eval(ERRF));
    }
    var n = poly.coefs.length - 1;
    var an = poly.coefs[n];
    return 10 * ERRF * poly.coefs.reduce(function (m, v, i) {
        var nm = v / an * Math.pow(maxabsX, i);
        return nm > m ? nm : m;
    }, 0);
};

///////////////////////////////////////////////////////////////////
/**
    Calculates upper Real roots bounds. <br/>
    Real roots are in interval [negX, posX]. Determined by Fujiwara method.
    @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}

    @returns {{ negX: Number, posX: Number }}
*/
Polynomial.prototype.bounds_UpperReal_Fujiwara = function () {
    var a = this.coefs;
    var n = a.length - 1;
    var an = a[n];
    if (an != 1) {
        a = this.coefs.map(function (v) { return v / an; });
    }
    var b = a.map(function (v, i) { return (i < n) ? Math.pow(Math.abs((i == 0) ? v / 2 : v), 1 / (n - i)) : v; });

    var coefSelectionFunc;
    var find2Max = function (acc, bi, i) {
        if (coefSelectionFunc(i)) {
            if (acc.max < bi) {
                acc.nearmax = acc.max;
                acc.max = bi;
            }
            else if (acc.nearmax < bi) {
                acc.nearmax = bi;
            }
        }
        return acc;
    };

    coefSelectionFunc = function (i) { return i < n && a[i] < 0; };
    var max_nearmax_pos = b.reduce(find2Max, { max: 0, nearmax: 0 });

    coefSelectionFunc = function (i) { return i < n && ((n % 2 == i % 2) ? a[i] < 0 : a[i] > 0); };
    var max_nearmax_neg = b.reduce(find2Max, { max: 0, nearmax: 0 });

    return {
        negX: -2 * max_nearmax_neg.max,
        posX: 2 * max_nearmax_pos.max
    };
};


///////////////////////////////////////////////////////////////////
/** 
    Calculates lower Real roots bounds. <br/>
    There are no Real roots in interval <negX, posX>. Determined by Fujiwara method.
    @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}

    @returns {{ negX: Number, posX: Number }}
*/
Polynomial.prototype.bounds_LowerReal_Fujiwara = function () {
    var poly = new Polynomial();
    poly.coefs = this.coefs.slice().reverse();
    var res = poly.bounds_UpperReal_Fujiwara();
    res.negX = 1 / res.negX;
    res.posX = 1 / res.posX;
    return res;
};


///////////////////////////////////////////////////////////////////
/** 
    Calculates left and right Real roots bounds. <br/>
    Real roots are in interval [minX, maxX]. Combines Fujiwara lower and upper bounds to get minimal interval.
    @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}

    @returns {{ minX: Number, maxX: Number }}
*/
Polynomial.prototype.bounds = function () {
    var urb = this.bounds_UpperReal_Fujiwara();
    var rb = { minX: urb.negX, maxX: urb.posX };
    if (urb.negX === 0 && urb.posX === 0)
        return rb;
    if (urb.negX === 0) {
        rb.minX = this.bounds_LowerReal_Fujiwara().posX;
    }
    else if (urb.posX === 0) {
        rb.maxX = this.bounds_LowerReal_Fujiwara().negX;
    }
    if (rb.minX > rb.maxX) {
        //console.log('Polynomial.prototype.bounds: poly has no real roots? or floating point error?');
        rb.minX = rb.maxX = 0;
    }
    return rb;
    // TODO: if sure that there are no complex roots 
    // (maybe by using Sturm's theorem) use:
    //return this.bounds_Real_Laguerre();
};


/////////////////////////////////////////////////////////////////// 
/**
    Newton's (Newton-Raphson) method for finding Real roots on univariate function. <br/>
    When using bounds, algorithm falls back to secant if newton goes out of range.
    Bisection is fallback for secant when determined secant is not efficient enough.
    @see {@link http://en.wikipedia.org/wiki/Newton%27s_method}
    @see {@link http://en.wikipedia.org/wiki/Secant_method}
    @see {@link http://en.wikipedia.org/wiki/Bisection_method}

    @param {Number} x0 - Inital root guess
    @param {function(x)} f - Function which root we are trying to find
    @param {function(x)} df - Derivative of function f
    @param {Number} max_iterations - Maximum number of algorithm iterations
    @param {Number} [min_x] - Left bound value
    @param {Number} [max_x] - Right bound value
    @returns {Number} - root
*/
Polynomial.newton_secant_bisection = function (x0, f, df, max_iterations, min, max) {
    var x, prev_dfx = 0, dfx, prev_x_ef_correction = 0, x_correction, x_new;
    var v, y_atmin, y_atmax;
    x = x0;
    var ACCURACY = 14;
    var min_correction_factor = Math.pow(10, -ACCURACY);
    var isBounded = (typeof min === 'number' && typeof max === 'number');
    if (isBounded) {
        if (min > max)
            throw new Error("newton root finding: min must be greater than max");
        y_atmin = f(min);
        y_atmax = f(max);
        if (sign(y_atmin) ==  sign(y_atmax))
            throw new Error("newton root finding: y values of bounds must be of opposite sign");
    }

    var isEnoughCorrection = function () {
        // stop if correction is too small
        // or if correction is in simple loop
        return (Math.abs(x_correction) <= min_correction_factor * Math.abs(x))
            || (prev_x_ef_correction == (x - x_correction) - x);
    };

    var i;
    //var stepMethod;
    //var details = [];
    for (i = 0; i < max_iterations; i++) {
        dfx = df(x);
        if (dfx == 0) {
            if (prev_dfx == 0) {
                // error
                throw new Error("newton root finding: df(x) is zero");
                //return null;
            }
            else {
                // use previous derivation value
                dfx = prev_dfx;
            }
            // or move x a little?
            //dfx = df(x != 0 ? x + x * 1e-15 : 1e-15);
        }
        //stepMethod = 'newton';
        prev_dfx = dfx;
        y = f(x);
        x_correction = y / dfx;
        x_new = x - x_correction;
        if (isEnoughCorrection()) {
            break;
        }

        if (isBounded) {
            if (sign(y) == sign(y_atmax)) {
                max = x;
                y_atmax = y;
            }
            else if (sign(y) == sign(y_atmin)) {
                min = x;
                y_atmin = y;
            }
            else {
                x = x_new;
                //console.log("newton root finding: sign(y) not matched.");
                break;
            }

            if ((x_new < min) || (x_new > max)) {
                if (sign(y_atmin) == sign(y_atmax)) {
                    break;
                }

                var RATIO_LIMIT = 50;
                var AIMED_BISECT_OFFSET = 0.25; // [0, 0.5)
                var dy = y_atmax - y_atmin;
                var dx = max - min;

                if (dy == 0) {
                    //stepMethod = 'bisect';
                    x_correction = x - (min + dx * 0.5);
                }
                else if (Math.abs(dy / Math.min(y_atmin, y_atmax)) > RATIO_LIMIT) {
                    //stepMethod = 'aimed bisect';
                    x_correction = x - (min + dx * (0.5 + (Math.abs(y_atmin) < Math.abs(y_atmax) ? -AIMED_BISECT_OFFSET : AIMED_BISECT_OFFSET)));
                }
                else {
                    //stepMethod = 'secant'; 
                    x_correction = x - (min - y_atmin / dy * dx);
                }
                x_new = x - x_correction;

                if (isEnoughCorrection()) {
                    break;
                }
            }
        }
        //details.push([stepMethod, i, x, x_new, x_correction, min, max, y]);
        prev_x_ef_correction = x - x_new;
        x = x_new;
    }
    //details.push([stepMethod, i, x, x_new, x_correction, min, max, y]);
    //console.log(details.join('\r\n'));
    //if (i == max_iterations)
    //    console.log('newt: steps=' + ((i==max_iterations)? i:(i + 1)));
    return x;
};

{
    module.exports = Polynomial;
}
});

var SqrtPolynomial_1 = createCommonjsModule(function (module) {
/**
 *
 *   SqrtPolynomial.js
 *
 *   copyright 2003, 2013 Kevin Lindsey
 *
 */

{
    var Polynomial = Polynomial_1;
}

/**
 *   class variables
 */
SqrtPolynomial.VERSION = 1.0;

// setup inheritance
SqrtPolynomial.prototype             = new Polynomial();
SqrtPolynomial.prototype.constructor = SqrtPolynomial;
SqrtPolynomial.superclass            = Polynomial.prototype;


/**
 *  SqrtPolynomial
 */
function SqrtPolynomial() {
    this.init( arguments );
}


/**
 *  eval
 *
 *  @param {Number} x
 *  @returns {Number}
 */
SqrtPolynomial.prototype.eval = function(x) {
    var TOLERANCE = 1e-7;
    var result = SqrtPolynomial.superclass.eval.call(this, x);

    // NOTE: May need to change the following.  I added these to capture
    // some really small negative values that were being generated by one
    // of my Bezier arcLength functions
    if ( Math.abs(result) < TOLERANCE ) result = 0;
    if ( result < 0 )
        throw new Error("SqrtPolynomial.eval: cannot take square root of negative number");

    return Math.sqrt(result);
};

SqrtPolynomial.prototype.toString = function() {
    var result = SqrtPolynomial.superclass.toString.call(this);

    return "sqrt(" + result + ")";
};

{
    module.exports = SqrtPolynomial;
}
});

// expose classes

var Polynomial = Polynomial_1;
var SqrtPolynomial = SqrtPolynomial_1;

var index = {
	Polynomial: Polynomial,
	SqrtPolynomial: SqrtPolynomial
};

exports['default'] = index;
exports.Polynomial = Polynomial;
exports.SqrtPolynomial = SqrtPolynomial;

}((this.kldPolynomial = this.kldPolynomial || {})));

  (function (exports,kldAffine,kldPolynomial) {
'use strict';

kldAffine = 'default' in kldAffine ? kldAffine['default'] : kldAffine;
kldPolynomial = 'default' in kldPolynomial ? kldPolynomial['default'] : kldPolynomial;

var Point2D$1 = kldAffine.Point2D;


/**
    getArcParameters

    @param {Point2D} startPoint
    @param {Point2D} endPoint
    @param {Number} rx
    @param {Number} ry
    @param {Number} angle - in degrees
    @param {Boolean} arcFlag
    @param {Boolean} sweepFlag
    @returns {{ center: Point2D, rx: Number, ry: Number, theta1: Number, deltaTheta: Number }}
*/
function getArcParameters(startPoint, endPoint, rx, ry, angle, arcFlag, sweepFlag) {
    function radian(ux, uy, vx, vy) {
        var dot = ux * vx + uy * vy;
        var mod = Math.sqrt((ux * ux + uy * uy) * (vx * vx + vy * vy));
        var rad = Math.acos(dot / mod);
        if (ux * vy - uy * vx < 0.0) rad = -rad;
        return rad;
    }
    angle = angle * Math.PI / 180;
    var c = Math.cos(angle);
    var s = Math.sin(angle);
    var TOLERANCE = 1e-6;
    var halfDiff = startPoint.subtract(endPoint).divide(2);
    var x1p = halfDiff.x * c + halfDiff.y * s;
    var y1p = halfDiff.x * -s + halfDiff.y * c;
    var x1px1p = x1p * x1p;
    var y1py1p = y1p * y1p;
    var lambda = (x1px1p / (rx * rx)) + (y1py1p / (ry * ry));
    var factor;
    if (lambda > 1) {
        factor = Math.sqrt(lambda);
        rx *= factor;
        ry *= factor;
    }
    var rxrx = rx * rx;
    var ryry = ry * ry;
    var rxy1 = rxrx * y1py1p;
    var ryx1 = ryry * x1px1p;
    factor = (rxrx * ryry - rxy1 - ryx1) / (rxy1 + ryx1);
    if (Math.abs(factor) < TOLERANCE) factor = 0;
    var sq = Math.sqrt(factor);
    if (arcFlag == sweepFlag) sq = -sq;
    var mid = startPoint.add(endPoint).divide(2);
    var cxp = sq * rx * y1p / ry;
    var cyp = sq * -ry * x1p / rx;
    //return new Point2D(cxp * c - cyp * s + mid.x, cxp * s + cyp * c + mid.y);

    var xcr1 = (x1p - cxp) / rx;
    var xcr2 = (x1p + cxp) / rx;
    var ycr1 = (y1p - cyp) / ry;
    var ycr2 = (y1p + cyp) / ry;

    var vcr1 = new Vector2D(1, 0);
    var theta1 = radian(1.0, 0.0, xcr1, ycr1);

    var deltaTheta = radian(xcr1, ycr1, -xcr2, -ycr2);
    var PIx2 = Math.PI * 2.0;
    while (deltaTheta > PIx2) deltaTheta -= PIx2;
    while (deltaTheta < 0.0) deltaTheta += PIx2;
    if (sweepFlag == false) deltaTheta -= PIx2;

    return {
        center: new Point2D$1(cxp * c - cyp * s + mid.x, cxp * s + cyp * c + mid.y),
        rx: rx,
        ry: ry,
        theta1: theta1,
        deltaTheta: deltaTheta
    };
}


/**
 *  IntersectionParams
 *
 *  @param {String} name
 *  @param {Array<Point2D} params
 *  @returns {IntersectionParams}
 */
function IntersectionParams$1(name, params) {
    this.init(name, params);
}

/**
 *  init
 *
 *  @param {String} type
 *  @param {Array<Point2D>} params
 */
IntersectionParams$1.prototype.init = function (type, params) {
    this.type = type;
    this.params = params;
    this.meta = {};
};

IntersectionParams$1.TYPE = {};
var IPTYPE$1 = IntersectionParams$1.TYPE;
IPTYPE$1.LINE = 'Line';
IPTYPE$1.RECT = 'Rectangle';
IPTYPE$1.ROUNDRECT = 'RoundRectangle';
IPTYPE$1.CIRCLE = 'Circle';
IPTYPE$1.ELLIPSE = 'Ellipse';
IPTYPE$1.POLYGON = 'Polygon';
IPTYPE$1.POLYLINE = 'Polyline';
IPTYPE$1.PATH = 'Path';
IPTYPE$1.ARC = 'Arc';
IPTYPE$1.BEZIER2 = 'Bezier2';
IPTYPE$1.BEZIER3 = 'Bezier3';


function parsePointsString(points) {
    return points.split(" ").map(function(point) {
        point = point.split(",");
        return new Point2D$1(point[0], point[1]);
    });
}

IntersectionParams$1.newShape = function(svgElementName, props) {
    svgElementName = svgElementName.toLowerCase();

    if(svgElementName === "line") {
        return IntersectionParams$1.newLine(
            new Point2D$1(props.x1, props.y1),
            new Point2D$1(props.x2, props.y2)
        );
    }

    if(svgElementName === "rect") {
        if(props.rx > 0 || props.ry > 0) {
            return IntersectionParams$1.newRoundRect(
                props.x, props.y,
                props.width, props.height,
                props.rx, props.ry
            );
        } else {
            return IntersectionParams$1.newRect(
                props.x, props.y,
                props.width, props.height
            );
        }
    }

    if(svgElementName === "circle") {
        return IntersectionParams$1.newCircle(
            new Point2D$1(props.cx, props.cy),
            props.r
        );
    }

    if(svgElementName === "ellipse") {
        return IntersectionParams$1.newEllipse(
            new Point2D$1(props.cx, props.cy),
            props.rx, props.ry
        );
    }

    if(svgElementName === "polygon") {
        return IntersectionParams$1.newPolygon(
            parsePointsString(props.points)
        );
    }

    if(svgElementName === "polyline") {
        return IntersectionParams$1.newPolyline(
            parsePointsString(props.points)
        );
    }

    if(svgElementName === "path") {
        return IntersectionParams$1.newPath(
            props.d
        );
    }

};


///////////////////////////////////////////////////////////////////
/**
    Creates IntersectionParams for arc.

    @param {Point2D} startPoint - arc start point
    @param {Point2D} endPoint - arc end point
    @param {Number} rx - arc ellipse x radius
    @param {Number} ry - arc ellipse y radius
    @param {Number} angle - arc ellipse rotation in degrees
    @param {Boolean} largeArcFlag
    @param {Boolean} sweepFlag
    @returns {IntersectionParams}
*/
IntersectionParams$1.newArc = function (startPoint, endPoint, rx, ry, angle, largeArcFlag, sweepFlag) {
    var p = getArcParameters(startPoint, endPoint, rx, ry, angle, largeArcFlag, sweepFlag);
    return new IntersectionParams$1(IPTYPE$1.ARC, [p.center, p.rx, p.ry, (angle * Math.PI / 180), p.theta1, p.deltaTheta]);
};

///////////////////////////////////////////////////////////////////
/**
    Creates IntersectionParams for bezier2.

    @param {Point2D} p1
    @param {Point2D} p2
    @param {Point2D} p3
    @returns {IntersectionParams}
*/
IntersectionParams$1.newBezier2 = function (p1, p2, p3) {
    return new IntersectionParams$1(IPTYPE$1.BEZIER2, [p1, p2, p3]);
};

///////////////////////////////////////////////////////////////////
/**
    Creates IntersectionParams for bezier3.

    @param {Point2D} p1
    @param {Point2D} p2
    @param {Point2D} p3
    @param {Point2D} p4
    @returns {IntersectionParams}
*/
IntersectionParams$1.newBezier3 = function (p1, p2, p3, p4) {
    return new IntersectionParams$1(IPTYPE$1.BEZIER3, [p1, p2, p3, p4]);
};

///////////////////////////////////////////////////////////////////
/**
    Creates IntersectionParams for circle.

    @param {Point2D} c
    @param {Number} r
    @returns {IntersectionParams}
*/
IntersectionParams$1.newCircle = function (c, r) {
    return new IntersectionParams$1(IPTYPE$1.CIRCLE, [c, r]);
};

///////////////////////////////////////////////////////////////////
/**
    Creates IntersectionParams for ellipse.

    @param {Point2D} c
    @param {Number} rx
    @param {Number} ry
    @returns {IntersectionParams}
*/
IntersectionParams$1.newEllipse = function (c, rx, ry) {
    return new IntersectionParams$1(IPTYPE$1.ELLIPSE, [c, rx, ry]);
};

///////////////////////////////////////////////////////////////////
/**
    Creates IntersectionParams for line.

    @param {Point2D} a1
    @param {Point2D} a2
    @returns {IntersectionParams}
*/
IntersectionParams$1.newLine = function (a1, a2) {
    return new IntersectionParams$1(IPTYPE$1.LINE, [a1, a2]);
};

///////////////////////////////////////////////////////////////////
/**
    Creates IntersectionParams for polygon.

    @param {Array<Point2D>} points
    @returns {IntersectionParams}
*/
IntersectionParams$1.newPolygon = function (points) {
    return new IntersectionParams$1(IPTYPE$1.POLYGON, [points]);
};

///////////////////////////////////////////////////////////////////
/**
    Creates IntersectionParams for polyline.

     @param {Array<Point2D>} points
    @returns {IntersectionParams}
*/
IntersectionParams$1.newPolyline = function (points) {
    return new IntersectionParams$1(IPTYPE$1.POLYLINE, [points]);
};


///////////////////////////////////////////////////////////////////
/**
    Creates IntersectionParams for rectangle.

    @param {Number} x
    @param {Number} y
    @param {Number} width
    @param {Number} height
    @returns {IntersectionParams}
*/
IntersectionParams$1.newRect = function (x, y, width, height) {
    var points = [];
    points.push(new Point2D$1(x, y));
    points.push(new Point2D$1(x + width, y));
    points.push(new Point2D$1(x + width, y + height));
    points.push(new Point2D$1(x, y + height));
    return new IntersectionParams$1(IPTYPE$1.RECT, [points]);
};

var degreesToRadians = function (angle) {
    return angle * Math.PI / 180;
};
///////////////////////////////////////////////////////////////////
/**
    Creates IntersectionParams for round rectangle, or for rectangle if rx and ry are 0.

    @param {Number} x
    @param {Number} y
    @param {Number} width
    @param {Number} height
    @param {Number} rx
    @param {Number} ry
    @returns {IntersectionParams}
*/
IntersectionParams$1.newRoundRect = function (x, y, width, height, rx, ry) {
    if (rx === 0 && ry === 0)
        return IntersectionParams$1.newRect(x, y, width, height);
    if (rx === 0)
        rx = ry;
    if (ry === 0)
        ry = rx;
    if (rx > width / 2)
        rx = width / 2;
    if (ry > height / 2)
        rx = height / 2;
    var shape = [];
    var x0 = x, x1 = x + rx, x2 = x + width - rx, x3 = x + width;
    var y0 = y, y1 = y + ry, y2 = y + height - ry, y3 = y + height;
    shape.push(new IntersectionParams$1(IPTYPE$1.ARC, [new Point2D$1(x1, y1), rx, ry, 0, degreesToRadians(180), degreesToRadians(90)]));
    shape.push(new IntersectionParams$1(IPTYPE$1.LINE, [new Point2D$1(x1, y0), new Point2D$1(x2, y0)]));
    shape.push(new IntersectionParams$1(IPTYPE$1.ARC, [new Point2D$1(x2, y1), rx, ry, 0, degreesToRadians(-90), degreesToRadians(90)]));
    shape.push(new IntersectionParams$1(IPTYPE$1.LINE, [new Point2D$1(x3, y1), new Point2D$1(x3, y2)]));
    shape.push(new IntersectionParams$1(IPTYPE$1.ARC, [new Point2D$1(x2, y2), rx, ry, 0, degreesToRadians(0), degreesToRadians(90)]));
    shape.push(new IntersectionParams$1(IPTYPE$1.LINE, [new Point2D$1(x2, y3), new Point2D$1(x1, y3)]));
    shape.push(new IntersectionParams$1(IPTYPE$1.ARC, [new Point2D$1(x1, y2), rx, ry, 0, degreesToRadians(90), degreesToRadians(90)]));
    shape.push(new IntersectionParams$1(IPTYPE$1.LINE, [new Point2D$1(x0, y2), new Point2D$1(x0, y1)]));
    shape[shape.length - 1].meta.closePath = true;
    return new IntersectionParams$1(IPTYPE$1.ROUNDRECT, [shape]);
};




function Token(type, text) {
    if (arguments.length > 0) {
        this.init(type, text);
    }
}
Token.prototype.init = function(type, text) {
    this.type = type;
    this.text = text;
};
Token.prototype.typeis = function(type) {
    return this.type == type;
};
var Path = {};
Path.COMMAND = 0;
Path.NUMBER = 1;
Path.EOD = 2;
Path.PARAMS = {
    A: ["rx", "ry", "x-axis-rotation", "large-arc-flag", "sweep-flag", "x", "y"],
    a: ["rx", "ry", "x-axis-rotation", "large-arc-flag", "sweep-flag", "x", "y"],
    C: ["x1", "y1", "x2", "y2", "x", "y"],
    c: ["x1", "y1", "x2", "y2", "x", "y"],
    H: ["x"],
    h: ["x"],
    L: ["x", "y"],
    l: ["x", "y"],
    M: ["x", "y"],
    m: ["x", "y"],
    Q: ["x1", "y1", "x", "y"],
    q: ["x1", "y1", "x", "y"],
    S: ["x2", "y2", "x", "y"],
    s: ["x2", "y2", "x", "y"],
    T: ["x", "y"],
    t: ["x", "y"],
    V: ["y"],
    v: ["y"],
    Z: [],
    z: []
};

function tokenize(d) {
    var tokens = new Array();
    while (d != "") {
        if (d.match(/^([ \t\r\n,]+)/)) {
            d = d.substr(RegExp.$1.length);
        } else if (d.match(/^([aAcChHlLmMqQsStTvVzZ])/)) {
            tokens[tokens.length] = new Token(Path.COMMAND, RegExp.$1);
            d = d.substr(RegExp.$1.length);
        } else if (d.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/)) {
            tokens[tokens.length] = new Token(Path.NUMBER, parseFloat(RegExp.$1));
            d = d.substr(RegExp.$1.length);
        } else {
            throw new Error("Unrecognized segment command: " + d);
        }
    }
    tokens[tokens.length] = new Token(Path.EOD, null);
    return tokens;
}

IntersectionParams$1.newPath = function(d) {
    var tokens = tokenize(d);
    var index = 0;
    var token = tokens[index];
    var mode = "BOD";
    var segments = [];

    while (!token.typeis(Path.EOD)) {
        var param_length;
        var params = new Array();
        if (mode == "BOD") {
            if (token.text == "M" || token.text == "m") {
                index++;
                param_length = Path.PARAMS[token.text].length;
                mode = token.text;
            } else {
                throw new Error("Path data must begin with a moveto command");
            }
        } else {
            if (token.typeis(Path.NUMBER)) {
                param_length = Path.PARAMS[mode].length;
            } else {
                index++;
                param_length = Path.PARAMS[token.text].length;
                mode = token.text;
            }
        }
        if ((index + param_length) < tokens.length) {
            for (var i = index; i < index + param_length; i++) {
                var number = tokens[i];
                if (number.typeis(Path.NUMBER)) params[params.length] = number.text;
                else throw new Error("Parameter type is not a number: " + mode + "," + number.text);
            }
            var segment;
            var length = segments.length;
            var previous = (length == 0) ? null : segments[length - 1];
            switch (mode) {
                case "A":
                    segment = new AbsoluteArcPath(params, previous);
                    break;
                case "C":
                    segment = new AbsoluteCurveto3(params, previous);
                    break;
                case "c":
                    segment = new RelativeCurveto3(params, previous);
                    break;
                case "H":
                    segment = new AbsoluteHLineto(params, previous);
                    break;
                case "L":
                    segment = new AbsoluteLineto(params, previous);
                    break;
                case "l":
                    segment = new RelativeLineto(params, previous);
                    break;
                case "M":
                    segment = new AbsoluteMoveto(params, previous);
                    break;
                case "m":
                    segment = new RelativeMoveto(params, previous);
                    break;
                case "Q":
                    segment = new AbsoluteCurveto2(params, previous);
                    break;
                case "q":
                    segment = new RelativeCurveto2(params, previous);
                    break;
                case "S":
                    segment = new AbsoluteSmoothCurveto3(params, previous);
                    break;
                case "s":
                    segment = new RelativeSmoothCurveto3(params, previous);
                    break;
                case "T":
                    segment = new AbsoluteSmoothCurveto2(params, previous);
                    break;
                case "t":
                    segment = new RelativeSmoothCurveto2(params, previous);
                    break;
                case "Z":
                    segment = new RelativeClosePath(params, previous);
                    break;
                case "z":
                    segment = new RelativeClosePath(params, previous);
                    break;
                default:
                    throw new Error("Unsupported segment type: " + mode);
            }
            segments.push(segment);
            index += param_length;
            token = tokens[index];
            if (mode == "M") mode = "L";
            if (mode == "m") mode = "l";
        } else {
            throw new Error("Path data ended before all parameters were found");
        }
    }

    var segmentParams = [];
    for(i=0; i<segments.length; i++) {
        var ip = segments[i].getIntersectionParams();
        if(ip) {
            segmentParams.push(ip);
        }
    }

    return new IntersectionParams$1(IPTYPE$1.PATH, [segmentParams]);
};


function AbsolutePathSegment(command, params, previous) {
    if (arguments.length > 0) this.init(command, params, previous);
}
AbsolutePathSegment.prototype.init = function(command, params, previous) {
    this.command = command;
    this.previous = previous;
    this.points = [];
    var index = 0;
    while (index < params.length) {
        this.points.push(new Point2D$1(params[index], params[index + 1]));
        index += 2;
    }
};
AbsolutePathSegment.prototype.getLastPoint = function() {
    return this.points[this.points.length - 1];
};
AbsolutePathSegment.prototype.getIntersectionParams = function() {
    return null;
};



function AbsoluteArcPath(params, previous) {
    if (arguments.length > 0) {
        this.init("A", params, previous);
    }
}
AbsoluteArcPath.prototype = new AbsolutePathSegment();
AbsoluteArcPath.prototype.constructor = AbsoluteCurveto2;
AbsoluteArcPath.superclass = AbsolutePathSegment.prototype;

AbsoluteArcPath.prototype.init = function(command, params, previous) {
    var point = new Array();
    var y = params.pop();
    var x = params.pop();
    point.push(x, y);
    AbsoluteArcPath.superclass.init.call(this, command, point, previous);
    this.rx = parseFloat(params.shift());
    this.ry = parseFloat(params.shift());
    this.angle = parseFloat(params.shift());
    this.arcFlag = parseFloat(params.shift());
    this.sweepFlag = parseFloat(params.shift());
};
AbsoluteArcPath.prototype.getIntersectionParams = function() {
    return new IntersectionParams$1("Ellipse", [this.getCenter(), this.rx, this.ry]);
};
AbsoluteArcPath.prototype.getCenter = function() {
    var startPoint = this.previous.getLastPoint();
    var endPoint = this.points[0];
    var rx = this.rx;
    var ry = this.ry;
    var angle = this.angle * Math.PI / 180;
    var c = Math.cos(angle);
    var s = Math.sin(angle);
    var TOLERANCE = 1e-6;
    var halfDiff = startPoint.subtract(endPoint).divide(2);
    var x1p = halfDiff.x * c + halfDiff.y * s;
    var y1p = halfDiff.x * -s + halfDiff.y * c;
    var x1px1p = x1p * x1p;
    var y1py1p = y1p * y1p;
    var lambda = (x1px1p / (rx * rx)) + (y1py1p / (ry * ry));
    if (lambda > 1) {
        var factor = Math.sqrt(lambda);
        rx *= factor;
        ry *= factor;
    }
    var rxrx = rx * rx;
    var ryry = ry * ry;
    var rxy1 = rxrx * y1py1p;
    var ryx1 = ryry * x1px1p;
    var factor = (rxrx * ryry - rxy1 - ryx1) / (rxy1 + ryx1);
    if (Math.abs(factor) < TOLERANCE) factor = 0;
    var sq = Math.sqrt(factor);
    if (this.arcFlag == this.sweepFlag) sq = -sq;
    var mid = startPoint.add(endPoint).divide(2);
    var cxp = sq * rx * y1p / ry;
    var cyp = sq * -ry * x1p / rx;
    return new Point2D$1(cxp * c - cyp * s + mid.x, cxp * s + cyp * c + mid.y);
};



function AbsoluteCurveto2(params, previous) {
    if (arguments.length > 0) {
        this.init("Q", params, previous);
    }
}
AbsoluteCurveto2.prototype = new AbsolutePathSegment();
AbsoluteCurveto2.prototype.constructor = AbsoluteCurveto2;
AbsoluteCurveto2.superclass = AbsolutePathSegment.prototype;

AbsoluteCurveto2.prototype.getIntersectionParams = function() {
    return new IntersectionParams$1("Bezier2", [this.previous.getLastPoint(), this.points[0], this.points[1]]);
};



function AbsoluteCurveto3(params, previous) {
    if (arguments.length > 0) {
        this.init("C", params, previous);
    }
}
AbsoluteCurveto3.prototype = new AbsolutePathSegment();
AbsoluteCurveto3.prototype.constructor = AbsoluteCurveto3;
AbsoluteCurveto3.superclass = AbsolutePathSegment.prototype;

AbsoluteCurveto3.prototype.getLastControlPoint = function() {
    return this.points[1];
};
AbsoluteCurveto3.prototype.getIntersectionParams = function() {
    return new IntersectionParams$1("Bezier3", [this.previous.getLastPoint(), this.points[0], this.points[1], this.points[2]]);
};


function AbsoluteHLineto(params, previous) {
    if (arguments.length > 0) {
        this.init("H", params, previous);
    }
}
AbsoluteHLineto.prototype = new AbsolutePathSegment();
AbsoluteHLineto.prototype.constructor = AbsoluteHLineto;
AbsoluteHLineto.superclass = AbsolutePathSegment.prototype;

AbsoluteHLineto.prototype.init = function(command, params, previous) {
    var prevPoint = previous.getLastPoint();
    var point = new Array();
    point.push(params.pop(), prevPoint.y);
    AbsoluteHLineto.superclass.init.call(this, command, point, previous);
};


function AbsoluteLineto(params, previous) {
    if (arguments.length > 0) {
        this.init("L", params, previous);
    }
}
AbsoluteLineto.prototype = new AbsolutePathSegment();
AbsoluteLineto.prototype.constructor = AbsoluteLineto;
AbsoluteLineto.superclass = AbsolutePathSegment.prototype;

AbsoluteLineto.prototype.getIntersectionParams = function() {
    return new IntersectionParams$1("Line", [this.previous.getLastPoint(), this.points[0]]);
};



function AbsoluteMoveto(params, previous) {
    if (arguments.length > 0) {
        this.init("M", params, previous);
    }
}
AbsoluteMoveto.prototype = new AbsolutePathSegment();
AbsoluteMoveto.prototype.constructor = AbsoluteMoveto;
AbsoluteMoveto.superclass = AbsolutePathSegment.prototype;


function AbsoluteSmoothCurveto2(params, previous) {
    if (arguments.length > 0) {
        this.init("T", params, previous);
    }
}
AbsoluteSmoothCurveto2.prototype = new AbsolutePathSegment();
AbsoluteSmoothCurveto2.prototype.constructor = AbsoluteSmoothCurveto2;
AbsoluteSmoothCurveto2.superclass = AbsolutePathSegment.prototype;

AbsoluteSmoothCurveto2.prototype.getControlPoint = function() {
    var lastPoint = this.previous.getLastPoint();
    var point;
    if (this.previous.command.match(/^[QqTt]$/)) {
        var ctrlPoint = this.previous.getControlPoint();
        var diff = ctrlPoint.subtract(lastPoint);
        point = lastPoint.subtract(diff);
    } else {
        point = lastPoint;
    }
    return point;
};
AbsoluteSmoothCurveto2.prototype.getIntersectionParams = function() {
    return new IntersectionParams$1("Bezier2", [this.previous.getLastPoint(), this.getControlPoint(), this.points[0]]);
};


function AbsoluteSmoothCurveto3(params, previous) {
    if (arguments.length > 0) {
        this.init("S", params, previous);
    }
}
AbsoluteSmoothCurveto3.prototype = new AbsolutePathSegment();
AbsoluteSmoothCurveto3.prototype.constructor = AbsoluteSmoothCurveto3;
AbsoluteSmoothCurveto3.superclass = AbsolutePathSegment.prototype;

AbsoluteSmoothCurveto3.prototype.getFirstControlPoint = function() {
    var lastPoint = this.previous.getLastPoint();
    var point;
    if (this.previous.command.match(/^[SsCc]$/)) {
        var lastControl = this.previous.getLastControlPoint();
        var diff = lastControl.subtract(lastPoint);
        point = lastPoint.subtract(diff);
    } else {
        point = lastPoint;
    }
    return point;
};
AbsoluteSmoothCurveto3.prototype.getLastControlPoint = function() {
    return this.points[0];
};
AbsoluteSmoothCurveto3.prototype.getIntersectionParams = function() {
    return new IntersectionParams$1("Bezier3", [this.previous.getLastPoint(), this.getFirstControlPoint(), this.points[0], this.points[1]]);
};


function RelativePathSegment(command, params, previous) {
    if (arguments.length > 0) this.init(command, params, previous);
}
RelativePathSegment.prototype = new AbsolutePathSegment();
RelativePathSegment.prototype.constructor = RelativePathSegment;
RelativePathSegment.superclass = AbsolutePathSegment.prototype;

RelativePathSegment.prototype.init = function(command, params, previous) {
    this.command = command;
    this.previous = previous;
    this.points = [];
    var lastPoint;
    if (this.previous) lastPoint = this.previous.getLastPoint();
    else lastPoint = new Point2D$1(0, 0);
    var index = 0;
    while (index < params.length) {
        var point = new Point2D$1(lastPoint.x + params[index], lastPoint.y + params[index + 1]);
        this.points.push(point);
        index += 2;
    }
};

function RelativeClosePath(params, previous) {
    if (arguments.length > 0) {
        this.init("z", params, previous);
    }
}
RelativeClosePath.prototype = new RelativePathSegment();
RelativeClosePath.prototype.constructor = RelativeClosePath;
RelativeClosePath.superclass = RelativePathSegment.prototype;
RelativeClosePath.prototype.getLastPoint = function() {
    var current = this.previous;
    var point;
    while (current) {
        if (current.command.match(/^[mMzZ]$/)) {
            point = current.getLastPoint();
            break;
        }
        current = current.previous;
    }
    return point;
};
RelativeClosePath.prototype.getIntersectionParams = function() {
    return new IntersectionParams$1("Line", [this.previous.getLastPoint(), this.getLastPoint()]);
};


function RelativeCurveto2(params, previous) {
    if (arguments.length > 0) {
        this.init("q", params, previous);
    }
}
RelativeCurveto2.prototype = new RelativePathSegment();
RelativeCurveto2.prototype.constructor = RelativeCurveto2;
RelativeCurveto2.superclass = RelativePathSegment.prototype;

RelativeCurveto2.prototype.getControlPoint = function() {
    return this.points[0];
};
RelativeCurveto2.prototype.getIntersectionParams = function() {
    return new IntersectionParams$1("Bezier2", [this.previous.getLastPoint(), this.points[0], this.points[1]]);
};


function RelativeCurveto3(params, previous) {
    if (arguments.length > 0) {
        this.init("c", params, previous);
    }
}
RelativeCurveto3.prototype = new RelativePathSegment();
RelativeCurveto3.prototype.constructor = RelativeCurveto3;
RelativeCurveto3.superclass = RelativePathSegment.prototype;

RelativeCurveto3.prototype.getLastControlPoint = function() {
    return this.points[1];
};
RelativeCurveto3.prototype.getIntersectionParams = function() {
    return new IntersectionParams$1("Bezier3", [this.previous.getLastPoint(), this.points[0], this.points[1], this.points[2]]);
};


function RelativeLineto(params, previous) {
    if (arguments.length > 0) {
        this.init("l", params, previous);
    }
}
RelativeLineto.prototype = new RelativePathSegment();
RelativeLineto.prototype.constructor = RelativeLineto;
RelativeLineto.superclass = RelativePathSegment.prototype;

RelativeLineto.prototype.toString = function() {
    var points = new Array();
    var command = "";
    var lastPoint;
    var point;
    if (this.previous) lastPoint = this.previous.getLastPoint();
    else lastPoint = new Point(0, 0);
    point = this.points[0].subtract(lastPoint);
    if (this.previous.constructor != this.constuctor)
        if (this.previous.constructor != RelativeMoveto) cmd = this.command;
    return cmd + point.toString();
};
RelativeLineto.prototype.getIntersectionParams = function() {
    return new IntersectionParams$1("Line", [this.previous.getLastPoint(), this.points[0]]);
};



function RelativeMoveto(params, previous) {
    if (arguments.length > 0) {
        this.init("m", params, previous);
    }
}
RelativeMoveto.prototype = new RelativePathSegment();
RelativeMoveto.prototype.constructor = RelativeMoveto;
RelativeMoveto.superclass = RelativePathSegment.prototype;



function RelativeSmoothCurveto2(params, previous) {
    if (arguments.length > 0) {
        this.init("t", params, previous);
    }
}
RelativeSmoothCurveto2.prototype = new RelativePathSegment();
RelativeSmoothCurveto2.prototype.constructor = RelativeSmoothCurveto2;
RelativeSmoothCurveto2.superclass = RelativePathSegment.prototype;

RelativeSmoothCurveto2.prototype.getControlPoint = function() {
    var lastPoint = this.previous.getLastPoint();
    var point;
    if (this.previous.command.match(/^[QqTt]$/)) {
        var ctrlPoint = this.previous.getControlPoint();
        var diff = ctrlPoint.subtract(lastPoint);
        point = lastPoint.subtract(diff);
    } else {
        point = lastPoint;
    }
    return point;
};
RelativeSmoothCurveto2.prototype.getIntersectionParams = function() {
    return new IntersectionParams$1("Bezier2", [this.previous.getLastPoint(), this.getControlPoint(), this.points[0]]);
};



function RelativeSmoothCurveto3(params, previous) {
    if (arguments.length > 0) {
        this.init("s", params, previous);
    }
}
RelativeSmoothCurveto3.prototype = new RelativePathSegment();
RelativeSmoothCurveto3.prototype.constructor = RelativeSmoothCurveto3;
RelativeSmoothCurveto3.superclass = RelativePathSegment.prototype;

RelativeSmoothCurveto3.prototype.getFirstControlPoint = function() {
    var lastPoint = this.previous.getLastPoint();
    var point;
    if (this.previous.command.match(/^[SsCc]$/)) {
        var lastControl = this.previous.getLastControlPoint();
        var diff = lastControl.subtract(lastPoint);
        point = lastPoint.subtract(diff);
    } else {
        point = lastPoint;
    }
    return point;
};
RelativeSmoothCurveto3.prototype.getLastControlPoint = function() {
    return this.points[0];
};
RelativeSmoothCurveto3.prototype.getIntersectionParams = function() {
    return new IntersectionParams$1("Bezier3", [this.previous.getLastPoint(), this.getFirstControlPoint(), this.points[0], this.points[1]]);
};


var IntersectionParams_1 = IntersectionParams$1;

/**
 *  Intersection
 */
function Intersection$1(status) {
    this.init(status);
}

/**
 *  init
 *
 *  @param {String} status
 *  @returns {Intersection}
 */
Intersection$1.prototype.init = function(status) {
    this.status = status;
    this.points = [];
};

/**
 *  appendPoint
 *
 *  @param {Point2D} point
 */
Intersection$1.prototype.appendPoint = function(point) {
    this.points.push(point);
};

/**
 *  appendPoints
 *
 *  @param {Array<Point2D>} points
 */
Intersection$1.prototype.appendPoints = function(points) {
    this.points = this.points.concat(points);
};

var Intersection_1 = Intersection$1;

/**
 *
 *  Intersection.js
 *
 *  copyright 2002, 2013 Kevin Lindsey
 *
 *  contribution {@link http://github.com/Quazistax/kld-intersections}
 *      @copyright 2015 Robert Benko (Quazistax) <quazistax@gmail.com>
 *      @license MIT
 */
 
var Point2D = kldAffine.Point2D;
var Vector2D$1 = kldAffine.Vector2D;
var Matrix2D = kldAffine.Matrix2D;
var Polynomial = kldPolynomial.Polynomial;
var IntersectionParams = IntersectionParams_1;
var Intersection = Intersection_1;

var IPTYPE = IntersectionParams.TYPE;



/**
 *  bezout
 *
 *  This code is based on MgcIntr2DElpElp.cpp written by David Eberly.  His
 *  code along with many other excellent examples are avaiable at his site:
 *  http://www.geometrictools.com
 *
 *  @param {Array<Point2D>} e1
 *  @param {Array<Point2D>} e2
 *  @returns {Polynomial}
 */
function bezout(e1, e2) {
    var AB    = e1[0]*e2[1] - e2[0]*e1[1];
    var AC    = e1[0]*e2[2] - e2[0]*e1[2];
    var AD    = e1[0]*e2[3] - e2[0]*e1[3];
    var AE    = e1[0]*e2[4] - e2[0]*e1[4];
    var AF    = e1[0]*e2[5] - e2[0]*e1[5];
    var BC    = e1[1]*e2[2] - e2[1]*e1[2];
    var BE    = e1[1]*e2[4] - e2[1]*e1[4];
    var BF    = e1[1]*e2[5] - e2[1]*e1[5];
    var CD    = e1[2]*e2[3] - e2[2]*e1[3];
    var DE    = e1[3]*e2[4] - e2[3]*e1[4];
    var DF    = e1[3]*e2[5] - e2[3]*e1[5];
    var BFpDE = BF + DE;
    var BEmCD = BE - CD;

    return new Polynomial(
        AB*BC - AC*AC,
        AB*BEmCD + AD*BC - 2*AC*AE,
        AB*BFpDE + AD*BEmCD - AE*AE - 2*AC*AF,
        AB*DF + AD*BFpDE - 2*AE*AF,
        AD*DF - AF*AF
    );
}

/**
    Removes from intersection points those points that are not between two rays determined by arc parameters.
    Rays begin at ellipse center and go through arc startPoint/endPoint.

    @param {Intersection} intersection - will be modified and returned
    @param {Point2D} c - center of arc ellipse
    @param {Number} rx
    @param {Number} ry
    @param {Number} phi - in radians
    @param {Number} th1 - in radians
    @param {Number} dth - in radians
    @param {Matrix2D} [m] - arc transformation matrix
    @returns {Intersection}
*/
function removePointsNotInArc(intersection, c, rx, ry, phi, th1, dth, m) {
    if (intersection.points.length === 0) return intersection;
    if (m && !m.isIdentity())
        var mp = m.inverse();
    var np = [];
    var vx = new Vector2D$1(1, 0);
    var pi2 = Math.PI * 2;
    var wasNeg = dth < 0;
    var wasBig = Math.abs(dth) > Math.PI;
    var m1 = new Matrix2D().scaleNonUniform(1, ry / rx).rotate(th1);
    var m2 = new Matrix2D().scaleNonUniform(1, ry / rx).rotate(th1 + dth);

    th1 = (vx.angleBetween(vx.transform(m1)) + pi2) % pi2;
    dth = vx.transform(m1).angleBetween(vx.transform(m2));
    dth = (wasBig ? pi2 - Math.abs(dth) : Math.abs(dth)) * (wasNeg ? -1 : 1);
    var m3 = new Matrix2D().rotate(phi).multiply(m1);

    for (var i = 0, p, a; i < intersection.points.length; i++) {
        p = intersection.points[i];
        a = vx.transform(m3).angleBetween(Vector2D$1.fromPoints(c, (mp) ? p.transform(mp) : p));
        if (dth >= 0) {
            a = (a + 2 * pi2) % pi2;
            if (a <= dth)
                np.push(p);
        } else {
            a = (a - 2 * pi2) % pi2;
            if (a >= dth)
                np.push(p);
        }
    }
    intersection.points = np;
    return intersection;
}

/**
    points1 will be modified, points close (almost identical) to any point in points2 will be removed

    @param {Array<Point2D>} points1 - will be modified, points close to any point in points2 will be removed
    @param {Array<Point2D>} points2
*/
function removeClosePoints(points1, points2) {
    if (points1.length === 0 || points2.length === 0)
        return;
    var maxf = function (p, v) { if (p < v.x) p = v.x; if (p < v.y) p = v.y; return p; };
    var max = points1.reduce(maxf, 0);
    max = points2.reduce(maxf, max);
    var ERRF = 1e-15;
    var ZEROepsilon = 100 * max * ERRF * Math.SQRT2;
    var j;
    for (var i = 0; i < points1.length;) {
        for (j = 0; j < points2.length; j++) {
            if (points1[i].distanceFrom(points2[j]) <= ZEROepsilon) {
                points1.splice(i, 1);
                break;
            }
        }
        if (j == points2.length)
            i++;
    }
}

// The basic intersection functions for all SVG shapes expect bezier curves
// If you need to support bezier curves, plug in the functions/bezier module
// like this: intersect.plugin( require('svg-intersections/lib/functions/bezier') )
var intersectionFunctions = {
            
    /**
        intersectPathShape

        @param {IntersectionParams} path
        @param {IntersectionParams} shape
        @param {Matrix2D} [m1]
        @param {Matrix2D} [m2]
        @returns {Intersection}
    */
    intersectPathShape: function (path, shape, m1, m2) {
        var result = new Intersection();
        var pathParams = path.params[0];
        var inter0;
        var previnter;
        for (var inter, i = 0; i < pathParams.length; i++) {
            inter = intersect$1(pathParams[i], shape, m1, m2);
            if (!inter0)
                inter0 = inter;
            if (previnter) {
                removeClosePoints(previnter.points, inter.points);
                result.appendPoints(previnter.points);
            }
            previnter = inter;
        }
        if (previnter) {
            result.appendPoints(previnter.points);
        }
        return result;
    },


    /**
        intersectLinesShape

        @param {IntersectionParams} lines - IntersectionParams with points as first parameter (like types RECT, POLYLINE or POLYGON)
        @param {IntersectionParams} shape - IntersectionParams of other shape
        @param {Matrix2D} [m1]
        @param {Matrix2D} [m2]
        @param {Boolean} [closed] - if set, determines if line between first and last point will be taken into callculation too. If not set, it's true for RECT and POLYGON, false for other <b>lines</b> types.
        @returns {Intersection}
    */
    intersectLinesShape: function (lines, shape, m1, m2, closed) {
        var IPTYPE = IntersectionParams.TYPE;
        var line_points = lines.params[0];
        var ip = new IntersectionParams(IPTYPE.LINE, [0, 0]);
        var result = new Intersection();
        var inter, i;
        var intersectLine = function (i1, i2) {
            ip.params[0] = line_points[i1];
            ip.params[1] = line_points[i2];
            inter = intersect$1(ip, shape, m1, m2);
            removeClosePoints(inter.points, [line_points[i2]]);
            result.appendPoints(inter.points);
        };
        for (i = 0; i < line_points.length - 1; i++) {
            intersectLine(i, i + 1);
        }
        if (typeof closed !== 'undefined' && closed || lines.type === IPTYPE.RECT || lines.type === IPTYPE.POLYGON) {
            intersectLine(line_points.length - 1, 0);
        }
        return result;
    },

    ///////////////////////////////////////////////////////////////////
    /**
        intersectArcShape

        @param {IntersectionParams} arc
        @param {IntersectionParams} shape
        @param {Matrix2D} [m1]
        @param {Matrix2D} [m2]
        @returns {Intersection}
    */
    intersectArcShape: function (arc, shape, m1, m2) {
        m1 = m1 || Matrix2D.IDENTITY;
        m2 = m2 || Matrix2D.IDENTITY;
        var c1 = arc.params[0],
            rx1 = arc.params[1],
            ry1 = arc.params[2],
            phi1 = arc.params[3],
            th1 = arc.params[4],
            dth1 = arc.params[5];

        var res;
        if (m1.isIdentity() && phi1 === 0) {
            res = intersect$1(IntersectionParams.newEllipse(c1, rx1, ry1), shape, m1, m2);
        }
        else {
            m1 = m1.multiply(Matrix2D.IDENTITY.translate(c1.x, c1.y).rotate(phi1));
            c1 = new Point2D(0, 0);
            phi1 = 0;
            res = intersect$1(IntersectionParams.newEllipse(c1, rx1, ry1), shape, m1, m2);
        }
        res = removePointsNotInArc(res, c1, rx1, ry1, phi1, th1, dth1, m1);
        return res;
    },

    /**
     *  Finds intersection points of two ellipses. <br/>
     *
     *  This code is based on MgcIntr2DElpElp.cpp written by David Eberly. His
     *  code along with many other excellent examples are avaiable at his site:
     *  http://www.geometrictools.com
     *
     *  Changes - 2015 Robert Benko (Quazistax)
     *
     *  @param {Point2D} c1
     *  @param {Number} rx1
     *  @param {Number} ry1
     *  @param {Point2D} c2
     *  @param {Number} rx2
     *  @param {Number} ry2
     *  @returns {Intersection}
     */
    intersectEllipseEllipse: function (c1, rx1, ry1, c2, rx2, ry2) {
        var a = [
            ry1 * ry1, 0, rx1 * rx1, -2 * ry1 * ry1 * c1.x, -2 * rx1 * rx1 * c1.y,
            ry1 * ry1 * c1.x * c1.x + rx1 * rx1 * c1.y * c1.y - rx1 * rx1 * ry1 * ry1
        ];
        var b = [
            ry2 * ry2, 0, rx2 * rx2, -2 * ry2 * ry2 * c2.x, -2 * rx2 * rx2 * c2.y,
            ry2 * ry2 * c2.x * c2.x + rx2 * rx2 * c2.y * c2.y - rx2 * rx2 * ry2 * ry2
        ];

        var yPoly = bezout(a, b);
        var yRoots = yPoly.getRoots();
        var epsilon = 1e-3;
        var norm0 = (a[0] * a[0] + 2 * a[1] * a[1] + a[2] * a[2]) * epsilon;
        var norm1 = (b[0] * b[0] + 2 * b[1] * b[1] + b[2] * b[2]) * epsilon;
        var result = new Intersection();

        var i;
        //Handling root calculation error causing not detecting intersection
        var clip = function (val, min, max) { return Math.max(min, Math.min(max, val)); };
        for (i = 0 ; i < yRoots.length; i++) {
            yRoots[i] = clip(yRoots[i], c1.y - ry1, c1.y + ry1);
            yRoots[i] = clip(yRoots[i], c2.y - ry2, c2.y + ry2);
        }

        //For detection of multiplicated intersection points
        yRoots.sort(function (a, b) { return a - b; });
        var rootPointsN = [];

        for (var y = 0; y < yRoots.length; y++) {
            var xPoly = new Polynomial(
                a[0],
                a[3] + yRoots[y] * a[1],
                a[5] + yRoots[y] * (a[4] + yRoots[y] * a[2])
            );
            var ERRF = 1e-15;
            if (Math.abs(xPoly.coefs[0]) < 10 * ERRF * Math.abs(xPoly.coefs[2]))
                xPoly.coefs[0] = 0;
            var xRoots = xPoly.getRoots();

            rootPointsN.push(0);
            for (var x = 0; x < xRoots.length; x++) {
                var test =
                    (a[0] * xRoots[x] + a[1] * yRoots[y] + a[3]) * xRoots[x] +
                    (a[2] * yRoots[y] + a[4]) * yRoots[y] + a[5];
                if (Math.abs(test) < norm0) {
                    test =
                        (b[0] * xRoots[x] + b[1] * yRoots[y] + b[3]) * xRoots[x] +
                        (b[2] * yRoots[y] + b[4]) * yRoots[y] + b[5];
                    if (Math.abs(test) < norm1) {
                        result.appendPoint(new Point2D(xRoots[x], yRoots[y]));
                        rootPointsN[y] += 1;
                    }
                }
            }
        }

        if (result.points.length <= 0)
            return result;

        //Removal of multiplicated intersection points
        var pts = result.points;
        if (pts.length == 8) {
            pts = pts.splice(0, 6);
            pts.splice(2, 2);
        }
        else if (pts.length == 7) {
            pts = pts.splice(0, 6);
            pts.splice(2, 2);
            pts.splice(rootPointsN.indexOf(1), 1);
        }
        else if (pts.length == 6) {
            pts.splice(2, 2);
            //console.log('ElEl 6pts: N: ' + rootPointsN.toString());
            if (rootPointsN.indexOf(0) > -1) {
                if (pts[0].distanceFrom(pts[1]) < pts[2].distanceFrom(pts[3])) {
                    pts.splice(0, 1);
                }
                else {
                    pts.splice(2, 1);
                }
            }
            else if (rootPointsN[0] == rootPointsN[3]) {
                pts.splice(1, 2);
            }
        }
        else if (pts.length == 4) {
            if (
                (yRoots.length == 2)
            || (yRoots.length == 4 && (rootPointsN[0] == 2 && rootPointsN[1] == 2 || rootPointsN[2] == 2 && rootPointsN[3] == 2))
            ) {
                pts.splice(2, 2);
            }
        }
        else if (pts.length == 3 || pts.length == 5) {
            i = rootPointsN.indexOf(2);
            if (i > -1) {
                if (pts.length == 3)
                    i = i % 2;
                var ii = i + (i % 2 ? -1 : 2);
                var d1, d2, d3;
                d1 = pts[i].distanceFrom(pts[i + 1]);
                d2 = pts[i].distanceFrom(pts[ii]);
                d3 = pts[i + 1].distanceFrom(pts[ii]);
                if (d1 < d2 && d1 < d3) {
                    pts.splice(i, 1);
                }
                else {
                    pts.splice(ii, 1);
                }
            }
        }

        var poly = yPoly;
        var ZEROepsilon = yPoly.zeroErrorEstimate();
        ZEROepsilon *= 100 * Math.SQRT2;
        for (i = 0; i < pts.length - 1;) {
            if (pts[i].distanceFrom(pts[i + 1]) < ZEROepsilon) {
                pts.splice(i + 1, 1);
                continue;
            }
            i++;
        }

        result.points = pts;
        return result;
    },


    /**
     *  intersectEllipseLine
     *
     *  NOTE: Rotation will need to be added to this function
     *
     *  @param {Point2D} c
     *  @param {Number} rx
     *  @param {Number} ry
     *  @param {Point2D} a1
     *  @param {Point2D} a2
     *  @returns {Intersection}
     */
    intersectEllipseLine: function(c, rx, ry, a1, a2) {
        var result;
        var origin = new Vector2D$1(a1.x, a1.y);
        var dir    = Vector2D$1.fromPoints(a1, a2);
        var center = new Vector2D$1(c.x, c.y);
        var diff   = origin.subtract(center);
        var mDir   = new Vector2D$1( dir.x/(rx*rx),  dir.y/(ry*ry)  );
        var mDiff  = new Vector2D$1( diff.x/(rx*rx), diff.y/(ry*ry) );

        var a = dir.dot(mDir);
        var b = dir.dot(mDiff);
        var c = diff.dot(mDiff) - 1.0;
        var d = b*b - a*c;

        var ERRF = 1e-15;
        var ZEROepsilon = 10 * Math.max(Math.abs(a), Math.abs(b), Math.abs(c)) * ERRF;
        if (Math.abs(d) < ZEROepsilon) {
            d = 0;
        }

        if ( d < 0 ) {
            result = new Intersection("Outside");
        } else if ( d > 0 ) {
            var root = Math.sqrt(d);
            var t_a  = (-b - root) / a;
            var t_b  = (-b + root) / a;

            t_b = (t_b > 1) ? t_b - ERRF : (t_b < 0) ? t_b + ERRF : t_b;
            t_a = (t_a > 1) ? t_a - ERRF : (t_a < 0) ? t_a + ERRF : t_a;

            if ( (t_a < 0 || 1 < t_a) && (t_b < 0 || 1 < t_b) ) {
                if ( (t_a < 0 && t_b < 0) || (t_a > 1 && t_b > 1) )
                    result = new Intersection("Outside");
                else
                    result = new Intersection("Inside");
            } else {
                result = new Intersection();
                if ( 0 <= t_a && t_a <= 1 )
                    result.appendPoint( a1.lerp(a2, t_a) );
                if ( 0 <= t_b && t_b <= 1 )
                    result.appendPoint( a1.lerp(a2, t_b) );
            }
        } else {
            var t = -b/a;
            if ( 0 <= t && t <= 1 ) {
                result = new Intersection();
                result.appendPoint( a1.lerp(a2, t) );
            } else {
                result = new Intersection("Outside");
            }
        }

        return result;
    },


    /**
     *  intersectLineLine
     *
     *  @param {Point2D} a1
     *  @param {Point2D} a2
     *  @param {Point2D} b1
     *  @param {Point2D} b2
     *  @returns {Intersection}
     */
    intersectLineLine: function(a1, a2, b1, b2) {
        var result;
        var ua_t = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);
        var ub_t = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x);
        var u_b  = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);

        if ( u_b !== 0 ) {
            var ua = ua_t / u_b;
            var ub = ub_t / u_b;

            if ( 0 <= ua && ua <= 1 && 0 <= ub && ub <= 1 ) {
                result = new Intersection();
                result.points.push(
                    new Point2D(
                        a1.x + ua * (a2.x - a1.x),
                        a1.y + ua * (a2.y - a1.y)
                    )
                );
            } else {
                result = new Intersection();
            }
        } else {
            if ( ua_t === 0 || ub_t === 0 ) {
                result = new Intersection("Coincident");
            } else {
                result = new Intersection("Parallel");
            }
        }

        return result;
    },


    /**
     *  intersectRayRay
     *
     *  @param {Point2D} a1
     *  @param {Point2D} a2
     *  @param {Point2D} b1
     *  @param {Point2D} b2
     *  @returns {Intersection}
     */
    intersectRayRay: function(a1, a2, b1, b2) {
        var result;

        var ua_t = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);
        var ub_t = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x);
        var u_b  = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);

        if ( u_b !== 0 ) {
            var ua = ua_t / u_b;

            result = new Intersection();
            result.points.push(
                new Point2D(
                    a1.x + ua * (a2.x - a1.x),
                    a1.y + ua * (a2.y - a1.y)
                )
            );
        } else {
            if ( ua_t === 0 || ub_t === 0 ) {
                result = new Intersection("Coincident");
            } else {
                result = new Intersection("Parallel");
            }
        }

        return result;
    }
};

var composedShapeMethods = {};
composedShapeMethods[IPTYPE.PATH] = intersectionFunctions.intersectPathShape;
composedShapeMethods[IPTYPE.POLYLINE] = intersectionFunctions.intersectLinesShape;
composedShapeMethods[IPTYPE.POLYGON] = intersectionFunctions.intersectLinesShape;
composedShapeMethods[IPTYPE.RECT] = intersectionFunctions.intersectLinesShape;
composedShapeMethods[IPTYPE.ROUNDRECT] = intersectionFunctions.intersectPathShape;
composedShapeMethods[IPTYPE.ARC] = intersectionFunctions.intersectArcShape;



function intersect$1(shape1, shape2, m1, m2) {
    var ip1 = shape1;
    var ip2 = shape2;
    var result;

    if (ip1 !== null && ip2 !== null) {
        var method;
        if (method = composedShapeMethods[ip1.type]) {
            result = method(ip1, ip2, m1, m2);
        }
        else if (method = composedShapeMethods[ip2.type]) {
            result = method(ip2, ip1, m2, m1);
        }
        else {
            var params;

            var params1, params2, type1, type2;

            if (ip1.type === IPTYPE.CIRCLE) {
                params1 = [ip1.params[0], ip1.params[1], ip1.params[1]];
                type1 = IPTYPE.ELLIPSE;
            }
            else {
                params1 = ip1.params.slice();
                type1 = ip1.type;
            }

            if (ip2.type === IPTYPE.CIRCLE) {
                params2 = [ip2.params[0], ip2.params[1], ip2.params[1]];
                type2 = IPTYPE.ELLIPSE;
            }
            else {
                params2 = ip2.params.slice();
                type2 = ip2.type;
            }

            //var m1 = new Matrix2D(), m2 = new Matrix2D();
            var SMF = 1;
            var itm;
            var useCTM = (m1 instanceof Matrix2D && m2 instanceof Matrix2D);// && (!m1.isIdentity() || !m2.isIdentity()));
            if (useCTM) {
                if (type1 === IPTYPE.ELLIPSE && type2 === IPTYPE.ELLIPSE) {
                    var m1_, m2_;
                    var d2;
                    var c1 = params1[0], rx1 = params1[1], ry1 = params1[2];
                    var c2 = params2[0], rx2 = params2[1], ry2 = params2[2];

                    m1 = m1.multiply(Matrix2D.IDENTITY.translate(c1.x, c1.y).scaleNonUniform(rx1 / SMF, ry1 / SMF));
                    c1 = new Point2D(0, 0);
                    rx1 = ry1 = SMF;

                    m2 = m2.multiply(Matrix2D.IDENTITY.translate(c2.x, c2.y).scaleNonUniform(rx2, ry2));
                    c2 = new Point2D(0, 0);
                    rx2 = ry2 = 1;

                    d2 = m1.inverse().multiply(m2).getDecompositionTRSR();
                    m1_ = d2.R.inverse().multiply(d2.T.inverse());
                    m2_ = d2.S;

                    rx2 = m2_.a;
                    ry2 = m2_.d;
                    c1 = c1.transform(m1_);
                    itm = m1.multiply(m1_.inverse());

                    params1[0] = c1;
                    params1[1] = rx1;
                    params1[2] = ry1;
                    params2[0] = c2;
                    params2[1] = rx2;
                    params2[2] = ry2;
                }
                else {
                    var transParams = function (type, params, m) {
                        var transParam = function (i) {
                            params[i] = params[i].transform(m);
                        };

                        if (type === IPTYPE.LINE) {
                            transParam(0);
                            transParam(1);
                        }
                        else if (type === IPTYPE.BEZIER2) {
                            transParam(0);
                            transParam(1);
                            transParam(2);
                        }
                        else if (type === IPTYPE.BEZIER3) {
                            transParam(0);
                            transParam(1);
                            transParam(2);
                            transParam(3);
                        }
                        else {
                            throw new Error('Unknown shape: ' + type);
                        }
                    };

                    if (type2 === IPTYPE.ELLIPSE) {
                        var tmp;
                        tmp = params2; params2 = params1; params1 = tmp;
                        tmp = type2; type2 = type1; type1 = tmp;
                        tmp = m2; m2 = m1; m1 = tmp;
                    }

                    if (type1 === IPTYPE.ELLIPSE) {
                        var c1 = params1[0], rx1 = params1[1], ry1 = params1[2];

                        m1 = m1.multiply(Matrix2D.IDENTITY.translate(c1.x, c1.y).scaleNonUniform(rx1 / SMF, ry1 / SMF));
                        c1 = new Point2D(0, 0);
                        rx1 = ry1 = SMF;

                        m2_ = m1.inverse().multiply(m2);
                        transParams(type2, params2, m2_);

                        itm = m1;

                        params1[0] = c1;
                        params1[1] = rx1;
                        params1[2] = ry1;
                    }
                    else {
                        transParams(type1, params1, m1);
                        transParams(type2, params2, m2);
                        itm = Matrix2D.IDENTITY;
                    }
                }
            }

            if (type1 < type2) {
                method = "intersect" + type1 + type2;
                params = params1.concat(params2);
            } else {
                method = "intersect" + type2 + type1;
                params = params2.concat(params1);
            }

            result = intersectionFunctions[method].apply(null, params);

            if (useCTM) {
                for (var i = 0; i < result.points.length; i++) {
                    result.points[i] = result.points[i].transform(itm);
                }
            }
        }
    } else {
        result = new Intersection();
    }

    return result;
}

intersect$1.plugin = function() {
    for(var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        for(var key in arg) {
            if(arg.hasOwnProperty(key)) {
                intersectionFunctions[key] = arg[key];
            }
        }
    }
};

var intersect_1 = intersect$1;

// expose module classes

var intersect = intersect_1;
var shape = IntersectionParams_1.newShape;

var index = {
	intersect: intersect,
	shape: shape
};

exports['default'] = index;
exports.intersect = intersect;
exports.shape = shape;

}((this.svgIntersections = this.svgIntersections || {}),GLOBAL.kldAffine,GLOBAL.kldPolynomial));

  (function (exports,kldAffine,kldPolynomial) {
'use strict';

kldAffine = 'default' in kldAffine ? kldAffine['default'] : kldAffine;
kldPolynomial = 'default' in kldPolynomial ? kldPolynomial['default'] : kldPolynomial;

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

/**
 *  Intersection
 */
function Intersection(status) {
    this.init(status);
}

/**
 *  init
 *
 *  @param {String} status
 *  @returns {Intersection}
 */
Intersection.prototype.init = function(status) {
    this.status = status;
    this.points = [];
};

/**
 *  appendPoint
 *
 *  @param {Point2D} point
 */
Intersection.prototype.appendPoint = function(point) {
    this.points.push(point);
};

/**
 *  appendPoints
 *
 *  @param {Array<Point2D>} points
 */
Intersection.prototype.appendPoints = function(points) {
    this.points = this.points.concat(points);
};

var Intersection_1 = Intersection;

var bezier = createCommonjsModule(function (module) {
var Intersection = Intersection_1;

var affine = kldAffine;
var Point2D = affine.Point2D;
var Vector2D = affine.Vector2D;

var Polynomial = kldPolynomial.Polynomial;

function removeMultipleRootsIn01(roots) {
    var ZEROepsilon = 1e-15;
    roots.sort(function (a, b) { return a - b; });
    for (var i = 1; i < roots.length;) {
        if (Math.abs(roots[i] - roots[i - 1]) < ZEROepsilon) {
            roots.splice(i, 1);
        }
        else {
            i++;
        }
    }
}

module.exports = {};


/**
 *  intersectBezier2Bezier2
 *
 *  @param {Point2D} a1
 *  @param {Point2D} a2
 *  @param {Point2D} a3
 *  @param {Point2D} b1
 *  @param {Point2D} b2
 *  @param {Point2D} b3
 *  @returns {Intersection}
 */
module.exports.intersectBezier2Bezier2 = function(a1, a2, a3, b1, b2, b3) {
    var a, b;
    var c12, c11, c10;
    var c22, c21, c20;
    var result = new Intersection();
    var poly;

    a = a2.multiply(-2);
    c12 = a1.add(a.add(a3));

    a = a1.multiply(-2);
    b = a2.multiply(2);
    c11 = a.add(b);

    c10 = new Point2D(a1.x, a1.y);

    a = b2.multiply(-2);
    c22 = b1.add(a.add(b3));

    a = b1.multiply(-2);
    b = b2.multiply(2);
    c21 = a.add(b);

    c20 = new Point2D(b1.x, b1.y);

    var v0, v1, v2, v3, v4, v5, v6;
    if ( c12.y === 0 ) {
        v0 = c12.x*(c10.y - c20.y);
        v1 = v0 - c11.x*c11.y;
        v2 = v0 + v1;
        v3 = c11.y*c11.y;

        poly = new Polynomial(
            c12.x*c22.y*c22.y,
            2*c12.x*c21.y*c22.y,
            c12.x*c21.y*c21.y - c22.x*v3 - c22.y*v0 - c22.y*v1,
            -c21.x*v3 - c21.y*v0 - c21.y*v1,
            (c10.x - c20.x)*v3 + (c10.y - c20.y)*v1
        );
    } else {
        v0 = c12.x*c22.y - c12.y*c22.x;
        v1 = c12.x*c21.y - c21.x*c12.y;
        v2 = c11.x*c12.y - c11.y*c12.x;
        v3 = c10.y - c20.y;
        v4 = c12.y*(c10.x - c20.x) - c12.x*v3;
        v5 = -c11.y*v2 + c12.y*v4;
        v6 = v2*v2;

        poly = new Polynomial(
            v0*v0,
            2*v0*v1,
            (-c22.y*v6 + c12.y*v1*v1 + c12.y*v0*v4 + v0*v5) / c12.y,
            (-c21.y*v6 + c12.y*v1*v4 + v1*v5) / c12.y,
            (v3*v6 + v4*v5) / c12.y
        );
    }

    var roots = poly.getRoots();
    for ( var i = 0; i < roots.length; i++ ) {
        var s = roots[i];

        if ( 0 <= s && s <= 1 ) {
            var xRoots = new Polynomial(
                c12.x,
                c11.x,
                c10.x - c20.x - s*c21.x - s*s*c22.x
            ).getRoots();
            var yRoots = new Polynomial(
                c12.y,
                c11.y,
                c10.y - c20.y - s*c21.y - s*s*c22.y
            ).getRoots();

            if ( xRoots.length > 0 && yRoots.length > 0 ) {
                var TOLERANCE = 1e-4;

                checkRoots:
                    for ( var j = 0; j < xRoots.length; j++ ) {
                        var xRoot = xRoots[j];

                        if ( 0 <= xRoot && xRoot <= 1 ) {
                            for ( var k = 0; k < yRoots.length; k++ ) {
                                if ( Math.abs( xRoot - yRoots[k] ) < TOLERANCE ) {
                                    result.points.push( c22.multiply(s*s).add(c21.multiply(s).add(c20)) );
                                    break checkRoots;
                                }
                            }
                        }
                    }
            }
        }
    }

    return result;
};


/**
 *  intersectBezier2Bezier3
 *
 *  @param {Point2D} a1
 *  @param {Point2D} a2
 *  @param {Point2D} a3
 *  @param {Point2D} b1
 *  @param {Point2D} b2
 *  @param {Point2D} b3
 *  @param {Point2D} b4
 *  @returns {Intersection}
 */
module.exports.intersectBezier2Bezier3 = function(a1, a2, a3, b1, b2, b3, b4) {
    var a, b,c, d;
    var c12, c11, c10;
    var c23, c22, c21, c20;
    var result = new Intersection();

    a = a2.multiply(-2);
    c12 = a1.add(a.add(a3));

    a = a1.multiply(-2);
    b = a2.multiply(2);
    c11 = a.add(b);

    c10 = new Point2D(a1.x, a1.y);

    a = b1.multiply(-1);
    b = b2.multiply(3);
    c = b3.multiply(-3);
    d = a.add(b.add(c.add(b4)));
    c23 = new Vector2D(d.x, d.y);

    a = b1.multiply(3);
    b = b2.multiply(-6);
    c = b3.multiply(3);
    d = a.add(b.add(c));
    c22 = new Vector2D(d.x, d.y);

    a = b1.multiply(-3);
    b = b2.multiply(3);
    c = a.add(b);
    c21 = new Vector2D(c.x, c.y);

    c20 = new Vector2D(b1.x, b1.y);

    var c10x2 = c10.x*c10.x;
    var c10y2 = c10.y*c10.y;
    var c11x2 = c11.x*c11.x;
    var c11y2 = c11.y*c11.y;
    var c12x2 = c12.x*c12.x;
    var c12y2 = c12.y*c12.y;
    var c20x2 = c20.x*c20.x;
    var c20y2 = c20.y*c20.y;
    var c21x2 = c21.x*c21.x;
    var c21y2 = c21.y*c21.y;
    var c22x2 = c22.x*c22.x;
    var c22y2 = c22.y*c22.y;
    var c23x2 = c23.x*c23.x;
    var c23y2 = c23.y*c23.y;

    var poly = new Polynomial(
        -2*c12.x*c12.y*c23.x*c23.y + c12x2*c23y2 + c12y2*c23x2,
        -2*c12.x*c12.y*c22.x*c23.y - 2*c12.x*c12.y*c22.y*c23.x + 2*c12y2*c22.x*c23.x +
            2*c12x2*c22.y*c23.y,
        -2*c12.x*c21.x*c12.y*c23.y - 2*c12.x*c12.y*c21.y*c23.x - 2*c12.x*c12.y*c22.x*c22.y +
            2*c21.x*c12y2*c23.x + c12y2*c22x2 + c12x2*(2*c21.y*c23.y + c22y2),
        2*c10.x*c12.x*c12.y*c23.y + 2*c10.y*c12.x*c12.y*c23.x + c11.x*c11.y*c12.x*c23.y +
            c11.x*c11.y*c12.y*c23.x - 2*c20.x*c12.x*c12.y*c23.y - 2*c12.x*c20.y*c12.y*c23.x -
            2*c12.x*c21.x*c12.y*c22.y - 2*c12.x*c12.y*c21.y*c22.x - 2*c10.x*c12y2*c23.x -
            2*c10.y*c12x2*c23.y + 2*c20.x*c12y2*c23.x + 2*c21.x*c12y2*c22.x -
            c11y2*c12.x*c23.x - c11x2*c12.y*c23.y + c12x2*(2*c20.y*c23.y + 2*c21.y*c22.y),
        2*c10.x*c12.x*c12.y*c22.y + 2*c10.y*c12.x*c12.y*c22.x + c11.x*c11.y*c12.x*c22.y +
            c11.x*c11.y*c12.y*c22.x - 2*c20.x*c12.x*c12.y*c22.y - 2*c12.x*c20.y*c12.y*c22.x -
            2*c12.x*c21.x*c12.y*c21.y - 2*c10.x*c12y2*c22.x - 2*c10.y*c12x2*c22.y +
            2*c20.x*c12y2*c22.x - c11y2*c12.x*c22.x - c11x2*c12.y*c22.y + c21x2*c12y2 +
            c12x2*(2*c20.y*c22.y + c21y2),
        2*c10.x*c12.x*c12.y*c21.y + 2*c10.y*c12.x*c21.x*c12.y + c11.x*c11.y*c12.x*c21.y +
            c11.x*c11.y*c21.x*c12.y - 2*c20.x*c12.x*c12.y*c21.y - 2*c12.x*c20.y*c21.x*c12.y -
            2*c10.x*c21.x*c12y2 - 2*c10.y*c12x2*c21.y + 2*c20.x*c21.x*c12y2 -
            c11y2*c12.x*c21.x - c11x2*c12.y*c21.y + 2*c12x2*c20.y*c21.y,
        -2*c10.x*c10.y*c12.x*c12.y - c10.x*c11.x*c11.y*c12.y - c10.y*c11.x*c11.y*c12.x +
            2*c10.x*c12.x*c20.y*c12.y + 2*c10.y*c20.x*c12.x*c12.y + c11.x*c20.x*c11.y*c12.y +
            c11.x*c11.y*c12.x*c20.y - 2*c20.x*c12.x*c20.y*c12.y - 2*c10.x*c20.x*c12y2 +
            c10.x*c11y2*c12.x + c10.y*c11x2*c12.y - 2*c10.y*c12x2*c20.y -
            c20.x*c11y2*c12.x - c11x2*c20.y*c12.y + c10x2*c12y2 + c10y2*c12x2 +
            c20x2*c12y2 + c12x2*c20y2
    );
    var roots = poly.getRootsInInterval(0,1);
    module.exports.Utils.removeMultipleRootsIn01(roots);

    for ( var i = 0; i < roots.length; i++ ) {
        var s = roots[i];
        var xRoots = new Polynomial(
            c12.x,
            c11.x,
            c10.x - c20.x - s*c21.x - s*s*c22.x - s*s*s*c23.x
        ).getRoots();
        var yRoots = new Polynomial(
            c12.y,
            c11.y,
            c10.y - c20.y - s*c21.y - s*s*c22.y - s*s*s*c23.y
        ).getRoots();

        if ( xRoots.length > 0 && yRoots.length > 0 ) {
            var TOLERANCE = 1e-4;

            checkRoots:
                for ( var j = 0; j < xRoots.length; j++ ) {
                    var xRoot = xRoots[j];

                    if ( 0 <= xRoot && xRoot <= 1 ) {
                        for ( var k = 0; k < yRoots.length; k++ ) {
                            if ( Math.abs( xRoot - yRoots[k] ) < TOLERANCE ) {
                                var v = c23.multiply(s * s * s).add(c22.multiply(s * s).add(c21.multiply(s).add(c20)));
                                result.points.push(new Point2D(v.x, v.y));
                                break checkRoots;
                            }
                        }
                    }
                }
        }
    }

    return result;

};

/**
 *  intersectBezier2Ellipse
 *
 *  @param {Point2D} p1
 *  @param {Point2D} p2
 *  @param {Point2D} p3
 *  @param {Point2D} ec
 *  @param {Number} rx
 *  @param {Number} ry
 *  @returns {Intersection}
 */
module.exports.intersectBezier2Ellipse = function(p1, p2, p3, ec, rx, ry) {
    var a, b;       // temporary variables
    var c2, c1, c0; // coefficients of quadratic
    var result = new Intersection();

    a = p2.multiply(-2);
    c2 = p1.add(a.add(p3));

    a = p1.multiply(-2);
    b = p2.multiply(2);
    c1 = a.add(b);

    c0 = new Point2D(p1.x, p1.y);

    var rxrx  = rx*rx;
    var ryry  = ry*ry;
    var roots = new Polynomial(
        ryry*c2.x*c2.x + rxrx*c2.y*c2.y,
        2*(ryry*c2.x*c1.x + rxrx*c2.y*c1.y),
        ryry*(2*c2.x*c0.x + c1.x*c1.x) + rxrx*(2*c2.y*c0.y+c1.y*c1.y) -
            2*(ryry*ec.x*c2.x + rxrx*ec.y*c2.y),
        2*(ryry*c1.x*(c0.x-ec.x) + rxrx*c1.y*(c0.y-ec.y)),
        ryry*(c0.x*c0.x+ec.x*ec.x) + rxrx*(c0.y*c0.y + ec.y*ec.y) -
            2*(ryry*ec.x*c0.x + rxrx*ec.y*c0.y) - rxrx*ryry
    ).getRoots();

    for ( var i = 0; i < roots.length; i++ ) {
        var t = roots[i];

        if ( 0 <= t && t <= 1 )
            result.points.push( c2.multiply(t*t).add(c1.multiply(t).add(c0)) );
    }

    return result;
};


/**
 *  intersectBezier2Line
 *
 *  @param {Point2D} p1
 *  @param {Point2D} p2
 *  @param {Point2D} p3
 *  @param {Point2D} a1
 *  @param {Point2D} a2
 *  @returns {Intersection}
 */
module.exports.intersectBezier2Line = function(p1, p2, p3, a1, a2) {
    var a, b;             // temporary variables
    var c2, c1, c0;       // coefficients of quadratic
    var cl;               // c coefficient for normal form of line
    var n;                // normal for normal form of line
    var min = a1.min(a2); // used to determine if point is on line segment
    var max = a1.max(a2); // used to determine if point is on line segment
    var result = new Intersection();

    a = p2.multiply(-2);
    c2 = p1.add(a.add(p3));

    a = p1.multiply(-2);
    b = p2.multiply(2);
    c1 = a.add(b);

    c0 = new Point2D(p1.x, p1.y);

    // Convert line to normal form: ax + by + c = 0
    // Find normal to line: negative inverse of original line's slope
    n = new Vector2D(a1.y - a2.y, a2.x - a1.x);

    // Determine new c coefficient
    cl = a1.x*a2.y - a2.x*a1.y;

    // Transform cubic coefficients to line's coordinate system and find roots
    // of cubic
    roots = new Polynomial(
        n.dot(c2),
        n.dot(c1),
        n.dot(c0) + cl
    ).getRoots();

    // Any roots in closed interval [0,1] are intersections on Bezier, but
    // might not be on the line segment.
    // Find intersections and calculate point coordinates
    for ( var i = 0; i < roots.length; i++ ) {
        var t = roots[i];

        if ( 0 <= t && t <= 1 ) {
            // We're within the Bezier curve
            // Find point on Bezier
            var p4 = p1.lerp(p2, t);
            var p5 = p2.lerp(p3, t);

            var p6 = p4.lerp(p5, t);

            // See if point is on line segment
            // Had to make special cases for vertical and horizontal lines due
            // to slight errors in calculation of p6
            if ( a1.x == a2.x ) {
                if ( min.y <= p6.y && p6.y <= max.y ) {
                    result.appendPoint( p6 );
                }
            } else if ( a1.y == a2.y ) {
                if ( min.x <= p6.x && p6.x <= max.x ) {
                    result.appendPoint( p6 );
                }
            } else if (min.x <= p6.x && p6.x <= max.x && min.y <= p6.y && p6.y <= max.y) {
                result.appendPoint( p6 );
            }
        }
    }

    return result;
};


/**
 *  intersectBezier3Bezier3
 *
 *  @param {Point2D} a1
 *  @param {Point2D} a2
 *  @param {Point2D} a3
 *  @param {Point2D} a4
 *  @param {Point2D} b1
 *  @param {Point2D} b2
 *  @param {Point2D} b3
 *  @param {Point2D} b4
 *  @returns {Intersection}
 */
module.exports.intersectBezier3Bezier3 = function(a1, a2, a3, a4, b1, b2, b3, b4) {
    var a, b, c, d;         // temporary variables
    var c13, c12, c11, c10; // coefficients of cubic
    var c23, c22, c21, c20; // coefficients of cubic
    var result = new Intersection();

    // Calculate the coefficients of cubic polynomial
    a = a1.multiply(-1);
    b = a2.multiply(3);
    c = a3.multiply(-3);
    d = a.add(b.add(c.add(a4)));
    c13 = new Vector2D(d.x, d.y);

    a = a1.multiply(3);
    b = a2.multiply(-6);
    c = a3.multiply(3);
    d = a.add(b.add(c));
    c12 = new Vector2D(d.x, d.y);

    a = a1.multiply(-3);
    b = a2.multiply(3);
    c = a.add(b);
    c11 = new Vector2D(c.x, c.y);

    c10 = new Vector2D(a1.x, a1.y);

    a = b1.multiply(-1);
    b = b2.multiply(3);
    c = b3.multiply(-3);
    d = a.add(b.add(c.add(b4)));
    c23 = new Vector2D(d.x, d.y);

    a = b1.multiply(3);
    b = b2.multiply(-6);
    c = b3.multiply(3);
    d = a.add(b.add(c));
    c22 = new Vector2D(d.x, d.y);

    a = b1.multiply(-3);
    b = b2.multiply(3);
    c = a.add(b);
    c21 = new Vector2D(c.x, c.y);

    c20 = new Vector2D(b1.x, b1.y);

    var c10x2 = c10.x*c10.x;
    var c10x3 = c10.x*c10.x*c10.x;
    var c10y2 = c10.y*c10.y;
    var c10y3 = c10.y*c10.y*c10.y;
    var c11x2 = c11.x*c11.x;
    var c11x3 = c11.x*c11.x*c11.x;
    var c11y2 = c11.y*c11.y;
    var c11y3 = c11.y*c11.y*c11.y;
    var c12x2 = c12.x*c12.x;
    var c12x3 = c12.x*c12.x*c12.x;
    var c12y2 = c12.y*c12.y;
    var c12y3 = c12.y*c12.y*c12.y;
    var c13x2 = c13.x*c13.x;
    var c13x3 = c13.x*c13.x*c13.x;
    var c13y2 = c13.y*c13.y;
    var c13y3 = c13.y*c13.y*c13.y;
    var c20x2 = c20.x*c20.x;
    var c20x3 = c20.x*c20.x*c20.x;
    var c20y2 = c20.y*c20.y;
    var c20y3 = c20.y*c20.y*c20.y;
    var c21x2 = c21.x*c21.x;
    var c21x3 = c21.x*c21.x*c21.x;
    var c21y2 = c21.y*c21.y;
    var c22x2 = c22.x*c22.x;
    var c22x3 = c22.x*c22.x*c22.x;
    var c22y2 = c22.y*c22.y;
    var c23x2 = c23.x*c23.x;
    var c23x3 = c23.x*c23.x*c23.x;
    var c23y2 = c23.y*c23.y;
    var c23y3 = c23.y*c23.y*c23.y;
    var poly = new Polynomial(
        -c13x3*c23y3 + c13y3*c23x3 - 3*c13.x*c13y2*c23x2*c23.y +
            3*c13x2*c13.y*c23.x*c23y2,
        -6*c13.x*c22.x*c13y2*c23.x*c23.y + 6*c13x2*c13.y*c22.y*c23.x*c23.y + 3*c22.x*c13y3*c23x2 -
            3*c13x3*c22.y*c23y2 - 3*c13.x*c13y2*c22.y*c23x2 + 3*c13x2*c22.x*c13.y*c23y2,
        -6*c21.x*c13.x*c13y2*c23.x*c23.y - 6*c13.x*c22.x*c13y2*c22.y*c23.x + 6*c13x2*c22.x*c13.y*c22.y*c23.y +
            3*c21.x*c13y3*c23x2 + 3*c22x2*c13y3*c23.x + 3*c21.x*c13x2*c13.y*c23y2 - 3*c13.x*c21.y*c13y2*c23x2 -
            3*c13.x*c22x2*c13y2*c23.y + c13x2*c13.y*c23.x*(6*c21.y*c23.y + 3*c22y2) + c13x3*(-c21.y*c23y2 -
            2*c22y2*c23.y - c23.y*(2*c21.y*c23.y + c22y2)),
        c11.x*c12.y*c13.x*c13.y*c23.x*c23.y - c11.y*c12.x*c13.x*c13.y*c23.x*c23.y + 6*c21.x*c22.x*c13y3*c23.x +
            3*c11.x*c12.x*c13.x*c13.y*c23y2 + 6*c10.x*c13.x*c13y2*c23.x*c23.y - 3*c11.x*c12.x*c13y2*c23.x*c23.y -
            3*c11.y*c12.y*c13.x*c13.y*c23x2 - 6*c10.y*c13x2*c13.y*c23.x*c23.y - 6*c20.x*c13.x*c13y2*c23.x*c23.y +
            3*c11.y*c12.y*c13x2*c23.x*c23.y - 2*c12.x*c12y2*c13.x*c23.x*c23.y - 6*c21.x*c13.x*c22.x*c13y2*c23.y -
            6*c21.x*c13.x*c13y2*c22.y*c23.x - 6*c13.x*c21.y*c22.x*c13y2*c23.x + 6*c21.x*c13x2*c13.y*c22.y*c23.y +
            2*c12x2*c12.y*c13.y*c23.x*c23.y + c22x3*c13y3 - 3*c10.x*c13y3*c23x2 + 3*c10.y*c13x3*c23y2 +
            3*c20.x*c13y3*c23x2 + c12y3*c13.x*c23x2 - c12x3*c13.y*c23y2 - 3*c10.x*c13x2*c13.y*c23y2 +
            3*c10.y*c13.x*c13y2*c23x2 - 2*c11.x*c12.y*c13x2*c23y2 + c11.x*c12.y*c13y2*c23x2 - c11.y*c12.x*c13x2*c23y2 +
            2*c11.y*c12.x*c13y2*c23x2 + 3*c20.x*c13x2*c13.y*c23y2 - c12.x*c12y2*c13.y*c23x2 -
            3*c20.y*c13.x*c13y2*c23x2 + c12x2*c12.y*c13.x*c23y2 - 3*c13.x*c22x2*c13y2*c22.y +
            c13x2*c13.y*c23.x*(6*c20.y*c23.y + 6*c21.y*c22.y) + c13x2*c22.x*c13.y*(6*c21.y*c23.y + 3*c22y2) +
            c13x3*(-2*c21.y*c22.y*c23.y - c20.y*c23y2 - c22.y*(2*c21.y*c23.y + c22y2) - c23.y*(2*c20.y*c23.y + 2*c21.y*c22.y)),
        6*c11.x*c12.x*c13.x*c13.y*c22.y*c23.y + c11.x*c12.y*c13.x*c22.x*c13.y*c23.y + c11.x*c12.y*c13.x*c13.y*c22.y*c23.x -
            c11.y*c12.x*c13.x*c22.x*c13.y*c23.y - c11.y*c12.x*c13.x*c13.y*c22.y*c23.x - 6*c11.y*c12.y*c13.x*c22.x*c13.y*c23.x -
            6*c10.x*c22.x*c13y3*c23.x + 6*c20.x*c22.x*c13y3*c23.x + 6*c10.y*c13x3*c22.y*c23.y + 2*c12y3*c13.x*c22.x*c23.x -
            2*c12x3*c13.y*c22.y*c23.y + 6*c10.x*c13.x*c22.x*c13y2*c23.y + 6*c10.x*c13.x*c13y2*c22.y*c23.x +
            6*c10.y*c13.x*c22.x*c13y2*c23.x - 3*c11.x*c12.x*c22.x*c13y2*c23.y - 3*c11.x*c12.x*c13y2*c22.y*c23.x +
            2*c11.x*c12.y*c22.x*c13y2*c23.x + 4*c11.y*c12.x*c22.x*c13y2*c23.x - 6*c10.x*c13x2*c13.y*c22.y*c23.y -
            6*c10.y*c13x2*c22.x*c13.y*c23.y - 6*c10.y*c13x2*c13.y*c22.y*c23.x - 4*c11.x*c12.y*c13x2*c22.y*c23.y -
            6*c20.x*c13.x*c22.x*c13y2*c23.y - 6*c20.x*c13.x*c13y2*c22.y*c23.x - 2*c11.y*c12.x*c13x2*c22.y*c23.y +
            3*c11.y*c12.y*c13x2*c22.x*c23.y + 3*c11.y*c12.y*c13x2*c22.y*c23.x - 2*c12.x*c12y2*c13.x*c22.x*c23.y -
            2*c12.x*c12y2*c13.x*c22.y*c23.x - 2*c12.x*c12y2*c22.x*c13.y*c23.x - 6*c20.y*c13.x*c22.x*c13y2*c23.x -
            6*c21.x*c13.x*c21.y*c13y2*c23.x - 6*c21.x*c13.x*c22.x*c13y2*c22.y + 6*c20.x*c13x2*c13.y*c22.y*c23.y +
            2*c12x2*c12.y*c13.x*c22.y*c23.y + 2*c12x2*c12.y*c22.x*c13.y*c23.y + 2*c12x2*c12.y*c13.y*c22.y*c23.x +
            3*c21.x*c22x2*c13y3 + 3*c21x2*c13y3*c23.x - 3*c13.x*c21.y*c22x2*c13y2 - 3*c21x2*c13.x*c13y2*c23.y +
            c13x2*c22.x*c13.y*(6*c20.y*c23.y + 6*c21.y*c22.y) + c13x2*c13.y*c23.x*(6*c20.y*c22.y + 3*c21y2) +
            c21.x*c13x2*c13.y*(6*c21.y*c23.y + 3*c22y2) + c13x3*(-2*c20.y*c22.y*c23.y - c23.y*(2*c20.y*c22.y + c21y2) -
            c21.y*(2*c21.y*c23.y + c22y2) - c22.y*(2*c20.y*c23.y + 2*c21.y*c22.y)),
        c11.x*c21.x*c12.y*c13.x*c13.y*c23.y + c11.x*c12.y*c13.x*c21.y*c13.y*c23.x + c11.x*c12.y*c13.x*c22.x*c13.y*c22.y -
            c11.y*c12.x*c21.x*c13.x*c13.y*c23.y - c11.y*c12.x*c13.x*c21.y*c13.y*c23.x - c11.y*c12.x*c13.x*c22.x*c13.y*c22.y -
            6*c11.y*c21.x*c12.y*c13.x*c13.y*c23.x - 6*c10.x*c21.x*c13y3*c23.x + 6*c20.x*c21.x*c13y3*c23.x +
            2*c21.x*c12y3*c13.x*c23.x + 6*c10.x*c21.x*c13.x*c13y2*c23.y + 6*c10.x*c13.x*c21.y*c13y2*c23.x +
            6*c10.x*c13.x*c22.x*c13y2*c22.y + 6*c10.y*c21.x*c13.x*c13y2*c23.x - 3*c11.x*c12.x*c21.x*c13y2*c23.y -
            3*c11.x*c12.x*c21.y*c13y2*c23.x - 3*c11.x*c12.x*c22.x*c13y2*c22.y + 2*c11.x*c21.x*c12.y*c13y2*c23.x +
            4*c11.y*c12.x*c21.x*c13y2*c23.x - 6*c10.y*c21.x*c13x2*c13.y*c23.y - 6*c10.y*c13x2*c21.y*c13.y*c23.x -
            6*c10.y*c13x2*c22.x*c13.y*c22.y - 6*c20.x*c21.x*c13.x*c13y2*c23.y - 6*c20.x*c13.x*c21.y*c13y2*c23.x -
            6*c20.x*c13.x*c22.x*c13y2*c22.y + 3*c11.y*c21.x*c12.y*c13x2*c23.y - 3*c11.y*c12.y*c13.x*c22x2*c13.y +
            3*c11.y*c12.y*c13x2*c21.y*c23.x + 3*c11.y*c12.y*c13x2*c22.x*c22.y - 2*c12.x*c21.x*c12y2*c13.x*c23.y -
            2*c12.x*c21.x*c12y2*c13.y*c23.x - 2*c12.x*c12y2*c13.x*c21.y*c23.x - 2*c12.x*c12y2*c13.x*c22.x*c22.y -
            6*c20.y*c21.x*c13.x*c13y2*c23.x - 6*c21.x*c13.x*c21.y*c22.x*c13y2 + 6*c20.y*c13x2*c21.y*c13.y*c23.x +
            2*c12x2*c21.x*c12.y*c13.y*c23.y + 2*c12x2*c12.y*c21.y*c13.y*c23.x + 2*c12x2*c12.y*c22.x*c13.y*c22.y -
            3*c10.x*c22x2*c13y3 + 3*c20.x*c22x2*c13y3 + 3*c21x2*c22.x*c13y3 + c12y3*c13.x*c22x2 +
            3*c10.y*c13.x*c22x2*c13y2 + c11.x*c12.y*c22x2*c13y2 + 2*c11.y*c12.x*c22x2*c13y2 -
            c12.x*c12y2*c22x2*c13.y - 3*c20.y*c13.x*c22x2*c13y2 - 3*c21x2*c13.x*c13y2*c22.y +
            c12x2*c12.y*c13.x*(2*c21.y*c23.y + c22y2) + c11.x*c12.x*c13.x*c13.y*(6*c21.y*c23.y + 3*c22y2) +
            c21.x*c13x2*c13.y*(6*c20.y*c23.y + 6*c21.y*c22.y) + c12x3*c13.y*(-2*c21.y*c23.y - c22y2) +
            c10.y*c13x3*(6*c21.y*c23.y + 3*c22y2) + c11.y*c12.x*c13x2*(-2*c21.y*c23.y - c22y2) +
            c11.x*c12.y*c13x2*(-4*c21.y*c23.y - 2*c22y2) + c10.x*c13x2*c13.y*(-6*c21.y*c23.y - 3*c22y2) +
            c13x2*c22.x*c13.y*(6*c20.y*c22.y + 3*c21y2) + c20.x*c13x2*c13.y*(6*c21.y*c23.y + 3*c22y2) +
            c13x3*(-2*c20.y*c21.y*c23.y - c22.y*(2*c20.y*c22.y + c21y2) - c20.y*(2*c21.y*c23.y + c22y2) -
            c21.y*(2*c20.y*c23.y + 2*c21.y*c22.y)),
        -c10.x*c11.x*c12.y*c13.x*c13.y*c23.y + c10.x*c11.y*c12.x*c13.x*c13.y*c23.y + 6*c10.x*c11.y*c12.y*c13.x*c13.y*c23.x -
            6*c10.y*c11.x*c12.x*c13.x*c13.y*c23.y - c10.y*c11.x*c12.y*c13.x*c13.y*c23.x + c10.y*c11.y*c12.x*c13.x*c13.y*c23.x +
            c11.x*c11.y*c12.x*c12.y*c13.x*c23.y - c11.x*c11.y*c12.x*c12.y*c13.y*c23.x + c11.x*c20.x*c12.y*c13.x*c13.y*c23.y +
            c11.x*c20.y*c12.y*c13.x*c13.y*c23.x + c11.x*c21.x*c12.y*c13.x*c13.y*c22.y + c11.x*c12.y*c13.x*c21.y*c22.x*c13.y -
            c20.x*c11.y*c12.x*c13.x*c13.y*c23.y - 6*c20.x*c11.y*c12.y*c13.x*c13.y*c23.x - c11.y*c12.x*c20.y*c13.x*c13.y*c23.x -
            c11.y*c12.x*c21.x*c13.x*c13.y*c22.y - c11.y*c12.x*c13.x*c21.y*c22.x*c13.y - 6*c11.y*c21.x*c12.y*c13.x*c22.x*c13.y -
            6*c10.x*c20.x*c13y3*c23.x - 6*c10.x*c21.x*c22.x*c13y3 - 2*c10.x*c12y3*c13.x*c23.x + 6*c20.x*c21.x*c22.x*c13y3 +
            2*c20.x*c12y3*c13.x*c23.x + 2*c21.x*c12y3*c13.x*c22.x + 2*c10.y*c12x3*c13.y*c23.y - 6*c10.x*c10.y*c13.x*c13y2*c23.x +
            3*c10.x*c11.x*c12.x*c13y2*c23.y - 2*c10.x*c11.x*c12.y*c13y2*c23.x - 4*c10.x*c11.y*c12.x*c13y2*c23.x +
            3*c10.y*c11.x*c12.x*c13y2*c23.x + 6*c10.x*c10.y*c13x2*c13.y*c23.y + 6*c10.x*c20.x*c13.x*c13y2*c23.y -
            3*c10.x*c11.y*c12.y*c13x2*c23.y + 2*c10.x*c12.x*c12y2*c13.x*c23.y + 2*c10.x*c12.x*c12y2*c13.y*c23.x +
            6*c10.x*c20.y*c13.x*c13y2*c23.x + 6*c10.x*c21.x*c13.x*c13y2*c22.y + 6*c10.x*c13.x*c21.y*c22.x*c13y2 +
            4*c10.y*c11.x*c12.y*c13x2*c23.y + 6*c10.y*c20.x*c13.x*c13y2*c23.x + 2*c10.y*c11.y*c12.x*c13x2*c23.y -
            3*c10.y*c11.y*c12.y*c13x2*c23.x + 2*c10.y*c12.x*c12y2*c13.x*c23.x + 6*c10.y*c21.x*c13.x*c22.x*c13y2 -
            3*c11.x*c20.x*c12.x*c13y2*c23.y + 2*c11.x*c20.x*c12.y*c13y2*c23.x + c11.x*c11.y*c12y2*c13.x*c23.x -
            3*c11.x*c12.x*c20.y*c13y2*c23.x - 3*c11.x*c12.x*c21.x*c13y2*c22.y - 3*c11.x*c12.x*c21.y*c22.x*c13y2 +
            2*c11.x*c21.x*c12.y*c22.x*c13y2 + 4*c20.x*c11.y*c12.x*c13y2*c23.x + 4*c11.y*c12.x*c21.x*c22.x*c13y2 -
            2*c10.x*c12x2*c12.y*c13.y*c23.y - 6*c10.y*c20.x*c13x2*c13.y*c23.y - 6*c10.y*c20.y*c13x2*c13.y*c23.x -
            6*c10.y*c21.x*c13x2*c13.y*c22.y - 2*c10.y*c12x2*c12.y*c13.x*c23.y - 2*c10.y*c12x2*c12.y*c13.y*c23.x -
            6*c10.y*c13x2*c21.y*c22.x*c13.y - c11.x*c11.y*c12x2*c13.y*c23.y - 2*c11.x*c11y2*c13.x*c13.y*c23.x +
            3*c20.x*c11.y*c12.y*c13x2*c23.y - 2*c20.x*c12.x*c12y2*c13.x*c23.y - 2*c20.x*c12.x*c12y2*c13.y*c23.x -
            6*c20.x*c20.y*c13.x*c13y2*c23.x - 6*c20.x*c21.x*c13.x*c13y2*c22.y - 6*c20.x*c13.x*c21.y*c22.x*c13y2 +
            3*c11.y*c20.y*c12.y*c13x2*c23.x + 3*c11.y*c21.x*c12.y*c13x2*c22.y + 3*c11.y*c12.y*c13x2*c21.y*c22.x -
            2*c12.x*c20.y*c12y2*c13.x*c23.x - 2*c12.x*c21.x*c12y2*c13.x*c22.y - 2*c12.x*c21.x*c12y2*c22.x*c13.y -
            2*c12.x*c12y2*c13.x*c21.y*c22.x - 6*c20.y*c21.x*c13.x*c22.x*c13y2 - c11y2*c12.x*c12.y*c13.x*c23.x +
            2*c20.x*c12x2*c12.y*c13.y*c23.y + 6*c20.y*c13x2*c21.y*c22.x*c13.y + 2*c11x2*c11.y*c13.x*c13.y*c23.y +
            c11x2*c12.x*c12.y*c13.y*c23.y + 2*c12x2*c20.y*c12.y*c13.y*c23.x + 2*c12x2*c21.x*c12.y*c13.y*c22.y +
            2*c12x2*c12.y*c21.y*c22.x*c13.y + c21x3*c13y3 + 3*c10x2*c13y3*c23.x - 3*c10y2*c13x3*c23.y +
            3*c20x2*c13y3*c23.x + c11y3*c13x2*c23.x - c11x3*c13y2*c23.y - c11.x*c11y2*c13x2*c23.y +
            c11x2*c11.y*c13y2*c23.x - 3*c10x2*c13.x*c13y2*c23.y + 3*c10y2*c13x2*c13.y*c23.x - c11x2*c12y2*c13.x*c23.y +
            c11y2*c12x2*c13.y*c23.x - 3*c21x2*c13.x*c21.y*c13y2 - 3*c20x2*c13.x*c13y2*c23.y + 3*c20y2*c13x2*c13.y*c23.x +
            c11.x*c12.x*c13.x*c13.y*(6*c20.y*c23.y + 6*c21.y*c22.y) + c12x3*c13.y*(-2*c20.y*c23.y - 2*c21.y*c22.y) +
            c10.y*c13x3*(6*c20.y*c23.y + 6*c21.y*c22.y) + c11.y*c12.x*c13x2*(-2*c20.y*c23.y - 2*c21.y*c22.y) +
            c12x2*c12.y*c13.x*(2*c20.y*c23.y + 2*c21.y*c22.y) + c11.x*c12.y*c13x2*(-4*c20.y*c23.y - 4*c21.y*c22.y) +
            c10.x*c13x2*c13.y*(-6*c20.y*c23.y - 6*c21.y*c22.y) + c20.x*c13x2*c13.y*(6*c20.y*c23.y + 6*c21.y*c22.y) +
            c21.x*c13x2*c13.y*(6*c20.y*c22.y + 3*c21y2) + c13x3*(-2*c20.y*c21.y*c22.y - c20y2*c23.y -
            c21.y*(2*c20.y*c22.y + c21y2) - c20.y*(2*c20.y*c23.y + 2*c21.y*c22.y)),
        -c10.x*c11.x*c12.y*c13.x*c13.y*c22.y + c10.x*c11.y*c12.x*c13.x*c13.y*c22.y + 6*c10.x*c11.y*c12.y*c13.x*c22.x*c13.y -
            6*c10.y*c11.x*c12.x*c13.x*c13.y*c22.y - c10.y*c11.x*c12.y*c13.x*c22.x*c13.y + c10.y*c11.y*c12.x*c13.x*c22.x*c13.y +
            c11.x*c11.y*c12.x*c12.y*c13.x*c22.y - c11.x*c11.y*c12.x*c12.y*c22.x*c13.y + c11.x*c20.x*c12.y*c13.x*c13.y*c22.y +
            c11.x*c20.y*c12.y*c13.x*c22.x*c13.y + c11.x*c21.x*c12.y*c13.x*c21.y*c13.y - c20.x*c11.y*c12.x*c13.x*c13.y*c22.y -
            6*c20.x*c11.y*c12.y*c13.x*c22.x*c13.y - c11.y*c12.x*c20.y*c13.x*c22.x*c13.y - c11.y*c12.x*c21.x*c13.x*c21.y*c13.y -
            6*c10.x*c20.x*c22.x*c13y3 - 2*c10.x*c12y3*c13.x*c22.x + 2*c20.x*c12y3*c13.x*c22.x + 2*c10.y*c12x3*c13.y*c22.y -
            6*c10.x*c10.y*c13.x*c22.x*c13y2 + 3*c10.x*c11.x*c12.x*c13y2*c22.y - 2*c10.x*c11.x*c12.y*c22.x*c13y2 -
            4*c10.x*c11.y*c12.x*c22.x*c13y2 + 3*c10.y*c11.x*c12.x*c22.x*c13y2 + 6*c10.x*c10.y*c13x2*c13.y*c22.y +
            6*c10.x*c20.x*c13.x*c13y2*c22.y - 3*c10.x*c11.y*c12.y*c13x2*c22.y + 2*c10.x*c12.x*c12y2*c13.x*c22.y +
            2*c10.x*c12.x*c12y2*c22.x*c13.y + 6*c10.x*c20.y*c13.x*c22.x*c13y2 + 6*c10.x*c21.x*c13.x*c21.y*c13y2 +
            4*c10.y*c11.x*c12.y*c13x2*c22.y + 6*c10.y*c20.x*c13.x*c22.x*c13y2 + 2*c10.y*c11.y*c12.x*c13x2*c22.y -
            3*c10.y*c11.y*c12.y*c13x2*c22.x + 2*c10.y*c12.x*c12y2*c13.x*c22.x - 3*c11.x*c20.x*c12.x*c13y2*c22.y +
            2*c11.x*c20.x*c12.y*c22.x*c13y2 + c11.x*c11.y*c12y2*c13.x*c22.x - 3*c11.x*c12.x*c20.y*c22.x*c13y2 -
            3*c11.x*c12.x*c21.x*c21.y*c13y2 + 4*c20.x*c11.y*c12.x*c22.x*c13y2 - 2*c10.x*c12x2*c12.y*c13.y*c22.y -
            6*c10.y*c20.x*c13x2*c13.y*c22.y - 6*c10.y*c20.y*c13x2*c22.x*c13.y - 6*c10.y*c21.x*c13x2*c21.y*c13.y -
            2*c10.y*c12x2*c12.y*c13.x*c22.y - 2*c10.y*c12x2*c12.y*c22.x*c13.y - c11.x*c11.y*c12x2*c13.y*c22.y -
            2*c11.x*c11y2*c13.x*c22.x*c13.y + 3*c20.x*c11.y*c12.y*c13x2*c22.y - 2*c20.x*c12.x*c12y2*c13.x*c22.y -
            2*c20.x*c12.x*c12y2*c22.x*c13.y - 6*c20.x*c20.y*c13.x*c22.x*c13y2 - 6*c20.x*c21.x*c13.x*c21.y*c13y2 +
            3*c11.y*c20.y*c12.y*c13x2*c22.x + 3*c11.y*c21.x*c12.y*c13x2*c21.y - 2*c12.x*c20.y*c12y2*c13.x*c22.x -
            2*c12.x*c21.x*c12y2*c13.x*c21.y - c11y2*c12.x*c12.y*c13.x*c22.x + 2*c20.x*c12x2*c12.y*c13.y*c22.y -
            3*c11.y*c21x2*c12.y*c13.x*c13.y + 6*c20.y*c21.x*c13x2*c21.y*c13.y + 2*c11x2*c11.y*c13.x*c13.y*c22.y +
            c11x2*c12.x*c12.y*c13.y*c22.y + 2*c12x2*c20.y*c12.y*c22.x*c13.y + 2*c12x2*c21.x*c12.y*c21.y*c13.y -
            3*c10.x*c21x2*c13y3 + 3*c20.x*c21x2*c13y3 + 3*c10x2*c22.x*c13y3 - 3*c10y2*c13x3*c22.y + 3*c20x2*c22.x*c13y3 +
            c21x2*c12y3*c13.x + c11y3*c13x2*c22.x - c11x3*c13y2*c22.y + 3*c10.y*c21x2*c13.x*c13y2 -
            c11.x*c11y2*c13x2*c22.y + c11.x*c21x2*c12.y*c13y2 + 2*c11.y*c12.x*c21x2*c13y2 + c11x2*c11.y*c22.x*c13y2 -
            c12.x*c21x2*c12y2*c13.y - 3*c20.y*c21x2*c13.x*c13y2 - 3*c10x2*c13.x*c13y2*c22.y + 3*c10y2*c13x2*c22.x*c13.y -
            c11x2*c12y2*c13.x*c22.y + c11y2*c12x2*c22.x*c13.y - 3*c20x2*c13.x*c13y2*c22.y + 3*c20y2*c13x2*c22.x*c13.y +
            c12x2*c12.y*c13.x*(2*c20.y*c22.y + c21y2) + c11.x*c12.x*c13.x*c13.y*(6*c20.y*c22.y + 3*c21y2) +
            c12x3*c13.y*(-2*c20.y*c22.y - c21y2) + c10.y*c13x3*(6*c20.y*c22.y + 3*c21y2) +
            c11.y*c12.x*c13x2*(-2*c20.y*c22.y - c21y2) + c11.x*c12.y*c13x2*(-4*c20.y*c22.y - 2*c21y2) +
            c10.x*c13x2*c13.y*(-6*c20.y*c22.y - 3*c21y2) + c20.x*c13x2*c13.y*(6*c20.y*c22.y + 3*c21y2) +
            c13x3*(-2*c20.y*c21y2 - c20y2*c22.y - c20.y*(2*c20.y*c22.y + c21y2)),
        -c10.x*c11.x*c12.y*c13.x*c21.y*c13.y + c10.x*c11.y*c12.x*c13.x*c21.y*c13.y + 6*c10.x*c11.y*c21.x*c12.y*c13.x*c13.y -
            6*c10.y*c11.x*c12.x*c13.x*c21.y*c13.y - c10.y*c11.x*c21.x*c12.y*c13.x*c13.y + c10.y*c11.y*c12.x*c21.x*c13.x*c13.y -
            c11.x*c11.y*c12.x*c21.x*c12.y*c13.y + c11.x*c11.y*c12.x*c12.y*c13.x*c21.y + c11.x*c20.x*c12.y*c13.x*c21.y*c13.y +
            6*c11.x*c12.x*c20.y*c13.x*c21.y*c13.y + c11.x*c20.y*c21.x*c12.y*c13.x*c13.y - c20.x*c11.y*c12.x*c13.x*c21.y*c13.y -
            6*c20.x*c11.y*c21.x*c12.y*c13.x*c13.y - c11.y*c12.x*c20.y*c21.x*c13.x*c13.y - 6*c10.x*c20.x*c21.x*c13y3 -
            2*c10.x*c21.x*c12y3*c13.x + 6*c10.y*c20.y*c13x3*c21.y + 2*c20.x*c21.x*c12y3*c13.x + 2*c10.y*c12x3*c21.y*c13.y -
            2*c12x3*c20.y*c21.y*c13.y - 6*c10.x*c10.y*c21.x*c13.x*c13y2 + 3*c10.x*c11.x*c12.x*c21.y*c13y2 -
            2*c10.x*c11.x*c21.x*c12.y*c13y2 - 4*c10.x*c11.y*c12.x*c21.x*c13y2 + 3*c10.y*c11.x*c12.x*c21.x*c13y2 +
            6*c10.x*c10.y*c13x2*c21.y*c13.y + 6*c10.x*c20.x*c13.x*c21.y*c13y2 - 3*c10.x*c11.y*c12.y*c13x2*c21.y +
            2*c10.x*c12.x*c21.x*c12y2*c13.y + 2*c10.x*c12.x*c12y2*c13.x*c21.y + 6*c10.x*c20.y*c21.x*c13.x*c13y2 +
            4*c10.y*c11.x*c12.y*c13x2*c21.y + 6*c10.y*c20.x*c21.x*c13.x*c13y2 + 2*c10.y*c11.y*c12.x*c13x2*c21.y -
            3*c10.y*c11.y*c21.x*c12.y*c13x2 + 2*c10.y*c12.x*c21.x*c12y2*c13.x - 3*c11.x*c20.x*c12.x*c21.y*c13y2 +
            2*c11.x*c20.x*c21.x*c12.y*c13y2 + c11.x*c11.y*c21.x*c12y2*c13.x - 3*c11.x*c12.x*c20.y*c21.x*c13y2 +
            4*c20.x*c11.y*c12.x*c21.x*c13y2 - 6*c10.x*c20.y*c13x2*c21.y*c13.y - 2*c10.x*c12x2*c12.y*c21.y*c13.y -
            6*c10.y*c20.x*c13x2*c21.y*c13.y - 6*c10.y*c20.y*c21.x*c13x2*c13.y - 2*c10.y*c12x2*c21.x*c12.y*c13.y -
            2*c10.y*c12x2*c12.y*c13.x*c21.y - c11.x*c11.y*c12x2*c21.y*c13.y - 4*c11.x*c20.y*c12.y*c13x2*c21.y -
            2*c11.x*c11y2*c21.x*c13.x*c13.y + 3*c20.x*c11.y*c12.y*c13x2*c21.y - 2*c20.x*c12.x*c21.x*c12y2*c13.y -
            2*c20.x*c12.x*c12y2*c13.x*c21.y - 6*c20.x*c20.y*c21.x*c13.x*c13y2 - 2*c11.y*c12.x*c20.y*c13x2*c21.y +
            3*c11.y*c20.y*c21.x*c12.y*c13x2 - 2*c12.x*c20.y*c21.x*c12y2*c13.x - c11y2*c12.x*c21.x*c12.y*c13.x +
            6*c20.x*c20.y*c13x2*c21.y*c13.y + 2*c20.x*c12x2*c12.y*c21.y*c13.y + 2*c11x2*c11.y*c13.x*c21.y*c13.y +
            c11x2*c12.x*c12.y*c21.y*c13.y + 2*c12x2*c20.y*c21.x*c12.y*c13.y + 2*c12x2*c20.y*c12.y*c13.x*c21.y +
            3*c10x2*c21.x*c13y3 - 3*c10y2*c13x3*c21.y + 3*c20x2*c21.x*c13y3 + c11y3*c21.x*c13x2 - c11x3*c21.y*c13y2 -
            3*c20y2*c13x3*c21.y - c11.x*c11y2*c13x2*c21.y + c11x2*c11.y*c21.x*c13y2 - 3*c10x2*c13.x*c21.y*c13y2 +
            3*c10y2*c21.x*c13x2*c13.y - c11x2*c12y2*c13.x*c21.y + c11y2*c12x2*c21.x*c13.y - 3*c20x2*c13.x*c21.y*c13y2 +
            3*c20y2*c21.x*c13x2*c13.y,
        c10.x*c10.y*c11.x*c12.y*c13.x*c13.y - c10.x*c10.y*c11.y*c12.x*c13.x*c13.y + c10.x*c11.x*c11.y*c12.x*c12.y*c13.y -
            c10.y*c11.x*c11.y*c12.x*c12.y*c13.x - c10.x*c11.x*c20.y*c12.y*c13.x*c13.y + 6*c10.x*c20.x*c11.y*c12.y*c13.x*c13.y +
            c10.x*c11.y*c12.x*c20.y*c13.x*c13.y - c10.y*c11.x*c20.x*c12.y*c13.x*c13.y - 6*c10.y*c11.x*c12.x*c20.y*c13.x*c13.y +
            c10.y*c20.x*c11.y*c12.x*c13.x*c13.y - c11.x*c20.x*c11.y*c12.x*c12.y*c13.y + c11.x*c11.y*c12.x*c20.y*c12.y*c13.x +
            c11.x*c20.x*c20.y*c12.y*c13.x*c13.y - c20.x*c11.y*c12.x*c20.y*c13.x*c13.y - 2*c10.x*c20.x*c12y3*c13.x +
            2*c10.y*c12x3*c20.y*c13.y - 3*c10.x*c10.y*c11.x*c12.x*c13y2 - 6*c10.x*c10.y*c20.x*c13.x*c13y2 +
            3*c10.x*c10.y*c11.y*c12.y*c13x2 - 2*c10.x*c10.y*c12.x*c12y2*c13.x - 2*c10.x*c11.x*c20.x*c12.y*c13y2 -
            c10.x*c11.x*c11.y*c12y2*c13.x + 3*c10.x*c11.x*c12.x*c20.y*c13y2 - 4*c10.x*c20.x*c11.y*c12.x*c13y2 +
            3*c10.y*c11.x*c20.x*c12.x*c13y2 + 6*c10.x*c10.y*c20.y*c13x2*c13.y + 2*c10.x*c10.y*c12x2*c12.y*c13.y +
            2*c10.x*c11.x*c11y2*c13.x*c13.y + 2*c10.x*c20.x*c12.x*c12y2*c13.y + 6*c10.x*c20.x*c20.y*c13.x*c13y2 -
            3*c10.x*c11.y*c20.y*c12.y*c13x2 + 2*c10.x*c12.x*c20.y*c12y2*c13.x + c10.x*c11y2*c12.x*c12.y*c13.x +
            c10.y*c11.x*c11.y*c12x2*c13.y + 4*c10.y*c11.x*c20.y*c12.y*c13x2 - 3*c10.y*c20.x*c11.y*c12.y*c13x2 +
            2*c10.y*c20.x*c12.x*c12y2*c13.x + 2*c10.y*c11.y*c12.x*c20.y*c13x2 + c11.x*c20.x*c11.y*c12y2*c13.x -
            3*c11.x*c20.x*c12.x*c20.y*c13y2 - 2*c10.x*c12x2*c20.y*c12.y*c13.y - 6*c10.y*c20.x*c20.y*c13x2*c13.y -
            2*c10.y*c20.x*c12x2*c12.y*c13.y - 2*c10.y*c11x2*c11.y*c13.x*c13.y - c10.y*c11x2*c12.x*c12.y*c13.y -
            2*c10.y*c12x2*c20.y*c12.y*c13.x - 2*c11.x*c20.x*c11y2*c13.x*c13.y - c11.x*c11.y*c12x2*c20.y*c13.y +
            3*c20.x*c11.y*c20.y*c12.y*c13x2 - 2*c20.x*c12.x*c20.y*c12y2*c13.x - c20.x*c11y2*c12.x*c12.y*c13.x +
            3*c10y2*c11.x*c12.x*c13.x*c13.y + 3*c11.x*c12.x*c20y2*c13.x*c13.y + 2*c20.x*c12x2*c20.y*c12.y*c13.y -
            3*c10x2*c11.y*c12.y*c13.x*c13.y + 2*c11x2*c11.y*c20.y*c13.x*c13.y + c11x2*c12.x*c20.y*c12.y*c13.y -
            3*c20x2*c11.y*c12.y*c13.x*c13.y - c10x3*c13y3 + c10y3*c13x3 + c20x3*c13y3 - c20y3*c13x3 -
            3*c10.x*c20x2*c13y3 - c10.x*c11y3*c13x2 + 3*c10x2*c20.x*c13y3 + c10.y*c11x3*c13y2 +
            3*c10.y*c20y2*c13x3 + c20.x*c11y3*c13x2 + c10x2*c12y3*c13.x - 3*c10y2*c20.y*c13x3 - c10y2*c12x3*c13.y +
            c20x2*c12y3*c13.x - c11x3*c20.y*c13y2 - c12x3*c20y2*c13.y - c10.x*c11x2*c11.y*c13y2 +
            c10.y*c11.x*c11y2*c13x2 - 3*c10.x*c10y2*c13x2*c13.y - c10.x*c11y2*c12x2*c13.y + c10.y*c11x2*c12y2*c13.x -
            c11.x*c11y2*c20.y*c13x2 + 3*c10x2*c10.y*c13.x*c13y2 + c10x2*c11.x*c12.y*c13y2 +
            2*c10x2*c11.y*c12.x*c13y2 - 2*c10y2*c11.x*c12.y*c13x2 - c10y2*c11.y*c12.x*c13x2 + c11x2*c20.x*c11.y*c13y2 -
            3*c10.x*c20y2*c13x2*c13.y + 3*c10.y*c20x2*c13.x*c13y2 + c11.x*c20x2*c12.y*c13y2 - 2*c11.x*c20y2*c12.y*c13x2 +
            c20.x*c11y2*c12x2*c13.y - c11.y*c12.x*c20y2*c13x2 - c10x2*c12.x*c12y2*c13.y - 3*c10x2*c20.y*c13.x*c13y2 +
            3*c10y2*c20.x*c13x2*c13.y + c10y2*c12x2*c12.y*c13.x - c11x2*c20.y*c12y2*c13.x + 2*c20x2*c11.y*c12.x*c13y2 +
            3*c20.x*c20y2*c13x2*c13.y - c20x2*c12.x*c12y2*c13.y - 3*c20x2*c20.y*c13.x*c13y2 + c12x2*c20y2*c12.y*c13.x
    );
    var roots = poly.getRootsInInterval(0,1);
    module.exports.Utils.removeMultipleRootsIn01(roots);

    for ( var i = 0; i < roots.length; i++ ) {
        var s = roots[i];
        var xRoots = new Polynomial(
            c13.x,
            c12.x,
            c11.x,
            c10.x - c20.x - s*c21.x - s*s*c22.x - s*s*s*c23.x
        ).getRoots();
        var yRoots = new Polynomial(
            c13.y,
            c12.y,
            c11.y,
            c10.y - c20.y - s*c21.y - s*s*c22.y - s*s*s*c23.y
        ).getRoots();

        if ( xRoots.length > 0 && yRoots.length > 0 ) {
            var TOLERANCE = 1e-4;

            checkRoots:
                for ( var j = 0; j < xRoots.length; j++ ) {
                    var xRoot = xRoots[j];

                    if ( 0 <= xRoot && xRoot <= 1 ) {
                        for ( var k = 0; k < yRoots.length; k++ ) {
                            if ( Math.abs( xRoot - yRoots[k] ) < TOLERANCE ) {
                                var v = c23.multiply(s * s * s).add(c22.multiply(s * s).add(c21.multiply(s).add(c20)));
                                result.points.push(new Point2D(v.x, v.y));
                                break checkRoots;
                            }
                        }
                    }
                }
        }
    }

    return result;
};

/**
 *  intersectBezier3Ellipse
 *
 *  @param {Point2D} p1
 *  @param {Point2D} p2
 *  @param {Point2D} p3
 *  @param {Point2D} p4
 *  @param {Point2D} ec
 *  @param {Number} rx
 *  @param {Number} ry
 *  @returns {Intersection}
 */
module.exports.intersectBezier3Ellipse = function(p1, p2, p3, p4, ec, rx, ry) {
    var a, b, c, d;       // temporary variables
    var c3, c2, c1, c0;   // coefficients of cubic
    var result = new Intersection();

    // Calculate the coefficients of cubic polynomial
    a = p1.multiply(-1);
    b = p2.multiply(3);
    c = p3.multiply(-3);
    d = a.add(b.add(c.add(p4)));
    c3 = new Vector2D(d.x, d.y);

    a = p1.multiply(3);
    b = p2.multiply(-6);
    c = p3.multiply(3);
    d = a.add(b.add(c));
    c2 = new Vector2D(d.x, d.y);

    a = p1.multiply(-3);
    b = p2.multiply(3);
    c = a.add(b);
    c1 = new Vector2D(c.x, c.y);

    c0 = new Vector2D(p1.x, p1.y);

    var rxrx  = rx*rx;
    var ryry  = ry*ry;
    var poly = new Polynomial(
        c3.x*c3.x*ryry + c3.y*c3.y*rxrx,
        2*(c3.x*c2.x*ryry + c3.y*c2.y*rxrx),
        2*(c3.x*c1.x*ryry + c3.y*c1.y*rxrx) + c2.x*c2.x*ryry + c2.y*c2.y*rxrx,
        2*c3.x*ryry*(c0.x - ec.x) + 2*c3.y*rxrx*(c0.y - ec.y) +
            2*(c2.x*c1.x*ryry + c2.y*c1.y*rxrx),
        2*c2.x*ryry*(c0.x - ec.x) + 2*c2.y*rxrx*(c0.y - ec.y) +
            c1.x*c1.x*ryry + c1.y*c1.y*rxrx,
        2*c1.x*ryry*(c0.x - ec.x) + 2*c1.y*rxrx*(c0.y - ec.y),
        c0.x*c0.x*ryry - 2*c0.y*ec.y*rxrx - 2*c0.x*ec.x*ryry +
            c0.y*c0.y*rxrx + ec.x*ec.x*ryry + ec.y*ec.y*rxrx - rxrx*ryry
    );
    var roots = poly.getRootsInInterval(0,1);
    module.exports.Utils.removeMultipleRootsIn01(roots);

    for ( var i = 0; i < roots.length; i++ ) {
        var t = roots[i];
        var v = c3.multiply(t * t * t).add(c2.multiply(t * t).add(c1.multiply(t).add(c0)));
        result.points.push(new Point2D(v.x, v.y));
    }

    return result;
};


/**
 *  intersectBezier3Line
 *
 *  Many thanks to Dan Sunday at SoftSurfer.com.  He gave me a very thorough
 *  sketch of the algorithm used here.  Without his help, I'm not sure when I
 *  would have figured out this intersection problem.
 *
 *  @param {Point2D} p1
 *  @param {Point2D} p2
 *  @param {Point2D} p3
 *  @param {Point2D} p4
 *  @param {Point2D} a1
 *  @param {Point2D} a2
 *  @returns {Intersection}
 */
module.exports.intersectBezier3Line = function(p1, p2, p3, p4, a1, a2) {
    var a, b, c, d;       // temporary variables
    var c3, c2, c1, c0;   // coefficients of cubic
    var cl;               // c coefficient for normal form of line
    var n;                // normal for normal form of line
    var min = a1.min(a2); // used to determine if point is on line segment
    var max = a1.max(a2); // used to determine if point is on line segment
    var result = new Intersection();

    // Start with Bezier using Bernstein polynomials for weighting functions:
    //     (1-t^3)P1 + 3t(1-t)^2P2 + 3t^2(1-t)P3 + t^3P4
    //
    // Expand and collect terms to form linear combinations of original Bezier
    // controls.  This ends up with a vector cubic in t:
    //     (-P1+3P2-3P3+P4)t^3 + (3P1-6P2+3P3)t^2 + (-3P1+3P2)t + P1
    //             /\                  /\                /\       /\
    //             ||                  ||                ||       ||
    //             c3                  c2                c1       c0

    // Calculate the coefficients
    a = p1.multiply(-1);
    b = p2.multiply(3);
    c = p3.multiply(-3);
    d = a.add(b.add(c.add(p4)));
    c3 = new Vector2D(d.x, d.y);

    a = p1.multiply(3);
    b = p2.multiply(-6);
    c = p3.multiply(3);
    d = a.add(b.add(c));
    c2 = new Vector2D(d.x, d.y);

    a = p1.multiply(-3);
    b = p2.multiply(3);
    c = a.add(b);
    c1 = new Vector2D(c.x, c.y);

    c0 = new Vector2D(p1.x, p1.y);

    // Convert line to normal form: ax + by + c = 0
    // Find normal to line: negative inverse of original line's slope
    n = new Vector2D(a1.y - a2.y, a2.x - a1.x);

    // Determine new c coefficient
    cl = a1.x*a2.y - a2.x*a1.y;

    // ?Rotate each cubic coefficient using line for new coordinate system?
    // Find roots of rotated cubic
    roots = new Polynomial(
        n.dot(c3),
        n.dot(c2),
        n.dot(c1),
        n.dot(c0) + cl
    ).getRoots();

    // Any roots in closed interval [0,1] are intersections on Bezier, but
    // might not be on the line segment.
    // Find intersections and calculate point coordinates
    for ( var i = 0; i < roots.length; i++ ) {
        var t = roots[i];

        if ( 0 <= t && t <= 1 ) {
            // We're within the Bezier curve
            // Find point on Bezier
            var p5 = p1.lerp(p2, t);
            var p6 = p2.lerp(p3, t);
            var p7 = p3.lerp(p4, t);

            var p8 = p5.lerp(p6, t);
            var p9 = p6.lerp(p7, t);

            var p10 = p8.lerp(p9, t);

            // See if point is on line segment
            // Had to make special cases for vertical and horizontal lines due
            // to slight errors in calculation of p10
            if ( a1.x == a2.x ) {
                if ( min.y <= p10.y && p10.y <= max.y ) {
                    result.appendPoint( p10 );
                }
            } else if ( a1.y == a2.y ) {
                if ( min.x <= p10.x && p10.x <= max.x ) {
                    result.appendPoint( p10 );
                }
            } else if (min.x <= p10.x && p10.x <= max.x && min.y <= p10.y && p10.y <= max.y) {
                result.appendPoint( p10 );
            }
        }
    }

    return result;
};
});

var bezier_1 = bezier.intersectBezier2Bezier2;
var bezier_2 = bezier.intersectBezier2Bezier3;
var bezier_3 = bezier.intersectBezier2Ellipse;
var bezier_4 = bezier.intersectBezier2Line;
var bezier_5 = bezier.intersectBezier3Bezier3;
var bezier_6 = bezier.intersectBezier3Ellipse;
var bezier_7 = bezier.intersectBezier3Line;

exports['default'] = bezier;
exports.intersectBezier2Bezier2 = bezier_1;
exports.intersectBezier2Bezier3 = bezier_2;
exports.intersectBezier2Ellipse = bezier_3;
exports.intersectBezier2Line = bezier_4;
exports.intersectBezier3Bezier3 = bezier_5;
exports.intersectBezier3Ellipse = bezier_6;
exports.intersectBezier3Line = bezier_7;

}((this.bezier = this.bezier || {}),kldAffine,kldPolynomial));

  if (typeof module !== "undefined" && typeof require === "function") {
     module.exports = GLOBAL.svgIntersections;
     module.exports.bezier = GLOBAL.bezier;
  }
})();

(function() {
  /*!
 * Bowser - a browser detector
 * https://github.com/ded/bowser
 * MIT License | (c) Dustin Diaz 2015
 */

!function (name, definition) {
  if (typeof module != 'undefined' && module.exports) module.exports = definition()
  else if (typeof define == 'function' && define.amd) define(definition)
  else this[name] = definition()
}('bowser', function () {
  /**
    * See useragents.js for examples of navigator.userAgent
    */

  var t = true

  function detect(ua) {

    function getFirstMatch(regex) {
      var match = ua.match(regex);
      return (match && match.length > 1 && match[1]) || '';
    }

    function getSecondMatch(regex) {
      var match = ua.match(regex);
      return (match && match.length > 1 && match[2]) || '';
    }

    var iosdevice = getFirstMatch(/(ipod|iphone|ipad)/i).toLowerCase()
      , likeAndroid = /like android/i.test(ua)
      , android = !likeAndroid && /android/i.test(ua)
      , nexusMobile = /nexus\s*[0-6]\s*/i.test(ua)
      , nexusTablet = !nexusMobile && /nexus\s*[0-9]+/i.test(ua)
      , chromeos = /CrOS/.test(ua)
      , silk = /silk/i.test(ua)
      , sailfish = /sailfish/i.test(ua)
      , tizen = /tizen/i.test(ua)
      , webos = /(web|hpw)os/i.test(ua)
      , windowsphone = /windows phone/i.test(ua)
      , windows = !windowsphone && /windows/i.test(ua)
      , mac = !iosdevice && !silk && /macintosh/i.test(ua)
      , linux = !android && !sailfish && !tizen && !webos && /linux/i.test(ua)
      , edgeVersion = getFirstMatch(/edge\/(\d+(\.\d+)?)/i)
      , versionIdentifier = getFirstMatch(/version\/(\d+(\.\d+)?)/i)
      , tablet = /tablet/i.test(ua)
      , mobile = !tablet && /[^-]mobi/i.test(ua)
      , xbox = /xbox/i.test(ua)
      , result

    if (/opera|opr|opios/i.test(ua)) {
      result = {
        name: 'Opera'
      , opera: t
      , version: versionIdentifier || getFirstMatch(/(?:opera|opr|opios)[\s\/](\d+(\.\d+)?)/i)
      }
    }
    else if (/coast/i.test(ua)) {
      result = {
        name: 'Opera Coast'
        , coast: t
        , version: versionIdentifier || getFirstMatch(/(?:coast)[\s\/](\d+(\.\d+)?)/i)
      }
    }
    else if (/yabrowser/i.test(ua)) {
      result = {
        name: 'Yandex Browser'
      , yandexbrowser: t
      , version: versionIdentifier || getFirstMatch(/(?:yabrowser)[\s\/](\d+(\.\d+)?)/i)
      }
    }
    else if (/ucbrowser/i.test(ua)) {
      result = {
          name: 'UC Browser'
        , ucbrowser: t
        , version: getFirstMatch(/(?:ucbrowser)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/mxios/i.test(ua)) {
      result = {
        name: 'Maxthon'
        , maxthon: t
        , version: getFirstMatch(/(?:mxios)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/epiphany/i.test(ua)) {
      result = {
        name: 'Epiphany'
        , epiphany: t
        , version: getFirstMatch(/(?:epiphany)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/puffin/i.test(ua)) {
      result = {
        name: 'Puffin'
        , puffin: t
        , version: getFirstMatch(/(?:puffin)[\s\/](\d+(?:\.\d+)?)/i)
      }
    }
    else if (/sleipnir/i.test(ua)) {
      result = {
        name: 'Sleipnir'
        , sleipnir: t
        , version: getFirstMatch(/(?:sleipnir)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/k-meleon/i.test(ua)) {
      result = {
        name: 'K-Meleon'
        , kMeleon: t
        , version: getFirstMatch(/(?:k-meleon)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (windowsphone) {
      result = {
        name: 'Windows Phone'
      , windowsphone: t
      }
      if (edgeVersion) {
        result.msedge = t
        result.version = edgeVersion
      }
      else {
        result.msie = t
        result.version = getFirstMatch(/iemobile\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/msie|trident/i.test(ua)) {
      result = {
        name: 'Internet Explorer'
      , msie: t
      , version: getFirstMatch(/(?:msie |rv:)(\d+(\.\d+)?)/i)
      }
    } else if (chromeos) {
      result = {
        name: 'Chrome'
      , chromeos: t
      , chromeBook: t
      , chrome: t
      , version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
      }
    } else if (/chrome.+? edge/i.test(ua)) {
      result = {
        name: 'Microsoft Edge'
      , msedge: t
      , version: edgeVersion
      }
    }
    else if (/vivaldi/i.test(ua)) {
      result = {
        name: 'Vivaldi'
        , vivaldi: t
        , version: getFirstMatch(/vivaldi\/(\d+(\.\d+)?)/i) || versionIdentifier
      }
    }
    else if (sailfish) {
      result = {
        name: 'Sailfish'
      , sailfish: t
      , version: getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/seamonkey\//i.test(ua)) {
      result = {
        name: 'SeaMonkey'
      , seamonkey: t
      , version: getFirstMatch(/seamonkey\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/firefox|iceweasel|fxios/i.test(ua)) {
      result = {
        name: 'Firefox'
      , firefox: t
      , version: getFirstMatch(/(?:firefox|iceweasel|fxios)[ \/](\d+(\.\d+)?)/i)
      }
      if (/\((mobile|tablet);[^\)]*rv:[\d\.]+\)/i.test(ua)) {
        result.firefoxos = t
      }
    }
    else if (silk) {
      result =  {
        name: 'Amazon Silk'
      , silk: t
      , version : getFirstMatch(/silk\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/phantom/i.test(ua)) {
      result = {
        name: 'PhantomJS'
      , phantom: t
      , version: getFirstMatch(/phantomjs\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/slimerjs/i.test(ua)) {
      result = {
        name: 'SlimerJS'
        , slimer: t
        , version: getFirstMatch(/slimerjs\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/blackberry|\bbb\d+/i.test(ua) || /rim\stablet/i.test(ua)) {
      result = {
        name: 'BlackBerry'
      , blackberry: t
      , version: versionIdentifier || getFirstMatch(/blackberry[\d]+\/(\d+(\.\d+)?)/i)
      }
    }
    else if (webos) {
      result = {
        name: 'WebOS'
      , webos: t
      , version: versionIdentifier || getFirstMatch(/w(?:eb)?osbrowser\/(\d+(\.\d+)?)/i)
      };
      /touchpad\//i.test(ua) && (result.touchpad = t)
    }
    else if (/bada/i.test(ua)) {
      result = {
        name: 'Bada'
      , bada: t
      , version: getFirstMatch(/dolfin\/(\d+(\.\d+)?)/i)
      };
    }
    else if (tizen) {
      result = {
        name: 'Tizen'
      , tizen: t
      , version: getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.\d+)?)/i) || versionIdentifier
      };
    }
    else if (/qupzilla/i.test(ua)) {
      result = {
        name: 'QupZilla'
        , qupzilla: t
        , version: getFirstMatch(/(?:qupzilla)[\s\/](\d+(?:\.\d+)+)/i) || versionIdentifier
      }
    }
    else if (/chromium/i.test(ua)) {
      result = {
        name: 'Chromium'
        , chromium: t
        , version: getFirstMatch(/(?:chromium)[\s\/](\d+(?:\.\d+)?)/i) || versionIdentifier
      }
    }
    else if (/chrome|crios|crmo/i.test(ua)) {
      result = {
        name: 'Chrome'
        , chrome: t
        , version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
      }
    }
    else if (android) {
      result = {
        name: 'Android'
        , version: versionIdentifier
      }
    }
    else if (/safari|applewebkit/i.test(ua)) {
      result = {
        name: 'Safari'
      , safari: t
      }
      if (versionIdentifier) {
        result.version = versionIdentifier
      }
    }
    else if (iosdevice) {
      result = {
        name : iosdevice == 'iphone' ? 'iPhone' : iosdevice == 'ipad' ? 'iPad' : 'iPod'
      }
      // WTF: version is not part of user agent in web apps
      if (versionIdentifier) {
        result.version = versionIdentifier
      }
    }
    else if(/googlebot/i.test(ua)) {
      result = {
        name: 'Googlebot'
      , googlebot: t
      , version: getFirstMatch(/googlebot\/(\d+(\.\d+))/i) || versionIdentifier
      }
    }
    else {
      result = {
        name: getFirstMatch(/^(.*)\/(.*) /),
        version: getSecondMatch(/^(.*)\/(.*) /)
     };
   }

    // set webkit or gecko flag for browsers based on these engines
    if (!result.msedge && /(apple)?webkit/i.test(ua)) {
      if (/(apple)?webkit\/537\.36/i.test(ua)) {
        result.name = result.name || "Blink"
        result.blink = t
      } else {
        result.name = result.name || "Webkit"
        result.webkit = t
      }
      if (!result.version && versionIdentifier) {
        result.version = versionIdentifier
      }
    } else if (!result.opera && /gecko\//i.test(ua)) {
      result.name = result.name || "Gecko"
      result.gecko = t
      result.version = result.version || getFirstMatch(/gecko\/(\d+(\.\d+)?)/i)
    }

    // set OS flags for platforms that have multiple browsers
    if (!result.msedge && (android || result.silk)) {
      result.android = t
    } else if (iosdevice) {
      result[iosdevice] = t
      result.ios = t
    } else if (mac) {
      result.mac = t
    } else if (xbox) {
      result.xbox = t
    } else if (windows) {
      result.windows = t
    } else if (linux) {
      result.linux = t
    }

    // OS version extraction
    var osVersion = '';
    if (result.windowsphone) {
      osVersion = getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i);
    } else if (iosdevice) {
      osVersion = getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i);
      osVersion = osVersion.replace(/[_\s]/g, '.');
    } else if (android) {
      osVersion = getFirstMatch(/android[ \/-](\d+(\.\d+)*)/i);
    } else if (result.webos) {
      osVersion = getFirstMatch(/(?:web|hpw)os\/(\d+(\.\d+)*)/i);
    } else if (result.blackberry) {
      osVersion = getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i);
    } else if (result.bada) {
      osVersion = getFirstMatch(/bada\/(\d+(\.\d+)*)/i);
    } else if (result.tizen) {
      osVersion = getFirstMatch(/tizen[\/\s](\d+(\.\d+)*)/i);
    }
    if (osVersion) {
      result.osversion = osVersion;
    }

    // device type extraction
    var osMajorVersion = osVersion.split('.')[0];
    if (
         tablet
      || nexusTablet
      || iosdevice == 'ipad'
      || (android && (osMajorVersion == 3 || (osMajorVersion >= 4 && !mobile)))
      || result.silk
    ) {
      result.tablet = t
    } else if (
         mobile
      || iosdevice == 'iphone'
      || iosdevice == 'ipod'
      || android
      || nexusMobile
      || result.blackberry
      || result.webos
      || result.bada
    ) {
      result.mobile = t
    }

    // Graded Browser Support
    // http://developer.yahoo.com/yui/articles/gbs
    if (result.msedge ||
        (result.msie && result.version >= 10) ||
        (result.yandexbrowser && result.version >= 15) ||
		    (result.vivaldi && result.version >= 1.0) ||
        (result.chrome && result.version >= 20) ||
        (result.firefox && result.version >= 20.0) ||
        (result.safari && result.version >= 6) ||
        (result.opera && result.version >= 10.0) ||
        (result.ios && result.osversion && result.osversion.split(".")[0] >= 6) ||
        (result.blackberry && result.version >= 10.1)
        || (result.chromium && result.version >= 20)
        ) {
      result.a = t;
    }
    else if ((result.msie && result.version < 10) ||
        (result.chrome && result.version < 20) ||
        (result.firefox && result.version < 20.0) ||
        (result.safari && result.version < 6) ||
        (result.opera && result.version < 10.0) ||
        (result.ios && result.osversion && result.osversion.split(".")[0] < 6)
        || (result.chromium && result.version < 20)
        ) {
      result.c = t
    } else result.x = t

    return result
  }

  var bowser = detect(typeof navigator !== 'undefined' ? navigator.userAgent : '')

  bowser.test = function (browserList) {
    for (var i = 0; i < browserList.length; ++i) {
      var browserItem = browserList[i];
      if (typeof browserItem=== 'string') {
        if (browserItem in bowser) {
          return true;
        }
      }
    }
    return false;
  }

  /**
   * Get version precisions count
   *
   * @example
   *   getVersionPrecision("1.10.3") // 3
   *
   * @param  {string} version
   * @return {number}
   */
  function getVersionPrecision(version) {
    return version.split(".").length;
  }

  /**
   * Array::map polyfill
   *
   * @param  {Array} arr
   * @param  {Function} iterator
   * @return {Array}
   */
  function map(arr, iterator) {
    var result = [], i;
    if (Array.prototype.map) {
      return Array.prototype.map.call(arr, iterator);
    }
    for (i = 0; i < arr.length; i++) {
      result = iterator(arr[i]);
    }
    return result;
  }

  /**
   * Calculate browser version weight
   *
   * @example
   *   compareVersions(['1.10.2.1',  '1.8.2.1.90'])    // 1
   *   compareVersions(['1.010.2.1', '1.09.2.1.90']);  // 1
   *   compareVersions(['1.10.2.1',  '1.10.2.1']);     // 0
   *   compareVersions(['1.10.2.1',  '1.0800.2']);     // -1
   *
   * @param  {Array<String>} versions versions to compare
   * @return {Number} comparison result
   */
  function compareVersions(versions) {
    // 1) get common precision for both versions, for example for "10.0" and "9" it should be 2
    var precision = Math.max(getVersionPrecision(versions[0]), getVersionPrecision(versions[1]));
    var chunks = map(versions, function (version) {
      var delta = precision - getVersionPrecision(version);

      // 2) "9" -> "9.0" (for precision = 2)
      version = version + new Array(delta + 1).join(".0");

      // 3) "9.0" -> ["000000000"", "000000009"]
      return map(version.split("."), function (chunk) {
        return new Array(20 - chunk.length).join("0") + chunk;
      }).reverse();
    });

    // iterate in reverse order by reversed chunks array
    while (--precision >= 0) {
      // 4) compare: "000000009" > "000000010" = false (but "9" > "10" = true)
      if (chunks[0][precision] > chunks[1][precision]) {
        return 1;
      }
      else if (chunks[0][precision] === chunks[1][precision]) {
        if (precision === 0) {
          // all version chunks are same
          return 0;
        }
      }
      else {
        return -1;
      }
    }
  }

  /**
   * Check if browser is unsupported
   *
   * @example
   *   bowser.isUnsupportedBrowser({
   *     msie: "10",
   *     firefox: "23",
   *     chrome: "29",
   *     safari: "5.1",
   *     opera: "16",
   *     phantom: "534"
   *   });
   *
   * @param  {Object}  minVersions map of minimal version to browser
   * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map
   * @param  {String}  [ua] user agent string
   * @return {Boolean}
   */
  function isUnsupportedBrowser(minVersions, strictMode, ua) {
    var _bowser = bowser;

    // make strictMode param optional with ua param usage
    if (typeof strictMode === 'string') {
      ua = strictMode;
      strictMode = void(0);
    }

    if (strictMode === void(0)) {
      strictMode = false;
    }
    if (ua) {
      _bowser = detect(ua);
    }

    var version = "" + _bowser.version;
    for (var browser in minVersions) {
      if (minVersions.hasOwnProperty(browser)) {
        if (_bowser[browser]) {
          // browser version and min supported version.
          return compareVersions([version, minVersions[browser]]) < 0;
        }
      }
    }

    return strictMode; // not found
  }

  /**
   * Check if browser is supported
   *
   * @param  {Object} minVersions map of minimal version to browser
   * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map
   * @param  {String}  [ua] user agent string
   * @return {Boolean}
   */
  function check(minVersions, strictMode, ua) {
    return !isUnsupportedBrowser(minVersions, strictMode, ua);
  }

  bowser.isUnsupportedBrowser = isUnsupportedBrowser;
  bowser.compareVersions = compareVersions;
  bowser.check = check;

  /*
   * Set our detect method to the main bowser object so we can
   * reuse it to test other user agents.
   * This is needed to implement future tests.
   */
  bowser._detect = detect;

  return bowser
});

  !function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.virtualDom=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var createElement = require("./vdom/create-element.js")

module.exports = createElement

},{"./vdom/create-element.js":15}],2:[function(require,module,exports){
var diff = require("./vtree/diff.js")

module.exports = diff

},{"./vtree/diff.js":35}],3:[function(require,module,exports){
var h = require("./virtual-hyperscript/index.js")

module.exports = h

},{"./virtual-hyperscript/index.js":22}],4:[function(require,module,exports){
var diff = require("./diff.js")
var patch = require("./patch.js")
var h = require("./h.js")
var create = require("./create-element.js")
var VNode = require('./vnode/vnode.js')
var VText = require('./vnode/vtext.js')

module.exports = {
    diff: diff,
    patch: patch,
    h: h,
    create: create,
    VNode: VNode,
    VText: VText
}

},{"./create-element.js":1,"./diff.js":2,"./h.js":3,"./patch.js":13,"./vnode/vnode.js":31,"./vnode/vtext.js":33}],5:[function(require,module,exports){
/*!
 * Cross-Browser Split 1.1.1
 * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>
 * Available under the MIT License
 * ECMAScript compliant, uniform cross-browser split method
 */

/**
 * Splits a string into an array of strings using a regex or string separator. Matches of the
 * separator are not included in the result array. However, if `separator` is a regex that contains
 * capturing groups, backreferences are spliced into the result each time `separator` is matched.
 * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably
 * cross-browser.
 * @param {String} str String to split.
 * @param {RegExp|String} separator Regex or string to use for separating the string.
 * @param {Number} [limit] Maximum number of items to include in the result array.
 * @returns {Array} Array of substrings.
 * @example
 *
 * // Basic use
 * split('a b c d', ' ');
 * // -> ['a', 'b', 'c', 'd']
 *
 * // With limit
 * split('a b c d', ' ', 2);
 * // -> ['a', 'b']
 *
 * // Backreferences in result array
 * split('..word1 word2..', /([a-z]+)(\d+)/i);
 * // -> ['..', 'word', '1', ' ', 'word', '2', '..']
 */
module.exports = (function split(undef) {

  var nativeSplit = String.prototype.split,
    compliantExecNpcg = /()??/.exec("")[1] === undef,
    // NPCG: nonparticipating capturing group
    self;

  self = function(str, separator, limit) {
    // If `separator` is not a regex, use `nativeSplit`
    if (Object.prototype.toString.call(separator) !== "[object RegExp]") {
      return nativeSplit.call(str, separator, limit);
    }
    var output = [],
      flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.extended ? "x" : "") + // Proposed for ES6
      (separator.sticky ? "y" : ""),
      // Firefox 3+
      lastLastIndex = 0,
      // Make `global` and avoid `lastIndex` issues by working with a copy
      separator = new RegExp(separator.source, flags + "g"),
      separator2, match, lastIndex, lastLength;
    str += ""; // Type-convert
    if (!compliantExecNpcg) {
      // Doesn't need flags gy, but they don't hurt
      separator2 = new RegExp("^" + separator.source + "$(?!\\s)", flags);
    }
    /* Values for `limit`, per the spec:
     * If undefined: 4294967295 // Math.pow(2, 32) - 1
     * If 0, Infinity, or NaN: 0
     * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
     * If negative number: 4294967296 - Math.floor(Math.abs(limit))
     * If other: Type-convert, then use the above rules
     */
    limit = limit === undef ? -1 >>> 0 : // Math.pow(2, 32) - 1
    limit >>> 0; // ToUint32(limit)
    while (match = separator.exec(str)) {
      // `separator.lastIndex` is not reliable cross-browser
      lastIndex = match.index + match[0].length;
      if (lastIndex > lastLastIndex) {
        output.push(str.slice(lastLastIndex, match.index));
        // Fix browsers whose `exec` methods don't consistently return `undefined` for
        // nonparticipating capturing groups
        if (!compliantExecNpcg && match.length > 1) {
          match[0].replace(separator2, function() {
            for (var i = 1; i < arguments.length - 2; i++) {
              if (arguments[i] === undef) {
                match[i] = undef;
              }
            }
          });
        }
        if (match.length > 1 && match.index < str.length) {
          Array.prototype.push.apply(output, match.slice(1));
        }
        lastLength = match[0].length;
        lastLastIndex = lastIndex;
        if (output.length >= limit) {
          break;
        }
      }
      if (separator.lastIndex === match.index) {
        separator.lastIndex++; // Avoid an infinite loop
      }
    }
    if (lastLastIndex === str.length) {
      if (lastLength || !separator.test("")) {
        output.push("");
      }
    } else {
      output.push(str.slice(lastLastIndex));
    }
    return output.length > limit ? output.slice(0, limit) : output;
  };

  return self;
})();

},{}],6:[function(require,module,exports){

},{}],7:[function(require,module,exports){
'use strict';

var OneVersionConstraint = require('individual/one-version');

var MY_VERSION = '7';
OneVersionConstraint('ev-store', MY_VERSION);

var hashKey = '__EV_STORE_KEY@' + MY_VERSION;

module.exports = EvStore;

function EvStore(elem) {
    var hash = elem[hashKey];

    if (!hash) {
        hash = elem[hashKey] = {};
    }

    return hash;
}

},{"individual/one-version":9}],8:[function(require,module,exports){
(function (global){
'use strict';

/*global window, global*/

var root = typeof window !== 'undefined' ?
    window : typeof global !== 'undefined' ?
    global : {};

module.exports = Individual;

function Individual(key, value) {
    if (key in root) {
        return root[key];
    }

    root[key] = value;

    return value;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],9:[function(require,module,exports){
'use strict';

var Individual = require('./index.js');

module.exports = OneVersion;

function OneVersion(moduleName, version, defaultValue) {
    var key = '__INDIVIDUAL_ONE_VERSION_' + moduleName;
    var enforceKey = key + '_ENFORCE_SINGLETON';

    var versionValue = Individual(enforceKey, version);

    if (versionValue !== version) {
        throw new Error('Can only have one copy of ' +
            moduleName + '.\n' +
            'You already have version ' + versionValue +
            ' installed.\n' +
            'This means you cannot install version ' + version);
    }

    return Individual(key, defaultValue);
}

},{"./index.js":8}],10:[function(require,module,exports){
(function (global){
var topLevel = typeof global !== 'undefined' ? global :
    typeof window !== 'undefined' ? window : {}
var minDoc = require('min-document');

if (typeof document !== 'undefined') {
    module.exports = document;
} else {
    var doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];

    if (!doccy) {
        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;
    }

    module.exports = doccy;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"min-document":6}],11:[function(require,module,exports){
"use strict";

module.exports = function isObject(x) {
	return typeof x === "object" && x !== null;
};

},{}],12:[function(require,module,exports){
var nativeIsArray = Array.isArray
var toString = Object.prototype.toString

module.exports = nativeIsArray || isArray

function isArray(obj) {
    return toString.call(obj) === "[object Array]"
}

},{}],13:[function(require,module,exports){
var patch = require("./vdom/patch.js")

module.exports = patch

},{"./vdom/patch.js":18}],14:[function(require,module,exports){
var isObject = require("is-object")
var isHook = require("../vnode/is-vhook.js")

module.exports = applyProperties

function applyProperties(node, props, previous) {
    for (var propName in props) {
        var propValue = props[propName]

        if (propValue === undefined) {
            removeProperty(node, propName, propValue, previous);
        } else if (isHook(propValue)) {
            removeProperty(node, propName, propValue, previous)
            if (propValue.hook) {
                propValue.hook(node,
                    propName,
                    previous ? previous[propName] : undefined)
            }
        } else {
            if (isObject(propValue)) {
                patchObject(node, props, previous, propName, propValue);
            } else {
                node[propName] = propValue
            }
        }
    }
}

function removeProperty(node, propName, propValue, previous) {
    if (previous) {
        var previousValue = previous[propName]

        if (!isHook(previousValue)) {
            if (propName === "attributes") {
                for (var attrName in previousValue) {
                    node.removeAttribute(attrName)
                }
            } else if (propName === "style") {
                for (var i in previousValue) {
                    node.style[i] = ""
                }
            } else if (typeof previousValue === "string") {
                node[propName] = ""
            } else {
                node[propName] = null
            }
        } else if (previousValue.unhook) {
            previousValue.unhook(node, propName, propValue)
        }
    }
}

function patchObject(node, props, previous, propName, propValue) {
    var previousValue = previous ? previous[propName] : undefined

    // Set attributes
    if (propName === "attributes") {
        for (var attrName in propValue) {
            var attrValue = propValue[attrName]

            if (attrValue === undefined) {
                node.removeAttribute(attrName)
            } else {
                node.setAttribute(attrName, attrValue)
            }
        }

        return
    }

    if(previousValue && isObject(previousValue) &&
        getPrototype(previousValue) !== getPrototype(propValue)) {
        node[propName] = propValue
        return
    }

    if (!isObject(node[propName])) {
        node[propName] = {}
    }

    var replacer = propName === "style" ? "" : undefined

    for (var k in propValue) {
        var value = propValue[k]
        if (k == 'background') node[propName][k] = "";
        node[propName][k] = (value === undefined) ? replacer : value
    }
}

function getPrototype(value) {
    if (Object.getPrototypeOf) {
        return Object.getPrototypeOf(value)
    } else if (value.__proto__) {
        return value.__proto__
    } else if (value.constructor) {
        return value.constructor.prototype
    }
}

},{"../vnode/is-vhook.js":26,"is-object":11}],15:[function(require,module,exports){
var document = require("global/document")

var applyProperties = require("./apply-properties")

var isVNode = require("../vnode/is-vnode.js")
var isVText = require("../vnode/is-vtext.js")
var isWidget = require("../vnode/is-widget.js")
var handleThunk = require("../vnode/handle-thunk.js")

module.exports = createElement

function createElement(vnode, opts) {
    var doc = opts ? opts.document || document : document
    var warn = opts ? opts.warn : null

    vnode = handleThunk(vnode).a

    if (isWidget(vnode)) {
        return vnode.init()
    } else if (isVText(vnode)) {
        return doc.createTextNode(vnode.text)
    } else if (!isVNode(vnode)) {
        if (warn) {
            warn("Item is not a valid virtual dom node", vnode)
        }
        return null
    }

    var node = (vnode.namespace === null) ?
        doc.createElement(vnode.tagName) :
        doc.createElementNS(vnode.namespace, vnode.tagName)

    var props = vnode.properties
    applyProperties(node, props)

    var children = vnode.children

    for (var i = 0; i < children.length; i++) {
        var childNode = createElement(children[i], opts)
        if (childNode) {
            node.appendChild(childNode)
        }
    }

    return node
}

},{"../vnode/handle-thunk.js":24,"../vnode/is-vnode.js":27,"../vnode/is-vtext.js":28,"../vnode/is-widget.js":29,"./apply-properties":14,"global/document":10}],16:[function(require,module,exports){
// Maps a virtual DOM tree onto a real DOM tree in an efficient manner.
// We don't want to read all of the DOM nodes in the tree so we use
// the in-order tree indexing to eliminate recursion down certain branches.
// We only recurse into a DOM node if we know that it contains a child of
// interest.

var noChild = {}

module.exports = domIndex

function domIndex(rootNode, tree, indices, nodes) {
    if (!indices || indices.length === 0) {
        return {}
    } else {
        indices.sort(ascending)
        return recurse(rootNode, tree, indices, nodes, 0)
    }
}

function recurse(rootNode, tree, indices, nodes, rootIndex) {
    nodes = nodes || {}


    if (rootNode) {
        if (indexInRange(indices, rootIndex, rootIndex)) {
            nodes[rootIndex] = rootNode
        }

        var vChildren = tree.children

        if (vChildren) {

            var childNodes = rootNode.childNodes

            for (var i = 0; i < tree.children.length; i++) {
                rootIndex += 1

                var vChild = vChildren[i] || noChild
                var nextIndex = rootIndex + (vChild.count || 0)

                // skip recursion down the tree if there are no nodes down here
                if (indexInRange(indices, rootIndex, nextIndex)) {
                    recurse(childNodes[i], vChild, indices, nodes, rootIndex)
                }

                rootIndex = nextIndex
            }
        }
    }

    return nodes
}

// Binary search for an index in the interval [left, right]
function indexInRange(indices, left, right) {
    if (indices.length === 0) {
        return false
    }

    var minIndex = 0
    var maxIndex = indices.length - 1
    var currentIndex
    var currentItem

    while (minIndex <= maxIndex) {
        currentIndex = ((maxIndex + minIndex) / 2) >> 0
        currentItem = indices[currentIndex]

        if (minIndex === maxIndex) {
            return currentItem >= left && currentItem <= right
        } else if (currentItem < left) {
            minIndex = currentIndex + 1
        } else  if (currentItem > right) {
            maxIndex = currentIndex - 1
        } else {
            return true
        }
    }

    return false;
}

function ascending(a, b) {
    return a > b ? 1 : -1
}

},{}],17:[function(require,module,exports){
var applyProperties = require("./apply-properties")

var isWidget = require("../vnode/is-widget.js")
var VPatch = require("../vnode/vpatch.js")

var updateWidget = require("./update-widget")

module.exports = applyPatch

function applyPatch(vpatch, domNode, renderOptions) {
    var type = vpatch.type
    var vNode = vpatch.vNode
    var patch = vpatch.patch

    switch (type) {
        case VPatch.REMOVE:
            return removeNode(domNode, vNode)
        case VPatch.INSERT:
            return insertNode(domNode, patch, renderOptions)
        case VPatch.VTEXT:
            return stringPatch(domNode, vNode, patch, renderOptions)
        case VPatch.WIDGET:
            return widgetPatch(domNode, vNode, patch, renderOptions)
        case VPatch.VNODE:
            return vNodePatch(domNode, vNode, patch, renderOptions)
        case VPatch.ORDER:
            reorderChildren(domNode, patch)
            return domNode
        case VPatch.PROPS:
            applyProperties(domNode, patch, vNode.properties)
            return domNode
        case VPatch.THUNK:
            return replaceRoot(domNode,
                renderOptions.patch(domNode, patch, renderOptions))
        default:
            return domNode
    }
}

function removeNode(domNode, vNode) {
    var parentNode = domNode.parentNode

    if (parentNode) {
        parentNode.removeChild(domNode)
    }

    destroyWidget(domNode, vNode);

    return null
}

function insertNode(parentNode, vNode, renderOptions) {
    var newNode = renderOptions.render(vNode, renderOptions)

    if (parentNode) {
        parentNode.appendChild(newNode)
    }

    return parentNode
}

function stringPatch(domNode, leftVNode, vText, renderOptions) {
    var newNode

    if (domNode.nodeType === 3) {
        domNode.replaceData(0, domNode.length, vText.text)
        newNode = domNode
    } else {
        var parentNode = domNode.parentNode
        newNode = renderOptions.render(vText, renderOptions)

        if (parentNode && newNode !== domNode) {
            parentNode.replaceChild(newNode, domNode)
        }
    }

    return newNode
}

function widgetPatch(domNode, leftVNode, widget, renderOptions) {
    var updating = updateWidget(leftVNode, widget)
    var newNode

    if (updating) {
        newNode = widget.update(leftVNode, domNode) || domNode
    } else {
        newNode = renderOptions.render(widget, renderOptions)
    }

    var parentNode = domNode.parentNode

    if (parentNode && newNode !== domNode) {
        parentNode.replaceChild(newNode, domNode)
    }

    if (!updating) {
        destroyWidget(domNode, leftVNode)
    }

    return newNode
}

function vNodePatch(domNode, leftVNode, vNode, renderOptions) {
    var parentNode = domNode.parentNode
    var newNode = renderOptions.render(vNode, renderOptions)

    if (parentNode && newNode !== domNode) {
        parentNode.replaceChild(newNode, domNode)
    }

    return newNode
}

function destroyWidget(domNode, w) {
    if (typeof w.destroy === "function" && isWidget(w)) {
        w.destroy(domNode)
    }
}

function reorderChildren(domNode, moves) {
    var childNodes = domNode.childNodes
    var keyMap = {}
    var node
    var remove
    var insert

    for (var i = 0; i < moves.removes.length; i++) {
        remove = moves.removes[i]
        node = childNodes[remove.from]
        if (remove.key) {
            keyMap[remove.key] = node
        }
        domNode.removeChild(node)
    }

    var length = childNodes.length
    for (var j = 0; j < moves.inserts.length; j++) {
        insert = moves.inserts[j]
        node = keyMap[insert.key]
        // this is the weirdest bug i've ever seen in webkit
        domNode.insertBefore(node, insert.to >= length++ ? null : childNodes[insert.to])
    }
}

function replaceRoot(oldRoot, newRoot) {
    if (oldRoot && newRoot && oldRoot !== newRoot && oldRoot.parentNode) {
        oldRoot.parentNode.replaceChild(newRoot, oldRoot)
    }

    return newRoot;
}

},{"../vnode/is-widget.js":29,"../vnode/vpatch.js":32,"./apply-properties":14,"./update-widget":19}],18:[function(require,module,exports){
var document = require("global/document")
var isArray = require("x-is-array")

var render = require("./create-element")
var domIndex = require("./dom-index")
var patchOp = require("./patch-op")
module.exports = patch

function patch(rootNode, patches, renderOptions) {
    renderOptions = renderOptions || {}
    renderOptions.patch = renderOptions.patch && renderOptions.patch !== patch
        ? renderOptions.patch
        : patchRecursive
    renderOptions.render = renderOptions.render || render

    return renderOptions.patch(rootNode, patches, renderOptions)
}

function patchRecursive(rootNode, patches, renderOptions) {
    var indices = patchIndices(patches)

    if (indices.length === 0) {
        return rootNode
    }

    var index = domIndex(rootNode, patches.a, indices)
    var ownerDocument = rootNode.ownerDocument

    if (!renderOptions.document && ownerDocument !== document) {
        renderOptions.document = ownerDocument
    }

    for (var i = 0; i < indices.length; i++) {
        var nodeIndex = indices[i]
        rootNode = applyPatch(rootNode,
            index[nodeIndex],
            patches[nodeIndex],
            renderOptions)
    }

    return rootNode
}

function applyPatch(rootNode, domNode, patchList, renderOptions) {
    if (!domNode) {
        return rootNode
    }

    var newNode

    if (isArray(patchList)) {
        for (var i = 0; i < patchList.length; i++) {
            newNode = patchOp(patchList[i], domNode, renderOptions)

            if (domNode === rootNode) {
                rootNode = newNode
            }
        }
    } else {
        newNode = patchOp(patchList, domNode, renderOptions)

        if (domNode === rootNode) {
            rootNode = newNode
        }
    }

    return rootNode
}

function patchIndices(patches) {
    var indices = []

    for (var key in patches) {
        if (key !== "a") {
            indices.push(Number(key))
        }
    }

    return indices
}

},{"./create-element":15,"./dom-index":16,"./patch-op":17,"global/document":10,"x-is-array":12}],19:[function(require,module,exports){
var isWidget = require("../vnode/is-widget.js")

module.exports = updateWidget

function updateWidget(a, b) {
    if (isWidget(a) && isWidget(b)) {
        if ("name" in a && "name" in b) {
            return a.id === b.id
        } else {
            return a.init === b.init
        }
    }

    return false
}

},{"../vnode/is-widget.js":29}],20:[function(require,module,exports){
'use strict';

var EvStore = require('ev-store');

module.exports = EvHook;

function EvHook(value) {
    if (!(this instanceof EvHook)) {
        return new EvHook(value);
    }

    this.value = value;
}

EvHook.prototype.hook = function (node, propertyName) {
    var es = EvStore(node);
    var propName = propertyName.substr(3);

    es[propName] = this.value;
};

EvHook.prototype.unhook = function(node, propertyName) {
    var es = EvStore(node);
    var propName = propertyName.substr(3);

    es[propName] = undefined;
};

},{"ev-store":7}],21:[function(require,module,exports){
'use strict';

module.exports = SoftSetHook;

function SoftSetHook(value) {
    if (!(this instanceof SoftSetHook)) {
        return new SoftSetHook(value);
    }

    this.value = value;
}

SoftSetHook.prototype.hook = function (node, propertyName) {
    if (node[propertyName] !== this.value) {
        node[propertyName] = this.value;
    }
};

},{}],22:[function(require,module,exports){
'use strict';

var isArray = require('x-is-array');

var VNode = require('../vnode/vnode.js');
var VText = require('../vnode/vtext.js');
var isVNode = require('../vnode/is-vnode');
var isVText = require('../vnode/is-vtext');
var isWidget = require('../vnode/is-widget');
var isHook = require('../vnode/is-vhook');
var isVThunk = require('../vnode/is-thunk');

var parseTag = require('./parse-tag.js');
var softSetHook = require('./hooks/soft-set-hook.js');
var evHook = require('./hooks/ev-hook.js');

module.exports = h;

function h(tagName, properties, children) {
    var childNodes = [];
    var tag, props, key, namespace;

    if (!children && isChildren(properties)) {
        children = properties;
        props = {};
    }

    props = props || properties || {};
    tag = parseTag(tagName, props);

    // support keys
    if (props.hasOwnProperty('key')) {
        key = props.key;
        props.key = undefined;
    }

    // support namespace
    if (props.hasOwnProperty('namespace')) {
        namespace = props.namespace;
        props.namespace = undefined;
    }

    // fix cursor bug
    if (tag === 'INPUT' &&
        !namespace &&
        props.hasOwnProperty('value') &&
        props.value !== undefined &&
        !isHook(props.value)
    ) {
        props.value = softSetHook(props.value);
    }

    transformProperties(props);

    if (children !== undefined && children !== null) {
        addChild(children, childNodes, tag, props);
    }


    return new VNode(tag, props, childNodes, key, namespace);
}

function addChild(c, childNodes, tag, props) {
    if (typeof c === 'string') {
        childNodes.push(new VText(c));
    } else if (typeof c === 'number') {
        childNodes.push(new VText(String(c)));
    } else if (isChild(c)) {
        childNodes.push(c);
    } else if (isArray(c)) {
        for (var i = 0; i < c.length; i++) {
            addChild(c[i], childNodes, tag, props);
        }
    } else if (c === null || c === undefined) {
        return;
    } else {
        throw UnexpectedVirtualElement({
            foreignObject: c,
            parentVnode: {
                tagName: tag,
                properties: props
            }
        });
    }
}

function transformProperties(props) {
    for (var propName in props) {
        if (props.hasOwnProperty(propName)) {
            var value = props[propName];

            if (isHook(value)) {
                continue;
            }

            if (propName.substr(0, 3) === 'ev-') {
                // add ev-foo support
                props[propName] = evHook(value);
            }
        }
    }
}

function isChild(x) {
    return isVNode(x) || isVText(x) || isWidget(x) || isVThunk(x);
}

function isChildren(x) {
    return typeof x === 'string' || isArray(x) || isChild(x);
}

function UnexpectedVirtualElement(data) {
    var err = new Error();

    err.type = 'virtual-hyperscript.unexpected.virtual-element';
    err.message = 'Unexpected virtual child passed to h().\n' +
        'Expected a VNode / Vthunk / VWidget / string but:\n' +
        'got:\n' +
        errorString(data.foreignObject) +
        '.\n' +
        'The parent vnode is:\n' +
        errorString(data.parentVnode)
        '\n' +
        'Suggested fix: change your `h(..., [ ... ])` callsite.';
    err.foreignObject = data.foreignObject;
    err.parentVnode = data.parentVnode;

    return err;
}

function errorString(obj) {
    try {
        return JSON.stringify(obj, null, '    ');
    } catch (e) {
        return String(obj);
    }
}

},{"../vnode/is-thunk":25,"../vnode/is-vhook":26,"../vnode/is-vnode":27,"../vnode/is-vtext":28,"../vnode/is-widget":29,"../vnode/vnode.js":31,"../vnode/vtext.js":33,"./hooks/ev-hook.js":20,"./hooks/soft-set-hook.js":21,"./parse-tag.js":23,"x-is-array":12}],23:[function(require,module,exports){
'use strict';

var split = require('browser-split');

var classIdSplit = /([\.#]?[a-zA-Z0-9\u007F-\uFFFF_:-]+)/;
var notClassId = /^\.|#/;

module.exports = parseTag;

function parseTag(tag, props) {
    if (!tag) {
        return 'DIV';
    }

    var noId = !(props.hasOwnProperty('id'));

    var tagParts = split(tag, classIdSplit);
    var tagName = null;

    if (notClassId.test(tagParts[1])) {
        tagName = 'DIV';
    }

    var classes, part, type, i;

    for (i = 0; i < tagParts.length; i++) {
        part = tagParts[i];

        if (!part) {
            continue;
        }

        type = part.charAt(0);

        if (!tagName) {
            tagName = part;
        } else if (type === '.') {
            classes = classes || [];
            classes.push(part.substring(1, part.length));
        } else if (type === '#' && noId) {
            props.id = part.substring(1, part.length);
        }
    }

    if (classes) {
        if (props.className) {
            classes.push(props.className);
        }

        props.className = classes.join(' ');
    }

    return props.namespace ? tagName : tagName.toUpperCase();
}

},{"browser-split":5}],24:[function(require,module,exports){
var isVNode = require("./is-vnode")
var isVText = require("./is-vtext")
var isWidget = require("./is-widget")
var isThunk = require("./is-thunk")

module.exports = handleThunk

function handleThunk(a, b) {
    var renderedA = a
    var renderedB = b

    if (isThunk(b)) {
        renderedB = renderThunk(b, a)
    }

    if (isThunk(a)) {
        renderedA = renderThunk(a, null)
    }

    return {
        a: renderedA,
        b: renderedB
    }
}

function renderThunk(thunk, previous) {
    var renderedThunk = thunk.vnode

    if (!renderedThunk) {
        renderedThunk = thunk.vnode = thunk.render(previous)
    }

    if (!(isVNode(renderedThunk) ||
            isVText(renderedThunk) ||
            isWidget(renderedThunk))) {
        throw new Error("thunk did not return a valid node");
    }

    return renderedThunk
}

},{"./is-thunk":25,"./is-vnode":27,"./is-vtext":28,"./is-widget":29}],25:[function(require,module,exports){
module.exports = isThunk

function isThunk(t) {
    return t && t.type === "Thunk"
}

},{}],26:[function(require,module,exports){
module.exports = isHook

function isHook(hook) {
    return hook &&
      (typeof hook.hook === "function" && !hook.hasOwnProperty("hook") ||
       typeof hook.unhook === "function" && !hook.hasOwnProperty("unhook"))
}

},{}],27:[function(require,module,exports){
var version = require("./version")

module.exports = isVirtualNode

function isVirtualNode(x) {
    return x && x.type === "VirtualNode" && x.version === version
}

},{"./version":30}],28:[function(require,module,exports){
var version = require("./version")

module.exports = isVirtualText

function isVirtualText(x) {
    return x && x.type === "VirtualText" && x.version === version
}

},{"./version":30}],29:[function(require,module,exports){
module.exports = isWidget

function isWidget(w) {
    return w && w.type === "Widget"
}

},{}],30:[function(require,module,exports){
module.exports = "2"

},{}],31:[function(require,module,exports){
var version = require("./version")
var isVNode = require("./is-vnode")
var isWidget = require("./is-widget")
var isThunk = require("./is-thunk")
var isVHook = require("./is-vhook")

module.exports = VirtualNode

var noProperties = {}
var noChildren = []

function VirtualNode(tagName, properties, children, key, namespace) {
    this.tagName = tagName
    this.properties = properties || noProperties
    this.children = children || noChildren
    this.key = key != null ? String(key) : undefined
    this.namespace = (typeof namespace === "string") ? namespace : null

    var count = (children && children.length) || 0
    var descendants = 0
    var hasWidgets = false
    var hasThunks = false
    var descendantHooks = false
    var hooks

    for (var propName in properties) {
        if (properties.hasOwnProperty(propName)) {
            var property = properties[propName]
            if (isVHook(property) && property.unhook) {
                if (!hooks) {
                    hooks = {}
                }

                hooks[propName] = property
            }
        }
    }

    for (var i = 0; i < count; i++) {
        var child = children[i]
        if (isVNode(child)) {
            descendants += child.count || 0

            if (!hasWidgets && child.hasWidgets) {
                hasWidgets = true
            }

            if (!hasThunks && child.hasThunks) {
                hasThunks = true
            }

            if (!descendantHooks && (child.hooks || child.descendantHooks)) {
                descendantHooks = true
            }
        } else if (!hasWidgets && isWidget(child)) {
            if (typeof child.destroy === "function") {
                hasWidgets = true
            }
        } else if (!hasThunks && isThunk(child)) {
            hasThunks = true;
        }
    }

    this.count = count + descendants
    this.hasWidgets = hasWidgets
    this.hasThunks = hasThunks
    this.hooks = hooks
    this.descendantHooks = descendantHooks
}

VirtualNode.prototype.version = version
VirtualNode.prototype.type = "VirtualNode"

},{"./is-thunk":25,"./is-vhook":26,"./is-vnode":27,"./is-widget":29,"./version":30}],32:[function(require,module,exports){
var version = require("./version")

VirtualPatch.NONE = 0
VirtualPatch.VTEXT = 1
VirtualPatch.VNODE = 2
VirtualPatch.WIDGET = 3
VirtualPatch.PROPS = 4
VirtualPatch.ORDER = 5
VirtualPatch.INSERT = 6
VirtualPatch.REMOVE = 7
VirtualPatch.THUNK = 8

module.exports = VirtualPatch

function VirtualPatch(type, vNode, patch) {
    this.type = Number(type)
    this.vNode = vNode
    this.patch = patch
}

VirtualPatch.prototype.version = version
VirtualPatch.prototype.type = "VirtualPatch"

},{"./version":30}],33:[function(require,module,exports){
var version = require("./version")

module.exports = VirtualText

function VirtualText(text) {
    this.text = String(text)
}

VirtualText.prototype.version = version
VirtualText.prototype.type = "VirtualText"

},{"./version":30}],34:[function(require,module,exports){
var isObject = require("is-object")
var isHook = require("../vnode/is-vhook")

module.exports = diffProps

function diffProps(a, b) {
    var diff

    for (var aKey in a) {
        if (!(aKey in b)) {
            diff = diff || {}
            diff[aKey] = undefined
        }

        var aValue = a[aKey]
        var bValue = b[aKey]

        if (aValue === bValue) {
            continue
        } else if (isObject(aValue) && isObject(bValue)) {
            if (getPrototype(bValue) !== getPrototype(aValue)) {
                diff = diff || {}
                diff[aKey] = bValue
            } else if (isHook(bValue)) {
                 diff = diff || {}
                 diff[aKey] = bValue
            } else {
                var objectDiff = diffProps(aValue, bValue)
                if (objectDiff) {
                    diff = diff || {}
                    diff[aKey] = objectDiff
                }
            }
        } else {
            diff = diff || {}
            diff[aKey] = bValue
        }
    }

    for (var bKey in b) {
        if (!(bKey in a)) {
            diff = diff || {}
            diff[bKey] = b[bKey]
        }
    }

    return diff
}

function getPrototype(value) {
  if (Object.getPrototypeOf) {
    return Object.getPrototypeOf(value)
  } else if (value.__proto__) {
    return value.__proto__
  } else if (value.constructor) {
    return value.constructor.prototype
  }
}

},{"../vnode/is-vhook":26,"is-object":11}],35:[function(require,module,exports){
var isArray = require("x-is-array")

var VPatch = require("../vnode/vpatch")
var isVNode = require("../vnode/is-vnode")
var isVText = require("../vnode/is-vtext")
var isWidget = require("../vnode/is-widget")
var isThunk = require("../vnode/is-thunk")
var handleThunk = require("../vnode/handle-thunk")

var diffProps = require("./diff-props")

module.exports = diff

function diff(a, b) {
    var patch = { a: a }
    walk(a, b, patch, 0)
    return patch
}

function walk(a, b, patch, index) {
    if (a === b) {
        return
    }

    var apply = patch[index]
    var applyClear = false

    if (isThunk(a) || isThunk(b)) {
        thunks(a, b, patch, index)
    } else if (b == null) {

        // If a is a widget we will add a remove patch for it
        // Otherwise any child widgets/hooks must be destroyed.
        // This prevents adding two remove patches for a widget.
        if (!isWidget(a)) {
            clearState(a, patch, index)
            apply = patch[index]
        }

        apply = appendPatch(apply, new VPatch(VPatch.REMOVE, a, b))
    } else if (isVNode(b)) {
        if (isVNode(a)) {
            if (a.tagName === b.tagName &&
                a.namespace === b.namespace &&
                a.key === b.key) {
                var propsPatch = diffProps(a.properties, b.properties)
                if (propsPatch) {
                    apply = appendPatch(apply,
                        new VPatch(VPatch.PROPS, a, propsPatch))
                }
                apply = diffChildren(a, b, patch, apply, index)
            } else {
                apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b))
                applyClear = true
            }
        } else {
            apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b))
            applyClear = true
        }
    } else if (isVText(b)) {
        if (!isVText(a)) {
            apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b))
            applyClear = true
        } else if (a.text !== b.text) {
            apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b))
        }
    } else if (isWidget(b)) {
        if (!isWidget(a)) {
            applyClear = true
        }

        apply = appendPatch(apply, new VPatch(VPatch.WIDGET, a, b))
    }

    if (apply) {
        patch[index] = apply
    }

    if (applyClear) {
        clearState(a, patch, index)
    }
}

function diffChildren(a, b, patch, apply, index) {
    var aChildren = a.children
    var orderedSet = reorder(aChildren, b.children)
    var bChildren = orderedSet.children

    var aLen = aChildren.length
    var bLen = bChildren.length
    var len = aLen > bLen ? aLen : bLen

    for (var i = 0; i < len; i++) {
        var leftNode = aChildren[i]
        var rightNode = bChildren[i]
        index += 1

        if (!leftNode) {
            if (rightNode) {
                // Excess nodes in b need to be added
                apply = appendPatch(apply,
                    new VPatch(VPatch.INSERT, null, rightNode))
            }
        } else {
            walk(leftNode, rightNode, patch, index)
        }

        if (isVNode(leftNode) && leftNode.count) {
            index += leftNode.count
        }
    }

    if (orderedSet.moves) {
        // Reorder nodes last
        apply = appendPatch(apply, new VPatch(
            VPatch.ORDER,
            a,
            orderedSet.moves
        ))
    }

    return apply
}

function clearState(vNode, patch, index) {
    // TODO: Make this a single walk, not two
    unhook(vNode, patch, index)
    destroyWidgets(vNode, patch, index)
}

// Patch records for all destroyed widgets must be added because we need
// a DOM node reference for the destroy function
function destroyWidgets(vNode, patch, index) {
    if (isWidget(vNode)) {
        if (typeof vNode.destroy === "function") {
            patch[index] = appendPatch(
                patch[index],
                new VPatch(VPatch.REMOVE, vNode, null)
            )
        }
    } else if (isVNode(vNode) && (vNode.hasWidgets || vNode.hasThunks)) {
        var children = vNode.children
        var len = children.length
        for (var i = 0; i < len; i++) {
            var child = children[i]
            index += 1

            destroyWidgets(child, patch, index)

            if (isVNode(child) && child.count) {
                index += child.count
            }
        }
    } else if (isThunk(vNode)) {
        thunks(vNode, null, patch, index)
    }
}

// Create a sub-patch for thunks
function thunks(a, b, patch, index) {
    var nodes = handleThunk(a, b)
    var thunkPatch = diff(nodes.a, nodes.b)
    if (hasPatches(thunkPatch)) {
        patch[index] = new VPatch(VPatch.THUNK, null, thunkPatch)
    }
}

function hasPatches(patch) {
    for (var index in patch) {
        if (index !== "a") {
            return true
        }
    }

    return false
}

// Execute hooks when two nodes are identical
function unhook(vNode, patch, index) {
    if (isVNode(vNode)) {
        if (vNode.hooks) {
            patch[index] = appendPatch(
                patch[index],
                new VPatch(
                    VPatch.PROPS,
                    vNode,
                    undefinedKeys(vNode.hooks)
                )
            )
        }

        if (vNode.descendantHooks || vNode.hasThunks) {
            var children = vNode.children
            var len = children.length
            for (var i = 0; i < len; i++) {
                var child = children[i]
                index += 1

                unhook(child, patch, index)

                if (isVNode(child) && child.count) {
                    index += child.count
                }
            }
        }
    } else if (isThunk(vNode)) {
        thunks(vNode, null, patch, index)
    }
}

function undefinedKeys(obj) {
    var result = {}

    for (var key in obj) {
        result[key] = undefined
    }

    return result
}

// List diff, naive left to right reordering
function reorder(aChildren, bChildren) {
    // O(M) time, O(M) memory
    var bChildIndex = keyIndex(bChildren)
    var bKeys = bChildIndex.keys
    var bFree = bChildIndex.free

    if (bFree.length === bChildren.length) {
        return {
            children: bChildren,
            moves: null
        }
    }

    // O(N) time, O(N) memory
    var aChildIndex = keyIndex(aChildren)
    var aKeys = aChildIndex.keys
    var aFree = aChildIndex.free

    if (aFree.length === aChildren.length) {
        return {
            children: bChildren,
            moves: null
        }
    }

    // O(MAX(N, M)) memory
    var newChildren = []

    var freeIndex = 0
    var freeCount = bFree.length
    var deletedItems = 0

    // Iterate through a and match a node in b
    // O(N) time,
    for (var i = 0 ; i < aChildren.length; i++) {
        var aItem = aChildren[i]
        var itemIndex

        if (aItem.key) {
            if (bKeys.hasOwnProperty(aItem.key)) {
                // Match up the old keys
                itemIndex = bKeys[aItem.key]
                newChildren.push(bChildren[itemIndex])

            } else {
                // Remove old keyed items
                itemIndex = i - deletedItems++
                newChildren.push(null)
            }
        } else {
            // Match the item in a with the next free item in b
            if (freeIndex < freeCount) {
                itemIndex = bFree[freeIndex++]
                newChildren.push(bChildren[itemIndex])
            } else {
                // There are no free items in b to match with
                // the free items in a, so the extra free nodes
                // are deleted.
                itemIndex = i - deletedItems++
                newChildren.push(null)
            }
        }
    }

    var lastFreeIndex = freeIndex >= bFree.length ?
        bChildren.length :
        bFree[freeIndex]

    // Iterate through b and append any new keys
    // O(M) time
    for (var j = 0; j < bChildren.length; j++) {
        var newItem = bChildren[j]

        if (newItem.key) {
            if (!aKeys.hasOwnProperty(newItem.key)) {
                // Add any new keyed items
                // We are adding new items to the end and then sorting them
                // in place. In future we should insert new items in place.
                newChildren.push(newItem)
            }
        } else if (j >= lastFreeIndex) {
            // Add any leftover non-keyed items
            newChildren.push(newItem)
        }
    }

    var simulate = newChildren.slice()
    var simulateIndex = 0
    var removes = []
    var inserts = []
    var simulateItem

    for (var k = 0; k < bChildren.length;) {
        var wantedItem = bChildren[k]
        simulateItem = simulate[simulateIndex]

        // remove items
        while (simulateItem === null && simulate.length) {
            removes.push(remove(simulate, simulateIndex, null))
            simulateItem = simulate[simulateIndex]
        }

        if (!simulateItem || simulateItem.key !== wantedItem.key) {
            // if we need a key in this position...
            if (wantedItem.key) {
                if (simulateItem && simulateItem.key) {
                    // if an insert doesn't put this key in place, it needs to move
                    if (bKeys[simulateItem.key] !== k + 1) {
                        removes.push(remove(simulate, simulateIndex, simulateItem.key))
                        simulateItem = simulate[simulateIndex]
                        // if the remove didn't put the wanted item in place, we need to insert it
                        if (!simulateItem || simulateItem.key !== wantedItem.key) {
                            inserts.push({key: wantedItem.key, to: k})
                        }
                        // items are matching, so skip ahead
                        else {
                            simulateIndex++
                        }
                    }
                    else {
                        inserts.push({key: wantedItem.key, to: k})
                    }
                }
                else {
                    inserts.push({key: wantedItem.key, to: k})
                }
                k++
            }
            // a key in simulate has no matching wanted key, remove it
            else if (simulateItem && simulateItem.key) {
                removes.push(remove(simulate, simulateIndex, simulateItem.key))
            }
        }
        else {
            simulateIndex++
            k++
        }
    }

    // remove all the remaining nodes from simulate
    while(simulateIndex < simulate.length) {
        simulateItem = simulate[simulateIndex]
        removes.push(remove(simulate, simulateIndex, simulateItem && simulateItem.key))
    }

    // If the only moves we have are deletes then we can just
    // let the delete patch remove these items.
    if (removes.length === deletedItems && !inserts.length) {
        return {
            children: newChildren,
            moves: null
        }
    }

    return {
        children: newChildren,
        moves: {
            removes: removes,
            inserts: inserts
        }
    }
}

function remove(arr, index, key) {
    arr.splice(index, 1)

    return {
        from: index,
        key: key
    }
}

function keyIndex(children) {
    var keys = {}
    var free = []
    var length = children.length

    for (var i = 0; i < length; i++) {
        var child = children[i]

        if (child.key) {
            keys[child.key] = i
        } else {
            free.push(i)
        }
    }

    return {
        keys: keys,     // A hash of key name to index
        free: free      // An array of unkeyed item indices
    }
}

function appendPatch(apply, patch) {
    if (apply) {
        if (isArray(apply)) {
            apply.push(patch)
        } else {
            apply = [apply, patch]
        }

        return apply
    } else {
        return patch
    }
}

},{"../vnode/handle-thunk":24,"../vnode/is-thunk":25,"../vnode/is-vnode":27,"../vnode/is-vtext":28,"../vnode/is-widget":29,"../vnode/vpatch":32,"./diff-props":34,"x-is-array":12}]},{},[4])(4)
});

  var GLOBAL = typeof window !== "undefined" ? window :
      typeof global!=="undefined" ? global :
        typeof self!=="undefined" ? self : this;
  System.global._classRecorder = {};
  var Label$$1,LoadingIndicator,ListItemMorph,DropDownList$$1;
this.lively = this.lively || {};
(function (exports,lively_graphics,lively_lang,vdom,gsap,lively_bindings,bowser,lively_notifications,lively_serializer2,lively_resources,lively_morphic,svgIntersections) {
'use strict';

var vdom__default = 'default' in vdom ? vdom['default'] : vdom;
bowser = 'default' in bowser ? bowser['default'] : bowser;

var config = {
  defaultShadow: {
    distance: 2,
    blur: 6
  },
  undoLevels: 20,
  halosEnabled: true,
  altClickDefinesThat: true,
  verboseLogging: true,
  maxStatusMessages: 5,
  repeatClickInterval: 250,
  showTooltipsAfter: 0.8,
  ide: {
    js: {
      ignoredPackages: ["lively.web", "no group"]
    }
  },
  globalKeyBindings: [{
    keys: {
      mac: "Meta-Z",
      win: "Ctrl-Z"
    },
    command: "undo"
  }, {
    keys: {
      mac: "Meta-Shift-Z",
      win: "Ctrl-Shift-Z"
    },
    command: "redo"
  }, {
    keys: "Alt-X",
    command: "run command"
  }, {
    keys: "Meta-H",
    command: "show halo for focused morph"
  }, {
    keys: "Alt-M",
    command: "select morph"
  }, {
    keys: "Escape",
    command: "escape"
  }, {
    keys: {
      win: "Ctrl-Escape",
      mac: "Meta-Escape"
    },
    command: "close active window or morph"
  }, {
    keys: "Alt-Shift-C",
    command: "toggle minimize active window"
  }, {
    keys: {
      mac: "Meta-O",
      win: "Ctrl-O"
    },
    command: "open status message of focused morph"
  }, {
    keys: {
      win: "Ctrl-K",
      mac: "Meta-K"
    },
    command: {
      command: "open workspace",
      onlyWhenFocused: false
    }
  }, {
    keys: "Alt-Shift-1",
    command: {
      command: "open shell terminal",
      onlyWhenFocused: false
    }
  }, {
    keys: {
      win: "Ctrl-B",
      mac: "Meta-B"
    },
    command: {
      command: "open browser",
      onlyWhenFocused: false
    }
  }, {
    keys: {
      win: "Ctrl-P",
      mac: "Meta-P"
    },
    command: {
      command: "open PartsBin",
      onlyWhenFocused: true
    }
  }, {
    keys: "Alt-T",
    command: {
      command: "choose and browse module",
      onlyWhenFocused: false
    }
  }, {
    keys: "Alt-Shift-T",
    command: {
      command: "choose and browse package resources",
      onlyWhenFocused: false
    }
  }, {
    keys: "Ctrl-X D",
    command: "open file browser"
  }, {
    keys: "Ctrl-X Ctrl-F",
    command: "open file"
  }, {
    keys: {
      win: "Ctrl-Shift-F",
      mac: "Meta-Shift-F"
    },
    command: {
      command: "open code search",
      onlyWhenFocused: false
    }
  }, {
    keys: "Left",
    command: {
      command: "move or resize halo target",
      args: {
        what: "move",
        direction: "left",
        offset: 1
      }
    }
  }, {
    keys: "Right",
    command: {
      command: "move or resize halo target",
      args: {
        what: "move",
        direction: "right",
        offset: 1
      }
    }
  }, {
    keys: "Up",
    command: {
      command: "move or resize halo target",
      args: {
        what: "move",
        direction: "up",
        offset: 1
      }
    }
  }, {
    keys: "Down",
    command: {
      command: "move or resize halo target",
      args: {
        what: "move",
        direction: "down",
        offset: 1
      }
    }
  }, {
    keys: "Meta-Left",
    command: {
      command: "move or resize halo target",
      args: {
        what: "move",
        direction: "left",
        offset: 10
      }
    }
  }, {
    keys: "Meta-Right",
    command: {
      command: "move or resize halo target",
      args: {
        what: "move",
        direction: "right",
        offset: 10
      }
    }
  }, {
    keys: "Meta-Up",
    command: {
      command: "move or resize halo target",
      args: {
        what: "move",
        direction: "up",
        offset: 10
      }
    }
  }, {
    keys: "Meta-Down",
    command: {
      command: "move or resize halo target",
      args: {
        what: "move",
        direction: "down",
        offset: 10
      }
    }
  }, {
    keys: "Alt-Left",
    command: {
      command: "move or resize halo target",
      args: {
        what: "move",
        direction: "left",
        offset: 100
      }
    }
  }, {
    keys: "Alt-Right",
    command: {
      command: "move or resize halo target",
      args: {
        what: "move",
        direction: "right",
        offset: 100
      }
    }
  }, {
    keys: "Alt-Up",
    command: {
      command: "move or resize halo target",
      args: {
        what: "move",
        direction: "up",
        offset: 100
      }
    }
  }, {
    keys: "Alt-Down",
    command: {
      command: "move or resize halo target",
      args: {
        what: "move",
        direction: "down",
        offset: 100
      }
    }
  }, {
    keys: "Shift-Left",
    command: {
      command: "move or resize halo target",
      args: {
        what: "resize",
        direction: "left",
        offset: 1
      }
    }
  }, {
    keys: "Shift-Right",
    command: {
      command: "move or resize halo target",
      args: {
        what: "resize",
        direction: "right",
        offset: 1
      }
    }
  }, {
    keys: "Shift-Up",
    command: {
      command: "move or resize halo target",
      args: {
        what: "resize",
        direction: "up",
        offset: 1
      }
    }
  }, {
    keys: "Shift-Down",
    command: {
      command: "move or resize halo target",
      args: {
        what: "resize",
        direction: "down",
        offset: 1
      }
    }
  }, {
    keys: "Meta-Shift-Left",
    command: {
      command: "move or resize halo target",
      args: {
        what: "resize",
        direction: "left",
        offset: 10
      }
    }
  }, {
    keys: "Meta-Shift-Right",
    command: {
      command: "move or resize halo target",
      args: {
        what: "resize",
        direction: "right",
        offset: 10
      }
    }
  }, {
    keys: "Meta-Shift-Up",
    command: {
      command: "move or resize halo target",
      args: {
        what: "resize",
        direction: "up",
        offset: 10
      }
    }
  }, {
    keys: "Meta-Shift-Down",
    command: {
      command: "move or resize halo target",
      args: {
        what: "resize",
        direction: "down",
        offset: 10
      }
    }
  }, {
    keys: "Alt-Shift-Left",
    command: {
      command: "move or resize halo target",
      args: {
        what: "resize",
        direction: "left",
        offset: 100
      }
    }
  }, {
    keys: "Alt-Shift-Right",
    command: {
      command: "move or resize halo target",
      args: {
        what: "resize",
        direction: "right",
        offset: 100
      }
    }
  }, {
    keys: "Alt-Shift-Up",
    command: {
      command: "move or resize halo target",
      args: {
        what: "resize",
        direction: "up",
        offset: 100
      }
    }
  }, {
    keys: "Alt-Shift-Down",
    command: {
      command: "move or resize halo target",
      args: {
        what: "resize",
        direction: "down",
        offset: 100
      }
    }
  }, {
    keys: {
      win: "Ctrl-`|Alt-`",
      mac: "Meta-1"
    },
    command: "window switcher"
  }, {
    keys: {
      mac: "Meta-Shift-L R E S 1",
      win: "Ctrl-Shift-L R E S 1"
    },
    command: {
      command: "resize active window",
      args: { how: "col1" }
    }
  }, {
    keys: {
      mac: "Meta-Shift-L R E S 2",
      win: "Ctrl-Shift-L R E S 2"
    },
    command: {
      command: "resize active window",
      args: { how: "col2" }
    }
  }, {
    keys: {
      mac: "Meta-Shift-L R E S 3",
      win: "Ctrl-Shift-L R E S 3"
    },
    command: {
      command: "resize active window",
      args: { how: "col3" }
    }
  }, {
    keys: {
      mac: "Meta-Shift-L R E S 4",
      win: "Ctrl-Shift-L R E S 4"
    },
    command: {
      command: "resize active window",
      args: { how: "col4" }
    }
  }, {
    keys: {
      mac: "Meta-Shift-L R E S 5",
      win: "Ctrl-Shift-L R E S 5"
    },
    command: {
      command: "resize active window",
      args: { how: "col5" }
    }
  }, {
    keys: {
      mac: "Meta-Shift-L R E S Alt-1",
      win: "Ctrl-Shift-L R E S Alt-1"
    },
    command: {
      command: "resize active window",
      args: { how: "quadrant1" }
    }
  }, {
    keys: {
      mac: "Meta-Shift-L R E S Alt-2",
      win: "Ctrl-Shift-L R E S Alt-2"
    },
    command: {
      command: "resize active window",
      args: { how: "quadrant2" }
    }
  }, {
    keys: {
      mac: "Meta-Shift-L R E S Alt-3",
      win: "Ctrl-Shift-L R E S Alt-3"
    },
    command: {
      command: "resize active window",
      args: { how: "quadrant3" }
    }
  }, {
    keys: {
      mac: "Meta-Shift-L R E S Alt-4",
      win: "Ctrl-Shift-L R E S Alt-4"
    },
    command: {
      command: "resize active window",
      args: { how: "quadrant4" }
    }
  }, {
    keys: {
      mac: "Meta-Shift-L R E S Alt-5",
      win: "Ctrl-Shift-L R E S Alt-5"
    },
    command: {
      command: "resize active window",
      args: { how: "quadrant5" }
    }
  }, {
    keys: {
      mac: "Meta-Shift-L R E S Alt-6",
      win: "Ctrl-Shift-L R E S Alt-6"
    },
    command: {
      command: "resize active window",
      args: { how: "quadrant6" }
    }
  }, {
    keys: {
      mac: "Meta-Shift-L R E S Alt-7",
      win: "Ctrl-Shift-L R E S Alt-7"
    },
    command: {
      command: "resize active window",
      args: { how: "quadrant7" }
    }
  }, {
    keys: {
      mac: "Meta-Shift-L R E S Alt-8",
      win: "Ctrl-Shift-L R E S Alt-8"
    },
    command: {
      command: "resize active window",
      args: { how: "quadrant8" }
    }
  }, {
    keys: {
      mac: "Meta-Shift-L R E S Alt-9",
      win: "Ctrl-Shift-L R E S Alt-9"
    },
    command: {
      command: "resize active window",
      args: { how: "quadrant9" }
    }
  }, {
    keys: {
      mac: "Meta-Shift-L R E S Alt-0",
      win: "Ctrl-Shift-L R E S Alt-0"
    },
    command: {
      command: "resize active window",
      args: { how: "quadrant0" }
    }
  }, {
    keys: {
      mac: "Meta-Shift-L R E S C",
      win: "Ctrl-Shift-L R E S C"
    },
    command: {
      command: "resize active window",
      args: { how: "center" }
    }
  }, {
    keys: {
      mac: "Meta-Shift-L R E S L",
      win: "Ctrl-Shift-L R E S L"
    },
    command: {
      command: "resize active window",
      args: { how: "left" }
    }
  }, {
    keys: {
      mac: "Meta-Shift-L R E S R",
      win: "Ctrl-Shift-L R E S R"
    },
    command: {
      command: "resize active window",
      args: { how: "right" }
    }
  }, {
    keys: {
      mac: "Meta-Shift-L R E S F",
      win: "Ctrl-Shift-L R E S F"
    },
    command: {
      command: "resize active window",
      args: { how: "full" }
    }
  }, {
    keys: {
      mac: "Meta-Shift-L R E S T",
      win: "Ctrl-Shift-L R E S T"
    },
    command: {
      command: "resize active window",
      args: { how: "top" }
    }
  }, {
    keys: {
      mac: "Meta-Shift-L R E S H T",
      win: "Ctrl-Shift-L R E S H T"
    },
    command: {
      command: "resize active window",
      args: { how: "halftop" }
    }
  }, {
    keys: {
      mac: "Meta-Shift-L R E S B",
      win: "Ctrl-Shift-L R E S B"
    },
    command: {
      command: "resize active window",
      args: { how: "bottom" }
    }
  }, {
    keys: {
      mac: "Meta-Shift-L R E S H B",
      win: "Ctrl-Shift-L R E S H B"
    },
    command: {
      command: "resize active window",
      args: { how: "halfbottom" }
    }
  }, {
    keys: {
      mac: "Meta-Shift-L R E S Escape",
      win: "Ctrl-Shift-L R E S Escape"
    },
    command: {
      command: "resize active window",
      args: { how: "reset" }
    }
  }],
  text: {
    cursorBlinkPeriod: 0.5,
    useSoftTabs: true,
    tabWidth: 2,
    markStackSize: 16,
    undoLevels: 50,
    clipboardBufferLength: 100,
    useMultiSelect: true,
    undoGroupDelay: 600,
    defaultKeyBindings: [{
      keys: {
        mac: "Meta-C",
        win: "Ctrl-C"
      },
      command: {
        command: "clipboard copy",
        passEvent: true
      }
    }, {
      keys: "Ctrl-W",
      command: {
        command: "manual clipboard copy",
        args: { "delete": true }
      }
    }, {
      keys: "Alt-W",
      command: "manual clipboard copy"
    }, {
      keys: "Ctrl-Y",
      command: "manual clipboard paste"
    }, {
      keys: "Alt-Y",
      command: {
        command: "manual clipboard paste",
        args: { killRingCycleBack: true }
      }
    }, {
      keys: {
        mac: "Meta-X",
        win: "Ctrl-X"
      },
      command: {
        command: "clipboard cut",
        passEvent: true
      }
    }, {
      keys: {
        mac: "Meta-V",
        win: "Ctrl-V"
      },
      command: {
        command: "clipboard paste",
        passEvent: true
      }
    }, {
      keys: {
        mac: "Meta-Z|Ctrl-Shift--|Ctrl-x u",
        win: "Ctrl-Z|Ctrl-Shift--|Ctrl-x u"
      },
      command: "text undo"
    }, {
      keys: {
        mac: "Meta-Shift-Z",
        win: "Ctrl-Shift-Z"
      },
      command: "text redo"
    }, {
      keys: {
        mac: "Meta-A|Ctrl-X H",
        win: "Ctrl-A|Ctrl-X H"
      },
      command: "select all"
    }, {
      keys: {
        mac: "Meta-D",
        win: "Ctrl-D"
      },
      command: "doit"
    }, {
      keys: { mac: "Meta-Shift-L X B" },
      command: "eval all"
    }, {
      keys: {
        mac: "Meta-P",
        win: "Ctrl-P"
      },
      command: "printit"
    }, {
      keys: {
        mac: "Meta-I",
        win: "Ctrl-I"
      },
      command: "print inspectit"
    }, {
      keys: {
        mac: "Meta-Shift-I",
        win: "Ctrl-Shift-I"
      },
      command: "inspectit"
    }, {
      keys: {
        mac: "Meta-Shift-U",
        win: "Ctrl-Shift-U"
      },
      command: "undefine variable"
    }, {
      keys: {
        mac: "Meta-S",
        win: "Ctrl-S"
      },
      command: "saveit"
    }, {
      keys: "Backspace",
      command: "delete backwards"
    }, {
      keys: {
        win: "Delete",
        mac: "Delete|Ctrl-D"
      },
      command: "delete"
    }, {
      keys: {
        win: "Left",
        mac: "Left|Ctrl-B"
      },
      command: "go left"
    }, {
      keys: {
        win: "Right",
        mac: "Right|Ctrl-F"
      },
      command: "go right"
    }, {
      keys: {
        win: "Up",
        mac: "Up|Ctrl-P"
      },
      command: "go up"
    }, {
      keys: {
        win: "Down",
        mac: "Down|Ctrl-N"
      },
      command: "go down"
    }, {
      keys: "Shift-Left",
      command: "select left"
    }, {
      keys: "Shift-Right",
      command: "select right"
    }, {
      keys: "Shift-Up",
      command: "select up"
    }, {
      keys: "Shift-Down",
      command: "select down"
    }, {
      keys: {
        win: "Ctrl-Right",
        mac: "Alt-Right|Alt-F"
      },
      command: "goto word right"
    }, {
      keys: {
        win: "Ctrl-Left",
        mac: "Alt-Left|Alt-B"
      },
      command: "goto word left"
    }, {
      keys: {
        win: "Ctrl-Shift-Right",
        mac: "Alt-Shift-Right|Alt-Shift-F"
      },
      command: {
        command: "goto word right",
        args: { select: true }
      }
    }, {
      keys: {
        win: "Ctrl-Shift-Left",
        mac: "Alt-Shift-Left|Alt-Shift-B"
      },
      command: {
        command: "goto word left",
        args: { select: true }
      }
    }, {
      keys: "Alt-Backspace",
      command: "delete word left"
    }, {
      keys: "Alt-D",
      command: "delete word right"
    }, {
      keys: "Alt-Ctrl-K",
      command: "delete word right"
    }, {
      keys: "Alt-Shift-2",
      command: "select word right"
    }, {
      keys: "Ctrl-X Ctrl-X",
      command: "reverse selection"
    }, {
      keys: {
        win: "Ctrl-Shift-L",
        mac: "Meta-L"
      },
      command: "select line"
    }, {
      keys: {
        win: "Shift-Home",
        mac: "Shift-Home|Ctrl-Shift-A"
      },
      command: {
        command: "goto line start",
        args: { select: true }
      }
    }, {
      keys: {
        win: "Home",
        mac: "Home|Ctrl-A"
      },
      command: {
        command: "goto line start",
        args: { select: false }
      }
    }, {
      keys: {
        win: "Shift-End",
        mac: "Shift-End|Ctrl-Shift-E"
      },
      command: {
        command: "goto line end",
        args: { select: true }
      }
    }, {
      keys: {
        win: "End",
        mac: "End|Ctrl-E"
      },
      command: {
        command: "goto line end",
        args: { select: false }
      }
    }, {
      keys: "Ctrl-C J",
      command: {
        command: "join line",
        args: { withLine: "before" }
      }
    }, {
      keys: "Ctrl-C Shift-J",
      command: {
        command: "join line",
        args: { withLine: "after" }
      }
    }, {
      keys: {
        win: "Ctrl-Shift-D",
        mac: "Meta-Shift-D|Ctrl-C P"
      },
      command: "duplicate line or selection"
    }, {
      keys: {
        win: "Ctrl-Backspace",
        mac: "Meta-Backspace"
      },
      command: "delete left until beginning of line"
    }, {
      keys: "Ctrl-K",
      command: "delete emtpy line or until end of line"
    }, {
      keys: {
        win: "Ctrl-Alt-Up|Ctrl-Alt-P",
        mac: "Ctrl-Meta-Up|Ctrl-Meta-P"
      },
      command: "move lines up"
    }, {
      keys: {
        win: "Ctrl-Alt-Down|Ctrl-Alt-N",
        mac: "Ctrl-Meta-Down|Ctrl-Meta-N"
      },
      command: "move lines down"
    }, {
      keys: {
        win: "PageDown",
        mac: "PageDown|Ctrl-V"
      },
      command: "goto page down"
    }, {
      keys: {
        win: "PageUp",
        mac: "PageUp|Alt-V"
      },
      command: "goto page up"
    }, {
      keys: {
        win: "Shift-PageDown",
        mac: "Shift-PageDown"
      },
      command: "goto page down and select"
    }, {
      keys: {
        win: "Shift-PageUp",
        mac: "Shift-PageUp"
      },
      command: "goto page up and select"
    }, {
      keys: "Alt-Ctrl-,",
      command: "move cursor to screen top in 1/3 steps"
    }, {
      keys: "Alt-Ctrl-.",
      command: "move cursor to screen bottom in 1/3 steps"
    }, {
      keys: {
        win: "Alt-Left",
        mac: "Meta-Left"
      },
      command: "goto matching left"
    }, {
      keys: {
        win: "Alt-Shift-Left",
        mac: "Meta-Shift-Left"
      },
      command: {
        command: "goto matching left",
        args: { select: true }
      }
    }, {
      keys: {
        win: "Alt-Right",
        mac: "Meta-Right"
      },
      command: "goto matching right"
    }, {
      keys: {
        win: "Alt-Shift-Right",
        mac: "Meta-Shift-Right"
      },
      command: {
        command: "goto matching right",
        args: { select: true }
      }
    }, {
      keys: "Alt-Ctrl-B",
      command: "goto matching left"
    }, {
      keys: "Alt-Ctrl-F",
      command: "goto matching right"
    }, {
      keys: "Ctrl-Up",
      command: "goto paragraph above"
    }, {
      keys: "Ctrl-Down",
      command: "goto paragraph below"
    }, {
      keys: {
        win: "Ctrl-Shift-Home",
        mac: "Meta-Shift-Up"
      },
      command: {
        command: "goto start",
        args: { select: true }
      }
    }, {
      keys: {
        win: "Ctrl-Shift-End",
        mac: "Meta-Shift-Down"
      },
      command: {
        command: "goto end",
        args: { select: true }
      }
    }, {
      keys: {
        win: "Ctrl-Home",
        mac: "Meta-Up|Meta-Home|Alt-Shift-,"
      },
      command: "goto start"
    }, {
      keys: {
        win: "Ctrl-End",
        mac: "Meta-Down|Meta-End|Alt-Shift-."
      },
      command: "goto end"
    }, {
      keys: "Ctrl-L",
      command: "realign top-bottom-center"
    }, {
      keys: {
        win: "Ctrl-Shift-L",
        mac: "Ctrl-Shift-L|Alt-G G"
      },
      command: "goto line"
    }, {
      keys: "Enter",
      command: "newline"
    }, {
      keys: "Space",
      command: {
        command: "insertstring",
        args: {
          string: " ",
          undoGroup: true
        }
      }
    }, {
      keys: "Tab",
      command: { command: "tab - snippet expand or indent" }
    }, {
      keys: {
        win: "Ctrl-]",
        mac: "Meta-]"
      },
      command: "indent"
    }, {
      keys: {
        win: "Ctrl-[",
        mac: "Meta-["
      },
      command: "outdent"
    }, {
      keys: {
        win: "Ctrl-Enter",
        mac: "Meta-Enter"
      },
      command: {
        command: "insert line",
        args: { where: "below" }
      }
    }, {
      keys: "Shift-Enter",
      command: {
        command: "insert line",
        args: { where: "above" }
      }
    }, {
      keys: "Ctrl-O",
      command: "split line"
    }, {
      keys: { mac: "Ctrl-X Ctrl-T" },
      command: "transpose chars"
    }, {
      keys: { mac: "Ctrl-C Ctrl-U" },
      command: "uppercase"
    }, {
      keys: { mac: "Ctrl-C Ctrl-L" },
      command: "lowercase"
    }, {
      keys: { mac: "Meta-Shift-L W t" },
      command: "remove trailing whitespace"
    }, {
      keys: "Ctrl-Space",
      command: "toggle active mark"
    }, {
      keys: { mac: "Meta-Shift-L L T" },
      command: "toggle line wrapping"
    }, {
      keys: {
        win: "Ctrl-=",
        mac: "Meta-="
      },
      command: "increase font size"
    }, {
      keys: {
        win: "Ctrl--",
        mac: "Meta--"
      },
      command: "decrease font size"
    }, {
      keys: "Esc|Ctrl-G",
      command: "cancel input"
    }, {
      keys: {
        win: "Ctrl-/",
        mac: "Meta-/"
      },
      command: "toggle comment"
    }, {
      keys: {
        win: "Alt-Ctrl-/",
        mac: "Alt-Meta-/|Alt-Meta-\xF7"
      },
      command: "toggle block comment"
    }, {
      keys: "Meta-Shift-L /  D",
      command: "comment box"
    }, {
      keys: {
        windows: "Ctrl-.",
        mac: "Meta-."
      },
      command: "[IyGotoChar] activate"
    }, {
      keys: {
        windows: "Ctrl-,",
        mac: "Meta-,"
      },
      command: {
        command: "[IyGotoChar] activate",
        args: { backwards: true }
      }
    }, {
      keys: "Alt-Shift-Space|Alt-Space|Meta-Shift-P",
      command: "text completion"
    }, {
      keys: "Alt-Q",
      command: "fit text to column"
    }, {
      keys: {
        win: "Ctrl-F|Ctrl-G|F3",
        mac: "Meta-F|Meta-G|Ctrl-S"
      },
      command: "search in text"
    }, {
      keys: {
        win: "Ctrl-Shift-F|Ctrl-Shift-G",
        mac: "Meta-Shift-F|Meta-Shift-G|Ctrl-R"
      },
      command: {
        command: "search in text",
        args: { backwards: true }
      }
    }, {
      keys: "Ctrl-Shift-/|Ctrl-C Ctrl-Shift-,",
      command: "[multi select] all like this"
    }, {
      keys: "Alt-Ctrl-P",
      command: "[multi select] add cursor above"
    }, {
      keys: "Alt-Ctrl-N",
      command: "[multi select] add cursor below"
    }, {
      keys: "Ctrl-Shift-,",
      command: "[multi select] more like this backward"
    }, {
      keys: "Ctrl-Shift-.",
      command: "[multi select] more like this forward"
    }, {
      keys: { mac: "Meta-Shift-," },
      command: "[multi select] goto previous focused cursor"
    }, {
      keys: { mac: "Meta-Shift-." },
      command: "[multi select] goto next focused cursor"
    }, {
      keys: "Ctrl-Shift-;",
      command: "[multi select] remove focused cursor"
    }, {
      keys: "Alt-Ctrl-A",
      command: "[multi select] align cursors"
    }, {
      keys: "Ctrl-X R",
      command: "[multi select] create rectangular selection"
    }, {
      keys: "Ctrl-C E",
      command: "[javascript] list errors and warnings"
    }, {
      keys: {
        mac: "Meta-Shift-L L I N T R",
        win: "Ctrl-Shift-L L I N T R"
      },
      command: "[javascript] eslint report"
    }, {
      keys: {
        mac: "Meta-Shift-L L I N T P",
        win: "Ctrl-Shift-L L I N T P"
      },
      command: "[javascript] eslint preview fixes"
    }, {
      keys: {
        mac: "Meta-Shift-L L I N T F",
        win: "Ctrl-Shift-L L I N T F"
      },
      command: "[javascript] eslint fix"
    }, {
      keys: "Ctrl-C I",
      command: "[javascript] inject import"
    }, {
      keys: {
        win: "Shift-Ctrl-S|Ctrl-Alt-Space",
        mac: "Ctrl-Command-space|Ctrl-Alt-Space"
      },
      command: "contractRegion"
    }, {
      keys: {
        win: "Shift-Ctrl-E|Ctrl-Shift-Space",
        mac: "Shift-Command-Space|Ctrl-Shift-Space"
      },
      command: "expandRegion"
    }, {
      keys: "Ctrl-Alt-h",
      command: "markDefun"
    }, {
      keys: "Ctrl-Alt-d|Ctrl-Alt-Down",
      command: "forwardDownSexp"
    }, {
      keys: "Ctrl-Alt-u|Ctrl-Alt-Up",
      command: "backwardUpSexp"
    }, {
      keys: "Ctrl-Alt-b|Ctrl-Alt-Left",
      command: "backwardSexp"
    }, {
      keys: "Ctrl-Alt-f|Ctrl-Alt-Right",
      command: "forwardSexp"
    }, {
      keys: "Alt-.",
      command: "selectDefinition"
    }, {
      keys: "Ctrl-Shift-'",
      command: "selectSymbolReferenceOrDeclaration"
    }, {
      keys: "Ctrl-Shift-[",
      command: "selectSymbolReferenceOrDeclarationPrev"
    }, {
      keys: "Ctrl-Shift-]",
      command: "selectSymbolReferenceOrDeclarationNext"
    }, {
      keys: {
        mac: "Meta-Shift-L D A T E",
        win: "Ctrl-Shift-L D A T E"
      },
      command: "insert date"
    }, {
      keys: "Ctrl-C Ctrl-I",
      command: "change string inflection"
    }, {
      keys: "Alt-Shift-4",
      command: "spell check word"
    }, {
      keys: "Alt-Shift-\\",
      command: "[shell] run shell command on region"
    }, {
      keys: {
        mac: "Meta-Shift-L O P E N",
        win: "Ctrl-Shift-L O P E N"
      },
      command: "open file at cursor"
    }]
  },
  codeEditor: {
    defaultTheme: "github",
    defaultStyle: {
      fontFamily: "Inconsolata, monospace",
      padding: lively_graphics.Rectangle.inset(4, 2, 4, 2),
      fontSize: 14,
      clipMode: "auto"
    }
  },
  remotes: { server: System.get("@system-env").browser ? document.location.origin + "/eval" : null }
};

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj$$1) {
  return typeof obj$$1;
} : function (obj$$1) {
  return obj$$1 && typeof Symbol === "function" && obj$$1.constructor === Symbol && obj$$1 !== Symbol.prototype ? "symbol" : typeof obj$$1;
};
var jsx = function () {
  var REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 60103;
  return function createRawReactElement(type, props, key, children) {
    var defaultProps = type && type.defaultProps;
    var childrenLength = arguments.length - 3;
    if (!props && childrenLength !== 0) {
      props = {};
    }
    if (props && defaultProps) {
      for (var propName in defaultProps) {
        if (props[propName] === void 0) {
          props[propName] = defaultProps[propName];
        }
      }
    } else if (!props) {
      props = defaultProps || {};
    }
    if (childrenLength === 1) {
      props.children = children;
    } else if (childrenLength > 1) {
      var childArray = Array(childrenLength);
      for (var i = 0; i < childrenLength; i++) {
        childArray[i] = arguments[i + 3];
      }
      props.children = childArray;
    }
    return {
      $$typeof: REACT_ELEMENT_TYPE,
      type: type,
      key: key === undefined ? null : "" + key,
      ref: null,
      props: props,
      _owner: null
    };
  };
}();
var asyncIterator = function (iterable) {
  if (typeof Symbol === "function") {
    if (Symbol.asyncIterator) {
      var method = iterable[Symbol.asyncIterator];
      if (method != null)
        return method.call(iterable);
    }
    if (Symbol.iterator) {
      return iterable[Symbol.iterator]();
    }
  }
  throw new TypeError("Object is not async iterable");
};
var asyncGenerator = function () {
  function AwaitValue(value) {
    this.value = value;
  }
  function AsyncGenerator(gen) {
    var front, back;
    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };
        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }
    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;
        if (value instanceof AwaitValue) {
          Promise.resolve(value.value).then(function (arg) {
            resume("next", arg);
          }, function (arg) {
            resume("throw", arg);
          });
        } else {
          settle(result.done ? "return" : "normal", result.value);
        }
      } catch (err) {
        settle("throw", err);
      }
    }
    function settle(type, value) {
      switch (type) {
      case "return":
        front.resolve({
          value: value,
          done: true
        });
        break;
      case "throw":
        front.reject(value);
        break;
      default:
        front.resolve({
          value: value,
          done: false
        });
        break;
      }
      front = front.next;
      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }
    this._invoke = send;
    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }
  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }
  AsyncGenerator.prototype.next = function (arg) {
    return this._invoke("next", arg);
  };
  AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke("throw", arg);
  };
  AsyncGenerator.prototype.return = function (arg) {
    return this._invoke("return", arg);
  };
  return {
    wrap: function (fn) {
      return function () {
        return new AsyncGenerator(fn.apply(this, arguments));
      };
    },
    await: function (value) {
      return new AwaitValue(value);
    }
  };
}();
var asyncGeneratorDelegate = function (inner, awaitWrap) {
  var iter = {}, waiting = false;
  function pump(key, value) {
    waiting = true;
    value = new Promise(function (resolve) {
      resolve(inner[key](value));
    });
    return {
      done: false,
      value: awaitWrap(value)
    };
  }
  
  if (typeof Symbol === "function" && Symbol.iterator) {
    iter[Symbol.iterator] = function () {
      return this;
    };
  }
  iter.next = function (value) {
    if (waiting) {
      waiting = false;
      return value;
    }
    return pump("next", value);
  };
  if (typeof inner.throw === "function") {
    iter.throw = function (value) {
      if (waiting) {
        waiting = false;
        throw value;
      }
      return pump("throw", value);
    };
  }
  if (typeof inner.return === "function") {
    iter.return = function (value) {
      return pump("return", value);
    };
  }
  return iter;
};
var asyncToGenerator = function (fn) {
  return function () {
    var gen = fn.apply(this, arguments);
    return new Promise(function (resolve, reject) {
      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }
        if (info.done) {
          resolve(value);
        } else {
          return Promise.resolve(value).then(function (value) {
            step("next", value);
          }, function (err) {
            step("throw", err);
          });
        }
      }
      return step("next");
    });
  };
};
var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function (Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
var defineEnumerableProperties = function (obj$$1, descs) {
  for (var key in descs) {
    var desc = descs[key];
    desc.configurable = desc.enumerable = true;
    if ("value" in desc)
      desc.writable = true;
    Object.defineProperty(obj$$1, key, desc);
  }
  return obj$$1;
};
var defaults = function (obj$$1, defaults) {
  var keys = Object.getOwnPropertyNames(defaults);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var value = Object.getOwnPropertyDescriptor(defaults, key);
    if (value && value.configurable && obj$$1[key] === undefined) {
      Object.defineProperty(obj$$1, key, value);
    }
  }
  return obj$$1;
};
var defineProperty = function (obj$$1, key, value) {
  if (key in obj$$1) {
    Object.defineProperty(obj$$1, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj$$1[key] = value;
  }
  return obj$$1;
};
var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var get$1 = function get$1(object, property, receiver) {
  if (object === null)
    object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);
  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);
    if (parent === null) {
      return undefined;
    } else {
      return get$1(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return getter.call(receiver);
  }
};
var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};
var _instanceof = function (left, right) {
  if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
    return right[Symbol.hasInstance](left);
  } else {
    return left instanceof right;
  }
};
var interopRequireDefault = function (obj$$1) {
  return obj$$1 && obj$$1.__esModule ? obj$$1 : { default: obj$$1 };
};
var interopRequireWildcard = function (obj$$1) {
  if (obj$$1 && obj$$1.__esModule) {
    return obj$$1;
  } else {
    var newObj = {};
    if (obj$$1 != null) {
      for (var key in obj$$1) {
        if (Object.prototype.hasOwnProperty.call(obj$$1, key))
          newObj[key] = obj$$1[key];
      }
    }
    newObj.default = obj$$1;
    return newObj;
  }
};
var newArrowCheck = function (innerThis, boundThis) {
  if (innerThis !== boundThis) {
    throw new TypeError("Cannot instantiate an arrow function");
  }
};
var objectDestructuringEmpty = function (obj$$1) {
  if (obj$$1 == null)
    throw new TypeError("Cannot destructure undefined");
};
var objectWithoutProperties = function (obj$$1, keys) {
  var target = {};
  for (var i in obj$$1) {
    if (keys.indexOf(i) >= 0)
      continue;
    if (!Object.prototype.hasOwnProperty.call(obj$$1, i))
      continue;
    target[i] = obj$$1[i];
  }
  return target;
};
var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};
var selfGlobal = typeof global === "undefined" ? self : global;
var set$1 = function set$1(object, property, value, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);
  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);
    if (parent !== null) {
      set$1(parent, property, value, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    desc.value = value;
  } else {
    var setter = desc.set;
    if (setter !== undefined) {
      setter.call(receiver, value);
    }
  }
  return value;
};
var slicedToArray = function () {
  function sliceIterator(arr$$1, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;
    try {
      for (var _i = arr$$1[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"])
          _i["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
  return function (arr$$1, i) {
    if (Array.isArray(arr$$1)) {
      return arr$$1;
    } else if (Symbol.iterator in Object(arr$$1)) {
      return sliceIterator(arr$$1, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();
var slicedToArrayLoose = function (arr$$1, i) {
  if (Array.isArray(arr$$1)) {
    return arr$$1;
  } else if (Symbol.iterator in Object(arr$$1)) {
    var _arr = [];
    for (var _iterator = arr$$1[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
      _arr.push(_step.value);
      if (i && _arr.length === i)
        break;
    }
    return _arr;
  } else {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }
};
var taggedTemplateLiteral = function (strings, raw) {
  return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } }));
};
var taggedTemplateLiteralLoose = function (strings, raw) {
  strings.raw = raw;
  return strings;
};
var temporalRef = function (val, name, undef) {
  if (val === undef) {
    throw new ReferenceError(name + " is not defined - temporal dead zone");
  } else {
    return val;
  }
};
var temporalUndefined = {};
var toArray = function (arr$$1) {
  return Array.isArray(arr$$1) ? arr$$1 : Array.from(arr$$1);
};
var toConsumableArray = function (arr$$1) {
  if (Array.isArray(arr$$1)) {
    for (var i = 0, arr2 = Array(arr$$1.length); i < arr$$1.length; i++)
      arr2[i] = arr$$1[i];
    return arr2;
  } else {
    return Array.from(arr$$1);
  }
};


var babelHelpers$1 = Object.freeze({
	jsx: jsx,
	asyncIterator: asyncIterator,
	asyncGenerator: asyncGenerator,
	asyncGeneratorDelegate: asyncGeneratorDelegate,
	asyncToGenerator: asyncToGenerator,
	classCallCheck: classCallCheck,
	createClass: createClass,
	defineEnumerableProperties: defineEnumerableProperties,
	defaults: defaults,
	defineProperty: defineProperty,
	get: get$1,
	inherits: inherits,
	interopRequireDefault: interopRequireDefault,
	interopRequireWildcard: interopRequireWildcard,
	newArrowCheck: newArrowCheck,
	objectDestructuringEmpty: objectDestructuringEmpty,
	objectWithoutProperties: objectWithoutProperties,
	possibleConstructorReturn: possibleConstructorReturn,
	selfGlobal: selfGlobal,
	set: set$1,
	slicedToArray: slicedToArray,
	slicedToArrayLoose: slicedToArrayLoose,
	taggedTemplateLiteral: taggedTemplateLiteral,
	taggedTemplateLiteralLoose: taggedTemplateLiteralLoose,
	temporalRef: temporalRef,
	temporalUndefined: temporalUndefined,
	toArray: toArray,
	toConsumableArray: toConsumableArray,
	typeof: _typeof,
	extends: _extends,
	instanceof: _instanceof
});

var ShadowObject$$1 = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("ShadowObject") && typeof __lively_classholder__.ShadowObject === "function" ? __lively_classholder__.ShadowObject : __lively_classholder__.ShadowObject = function ShadowObject$$1(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function ShadowObject_initialize_(args) {
      if (lively_lang.obj.isBoolean(args)) args = config.defaultShadow;
      var _args = args,
          rotation = _args.rotation,
          distance = _args.distance,
          blur = _args.blur,
          color = _args.color,
          morph$$1 = _args.morph;

      this.rotation = lively_lang.obj.isNumber(rotation) ? rotation : 45;
      this.distance = lively_lang.obj.isNumber(distance) ? distance : 2;
      this.blur = lively_lang.obj.isNumber(blur) ? blur : 6;
      this.color = color || lively_graphics.Color.gray.darker();
      this.morph = morph$$1;
    }
  }, {
    key: "distance",
    get: function get() {
      return this._distance;
    }
  }, {
    key: "blur",
    get: function get() {
      return this._blur;
    }
  }, {
    key: "rotation",
    get: function get() {
      return this._rotation;
    }
  }, {
    key: "color",
    get: function get() {
      return this._color;
    }
  }, {
    key: "distance",
    set: function set(d) {
      this._distance = d;
      if (this.morph) this.morph.dropShadow = this;
    }
  }, {
    key: "blur",
    set: function set(b) {
      this._blur = b;
      if (this.morph) this.morph.dropShadow = this;
    }
  }, {
    key: "rotation",
    set: function set(r) {
      this._rotation = r;
      if (this.morph) this.morph.dropShadow = this;
    }
  }, {
    key: "color",
    set: function set(c) {
      this._color = c;
      if (this.morph) this.morph.dropShadow = this;
    }
  }, {
    key: "isShadowObject",
    get: function get() {
      return true;
    }
  }, {
    key: "toCss",
    value: function ShadowObject_toCss_() {
      var _Point$polar = lively_graphics.Point.polar(this.distance, lively_lang.num.toRadians(this.rotation)),
          x = _Point$polar.x,
          y = _Point$polar.y;

      return this.color.toString() + " " + x + "px " + y + "px " + this.blur + "px";
    }
  }, {
    key: "toFilterCss",
    value: function ShadowObject_toFilterCss_() {
      var _Point$polar2 = lively_graphics.Point.polar(this.distance, lively_lang.num.toRadians(this.rotation)),
          x = _Point$polar2.x,
          y = _Point$polar2.y;

      return "drop-shadow(" + x + "px " + y + "px " + this.blur + "px " + this.color.toString() + ")";
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 228,
    end: 1676
  });
}(undefined);
var StyleMapper = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("StyleMapper") && typeof __lively_classholder__.StyleMapper === "function" ? __lively_classholder__.StyleMapper : __lively_classholder__.StyleMapper = function StyleMapper(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, undefined, [{
    key: "getTransform",
    value: function StyleMapper_getTransform_(_ref) {
      var position = _ref.position,
          origin = _ref.origin,
          scale = _ref.scale,
          rotation = _ref.rotation;

      return { transform: "translate3d(" + (position.x - origin.x).toFixed(2) + "px, " + (position.y - origin.y).toFixed(2) + "px, 0px) rotate(" + lively_lang.num.toDegrees(rotation).toFixed(2) + "deg) scale(" + scale.toFixed(2) + "," + scale.toFixed(2) + ")" };
    }
  }, {
    key: "getTransformOrigin",
    value: function StyleMapper_getTransformOrigin_(_ref2) {
      var origin = _ref2.origin;

      return origin && { transformOrigin: origin.x + "px " + origin.y + "px" };
    }
  }, {
    key: "getDisplay",
    value: function StyleMapper_getDisplay_(_ref3) {
      var visible = _ref3.visible;

      return visible != null && { display: visible ? "inline" : "none" };
    }
  }, {
    key: "getBorderRadius",
    value: function StyleMapper_getBorderRadius_(_ref4) {
      var borderRadiusLeft = _ref4.borderRadiusLeft,
          borderRadiusRight = _ref4.borderRadiusRight,
          borderRadiusBottom = _ref4.borderRadiusBottom,
          borderRadiusTop = _ref4.borderRadiusTop;

      return { borderRadius: borderRadiusTop + "px " + borderRadiusTop + "px " + borderRadiusBottom + "px " + borderRadiusBottom + "px / " + borderRadiusLeft + "px " + borderRadiusRight + "px " + borderRadiusRight + "px " + borderRadiusLeft + "px" };
    }
  }, {
    key: "getBorder",
    value: function StyleMapper_getBorder_(_ref5) {
      var borderWidthLeft = _ref5.borderWidthLeft,
          borderColorLeft = _ref5.borderColorLeft,
          borderStyleLeft = _ref5.borderStyleLeft,
          borderWidthRight = _ref5.borderWidthRight,
          borderColorRight = _ref5.borderColorRight,
          borderStyleRight = _ref5.borderStyleRight,
          borderColor = _ref5.borderColor,
          borderWidthBottom = _ref5.borderWidthBottom,
          borderColorBottom = _ref5.borderColorBottom,
          borderStyleBottom = _ref5.borderStyleBottom,
          borderWidthTop = _ref5.borderWidthTop,
          borderColorTop = _ref5.borderColorTop,
          borderStyleTop = _ref5.borderStyleTop;

      return Object.assign({
        "border-left-style": "" + borderStyleLeft,
        "border-right-style": "" + borderStyleRight,
        "border-bottom-style": "" + borderStyleBottom,
        "border-top-style": "" + borderStyleTop,
        "border-left-width": borderWidthLeft + "px",
        "border-right-width": borderWidthRight + "px",
        "border-bottom-width": borderWidthBottom + "px",
        "border-top-width": borderWidthTop + "px",
        "border-top-color": borderColorTop ? borderColorTop.toString() : "transparent",
        "border-right-color": borderColorRight ? borderColorRight.toString() : "transparent",
        "border-bottom-color": borderColorBottom ? borderColorBottom.toString() : "transparent",
        "border-left-color": borderColorLeft ? borderColorLeft.toString() : "transparent"
      }, borderColor && borderColor.isGradient ? { "border-image": borderColor.toString() } : {});
    }
  }, {
    key: "getFill",
    value: function StyleMapper_getFill_(_ref6) {
      var fill = _ref6.fill;

      return fill && { background: fill.toString() };
    }
  }, {
    key: "getExtentStyle",
    value: function StyleMapper_getExtentStyle_(_ref7) {
      var width = _ref7.width,
          height = _ref7.height,
          extent = _ref7.extent;

      if (width && height) return {
        width: width + "px",
        height: height + "px"
      };
      if (extent) return {
        width: extent.x + "px",
        height: extent.y + "px"
      };
      return null;
    }
  }, {
    key: "getShadowStyle",
    value: function StyleMapper_getShadowStyle_(morph$$1) {
      if (morph$$1.isSvgMorph || morph$$1.isImage) return { filter: shadowCss(morph$$1) };
      return { boxShadow: morph$$1.dropShadow ? morph$$1.dropShadow.toCss() : "none" };
    }
  }, {
    key: "getSvgAttributes",
    value: function StyleMapper_getSvgAttributes_(_ref8) {
      var width = _ref8.width,
          height = _ref8.height,
          borderWidth = _ref8.borderWidth;

      return {
        width: width || 1,
        height: height || 1,
        viewBox: [0, 0, width || 1, height || 1].join(" ")
      };
    }
  }, {
    key: "getPathAttributes",
    value: function StyleMapper_getPathAttributes_(path) {
      var fill = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var vertices = path.vertices.map(function (_ref9) {
        var x = _ref9.x,
            y = _ref9.y,
            controlPoints = _ref9.controlPoints;

        return Object.assign({ controlPoints: controlPoints }, path.origin.addXY(x, y));
      }),
          _arr$first = lively_lang.arr.first(vertices),
          startX = _arr$first.x,
          startY = _arr$first.y,
          _arr$first$controlPoi = _arr$first.controlPoints.next,
          startNextX = _arr$first$controlPoi.x,
          startNextY = _arr$first$controlPoi.y,
          startNext = lively_graphics.pt(startX + startNextX, startY + startNextY),
          _arr$last = lively_lang.arr.last(vertices),
          endX = _arr$last.x,
          endY = _arr$last.y,
          _arr$last$controlPoin = _arr$last.controlPoints.previous,
          endPrevX = _arr$last$controlPoin.x,
          endPrevY = _arr$last$controlPoin.y,
          endPrev = lively_graphics.pt(endX + endPrevX, endY + endPrevY),
          interVertices = vertices.slice(1, -1);
      return Object.assign({ "stroke-width": path.borderWidth }, this.getSvgBorderStyle(path), {
        fill: path.fill ? path.fill.isGradient ? "url(#gradient-fill" + path.id + ")" : path.fill.toString() : "transparent",
        "paint-order": "stroke",
        stroke: path.borderColor.isGradient ? "url(#gradient-borderColor" + path.id + ")" : path.borderColor.toString(),
        d: "M" + (startX + ", " + startY + " ") + "C " + (startNext.x + ", " + startNext.y + " ") + interVertices.map(function (_ref10) {
          var x = _ref10.x,
              y = _ref10.y,
              _ref10$controlPoints = _ref10.controlPoints,
              p = _ref10$controlPoints.previous,
              n = _ref10$controlPoints.next;

          return x + p.x + "," + (y + p.y) + " " + x + "," + y + " C " + (x + n.x) + "," + (y + n.y);
        }).join(" ") + (" " + endPrev.x + "," + endPrev.y + " " + endX + "," + endY)
      });
    }
  }, {
    key: "getSvgBorderStyle",
    value: function StyleMapper_getSvgBorderStyle_(svg) {
      var style = {
        solid: {},
        dashed: { "stroke-dasharray": svg.borderWidth * 1.61 + " " + svg.borderWidth },
        dotted: {
          "stroke-dasharray": "1 " + svg.borderWidth * 2,
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        }
      };
      return style[svg.borderStyle];
    }
  }, {
    key: "getStyleProps",
    value: function StyleMapper_getStyleProps_(morph$$1) {
      return Object.assign({}, this.getFill(morph$$1), {}, this.getTransform(morph$$1), {}, this.getTransformOrigin(morph$$1), {}, this.getDisplay(morph$$1), {}, this.getExtentStyle(morph$$1), {}, this.getBorder(morph$$1), {}, this.getBorderRadius(morph$$1), {}, this.getShadowStyle(morph$$1), {}, morph$$1.opacity != null && { opacity: morph$$1.opacity });
    }
  }], __lively_classholder__, undefined, {
    start: 1678,
    end: 6548
  });
}(undefined);
var AnimationQueue = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("AnimationQueue") && typeof __lively_classholder__.AnimationQueue === "function" ? __lively_classholder__.AnimationQueue : __lively_classholder__.AnimationQueue = function AnimationQueue(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function AnimationQueue_initialize_(morph$$1) {
      this.morph = morph$$1;
      this.animations = [];
    }
  }, {
    key: "maskedProps",
    value: function AnimationQueue_maskedProps_(type) {
      var l = this.animations.length;
      if (l > 0) {
        return lively_lang.obj.merge(this.animations.map(function (a) {
          return a.getAnimationProps(type)[0];
        }));
      } else {
        return {};
      }
    }
  }, {
    key: "animationsActive",
    get: function get() {
      return true;
    }
  }, {
    key: "registerAnimation",
    value: function AnimationQueue_registerAnimation_(config$$1) {
      var _this = this;

      var anim = new PropertyAnimation(this, this.morph, config$$1);
      return this.morph.withMetaDo({ animation: anim }, function () {
        if (!_this.animations.find(function (a) {
          return a.equals(anim);
        }) && anim.affectsMorph) {
          anim.assignProps();
          _this.animations.push(anim);
          return anim;
        }
      });
    }
  }, {
    key: "startAnimationsFor",
    value: function AnimationQueue_startAnimationsFor_(node) {
      this.animations.forEach(function (anim) {
        return anim.start(node);
      });
    }
  }, {
    key: "startSvgAnimationsFor",
    value: function AnimationQueue_startSvgAnimationsFor_(svgNode, type) {
      this.animations.forEach(function (anim) {
        return anim.startSvg(svgNode, type);
      });
    }
  }, {
    key: "removeAnimation",
    value: function AnimationQueue_removeAnimation_(animation) {
      lively_lang.arr.remove(this.animations, animation);
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 6557,
    end: 7515
  });
}(undefined);
var PropertyAnimation = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("PropertyAnimation") && typeof __lively_classholder__.PropertyAnimation === "function" ? __lively_classholder__.PropertyAnimation : __lively_classholder__.PropertyAnimation = function PropertyAnimation(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function PropertyAnimation_initialize_(queue, morph$$1, config$$1) {
      this.queue = queue;
      this.morph = morph$$1;
      this.config = this.convertBounds(config$$1);
      this.needsAnimation = {
        svg: morph$$1.isSvgMorph,
        path: morph$$1.isPath,
        polygon: morph$$1.isPolygon
      };
    }
  }, {
    key: "asPromise",
    value: function PropertyAnimation_asPromise_() {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        _this2.resolvePromise = function () {
          _this2.onFinish(_this2);
          resolve(_this2.morph);
        };
      });
    }
  }, {
    key: "finish",
    value: function PropertyAnimation_finish_() {
      this.queue.removeAnimation(this);
      this.resolvePromise ? this.resolvePromise() : this.onFinish();
    }
  }, {
    key: "convertBounds",
    value: function PropertyAnimation_convertBounds_(config$$1) {
      var bounds = config$$1.bounds,
          origin = config$$1.origin,
          rotation = config$$1.rotation,
          scale = config$$1.scale,
          layout = config$$1.layout,
          origin = origin || this.morph.origin,
          rotation = rotation || this.morph.rotation,
          scale = scale || this.morph.scale;

      if (bounds) {
        return Object.assign({}, lively_lang.obj.dissoc(config$$1, ["bounds"]), {
          origin: origin,
          rotation: rotation,
          scale: scale,
          position: bounds.topLeft().addPt(origin),
          extent: bounds.extent()
        });
      } else {
        return config$$1;
      }
    }
  }, {
    key: "equals",
    value: function PropertyAnimation_equals_(animation) {
      return lively_lang.obj.equals(this.changedProps, animation.changedProps);
    }
  }, {
    key: "affectsMorph",
    get: function get() {
      var _this3 = this;

      return lively_lang.properties.any(this.changedProps, function (changedProps, prop) {
        return !lively_lang.obj.equals(changedProps[prop], _this3.morph[prop]);
      });
    }
  }, {
    key: "changedProps",
    get: function get() {
      return lively_lang.obj.dissoc(this.config, ["easing", "onFinish", "duration"]);
    }
  }, {
    key: "easing",
    get: function get() {
      return this.config.easing || "easeInOutQuint";
    }
  }, {
    key: "onFinish",
    get: function get() {
      return this.config.onFinish || function () {};
    }
  }, {
    key: "onFinish",
    set: function set(cb) {
      this.config.onFinish = cb;
    }
  }, {
    key: "duration",
    get: function get() {
      return this.config.duration || 1000;
    }
  }, {
    key: "getChangedProps",
    value: function PropertyAnimation_getChangedProps_(before, after) {
      var unchangedProps = [];
      for (var prop in before) {
        if (lively_lang.obj.equals(after[prop], before[prop])) {
          unchangedProps.push(prop);
        }
      }
      return [lively_lang.obj.dissoc(before, unchangedProps), lively_lang.obj.dissoc(after, unchangedProps)];
    }
  }, {
    key: "getAnimationProps",
    value: function PropertyAnimation_getAnimationProps_(type) {
      var _getChangedProps = this.getChangedProps(this.beforeProps[type], this.afterProps[type]),
          _getChangedProps2 = slicedToArray(_getChangedProps, 2),
          before = _getChangedProps2[0],
          after = _getChangedProps2[1];

      return [lively_lang.obj.isEmpty(before) ? false : before, lively_lang.obj.isEmpty(after) ? false : after];
    }
  }, {
    key: "gatherAnimationProps",
    value: function PropertyAnimation_gatherAnimationProps_() {
      return {
        css: StyleMapper.getStyleProps(this.morph),
        svg: this.morph.isSvgMorph && StyleMapper.getSvgAttributes(this.morph),
        path: this.morph.isPath && StyleMapper.getPathAttributes(this.morph),
        polygon: this.morph.isPolygon && StyleMapper.getPathAttributes(this.morph)
      };
    }
  }, {
    key: "assignProps",
    value: function PropertyAnimation_assignProps_() {
      this.beforeProps = this.gatherAnimationProps();
      Object.assign(this.morph, this.changedProps);
      this.afterProps = this.gatherAnimationProps();
    }
  }, {
    key: "startSvg",
    value: function PropertyAnimation_startSvg_(svgNode, type) {
      if (this.needsAnimation[type]) {
        this.needsAnimation[type] = false;

        var _getAnimationProps = this.getAnimationProps(type),
            _getAnimationProps2 = slicedToArray(_getAnimationProps, 2),
            before = _getAnimationProps2[0],
            after = _getAnimationProps2[1];

        this.tween(svgNode, { attr: before }, { attr: after });
      }
    }
  }, {
    key: "start",
    value: function PropertyAnimation_start_(node) {
      if (!this.active) {
        this.active = true;

        var _getAnimationProps3 = this.getAnimationProps("css"),
            _getAnimationProps4 = slicedToArray(_getAnimationProps3, 2),
            before = _getAnimationProps4[0],
            after = _getAnimationProps4[1];

        this.tween(node, before, after);
      }
    }
  }, {
    key: "tween",
    value: function PropertyAnimation_tween_(node, before, after) {
      var _this4 = this;

      var onComplete = function onComplete() {
        _this4.finish();
        _this4.morph.makeDirty();
      };
      if (TweenMax && before && after) {
        TweenMax.fromTo(node, this.duration / 1000, before, Object.assign({}, after, {
          ease: this.easing,
          overwrite: false,
          onComplete: onComplete
        }));
      } else {
        onComplete();
      }
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 7524,
    end: 11544
  });
}(undefined);
function defaultStyle(morph$$1) {
  var opacity = morph$$1.opacity,
      clipMode = morph$$1.clipMode,
      reactsToPointer = morph$$1.reactsToPointer,
      nativeCursor = morph$$1.nativeCursor;

  return Object.assign({}, StyleMapper.getStyleProps(morph$$1), {}, morph$$1._animationQueue.maskedProps("css"), {
    position: "absolute",
    overflow: clipMode,
    "pointer-events": reactsToPointer ? "auto" : "none",
    cursor: nativeCursor
  });
}
function MorphAfterRenderHook(morph$$1, renderer) {
  this.morph = morph$$1;
  this.renderer = renderer;
}
MorphAfterRenderHook.prototype.hook = function (node, propertyName, previousValue) {
  var _this5 = this;

  lively_lang.promise.waitFor(400, function () {
    return !!node.parentNode;
  }).catch(function (err) {
    return false;
  }).then(function (isInDOM) {
    if (isInDOM) {
      if (_this5.morph._submorphOrderChanged && _this5.morph.submorphs.length) {
        _this5.morph._submorphOrderChanged = false;
        _this5.updateScrollOfSubmorphs(_this5.morph, _this5.renderer);
      } else if (_this5.morph.isClip()) _this5.updateScroll(_this5.morph, node);
    }
    _this5.morph._rendering = false;
  });
};
MorphAfterRenderHook.prototype.updateScroll = function (morph$$1, node) {
  var _this6 = this;

  var interactiveScrollInProgress = morph$$1.env.eventDispatcher.eventState.scroll.interactiveScrollInProgress;

  if (interactiveScrollInProgress) return interactiveScrollInProgress.then(function () {
    return _this6.updateScroll(morph$$1, node);
  });
  if (node) {
    var _morph$scroll = morph$$1.scroll,
        x = _morph$scroll.x,
        y = _morph$scroll.y;

    node.scrollTop !== y && (node.scrollTop = y);
    node.scrollLeft !== x && (node.scrollLeft = x);
  }
};
MorphAfterRenderHook.prototype.updateScrollOfSubmorphs = function (morph$$1, renderer) {
  var _this7 = this;

  morph$$1.submorphs.forEach(function (m) {
    if (m.isClip()) _this7.updateScroll(m, renderer.getNodeForMorph(m));
    _this7.updateScrollOfSubmorphs(m, renderer);
  });
};
function Animation(morph$$1) {
  this.morph = morph$$1;
}

Animation.prototype.hook = function (node) {
  this.morph._animationQueue.startAnimationsFor(node);
};
function SvgAnimation(morph$$1, type) {
  this.morph = morph$$1;
  this.type = type;
}

SvgAnimation.prototype.hook = function (node) {
  this.morph._animationQueue.startSvgAnimationsFor(node, this.type);
};
function defaultAttributes(morph$$1, renderer) {
  return {
    animation: new Animation(morph$$1),
    key: morph$$1.id,
    id: morph$$1.id,
    className: (morph$$1.hideScrollbars ? morph$$1.styleClasses.concat("hiddenScrollbar") : morph$$1.styleClasses).join(" "),
    draggable: false,
    "morph-after-render-hook": new MorphAfterRenderHook(morph$$1, renderer)
  };
}
function svgAttributes(svg) {
  return {
    animation: new SvgAnimation(svg, "svg"),
    attributes: Object.assign({}, StyleMapper.getSvgAttributes(svg), {}, svg._animationQueue.maskedProps("svg"))
  };
}
function pathAttributes(path) {
  return {
    animation: new SvgAnimation(path, "path"),
    attributes: Object.assign({}, StyleMapper.getPathAttributes(path), {}, path._animationQueue.maskedProps("path"))
  };
}
function shadowCss(morph$$1) {
  return morph$$1.dropShadow ? morph$$1.dropShadow.toFilterCss() : "";
}
function initDOMState(renderer, world) {
  renderer.rootNode.appendChild(renderer.domNode);
  renderer.ensureDefaultCSS().then(function () {
    return lively_lang.promise.delay(500);
  }).then(function () {
    return world.env.fontMetric.reset();
  }).then(function () {
    return world.withAllSubmorphsDo(function (ea) {
      return (ea.isText || ea.isLabel) && ea.forceRerender();
    });
  }).catch(function (err) {
    return console.error();
  });
}
function renderMorph$1(morph$$1) {
  var renderer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : morph$$1.env.renderer;

  return vdom.create(morph$$1.render(renderer));
}
function renderRootMorph(world, renderer) {
  if (!world.needsRerender()) return;
  var tree$$1 = renderer.renderMap.get(world) || renderer.render(world),
      domNode = renderer.domNode || (renderer.domNode = vdom.create(tree$$1, renderer.domEnvironment)),
      newTree = renderer.render(world),
      patches = vdom.diff(tree$$1, newTree);
  if (!domNode.parentNode) initDOMState(renderer, world);
  vdom.patch(domNode, patches);
}

var createDOMEnvironment_browser = function () {
  var _ref = asyncToGenerator(regeneratorRuntime.mark(function _callee() {
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.t0 = IFramedDomEnvironment;
            _context.next = 3;
            return createIFrame(document.body);

          case 3:
            _context.t1 = _context.sent;
            return _context.abrupt("return", new _context.t0(_context.t1));

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  return function createDOMEnvironment_browser() {
    return _ref.apply(this, arguments);
  };
}();

function createIFrame(parentElement) {
  var url = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "about:blank";
  var bounds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new lively_graphics.Rectangle(0, 0, 700, 700);

  return new Promise(function (resolve, reject) {
    if (!parentElement) throw new Error("Need parent element!");
    var iframe = document.createElement("iframe");
    iframe.style.position = "absolute";
    iframe.style.top = bounds.top() + "px";
    iframe.style.left = bounds.left() + "px";
    iframe.style.width = bounds.width + "px";
    iframe.style.height = bounds.height + "px";
    iframe.src = url;
    var loaded = false;
    iframe.onload = function (evt) {
      loaded = true;
      iframe.onload = null;
      resolve(iframe);
    };
    lively_lang.promise.waitFor(1000, function () {
      return !!loaded;
    }).catch(function (err) {
      return reject(new Error("iframe load timeout"));
    });
    parentElement.appendChild(iframe);
  });
}

function requestAnimationFramePolyfill(window) {
  var lastTime = 0,
      vendors = ["ms", "moz", "webkit", "o"];
  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
    window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];
    window.cancelAnimationFrame = window[vendors[x] + "CancelAnimationFrame"] || window[vendors[x] + "CancelRequestAnimationFrame"];
  }
  if (!window.requestAnimationFrame) window.requestAnimationFrame = function (callback, element) {
    var currTime = Date.now(),
        timeToCall = Math.max(0, 16 - (currTime - lastTime)),
        id = window.setTimeout(function () {
      callback(currTime + timeToCall);
    }, timeToCall);
    lastTime = currTime + timeToCall;
    return id;
  };
  if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function (id) {
    clearTimeout(id);
  };
}

function createDOMEnvironment_node() {
  var morphicDir = System.decanonicalize("lively.morphic/").replace(/file:\/\//, ""),
      jsdom = System._nodeRequire(morphicDir + "node_modules/jsdom"),
      virtualConsole = jsdom.createVirtualConsole().sendTo(console);
  return new Promise(function (resolve, reject) {
    jsdom.env("<div></div>", ["https://code.jquery.com/pep/0.4.1/pep.js"], { virtualConsole: virtualConsole }, function (err, window) {
      return err ? reject(err) : resolve(new DomEnvironment(window, window.document, function () {
        return window.close();
      }));
    });
  });
}
function createDOMEnvironment() {
  return System.get("@system-env").browser ? createDOMEnvironment_browser() : createDOMEnvironment_node();
}
var DomEnvironment = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("DomEnvironment") && typeof __lively_classholder__.DomEnvironment === "function" ? __lively_classholder__.DomEnvironment : __lively_classholder__.DomEnvironment = function DomEnvironment(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function DomEnvironment_initialize_(window, document, destroyFn) {
      requestAnimationFramePolyfill(window);
      this.window = window;
      this.document = document;
      this.destroyFn = destroyFn;
    }
  }, {
    key: "destroy",
    value: function DomEnvironment_destroy_() {
      if (typeof this.destroyFn === "function") this.destroyFn();
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 2791,
    end: 3085
  });
}(undefined);
var IFramedDomEnvironment = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("IFramedDomEnvironment") && typeof __lively_classholder__.IFramedDomEnvironment === "function" ? __lively_classholder__.IFramedDomEnvironment : __lively_classholder__.IFramedDomEnvironment = function IFramedDomEnvironment(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function IFramedDomEnvironment_initialize_(iframe) {
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, iframe.contentWindow, iframe.contentWindow.document, function () {
        iframe.contentWindow && iframe.contentWindow.close();
        iframe.parentNode && iframe.parentNode.removeChild(iframe);
      });
      this.iframe = iframe;
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 3087,
    end: 3431
  });
}(DomEnvironment);
var _defaultEnv;
function defaultDOMEnv() {
  return _defaultEnv || (_defaultEnv = System.get("@system-env").browser ? new DomEnvironment(window, document) : createDOMEnvironment());
}
function setCSSDef(node, cssDefString, doc) {
  lively_lang.arr.from(node.childNodes).forEach(function (c) {
    return node.removeChild(c);
  });
  var rules = doc.createTextNode(cssDefString);
  if (node.styleSheet) node.styleSheet.cssText = rules.nodeValue;else node.appendChild(rules);
  return node;
}
function addCSSDef(id, cssString, doc) {
  var style = doc.createElement("style");
  style.type = "text/css";
  if (id) style.setAttribute("id", id);
  setCSSDef(style, cssString, doc);
  doc.head.appendChild(style);
  return style;
}
function addOrChangeCSSDeclaration() {
  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "lively-css";
  var cssString = arguments[1];
  var doc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document;

  var node = doc.getElementById(id);
  return node ? setCSSDef(node, cssString, doc) : addCSSDef(id, cssString, doc);
}
function addOrChangeLinkedCSS(id, url) {
  var doc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document;

  var link = doc.getElementById(id);
  if (!link) {
    link = doc.createElement("link");
    link.type = "text/css";
    link.rel = "stylesheet";
    link.setAttribute("id", id);
    doc.head.appendChild(link);
  }
  link.setAttribute("href", url);
  var loaded = false;
  link.onload = function () {
    return loaded = true;
  };
  return lively_lang.promise.waitFor(function () {
    return !!loaded && link;
  });
}

var defaultCSS = "\n\n/*-=- html fixes -=-*/\n\ntextarea.lively-text-input.debug {\n  z-index: 20 !important;\n  opacity: 1 !important;\n  background: rgba(0,255,0,0.5) !important;\n}\n\n.no-html-select {\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.hiddenScrollbar::-webkit-scrollbar { \n  /* This is the magic bit */\n  display: none;\n}\n\n\n/*-=- generic morphic -=-*/\n\n.Morph {\n  outline: none;\n  /*for aliasing issue in chrome: http://stackoverflow.com/questions/6492027/css-transform-jagged-edges-in-chrome*/\n  -webkit-backface-visibility: hidden;\n\n  /*include border size in extent of element*/\n  box-sizing: border-box;\n\n  /*don't use dom selection on morphs*/\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  zIndex: 1010\n}\n\n.Tooltip {\n  z-index:  3;\n}\n\n.Hand {\n  z-index: 1;\n}\n\n/*-=- halos -=-*/\n\n.Halo {\n  z-index: 2;\n}\n\n.HaloItem {\n  /*FIXME: we shouldn't need to hardcode the size...*/\n\t line-height: 24px !important;\n\t text-align: center;\n\t vertical-align: middle;\n}\n\n.halo-mesh {\n  background-color:transparent;\n  background-image: linear-gradient(rgba(0,0,0,.1) 2px, transparent 2px),\n  linear-gradient(90deg, rgba(0,0,0,.1) 2px, transparent 2px),\n  linear-gradient(rgba(0,0,0,.1) 1px, transparent 1px),\n  linear-gradient(90deg, rgba(0,0,0,.1) 1px, transparent 1px);\n  background-size:100px 100px, 100px 100px, 10px 10px, 10px 10px;\n  background-position:-2px -2px, -2px -2px, -1px -1px, -1px -1px;\n}\n\n/*-=- text -=-*/\n\n.center-text {\n\t text-align: center;\n}\n\n.v-center-text {\n  position: relative;\n  top: 50%;\n  transform: translateY(-50%);\n}\n\ndiv.text-layer span {\n  line-height: normal;\n}\n\n/*-=- text -=-*/\n\n.Label span {\n  white-space: nowrap;\n}\n\n.Label .annotation {\n/*  vertical-align: middle;\n  height: 100%;*/\n  /*vertical align*/\n  float: right;\n  position: relative;\n  top: 50%;\n  transform: translateY(-50%);\n  text-align: right;\n}\n\n.truncated-text {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n";
var Renderer = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("Renderer") && typeof __lively_classholder__.Renderer === "function" ? __lively_classholder__.Renderer : __lively_classholder__.Renderer = function Renderer(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function Renderer_initialize_(world, rootNode, domEnvironment) {
      if (!world || !world.isMorph) throw new Error("Trying to initialize renderer with an invalid world morph: " + world);
      if (!rootNode || !("nodeType" in rootNode)) throw new Error("Trying to initialize renderer with an invalid root node: " + rootNode);
      if (!domEnvironment) {
        var doc = rootNode.ownerDocument;
        domEnvironment = {
          window: System.global,
          document: doc
        };
      }
      this.worldMorph = world;
      world._renderer = this;
      this.rootNode = rootNode;
      this.domNode = null;
      this.domEnvironment = domEnvironment;
      this.renderMap = new WeakMap();
      this.renderWorldLoopProcess = null;
      this.afterRenderCallTargets = [];
      this.requestAnimationFrame = domEnvironment.window.requestAnimationFrame.bind(domEnvironment.window);
    }
  }, {
    key: "clear",
    value: function Renderer_clear_() {
      this.stopRenderWorldLoop();
      this.domNode && this.domNode.parentNode.removeChild(this.domNode);
      this.domNode = null;
      this.renderMap = new WeakMap();
    }
  }, {
    key: "ensureDefaultCSS",
    value: function Renderer_ensureDefaultCSS_() {
      var _this = this;

      return lively_lang.promise.waitFor(3000, function () {
        return _this.domNode.ownerDocument;
      }).then(function (doc) {
        return Promise.all([addOrChangeCSSDeclaration("lively-morphic-css", defaultCSS, doc), addOrChangeLinkedCSS("lively-font-awesome", System.decanonicalize("lively.morphic/assets/font-awesome/css/font-awesome.css"), doc), addOrChangeLinkedCSS("lively-font-inconsolata", System.decanonicalize("lively.morphic/assets/inconsolata/inconsolata.css"), doc)]);
      });
    }
  }, {
    key: "startRenderWorldLoop",
    value: function Renderer_startRenderWorldLoop_() {
      var _this2 = this;

      this.renderWorldLoopProcess = this.requestAnimationFrame(function () {
        return _this2.startRenderWorldLoop();
      });
      this.worldMorph.renderAsRoot(this);
      return this;
    }
  }, {
    key: "stopRenderWorldLoop",
    value: function Renderer_stopRenderWorldLoop_() {
      this.domEnvironment.window.cancelAnimationFrame(this.renderWorldLoopProcess);
      this.renderWorldLoopProcess = null;
    }
  }, {
    key: "getNodeForMorph",
    value: function Renderer_getNodeForMorph_(morph$$1) {
      return this.domNode ? this.domNode.querySelector("#" + morph$$1.id) : null;
    }
  }, {
    key: "getMorphForNode",
    value: function Renderer_getMorphForNode_(node) {
      return this.worldMorph ? this.worldMorph.withAllSubmorphsDetect(function (morph$$1) {
        return morph$$1.id === node.id;
      }) : null;
    }
  }, {
    key: "render",
    value: function Renderer_render_(x) {
      if (!x.needsRerender()) {
        var renderedTree = this.renderMap.get(x);
        if (renderedTree) return renderedTree;
      }
      x.aboutToRender(this);
      var tree$$1 = x.render(this);
      this.renderMap.set(x, tree$$1);
      return tree$$1;
    }
  }, {
    key: "renderMorph",
    value: function Renderer_renderMorph_(morph$$1) {
      return vdom.h("div", Object.assign({}, defaultAttributes(morph$$1, this), { style: defaultStyle(morph$$1) }), this.renderSubmorphs(morph$$1));
    }
  }, {
    key: "renderSubmorphs",
    value: function Renderer_renderSubmorphs_(morph$$1) {
      var _this3 = this;

      return vdom.h("div", {
        style: {
          position: "absolute",
          transform: "translate(" + (morph$$1.origin.x - morph$$1.borderWidthLeft) + "px," + (morph$$1.origin.y - morph$$1.borderWidthTop) + "px)"
        }
      }, morph$$1.submorphs.map(function (m) {
        return _this3.render(m);
      }));
    }
  }, {
    key: "renderImage",
    value: function Renderer_renderImage_(image) {
      return vdom.h("div", Object.assign({}, defaultAttributes(image, this), { style: defaultStyle(image) }), [vdom.h("img", {
        src: image.imageUrl,
        draggable: false,
        style: {
          "pointer-events": "none",
          position: "absolute",
          width: "100%",
          height: "100%"
        }
      }), this.renderSubmorphs(image)]);
    }
  }, {
    key: "renderCheckBox",
    value: function Renderer_renderCheckBox_(checkbox) {
      return vdom.h("div", Object.assign({}, defaultAttributes(checkbox, this), { style: defaultStyle(checkbox) }), [vdom.h("input", {
        type: "checkbox",
        checked: checkbox.checked,
        disabled: !checkbox.active,
        draggable: false,
        style: {
          "pointer-events": "none",
          position: "relative",
          top: "-3px",
          left: "-4px",
          width: "100%",
          height: "100%"
        }
      }), this.renderSubmorphs(checkbox)]);
    }
  }, {
    key: "renderPath",
    value: function Renderer_renderPath_(path) {
      var vertices = vdom.h("path", Object.assign({
        namespace: "http://www.w3.org/2000/svg",
        id: "svg" + path.id
      }, pathAttributes(path)));
      return this.renderSvgMorph(path, vertices);
    }
  }, {
    key: "renderSvgMorph",
    value: function Renderer_renderSvgMorph_(morph$$1, svg) {
      var _defaultStyle = defaultStyle(morph$$1),
          position = _defaultStyle.position,
          filter = _defaultStyle.filter,
          display = _defaultStyle.display,
          opacity = _defaultStyle.opacity,
          transform = _defaultStyle.transform,
          transformOrigin = _defaultStyle.transformOrigin,
          cursor = _defaultStyle.cursor,
          _morph$innerBounds = morph$$1.innerBounds(),
          width = _morph$innerBounds.width,
          height = _morph$innerBounds.height,
          defs = vdom.h("defs", { namespace: "http://www.w3.org/2000/svg" }, [morph$$1.fill && morph$$1.fill.isGradient ? [renderGradient(morph$$1, "fill")] : null, morph$$1.borderColor && morph$$1.borderColor.isGradient ? [renderGradient(morph$$1, "borderColor")] : null]);

      return vdom.h("div", Object.assign({}, defaultAttributes(morph$$1, this), {
        style: {
          transform: transform,
          transformOrigin: transformOrigin,
          position: position,
          opacity: opacity,
          cursor: cursor,
          width: width + "px",
          height: height + "px",
          display: display,
          filter: filter,
          "pointer-events": morph$$1.reactsToPointer ? "auto" : "none"
        }
      }), [vdom.h("svg", Object.assign({
        namespace: "http://www.w3.org/2000/svg",
        version: "1.1",
        style: {
          position: "absolute",
          "pointer-events": "none",
          overflow: "visible"
        }
      }, svgAttributes(morph$$1)), [defs, svg]), this.renderSubmorphs(morph$$1)]);
    }
  }], [{
    key: "default",
    value: function Renderer_default_() {
      return this._default || new this();
    }
  }], __lively_classholder__, undefined, {
    start: 2453,
    end: 8256
  });
}(undefined);
function renderGradient(morph$$1, prop) {
  var gradient = morph$$1[prop],
      bounds = gradient.bounds,
      focus = gradient.focus,
      vector = gradient.vector;
  return vdom.h(gradient.type, {
    namespace: "http://www.w3.org/2000/svg",
    attributes: Object.assign({
      id: "gradient-" + prop + morph$$1.id,
      gradientUnits: "userSpaceOnUse",
      r: "50%"
    }, vector && { gradientTransform: "rotate(" + lively_lang.num.toDegrees(vector.extent().theta()) + ", " + morph$$1.width / 2 + ", " + morph$$1.height / 2 + ")" }, {}, focus && bounds && {
      gradientTransform: "matrix(\n                                    " + bounds.width / morph$$1.width + ", 0, 0, " + bounds.height / morph$$1.height + ", \n                                    " + (morph$$1.width / 2 - bounds.width / morph$$1.width * (morph$$1.width / 2) + focus.x * morph$$1.width - morph$$1.width / 2) + ",\n                                    " + (morph$$1.height / 2 - bounds.height / morph$$1.height * (morph$$1.height / 2) + focus.y * morph$$1.height - morph$$1.height / 2) + ")"
    })
  }, gradient.stops.map(function (_ref) {
    var offset = _ref.offset,
        color = _ref.color;
    return vdom.h("stop", {
      namespace: "http://www.w3.org/2000/svg",
      attributes: {
        offset: offset * 100 + "%",
        "stop-color": color.toString()
      }
    });
  }));
}

var FontMetric = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("FontMetric") && typeof __lively_classholder__.FontMetric === "function" ? __lively_classholder__.FontMetric : __lively_classholder__.FontMetric = function FontMetric(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function FontMetric_initialize_() {
      this.charMap = {};
      this.cachedBoundsInfo = {};
      this.element = null;
    }
  }, {
    key: "reset",
    value: function FontMetric_reset_() {
      var doc, parentNode;
      if (this.element) {
        parentNode = this.element.parentNode;
        doc = this.element.ownerDocument;
      }
      this.uninstall();
      this.charMap = {};
      this.cachedBoundsInfo = {};
      if (doc && parentNode) this.install(doc, parentNode);
    }
  }, {
    key: "install",
    value: function FontMetric_install_(doc, parentEl) {
      this.element = doc.createElement("div");
      this.element.name = "fontMetric";
      this.setMeasureNodeStyles(this.element.style, true);
      parentEl.appendChild(this.element);
    }
  }, {
    key: "uninstall",
    value: function FontMetric_uninstall_() {
      if (!this.element) return;
      if (this.element.parentNode) this.element.parentNode.removeChild(this.element);
      this.element = null;
    }
  }, {
    key: "setMeasureNodeStyles",
    value: function FontMetric_setMeasureNodeStyles_(style, isRoot) {
      style.width = style.height = "auto";
      style.left = style.top = "0px";
      style.visibility = "hidden";
      style.position = "absolute";
      style.whiteSpace = "pre";
      style.font = "inherit";
      style.overflow = isRoot ? "hidden" : "visible";
    }
  }, {
    key: "measure",
    value: function FontMetric_measure_(style, text) {
      var fontFamily = style.fontFamily,
          fontSize = style.fontSize,
          fontWeight = style.fontWeight,
          fontStyle = style.fontStyle,
          textDecoration = style.textDecoration,
          textStyleClasses = style.textStyleClasses,
          rect$$1 = null;

      this.element.textContent = text;
      this.element.style.fontFamily = fontFamily;
      this.element.style.fontSize = fontSize + "px";
      this.element.style.fontWeight = fontWeight, this.element.style.fontStyle = fontStyle, this.element.style.textDecoration = textDecoration;
      this.element.className = textStyleClasses ? textStyleClasses.join(" ") : "";
      var width, height;
      try {
        var _element$getBoundingC = this.element.getBoundingClientRect();

        width = _element$getBoundingC.width;
        height = _element$getBoundingC.height;
      } catch (e) {
        return {
          width: 0,
          height: 0
        };
      }
      
      return {
        height: height,
        width: width
      };
    }
  }, {
    key: "charBoundsFor",
    value: function FontMetric_charBoundsFor_(style, str) {
      var nCols = str.length,
          bounds = new Array(nCols),
          _cachedBoundsInfo = this.cachedBoundsInfo,
          cachedBounds = _cachedBoundsInfo.bounds,
          cachedStr = _cachedBoundsInfo.str,
          cachedStyle = _cachedBoundsInfo.style,
          isMonospace = !this.isProportional(style.fontFamily);
      if (isMonospace) {
        var single = this.sizeFor(style, "x", true),
            double = this.sizeFor(style, "xx", true),
            width = double.width - single.width,
            height = single.height,
            x = 0;
        for (var i = 0; i < nCols; i++) {
          x = width * i;
          bounds[i] = {
            x: x,
            y: 0,
            width: width,
            height: height
          };
        }
      } else {
        var useCache = cachedBounds && lively_lang.obj.equals(cachedStyle, style),
            adjustSpacing = !style.fixedCharacterSpacing;
        for (var col = 0, _x = 0; col < nCols; col++) {
          var _width = void 0,
              _height = void 0,
              char = str[col];
          if (adjustSpacing) {
            useCache = useCache && char === cachedStr[col];
            if (useCache) {
              
              var _cachedBounds$col = cachedBounds[col];
              _width = _cachedBounds$col.width;
              _height = _cachedBounds$col.height;
            } else {
              var prefix = str.substr(0, col + 1);

              var _measure = this.measure(style, prefix);

              _width = _measure.width;
              _height = _measure.height;

              _width -= _x;
            }
          } else {
            var _sizeFor = this.sizeFor(style, char);

            _width = _sizeFor.width;
            _height = _sizeFor.height;
          }
          bounds[col] = {
            x: _x,
            y: 0,
            width: _width,
            height: _height
          };
          _x += _width;
        }
        if (adjustSpacing) this.cachedBoundsInfo = {
          bounds: bounds,
          str: str,
          style: style
        };
      }
      return bounds;
    }
  }, {
    key: "isProportional",
    value: function FontMetric_isProportional_(fontFamily) {
      var style = {
        fontFamily: fontFamily,
        fontSize: 12
      },
          w_width = this.sizeFor(style, "w").width,
          i_width = this.sizeFor(style, "i").width;
      return w_width !== i_width;
    }
  }, {
    key: "sizeFor",
    value: function FontMetric_sizeFor_(style, string$$1) {
      var forceCache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var fontFamily = style.fontFamily,
          fontSize = style.fontSize,
          fontWeight = style.fontWeight,
          fontStyle = style.fontStyle,
          textDecoration = style.textDecoration,
          textStyleClasses = style.textStyleClasses,
          relevantStyle = {
        fontFamily: fontFamily,
        fontSize: fontSize,
        fontWeight: fontWeight,
        fontStyle: fontStyle,
        textDecoration: textDecoration,
        textStyleClasses: textStyleClasses
      };

      if (!forceCache && string$$1.length > 1) return this.measure(relevantStyle, string$$1);
      var className = textStyleClasses ? textStyleClasses.join(" ") : "";
      var styleKey = [fontFamily, fontSize, fontWeight, fontStyle, textDecoration, className].join("-");
      if (!this.charMap[styleKey]) this.charMap[styleKey] = {};
      if (!this.charMap[styleKey][string$$1]) this.charMap[styleKey][string$$1] = this.measure(relevantStyle, string$$1);
      return this.charMap[styleKey][string$$1];
    }
  }, {
    key: "asciiSizes",
    value: function FontMetric_asciiSizes_(style) {
      var result = {};
      for (var i = 32; i <= 126; i++) {
        var char = String.fromCharCode(i);
        result[char] = this.sizeFor(style, char);
      }
      return result;
    }
  }, {
    key: "defaultLineHeight",
    value: function FontMetric_defaultLineHeight_(style) {
      return this.sizeFor(style, " ").height;
    }
  }], [{
    key: "default",
    value: function FontMetric_default_() {
      if (!this._fontMetric) throw new Error("FontMetric has not yet been initialized!");
      return this._fontMetric;
    }
  }, {
    key: "initDefault",
    value: function FontMetric_initDefault_(domEnv) {
      if (!this._fontMetric) {
        if (!domEnv && typeof document === "undefined") throw new Error("Cannot initialize FontMetric without document");
        if (!domEnv) domEnv = { document: document };
        this._fontMetric = this.forDOMEnv(domEnv);
      }
      return this._fontMetric;
    }
  }, {
    key: "removeDefault",
    value: function FontMetric_removeDefault_() {
      if (this._fontMetric) {
        this._fontMetric.uninstall();
        this._fontMetric = null;
      }
    }
  }, {
    key: "forDOMEnv",
    value: function FontMetric_forDOMEnv_(_ref) {
      var document = _ref.document;

      var fontMetric = new FontMetric();
      fontMetric.install(document, document.body);
      return fontMetric;
    }
  }], __lively_classholder__, undefined, {
    start: 60,
    end: 5736
  });
}(undefined);

function signalBindings(obj$$1, name, change) {
  var conns = obj$$1.attributeConnections;
  if (!conns) return;
  conns = conns.slice();
  for (var i = 0; i < conns.length; i++) {
    if (conns[i].sourceAttrName === name) conns[i].update(change);
    if (change.prop && conns[i].sourceAttrName === change.prop) conns[i].update(change.value);
  }
}
function informMorph(changeManager, change, morph$$1) {
  try {
    morph$$1.onChange(change);
    signalBindings(morph$$1, "change", change);
    var owner = morph$$1.owner;
    while (owner) {
      owner.onSubmorphChange(change, morph$$1);
      owner = owner.owner;
    }
  } catch (err) {
    console.error("Error in informMorph: " + err.stack);
  }
}
var Change = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("Change") && typeof __lively_classholder__.Change === "function" ? __lively_classholder__.Change : __lively_classholder__.Change = function Change(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function Change_initialize_(target) {
      this.target = target;
      this.group = null;
    }
  }, {
    key: "type",
    get: function get() {
      return "abstract change";
    }
  }, {
    key: "apply",
    value: function Change_apply_() {
      throw new Error("Not yet implemented");
    }
  }, {
    key: "reverseApply",
    value: function Change_reverseApply_() {
      throw new Error("Not yet implemented");
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 859,
    end: 1109
  });
}(undefined);
var GroupChange = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("GroupChange") && typeof __lively_classholder__.GroupChange === "function" ? __lively_classholder__.GroupChange : __lively_classholder__.GroupChange = function GroupChange(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function GroupChange_initialize_(target) {
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, target);
      this.changes = [];
    }
  }, {
    key: "consumesChanges",
    value: function GroupChange_consumesChanges_() {
      return true;
    }
  }, {
    key: "addChange",
    value: function GroupChange_addChange_(c) {
      this.changes.push(c);
      c.group = this;
    }
  }, {
    key: "apply",
    value: function GroupChange_apply_() {
      this.changes.slice().forEach(function (change) {
        return change.apply();
      });
      return this;
    }
  }, {
    key: "reverseApply",
    value: function GroupChange_reverseApply_() {
      this.changes.slice().reverse().forEach(function (change) {
        return change.reverseApply();
      });
      return this;
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 1118,
    end: 1541
  });
}(Change);
var ValueChange = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("ValueChange") && typeof __lively_classholder__.ValueChange === "function" ? __lively_classholder__.ValueChange : __lively_classholder__.ValueChange = function ValueChange(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: "type",
    get: function get() {
      return "setter";
    }
  }, {
    key: Symbol.for("lively-instance-initialize"),
    value: function ValueChange_initialize_(target, prop, value, meta) {
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, target);
      this.prop = prop;
      this.value = value;
      this.prevValue = null;
      this.meta = meta;
    }
  }, {
    key: "apply",
    value: function ValueChange_apply_() {
      var target = this.target,
          prop = this.prop,
          value = this.value;

      target[prop] = value;
    }
  }, {
    key: "reverseApply",
    value: function ValueChange_reverseApply_() {
      var target = this.target,
          prop = this.prop,
          prevValue = this.prevValue;

      target[prop] = prevValue;
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 1550,
    end: 1959
  });
}(Change);
var MethodCallChange = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("MethodCallChange") && typeof __lively_classholder__.MethodCallChange === "function" ? __lively_classholder__.MethodCallChange : __lively_classholder__.MethodCallChange = function MethodCallChange(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: "type",
    get: function get() {
      return "method-call";
    }
  }, {
    key: Symbol.for("lively-instance-initialize"),
    value: function MethodCallChange_initialize_(target, selector, args, undo, meta) {
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, target);
      this.selector = selector;
      this.args = args;
      this.undo = undo;
      this.meta = meta;
    }
  }, {
    key: "apply",
    value: function MethodCallChange_apply_() {
      var target = this.target,
          selector = this.selector,
          args = this.args;

      target[selector].apply(target, args);
    }
  }, {
    key: "reverseApply",
    value: function MethodCallChange_reverseApply_() {
      if (!this.undo) return;
      if (typeof this.undo === "function") this.undo();else {
        var _undo = this.undo,
            target = _undo.target,
            selector = _undo.selector,
            args = _undo.args;

        target[selector].apply(target, args);
      }
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 1968,
    end: 2541
  });
}(GroupChange);
var ChangeManager = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("ChangeManager") && typeof __lively_classholder__.ChangeManager === "function" ? __lively_classholder__.ChangeManager : __lively_classholder__.ChangeManager = function ChangeManager(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function ChangeManager_initialize_() {
      this.reset();
    }
  }, {
    key: "reset",
    value: function ChangeManager_reset_() {
      this.changes = [];
      this.revision = 0;
      this.changeRecordersPerMorph = new WeakMap();
      this.changeRecorders = {};
      this.changeGroupStack = [];
      this.defaultMeta = {};
      this.metaStack = [];
    }
  }, {
    key: "changesFor",
    value: function ChangeManager_changesFor_(morph$$1) {
      return this.changes.filter(function (c) {
        return c.target === morph$$1;
      });
    }
  }, {
    key: "apply",
    value: function ChangeManager_apply_(target, change) {
      change.apply();
    }
  }, {
    key: "doWithValueChangeMeta",
    value: function ChangeManager_doWithValueChangeMeta_(meta, morph$$1, doFn) {
      this.defaultMeta = meta;
      this.metaStack.push(meta);
      var res = doFn(morph$$1);
      this.metaStack.pop();
      this.defaultMeta = lively_lang.arr.last(this.metaStack) || {};
      return res;
    }
  }, {
    key: "addValueChange",
    value: function ChangeManager_addValueChange_(morph$$1, prop, value, meta) {
      var change = new ValueChange(morph$$1, prop, value, Object.assign({}, this.defaultMeta, {}, meta));
      return this._record(morph$$1, change);
    }
  }, {
    key: "addMethodCallChangeDoing",
    value: function ChangeManager_addMethodCallChangeDoing_(spec, morph$$1, doFn) {
      var target = spec.target,
          selector = spec.selector,
          args = spec.args,
          undo = spec.undo;

      if (!undo) undo = function undo() {
        return console.warn("No undo recorded for " + target + "." + selector);
      };
      var change = new MethodCallChange(target, selector, args, undo, this.defaultMeta);
      morph$$1.groupChangesWhile(change, doFn);
      return change;
    }
  }, {
    key: "_record",
    value: function ChangeManager__record_(morph$$1, change) {
      if (change.hasOwnProperty("value")) {
        change.prevValue = morph$$1._morphicState[change.prop];
        morph$$1._morphicState[change.prop] = change.value;
      }
      morph$$1.makeDirty();
      var grouping = lively_lang.arr.last(this.changeGroupStack);
      if (grouping && grouping.consumesChanges()) {
        grouping.addChange(change);
      } else {
        this.changes.push(change);
        morph$$1._rev = ++this.revision;
        this.informChangeListeners(change);
      }
      informMorph(this, change, morph$$1);
      return change;
    }
  }, {
    key: "groupChangesWhile",
    value: function ChangeManager_groupChangesWhile_(targetMorph, groupChange, whileFn) {
      var record = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

      if (!groupChange) groupChange = new GroupChange(targetMorph);
      this.changeGroupStack.push(groupChange);
      try {
        whileFn();
        lively_lang.arr.remove(this.changeGroupStack, groupChange);
        return record ? this._record(targetMorph, groupChange) : groupChange;
      } catch (err) {
        lively_lang.arr.remove(this.changeGroupStack, groupChange);
        throw err;
      }
    }
  }, {
    key: "dontRecordChangesWhile",
    value: function ChangeManager_dontRecordChangesWhile_(targetMorph, whileFn) {
      return this.groupChangesWhile(targetMorph, undefined, whileFn, false);
    }
  }, {
    key: "recordChangesWhile",
    value: function ChangeManager_recordChangesWhile_(whileFn, optFilter) {
      var from = this.changes.length;
      whileFn();
      var changes = this.changes.slice(from, this.changes.length);
      return optFilter ? changes.filter(optFilter) : changes;
    }
  }, {
    key: "addChangeListener",
    value: function ChangeManager_addChangeListener_(listenFn) {
      lively_bindings.connect(this, "changeRecorded", listenFn, "call", { updater: function updater($upd, change) {
          return $upd(null, change);
        } });
    }
  }, {
    key: "removeChangeListener",
    value: function ChangeManager_removeChangeListener_(listenFn) {
      lively_bindings.disconnect(this, "changeRecorded", listenFn, "call");
    }
  }, {
    key: "informChangeListeners",
    value: function ChangeManager_informChangeListeners_(change) {
      var conns = this.attributeConnections;
      if (!conns) return;
      conns = conns.slice();
      for (var i = 0; i < conns.length; i++) {
        var c = conns[i];
        if (c.sourceAttrName === "changeRecorded") c.update(change);
      }
    }
  }, {
    key: "recordChangesStart",
    value: function ChangeManager_recordChangesStart_(optFilter) {
      var optName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

      var id = lively_lang.obj.newKeyIn(this.changeRecorders, optName + "__change_recorder_" + Date.now()),
          listener = optFilter ? function (change) {
        return optFilter(change) && recorder.changes.push(change);
      } : function (change) {
        return recorder.changes.push(change);
      },
          recorder = this.changeRecorders[id] = {
        id: id,
        filter: optFilter,
        changes: [],
        listener: listener
      };
      this.addChangeListener(listener);
      return recorder;
    }
  }, {
    key: "recordChangesStop",
    value: function ChangeManager_recordChangesStop_(id) {
      if (!(id in this.changeRecorders)) return [];
      var _changeRecorders$id = this.changeRecorders[id],
          changes = _changeRecorders$id.changes,
          listener = _changeRecorders$id.listener;

      delete this.changeRecorders[id];
      this.removeChangeListener(listener);
      return changes;
    }
  }, {
    key: "recordChangesStartForMorph",
    value: function ChangeManager_recordChangesStartForMorph_(morph$$1, optFilter) {
      var recorder = this.recordChangesStart(optFilter, morph$$1.id);
      var perMorph = this.changeRecordersPerMorph.get(morph$$1);
      if (!perMorph) {
        perMorph = [];
        this.changeRecordersPerMorph.set(morph$$1, perMorph);
      }
      perMorph.push(recorder.id);
      return recorder;
    }
  }, {
    key: "recordChangesStopForMorph",
    value: function ChangeManager_recordChangesStopForMorph_(morph$$1, optId) {
      var perMorph = this.changeRecordersPerMorph.get(morph$$1);
      if (!perMorph || !perMorph.length) {
        console.warn("Cannot endMorphChangeRecorder for morph " + morph$$1 + ": recorder not found");
        return [];
      }
      var id = optId;
      if (!optId) id = perMorph.pop();else lively_lang.arr.remove(perMorph, id);
      return this.recordChangesStop(id);
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 2551,
    end: 7738
  });
}(undefined);

var Undo = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("Undo") && typeof __lively_classholder__.Undo === "function" ? __lively_classholder__.Undo : __lively_classholder__.Undo = function Undo(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function Undo_initialize_(name) {
      var targets = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var no = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      this.name = name;
      this.targets = targets;
      this.recorder = null;
      this.changes = null;
      this.timestamp = null;
      this.no = no;
    }
  }, {
    key: "recorded",
    value: function Undo_recorded_() {
      return !!this.changes;
    }
  }, {
    key: "isRecording",
    value: function Undo_isRecording_() {
      return !!this.recorder;
    }
  }, {
    key: "startRecording",
    value: function Undo_startRecording_(filterFn) {
      var _this = this;

      if (this.recorded() || this.isRecording()) throw new Error("Undo already recorded / recording");
      if (!this.targets.length) throw new Error("Undo has no target morphs");
      this.timestamp = Date.now();
      var morph$$1 = this.targets[0];
      this.recorder = morph$$1.recordChangesStart(function (change) {
        var target = change.target;

        if (target.isUsedAsEpiMorph()) return false;
        if (!_this.targets.some(function (undoTarget) {
          return undoTarget === target || undoTarget.isAncestorOf(target);
        })) return false;
        if (typeof filterFn === "function") return filterFn(change);
        return true;
      });
      return this;
    }
  }, {
    key: "stopRecording",
    value: function Undo_stopRecording_() {
      var name = this.name,
          _recorder = this.recorder,
          id = _recorder.id,
          changes = _recorder.changes,
          _targets = slicedToArray(this.targets, 1),
          morph$$1 = _targets[0];

      this.changes = morph$$1.recordChangesStop(id);
      this.targets = null;
      this.recorder = null;
    }
  }, {
    key: "apply",
    value: function Undo_apply_() {
      if (!this.recorded()) throw new Error("Cannot apply undo that has no changes recorded yet");
      this.changes.slice().forEach(function (change) {
        return change.apply();
      });
      return this;
    }
  }, {
    key: "reverseApply",
    value: function Undo_reverseApply_() {
      if (!this.recorded()) throw new Error("Cannot reverseApply undo that has no changes recorded yet");
      this.changes.slice().reverse().forEach(function (change) {
        return change.reverseApply();
      });
      return this;
    }
  }, {
    key: "addTarget",
    value: function Undo_addTarget_(t) {
      lively_lang.arr.pushIfNotIncluded(this.targets, t);
    }
  }, {
    key: "addUndos",
    value: function Undo_addUndos_(undos) {
      undos = lively_lang.arr.sortBy(undos.concat(this).filter(function (ea) {
        return ea.recorded();
      }), function (_ref) {
        var no = _ref.no;
        return no;
      });
      if (!undos.length) return;
      this.changes = lively_lang.arr.flatmap(undos, function (_ref2) {
        var changes = _ref2.changes;
        return changes;
      });
      this.timestamp = undos[0].timestamp;
      this.no = undos[0].no;
      this.name = undos.map(function (_ref3) {
        var name = _ref3.name;
        return name;
      }).join("-");
    }
  }, {
    key: "toString",
    value: function Undo_toString_() {
      var name = this.name,
          changes = this.changes,
          no = this.no,
          isRecording = this.isRecording(),
          changesString = !changes.length ? "no changes" : "\n  " + changes.map(function (_ref4) {
        var selector = _ref4.selector,
            args = _ref4.args,
            prop = _ref4.prop,
            value = _ref4.value,
            target = _ref4.target;
        return selector ? target + "." + selector + "(" + args.map(printArg) + ")" : target + "." + prop + " = " + printArg(value);
      }).join("\n  ");

      return "Undo(" + no + ":" + name + " " + (isRecording ? "RECORDING " : "") + changesString + ")";
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 54,
    end: 2487
  });
}(undefined);
function printArg(x) {
  return lively_lang.obj.inspect(x, { maxDepth: 1 }).replace(/\n/g, "").replace(/\s+/g, " ");
}
var UndoManager = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("UndoManager") && typeof __lively_classholder__.UndoManager === "function" ? __lively_classholder__.UndoManager : __lively_classholder__.UndoManager = function UndoManager(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function UndoManager_initialize_(optFilter) {
      this.reset();
      this.filter = optFilter;
    }
  }, {
    key: "reset",
    value: function UndoManager_reset_() {
      this.undos = [];
      this.redos = [];
      this.undoInProgress = null;
      this.applyCount = 0;
      this.counter = 0;
      this.grouping = {
        current: [],
        debounce: null,
        debouncedCanceled: false,
        debounceTime: 31
      };
    }
  }, {
    key: "group",
    value: function UndoManager_group_() {
      var prevUndo = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      this.groupLaterCancel();
      if (prevUndo && this.undos.includes(prevUndo)) this.grouping.current = lively_lang.arr.uniq(this.undos.slice(this.undos.indexOf(prevUndo)).concat(this.grouping.current));
      if (!this.grouping.current.length) return;
      var grouped = this.grouping.current.slice(1),
          undoGroup = this.grouping.current[0];
      undoGroup.addUndos(grouped);
      this.undos = lively_lang.arr.withoutAll(this.undos, grouped);
      this.grouping.current = [];
    }
  }, {
    key: "ensureNewGroup",
    value: function UndoManager_ensureNewGroup_(morph$$1) {
      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "new undo group";

      this.group();
      this.undoStart(morph$$1, name);
      return this.undoStop();
    }
  }, {
    key: "groupLaterCancel",
    value: function UndoManager_groupLaterCancel_() {
      var state = this.grouping;
      if (!state.debounce) return;
      state.debouncedCanceled = true;
      this.grouping = Object.assign({}, state, {
        debounce: null,
        debouncedCanceled: false
      });
    }
  }, {
    key: "groupLater",
    value: function UndoManager_groupLater_(time) {
      var _this2 = this;

      var state = this.grouping;
      (state.debounce || (state.debounce = lively_lang.fun.debounce(time || state.debounceTime, function () {
        state.debounce = null;
        state.debouncedCanceled || _this2.group();
      })))();
    }
  }, {
    key: "undoStart",
    value: function UndoManager_undoStart_(morph$$1, name) {
      if (this.applyCount) return;
      if (this.undoInProgress) {
        console.warn("There is already an undo recorded");
        return;
      }
      return this.undoInProgress = new Undo(name, [morph$$1], this.counter++).startRecording(this.filter);
    }
  }, {
    key: "undoStop",
    value: function UndoManager_undoStop_() {
      var undo = this.undoInProgress;
      if (!undo) return null;
      undo.stopRecording();
      this.undoInProgress = null;
      this.undos.push(undo);
      this.grouping.current.push(undo);
      if (this.redos.length) this.redos.length = 0;
      return undo;
    }
  }, {
    key: "undo",
    value: function UndoManager_undo_() {
      this.undoStop();
      var undo = this.undos.pop();
      if (!undo) return;
      lively_lang.arr.remove(this.grouping.current, undo);
      this.redos.unshift(undo);
      this.applyCount++;
      try {
        undo.reverseApply();
      } finally {
        this.applyCount--;
      }
      return undo;
    }
  }, {
    key: "redo",
    value: function UndoManager_redo_() {
      this.undoStop();
      var redo = this.redos.shift();
      if (!redo) return;
      this.undos.push(redo);
      this.applyCount++;
      try {
        redo.apply();
      } finally {
        this.applyCount--;
      }
      return redo;
    }
  }, {
    key: "toString",
    value: function UndoManager_toString_() {
      var undosPrinted = this.undos.length === 0 ? "" : "\n  " + (this.undos.length > 20 ? "...\n  " : "") + this.undos.slice(-20).join("\n  ");
      var undoInProgress = !!this.undoInProgress;
      return "UndoManager(" + this.undos.length + " undos, " + this.redos.length + " redos, " + (undoInProgress ? ", UNDO IN PROGRESS" : "") + undosPrinted + ")";
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 2619,
    end: 5662
  });
}(undefined);

var placeholderValue = "\x01\x01";
var placeholderRe = new RegExp("\x01", "g");
var TextInput = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("TextInput") && typeof __lively_classholder__.TextInput === "function" ? __lively_classholder__.TextInput : __lively_classholder__.TextInput = function TextInput(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function TextInput_initialize_(eventDispatcher) {
      this.eventDispatcher = eventDispatcher;
      this.domState = {
        rootNode: null,
        textareaNode: null,
        eventHandlers: [],
        isInstalled: false
      };
      this.inputState = {
        composition: null,
        manualCopy: null,
        manualPaste: null
      };
    }
  }, {
    key: "install",
    value: function TextInput_install_(newRootNode) {
      var _this = this;

      var domState = this.domState,
          isInstalled = domState.isInstalled,
          rootNode = domState.rootNode;
      if (isInstalled) {
        if (rootNode === newRootNode) return;
        this.uninstall();
      }
      domState.isInstalled = true;
      domState.rootNode = newRootNode;
      newRootNode.tabIndex = 1;
      var doc = newRootNode.ownerDocument,
          textareaNode = domState.textareaNode = doc.createElement("textarea");
      textareaNode.setAttribute("style", "\n      position: absolute;\n      /*extent cannot be 0, input won't work correctly in Chrome 52.0*/\n      width: 20px; height: 20px;\n      z-index: 0;\n      opacity: 0;\n      background: transparent;\n      -moz-appearance: none;\n      appearance: none;\n      border: none;\n      resize: none;\n      outline: none;\n      overflow: hidden;\n      font: inherit;\n      padding: 0 1px;\n      margin: 0 -1px;\n      text-indent: -1em;\n      " + (bowser.mobile || bowser.tablet ? "display: none;" : "") + "\n      -ms-user-select: text;\n      -moz-user-select: text;\n      -webkit-user-select: text;\n      user-select: text;\n      /*with pre-line chrome inserts &nbsp; instead of space*/\n      white-space: pre!important;");
      if (bowser.tablet || bowser.mobile) textareaNode.setAttribute("x-palm-disable-auto-cap", true);
      textareaNode.setAttribute("wrap", "off");
      textareaNode.setAttribute("autocorrect", "off");
      textareaNode.setAttribute("autocapitalize", "off");
      textareaNode.setAttribute("spellcheck", false);
      textareaNode.className = "lively-text-input";
      textareaNode.value = "";
      newRootNode.insertBefore(textareaNode, newRootNode.firstChild);
      domState.eventHandlers = [{
        type: "focus",
        node: newRootNode,
        fn: function fn(evt) {
          return _this.onRootNodeFocus(evt);
        },
        capturing: true
      }, {
        type: "keydown",
        node: domState.textareaNode,
        fn: function fn(evt) {
          return _this.eventDispatcher.dispatchDOMEvent(evt);
        },
        capturing: false
      }, {
        type: "keyup",
        node: domState.textareaNode,
        fn: function fn(evt) {
          return _this.eventDispatcher.dispatchDOMEvent(evt);
        },
        capturing: false
      }, {
        type: "cut",
        node: domState.textareaNode,
        fn: function fn(evt) {
          return _this.eventDispatcher.dispatchDOMEvent(evt);
        },
        capturing: false
      }, {
        type: "copy",
        node: domState.textareaNode,
        fn: function fn(evt) {
          return _this.inputState.manualCopy ? _this.inputState.manualCopy.onEvent(evt) : _this.eventDispatcher.dispatchDOMEvent(evt);
        },
        capturing: false
      }, {
        type: "paste",
        node: domState.textareaNode,
        fn: function fn(evt) {
          return _this.inputState.manualPaste ? _this.inputState.manualPaste.onEvent(evt) : _this.eventDispatcher.dispatchDOMEvent(evt);
        },
        capturing: false
      }, {
        type: "compositionstart",
        node: domState.textareaNode,
        fn: function fn(evt) {
          return _this.onCompositionStart(evt);
        },
        capturing: false
      }, {
        type: "compositionend",
        node: domState.textareaNode,
        fn: function fn(evt) {
          return _this.onCompositionEnd(evt);
        },
        capturing: false
      }, {
        type: "compositionupdate",
        node: domState.textareaNode,
        fn: function fn(evt) {
          return _this.onCompositionUpdate(evt);
        },
        capturing: false
      }, {
        type: "input",
        node: domState.textareaNode,
        fn: function fn(evt) {
          return _this.onInput(evt);
        },
        capturing: false
      }];
      domState.eventHandlers.forEach(function (_ref) {
        var type = _ref.type,
            node = _ref.node,
            fn = _ref.fn,
            capturing = _ref.capturing;
        return node.addEventListener(type, fn, capturing);
      });
      return this;
    }
  }, {
    key: "uninstall",
    value: function TextInput_uninstall_() {
      var domState = this.domState;
      domState.isInstalled = false;
      domState.eventHandlers.forEach(function (_ref2) {
        var node = _ref2.node,
            type = _ref2.type,
            fn = _ref2.fn,
            capturing = _ref2.capturing;
        return node.removeEventListener(type, fn, capturing);
      });
      var n = domState.textareaNode;
      n && n.parentNode && n.parentNode.removeChild(n);
      domState.rootNode = null;
      return this;
    }
  }, {
    key: "resetValue",
    value: function TextInput_resetValue_() {
      var n = this.domState.textareaNode;
      n && (n.value = placeholderValue);
    }
  }, {
    key: "readValue",
    value: function TextInput_readValue_() {
      var n = this.domState.textareaNode;
      return n ? n.value.replace(placeholderRe, "") : "";
    }
  }, {
    key: "focus",
    value: function TextInput_focus_(morph$$1, world) {
      var node = this.domState.textareaNode;
      if (!node) return;
      node.ownerDocument.activeElement !== node && node.focus();
      if (bowser.firefox) Promise.resolve().then(function () {
        return node.ownerDocument.activeElement !== node && node.focus();
      });
      if (morph$$1 && morph$$1.isText) this.ensureBeingAtCursorOfText(morph$$1);else if (world) this.ensureBeingInVisibleBoundsOfWorld(world);
    }
  }, {
    key: "blur",
    value: function TextInput_blur_() {
      var node = this.domState.textareaNode;
      node && node.blur();
    }
  }, {
    key: "doCopy",
    value: function TextInput_doCopy_(content) {
      var _this2 = this;

      return this.execCommand("manualCopy", function () {
        var el = _this2.domState.textareaNode;
        el.value = content;
        el.select();
        el.ownerDocument.execCommand("copy");
      });
    }
  }, {
    key: "doPaste",
    value: function TextInput_doPaste_() {
      var _this3 = this;

      return this.execCommand("manualPaste", function () {
        var el = _this3.domState.textareaNode;
        el.value = "";
        el.select();
        el.ownerDocument.execCommand("paste");
      });
    }
  }, {
    key: "execCommand",
    value: function () {
      var _ref3 = asyncToGenerator(regeneratorRuntime.mark(function _callee(stateName, execFn) {
        var state, deferred, isDone;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (this.domState.isInstalled) {
                  _context.next = 2;
                  break;
                }

                throw new Error("Cannot copy to clipboard \u2013 input helper is not installed into DOM!");

              case 2:
                state = this.inputState;

                if (!state[stateName]) {
                  _context.next = 11;
                  break;
                }

                _context.prev = 4;
                _context.next = 7;
                return state[stateName].promise;

              case 7:
                _context.next = 11;
                break;

              case 9:
                _context.prev = 9;
                _context.t0 = _context["catch"](4);

              case 11:
                deferred = lively_lang.promise.deferred(), isDone = false;

                state[stateName] = {
                  onEvent: function onEvent(evt) {
                    if (isDone) return;
                    state[stateName] = null;
                    isDone = true;
                    deferred.resolve(evt);
                  },
                  promise: deferred.promise
                };
                execFn();
                _context.prev = 14;
                _context.next = 17;
                return lively_lang.promise.waitFor(800, function () {
                  return isDone;
                });

              case 17:
                _context.next = 24;
                break;

              case 19:
                _context.prev = 19;
                _context.t1 = _context["catch"](14);

                state[stateName] = null;
                isDone = true;
                deferred.reject(_context.t1);

              case 24:
                return _context.abrupt("return", deferred.promise);

              case 25:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[4, 9], [14, 19]]);
      }));

      function TextInput_execCommand_(_x, _x2) {
        return _ref3.apply(this, arguments);
      }

      return TextInput_execCommand_;
    }()
  }, {
    key: "onRootNodeFocus",
    value: function TextInput_onRootNodeFocus_(evt) {
      var _ref4 = this.domState || {},
          textareaNode = _ref4.textareaNode,
          rootNode = _ref4.rootNode;

      if (evt.target === textareaNode || evt.target === rootNode) this.focus();
      this.inputState.composition = null;
    }
  }, {
    key: "onInput",
    value: function TextInput_onInput_(evt) {
      if (this.inputState.composition) return;
      if (!evt.data) evt.data = this.readValue();
      this.resetValue();
      this.eventDispatcher.dispatchDOMEvent(evt);
    }
  }, {
    key: "onCompositionStart",
    value: function TextInput_onCompositionStart_(evt) {
      this.inputState.composition = {};
    }
  }, {
    key: "onCompositionUpdate",
    value: function TextInput_onCompositionUpdate_(evt) {
      var c = this.inputState.composition,
          val = this.readValue();
      if (c.lastValue === val) return;
      c.lastValue = val;
    }
  }, {
    key: "onCompositionEnd",
    value: function TextInput_onCompositionEnd_(evt) {
      this.inputState.composition = null;
    }
  }, {
    key: "setPosition",
    value: function TextInput_setPosition_(pos) {
      var _ref5 = this.domState || {},
          textareaNode = _ref5.textareaNode;

      if (!textareaNode) return;
      textareaNode.style.left = pos.x + "px";
      textareaNode.style.top = pos.y + "px";
    }
  }, {
    key: "ensureBeingInVisibleBoundsOfWorld",
    value: function TextInput_ensureBeingInVisibleBoundsOfWorld_(world) {
      this.setPosition(world.visibleBounds().center());
    }
  }, {
    key: "ensureBeingAtCursorOfText",
    value: function TextInput_ensureBeingAtCursorOfText_(textMorph) {
      if (!textMorph.world()) return;
      var localCursorPos = textMorph.textLayout.pixelPositionFor(textMorph, textMorph.cursorPosition),
          posInClippedBounds = textMorph.innerBounds().constrainPt(localCursorPos),
          globalCursorPos = textMorph.worldPoint(posInClippedBounds.subPt(textMorph.scroll));
      this.setPosition(globalCursorPos);
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 169,
    end: 8510
  });
}(undefined);

var KillRing = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("KillRing") && typeof __lively_classholder__.KillRing === "function" ? __lively_classholder__.KillRing : __lively_classholder__.KillRing = function KillRing(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function KillRing_initialize_() {
      var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      this.size = size;
      this.buffer = [];
      this.pointer = -1;
    }
  }, {
    key: "isCycling",
    value: function KillRing_isCycling_() {
      return this.pointer !== this.buffer.length - 1;
    }
  }, {
    key: "add",
    value: function KillRing_add_(x) {
      var b = this.buffer;
      b.push(x);
      if (this.size && b.length > this.size) b.splice(0, b.length - this.size);
      this.pointer = this.buffer.length - 1;
      return x;
    }
  }, {
    key: "yank",
    value: function KillRing_yank_() {
      return this.buffer[this.pointer] || "";
    }
  }, {
    key: "back",
    value: function KillRing_back_() {
      this.pointer = (this.pointer <= 0 ? this.buffer.length : this.pointer) - 1;
      return this.yank();
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 51,
    end: 614
  });
}(undefined);

var letterRe = /[a-z]/i;
function computeHashIdOfEvent(evt) {
  var key = evt.key,
      ctrlKey = evt.ctrlKey,
      altKey = evt.altKey,
      shiftKey = evt.shiftKey,
      metaKey = evt.metaKey,
      hashId = 0 | (ctrlKey ? 1 : 0) | (altKey ? 2 : 0) | (shiftKey ? 4 : 0) | (metaKey ? 8 : 0);

  if (hashId === 0 && !canonicalizeFunctionKey(key) && key && letterRe.test(key)) hashId = -1;
  return hashId;
}
var KEY_MODS = function () {
  var base = {
    "control": 1,
    "ctrl": 1,
    "alt": 2,
    "option": 2,
    "shift": 4,
    "super": 8,
    "win": 8,
    "meta": 8,
    "command": 8,
    "cmd": 8
  };
  var mods = ["alt", "ctrl", "meta", "shift"];
  for (var i = Math.pow(2, mods.length); i--;) {
    base[i] = mods.filter(function (x) {
      return i & base[x];
    }).join("-") + "-";
  }base[0] = "";
  base[-1] = "input-";
  return base;
}();
var isNumber = function () {
  var numberRe = /^[0-9]+$/;
  return function (key) {
    return numberRe.test(key);
  };
}();
function isModifier(key) {
  if (isNumber(key)) return false;
  key = key.replace(/-$/, "").toLowerCase();
  return lively_lang.arr.withoutAll(Object.keys(KEY_MODS), ["", "input-"]).includes(key);
}
var FUNCTION_KEYS = ["backspace", "tab", "enter", "pause", "escape", " ", "pageup", "pagedown", "end", "home", "left", "up", "right", "down", "print", "insert", "delete", "numpad0", "numpad1", "numpad2", "numpad3", "numpad4", "numpad5", "numpad6", "numpad7", "numpad8", "numpad9", "numpadenter", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "f10", "f11", "f12", "numlock", "scrolllock"];
function canonicalizeFunctionKey(key) {
  key = key.toLowerCase();
  switch (key) {
    case "space":
      key = "space";
      break;
    case "esc":
      key = "escape";
      break;
    case "return":
      key = "enter";
      break;
    case "arrowleft":
      key = "left";
      break;
    case "arrowright":
      key = "right";
      break;
    case "arrowup":
      key = "up";
      break;
    case "arrowdown":
      key = "down";
      break;
    case "esc":
      key = "escape";
      break;
    case "return":
      key = "enter";
      break;
  }
  return FUNCTION_KEYS.includes(key) ? lively_lang.string.capitalize(key) : "";
}
function decodeKeyIdentifier(identifier, keyCode) {
  var id = identifier,
      unicodeDecodeRe = /u\+?([\d\w]{4})/gi,
      unicodeReplacer = function unicodeReplacer(match, grp) {
    return String.fromCharCode(parseInt(grp, 16));
  },
      key = id && id.replace(unicodeDecodeRe, unicodeReplacer);
  if (key === "Command" || key === "Cmd") key = "Meta";
  if (key === " ") key = "Space";
  if (keyCode === 8) key = "Backspace";
  return key;
}
function identifyKeyFromCode(_ref) {
  var code = _ref.code;

  if (typeof code !== "string") return null;
  if (code.startsWith("Key")) return code.slice(3);
  if (code.startsWith("Numpad")) return code;
  if (code.startsWith("Digit")) return code.slice(5);
  if (code.startsWith("Arrow")) return code.slice(5);
  if (code.match(/^F[0-9]{1-2}$/)) return code;
  switch (code) {
    case "Insert":
    case "Home":
    case "PageUp":
    case "PageDown":
      return code;
    case "Period":
      return ".";
    case "Comma":
      return ",";
    case "Help":
      return "Insert";
    case "Equal":
      return "=";
    case "Backslash":
    case "IntlBackslash":
      return "\\";
    case "Equal":
      return "=";
    case "Minus":
      return "-";
    case "BracketRight":
      return "]";
    case "BracketLeft":
      return "[";
    case "Quote":
      return "'";
    case "Backquote":
      return "`";
    case "Semicolon":
      return ";";
  }
  return null;
}
function dedasherize(keyCombo) {
  var parts = [];
  while (true) {
    var idx = keyCombo.indexOf("-");
    if (idx === -1) {
      if (keyCombo) parts.push(keyCombo);
      return parts;
    }
    if (idx === 0) {
      parts.push(keyCombo[0]);
      keyCombo = keyCombo.slice(2);
    } else {
      parts.push(keyCombo.slice(0, idx));
      keyCombo = keyCombo.slice(idx + 1);
    }
  }
}
var Keys = {
  computeHashIdOfEvent: computeHashIdOfEvent,
  keyComboToEventSpec: function keyComboToEventSpec(keyCombo, flags) {
    var spec = Object.assign({
      _isLivelyKeyEventSpec: true,
      keyCombo: "",
      key: "",
      ctrlKey: false,
      shiftKey: false,
      altKey: false,
      metaKey: false,
      altGraphKey: false,
      isFunctionKey: false,
      isModified: false,
      onlyModifiers: false
    }, flags);
    var keyMods = dedasherize(keyCombo),
        modsToEvent = {
      shift: "shiftKey",
      control: "ctrlKey",
      ctrl: "ctrlKey",
      alt: "altKey",
      meta: "metaKey",
      command: "metaKey",
      cmd: "metaKey"
    };
    if (keyMods[0] === "input" && keyMods.length === 2) {
      spec.keyCombo = keyCombo;
      spec.key = keyMods[1];
      return spec;
    }
    for (var i = keyMods.length - 1; i >= 0; i--) {
      var mod = keyMods[i],
          modEventFlag = modsToEvent[mod.toLowerCase()];
      if (!modEventFlag) continue;
      keyMods.splice(i, 1);
      spec.isModified = true;
      spec[modEventFlag] = true;
    }
    if (!keyMods.length) {
      spec.keyCombo = Keys.eventToKeyCombo(spec);
      spec.key = lively_lang.arr.last(dedasherize(spec.keyCombo));
      spec.onlyModifiers = true;
      return spec;
    }
    if (keyMods.length > 1) {
      console.warn("Strange key \"" + keyCombo + "\" encountered in keyComboToEventSpec, parsing probably failed");
    }
    var trailing = lively_lang.arr.last(keyMods);
    var fnKey = canonicalizeFunctionKey(trailing);
    if (fnKey) {
      spec.isFunctionKey = true;
      spec.key = fnKey;
    } else if (spec.isModified) {
      spec.key = lively_lang.string.capitalize(trailing);
    } else {
      spec.key = trailing;
    }
    spec.keyCombo = Keys.eventToKeyCombo(spec);
    return spec;
  },
  eventToKeyCombo: function eventToKeyCombo(evt, options) {
    var _Object$assign = Object.assign({
      ignoreModifiersIfNoCombo: false,
      ignoreKeys: []
    }, options),
        ignoreModifiersIfNoCombo = _Object$assign.ignoreModifiersIfNoCombo,
        ignoreKeys = _Object$assign.ignoreKeys;

    var key = evt.key,
        data = evt.data,
        keyIdentifier = evt.keyIdentifier;

    if (typeof data === "string") return "input-" + data;
    if (!key && keyIdentifier) {
      key = decodeKeyIdentifier(keyIdentifier, evt.which || evt.keyCode);
      evt.key = key = key[evt.shiftKey ? "toUpperCase" : "toLowerCase"]();
      if (isModifier(key)) return lively_lang.string.capitalize(key);
    }
    var mod = KEY_MODS[computeHashIdOfEvent(evt)];
    if (mod === "input-") return mod + key;
    if (evt.code) key = identifyKeyFromCode(evt) || key;
    var keyCombo = !key || isModifier(key) ? mod.replace(/-$/, "") : mod + key;
    if (keyCombo.match(/\s$/)) keyCombo = keyCombo.replace(/\s$/, "Space");
    return keyCombo.replace(/(^|-)([a-z])/g, function (_, start, char) {
      return start + char.toUpperCase();
    });
  },
  canonicalizeKeyCombo: function canonicalizeKeyCombo(string$$1) {
    return Keys.eventToKeyCombo(Keys.keyComboToEventSpec(string$$1));
  },
  canonicalizeEvent: function canonicalizeEvent(evt) {
    return evt._isLivelyKeyEventSpec ? evt : Keys.keyComboToEventSpec(Keys.eventToKeyCombo(evt));
  }
};

function cumulativeElementOffset(element) {
  var offsetTop = 0,
      offsetLeft = 0;
  do {
    offsetTop += element.offsetTop || 0;
    offsetLeft += element.offsetLeft || 0;
    element = element.offsetParent;
  } while (element);
  return {
    offsetLeft: offsetLeft,
    offsetTop: offsetTop
  };
}
var pointerEvents = ["pointerover", "pointerenter", "pointerout", "pointerleave", "pointerdown", "pointermove", "pointerup", "pointercancel", "gotpointercapture", "lostpointercapture"];
var mouseEvents = ["mouseover", "mouseenter", "mousedown", "mousemove", "mouseup", "mouseout", "mouseleave", "click", "dblclick", "contextmenu", "mousewheel"];
var keyboardEvents = ["keydown", "keyup", "keypress"];
var keyLikeEvents = keyboardEvents.concat("input", "compositionstart", "compositionupdate", "compositionend");
var Event = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("Event") && typeof __lively_classholder__.Event === "function" ? __lively_classholder__.Event : __lively_classholder__.Event = function Event(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function Event_initialize_(type, domEvt, dispatcher, targetMorphs, hand, halo, layoutHalo) {
      this.type = type;
      this.domEvt = domEvt;
      this.dispatcher = dispatcher;
      this.targetMorphs = targetMorphs;
      this.hand = hand;
      this.halo = halo;
      this.layoutHalo = layoutHalo;
      this.stopped = false;
      this._keyCombo = undefined;
      this.onDispatchCallbacks = [];
      this.onAfterDispatchCallbacks = [];
      this.onStopCallbacks = [];
    }
  }, {
    key: "onDispatch",
    value: function Event_onDispatch_(cb) {
      this.onDispatchCallbacks.push(cb);
      return this;
    }
  }, {
    key: "onAfterDispatch",
    value: function Event_onAfterDispatch_(cb) {
      this.onAfterDispatchCallbacks.push(cb);
      return this;
    }
  }, {
    key: "onStop",
    value: function Event_onStop_(cb) {
      this.onStopCallbacks.push(cb);
      return this;
    }
  }, {
    key: "data",
    get: function get() {
      return this.domEvt.data;
    }
  }, {
    key: "world",
    get: function get() {
      return this.dispatcher.world;
    }
  }, {
    key: "state",
    get: function get() {
      return this.dispatcher.eventState;
    }
  }, {
    key: "keyInputState",
    get: function get() {
      return this.state.keyInputState;
    }
  }, {
    key: "isMouseEvent",
    value: function Event_isMouseEvent_() {
      return pointerEvents.includes(this.type) || mouseEvents.includes(this.type);
    }
  }, {
    key: "isKeyboardEvent",
    value: function Event_isKeyboardEvent_() {
      return !this.isMouseEvent() && keyboardEvents.includes(this.type);
    }
  }, {
    key: "stop",
    value: function Event_stop_() {
      this.stopped = true;
      this.domEvt && this.domEvt.stopPropagation();
      this.domEvt && this.domEvt.preventDefault();
      this.onStopCallbacks.forEach(function (ea) {
        return ea();
      });
    }
  }, {
    key: "targetMorph",
    get: function get() {
      return this.targetMorphs[0];
    }
  }, {
    key: "timestamp",
    get: function get() {
      return this.domEvt.timeStamp;
    }
  }, {
    key: "position",
    get: function get() {
      if (!this.domEvt) return lively_graphics.pt(0, 0);
      var worldNode = this.domEvt.target;
      while (worldNode) {
        if (worldNode.id === this.world.id) break;
        worldNode = worldNode.parentNode;
      }
      if (!worldNode) {
        console.error("event position: cannot find world node for determining the position!");
        return lively_graphics.pt(0, 0);
      }

      var _cumulativeElementOff = cumulativeElementOffset(worldNode),
          offsetLeft = _cumulativeElementOff.offsetLeft,
          offsetTop = _cumulativeElementOff.offsetTop,
          _domEvt = this.domEvt,
          pageX = _domEvt.pageX,
          pageY = _domEvt.pageY,
          pos = lively_graphics.pt((pageX || 0) - offsetLeft, (pageY || 0) - offsetTop);

      if (this.world.scale !== 1) pos = pos.scaleBy(1 / this.world.scale);
      return pos;
    }
  }, {
    key: "startPosition",
    get: function get() {
      return this.state.clickedOnPosition;
    }
  }, {
    key: "positionIn",
    value: function Event_positionIn_(aMorph) {
      return aMorph.localize(this.position);
    }
  }, {
    key: "isClickTarget",
    value: function Event_isClickTarget_(morph$$1) {
      var clicked = this.state.clickedOnMorph;
      return clicked && (morph$$1 === clicked || morph$$1.isAncestorOf(clicked));
    }
  }, {
    key: "leftMouseButtonPressed",
    value: function Event_leftMouseButtonPressed_() {
      return this.domEvt ? (this.domEvt.buttons || 0) & 1 : false;
    }
  }, {
    key: "rightMouseButtonPressed",
    value: function Event_rightMouseButtonPressed_() {
      return this.domEvt ? (this.domEvt.buttons || 0) & 2 : false;
    }
  }, {
    key: "middleMouseButtonPressed",
    value: function Event_middleMouseButtonPressed_() {
      return this.domEvt ? (this.domEvt.buttons || 0) & 4 : false;
    }
  }, {
    key: "isCommandKey",
    value: function Event_isCommandKey_() {
      var domEvt = this.domEvt;
      if (!domEvt) return false;
      var isCmd = false;
      if (!bowser.mac) isCmd = isCmd || domEvt.ctrlKey;
      if (bowser.tablet || bowser.tablet) isCmd = isCmd || false;
      return isCmd || domEvt.metaKey || domEvt.keyIdentifier === "Meta";
    }
  }, {
    key: "isShiftDown",
    value: function Event_isShiftDown_(domEvt) {
      return this.domEvt && !!this.domEvt.shiftKey;
    }
  }, {
    key: "isCtrlDown",
    value: function Event_isCtrlDown_(domEvt) {
      return this.domEvt && !!this.domEvt.ctrlKey;
    }
  }, {
    key: "isAltDown",
    value: function Event_isAltDown_(domEvt) {
      return this.domEvt && !!this.domEvt.altKey;
    }
  }, {
    key: "keyCombo",
    get: function get() {
      return this._keyCombo || (this._keyCombo = Keys.eventToKeyCombo(this.domEvt));
    }
  }, {
    key: "keyCombo",
    set: function set(keyCombo) {
      return this._keyCombo = keyCombo;
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 1242,
    end: 4845
  });
}(undefined);
var KeyEvent = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("KeyEvent") && typeof __lively_classholder__.KeyEvent === "function" ? __lively_classholder__.KeyEvent : __lively_classholder__.KeyEvent = function KeyEvent(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function KeyEvent_initialize_(type, domEvt, dispatcher, targetMorphs, hand, halo, layoutHalo) {
      console.assert(keyLikeEvents.includes(type), "not a keyboard event: " + type);
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, type, domEvt, dispatcher, targetMorphs, hand, halo, layoutHalo);
      Object.assign(this, Keys.canonicalizeEvent(domEvt));
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 4855,
    end: 5188
  });
}(Event);
var SimulatedDOMEvent = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("SimulatedDOMEvent") && typeof __lively_classholder__.SimulatedDOMEvent === "function" ? __lively_classholder__.SimulatedDOMEvent : __lively_classholder__.SimulatedDOMEvent = function SimulatedDOMEvent(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function SimulatedDOMEvent_initialize_() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (props.position) {
        var _props = props,
            _props$position = _props.position,
            x = _props$position.x,
            y = _props$position.y,
            target = _props.target;

        props = lively_lang.obj.dissoc(props, ["position"]);
        props.pageX = x;
        props.pageY = y;
      }
      if (!props.hasOwnProperty("pointerId") && mouseEvents.concat(pointerEvents).includes(props.type)) {
        props = Object.assign({}, props, { pointerId: 1 });
      }
      Object.assign(this, Object.assign({
        type: undefined,
        target: undefined,
        pageX: undefined,
        pageY: undefined,
        pointerId: undefined,
        pointerType: "mouse",
        buttons: 0,
        keyCode: undefined,
        keyString: "",
        keyIdentifier: undefined,
        altKey: false,
        ctrlKey: false,
        shiftKey: false,
        metaKey: false,
        stopped: false
      }, props));
    }
  }, {
    key: "preventDefault",
    value: function SimulatedDOMEvent_preventDefault_() {
      this.defaultPrevented = true;
    }
  }, {
    key: "stopPropagation",
    value: function SimulatedDOMEvent_stopPropagation_() {
      this.propagationStopped = true;
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 5197,
    end: 6093
  });
}(undefined);

var domEventsWeListenTo = [{
  type: "pointerdown",
  capturing: false
}, {
  type: "pointerup",
  capturing: false
}, {
  type: "pointermove",
  capturing: false
}, {
  type: "pointerover",
  capturing: false
}, {
  type: "pointerout",
  capturing: false
}, {
  type: "contextmenu",
  capturing: false
}, {
  type: "scroll",
  capturing: true
}, {
  type: "wheel",
  capturing: false
}];
var globalDomEventsWeListenTo = [{
  type: "resize",
  capturing: false,
  morphMethod: "onWindowResize"
}, {
  type: "orientationchange",
  capturing: false,
  morphMethod: "onWindowResize"
}, {
  type: "scroll",
  capturing: false,
  morphMethod: "onWindowScroll"
}];
var typeToMethodMap = {
  "pointerdown": "onMouseDown",
  "pointerup": "onMouseUp",
  "pointermove": "onMouseMove",
  "hoverin": "onHoverIn",
  "hoverout": "onHoverOut",
  "drag": "onDrag",
  "dragstart": "onDragStart",
  "dragend": "onDragEnd",
  "grab": "onGrab",
  "drop": "onDrop",
  "keydown": "onKeyDown",
  "keyup": "onKeyUp",
  "input": "onTextInput",
  "compositionstart": "onCompositionStart",
  "compositionupdate": "onCompositionUpdate",
  "compositionend": "onCompositionEnd",
  "blur": "onBlur",
  "focus": "onFocus",
  "contextmenu": "onContextMenu",
  "cut": "onCut",
  "copy": "onCopy",
  "paste": "onPaste",
  "scroll": "onScroll",
  "wheel": "onMouseWheel"
};
var focusTargetingEvents = ["keydown", "keyup", "keypress", "input", "compositionstart", "compositionupdate", "compositionend", "cut", "copy", "paste"];
function dragStartEvent(domEvt, dispatcher, targetMorph, state, hand, halo, layoutHalo) {
  var evt = new Event("dragstart", domEvt, dispatcher, [targetMorph], hand, halo, layoutHalo).onDispatch(function () {
    state.draggedMorph = targetMorph;
    state.lastDragPosition = evt.position;
    state.dragDelta = lively_graphics.pt(0, 0);
  }).onStop(function () {
    state.draggedMorph = null;
    dispatcher.schedule(dragEndEvent(domEvt, dispatcher, targetMorph, state, hand, halo, layoutHalo));
  });
  return evt;
}
function dragEvent(domEvt, dispatcher, targetMorph, state, hand, halo, layoutHalo) {
  var evt = new Event("drag", domEvt, dispatcher, [state.draggedMorph], hand, halo, layoutHalo).onDispatch(function () {
    state.dragDelta = (state.draggedMorph.owner || dispatcher.world).getInverseTransform().transformDirection(evt.position.subPt(state.lastDragPosition));
  }).onAfterDispatch(function () {
    return state.lastDragPosition = evt.position;
  }).onStop(function () {
    state.draggedMorph = null;
    dispatcher.schedule(dragEndEvent(domEvt, dispatcher, targetMorph, state, hand, halo, layoutHalo));
  });
  return evt;
}
function dragEndEvent(domEvt, dispatcher, targetMorph, state, hand, halo, layoutHalo) {
  var ctx = state.draggedMorph || targetMorph,
      evt = new Event("dragend", domEvt, dispatcher, [ctx], hand, halo, layoutHalo).onDispatch(function () {
    return state.dragDelta = (ctx.owner || dispatcher.world).getInverseTransform().transformDirection(evt.position.subPt(state.lastDragPosition));
  }).onAfterDispatch(function () {
    state.draggedMorph = null;
    state.lastDragPosition = null;
  });
  return evt;
}
function focusEvents(dispatcher, targetMorph) {
  var state = dispatcher.eventState;
  if (state.focusedMorph === targetMorph) return [];
  var domEvt = null,
      hand = null,
      halo = null,
      layoutHalo = null,
      events = [];
  state.focusedMorph && events.push(new Event("blur", domEvt, this, [state.focusedMorph], hand, halo, layoutHalo).onDispatch(function () {
    return state.focusedMorph = null;
  }));
  events.push(new Event("focus", domEvt, this, [targetMorph], hand, halo, layoutHalo).onDispatch(function () {
    return state.focusedMorph = targetMorph;
  }));
  return events;
}
var EventDispatcher = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("EventDispatcher") && typeof __lively_classholder__.EventDispatcher === "function" ? __lively_classholder__.EventDispatcher : __lively_classholder__.EventDispatcher = function EventDispatcher(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function EventDispatcher_initialize_(domEventEmitter, world) {
      this.activations = 0;
      this.emitter = domEventEmitter;
      this.keyInputHelper = null;
      this.world = world;
      this.installed = false;
      this.handlerFunctions = [];
      this.killRing = new KillRing(config.text.clipboardBufferLength);
      this.resetState();
    }
  }, {
    key: "resetState",
    value: function EventDispatcher_resetState_() {
      this.eventState = {
        focusedMorph: null,
        clickedOnPosition: null,
        clickedOnMorph: null,
        clickCount: 0,
        prevClick: null,
        draggedMorph: null,
        dragDelta: null,
        lastDragPosition: null,
        hover: {
          hoveredOverMorphs: [],
          unresolvedPointerOut: false
        },
        scroll: { interactiveScrollInProgress: null },
        keyInputState: null
      };
      this.resetKeyInputState();
    }
  }, {
    key: "resetKeyInputState",
    value: function EventDispatcher_resetKeyInputState_() {
      this.eventState.keyInputState = {
        keyChain: "",
        count: undefined
      };
    }
  }, {
    key: "focusMorph",
    value: function EventDispatcher_focusMorph_(morph$$1) {
      var _this = this;

      this.keyInputHelper && this.keyInputHelper.focus(morph$$1, this.world);
      focusEvents(this, morph$$1).forEach(function (evt) {
        return _this.dispatchEvent(evt);
      });
    }
  }, {
    key: "isMorphFocused",
    value: function EventDispatcher_isMorphFocused_(morph$$1) {
      return this.eventState.focusedMorph === morph$$1;
    }
  }, {
    key: "whenIdle",
    value: function EventDispatcher_whenIdle_() {
      var _this2 = this;

      return lively_lang.promise.waitFor(function () {
        return _this2.activations === 0;
      });
    }
  }, {
    key: "install",
    value: function EventDispatcher_install_(rootNode) {
      var _this3 = this;

      if (this.installed) return this;
      this.installed = true;
      var emitter = this.emitter,
          globalEmitter = System.global;
      domEventsWeListenTo.forEach(function (_ref) {
        var type = _ref.type,
            capturing = _ref.capturing;

        var fn = function fn(evt) {
          return _this3.dispatchDOMEvent(evt);
        };
        _this3.handlerFunctions.push({
          node: emitter,
          type: type,
          fn: fn,
          capturing: capturing
        });
        emitter.addEventListener(type, fn, capturing);
      });
      globalEmitter.addEventListener && globalDomEventsWeListenTo.forEach(function (_ref2) {
        var type = _ref2.type,
            capturing = _ref2.capturing,
            morphMethod = _ref2.morphMethod;

        var fn = function fn(evt) {
          return _this3.dispatchDOMEvent(evt, _this3.world, morphMethod);
        };
        _this3.handlerFunctions.push({
          node: globalEmitter,
          type: type,
          fn: fn,
          capturing: capturing
        });
        globalEmitter.addEventListener(type, fn, capturing);
      });
      this.keyInputHelper = new TextInput(this).install(rootNode);
      return this;
    }
  }, {
    key: "uninstall",
    value: function EventDispatcher_uninstall_() {
      this.installed = false;
      var handlerFunctions = this.handlerFunctions;
      handlerFunctions.forEach(function (_ref3) {
        var node = _ref3.node,
            type = _ref3.type,
            fn = _ref3.fn,
            capturing = _ref3.capturing;
        return node.removeEventListener(type, fn, capturing);
      });
      handlerFunctions.length = 0;
      this.keyInputHelper && this.keyInputHelper.uninstall();
      this.keyInputHelper = null;
      return this;
    }
  }, {
    key: "processDOMEvent",
    value: function EventDispatcher_processDOMEvent_(domEvt, targetMorph) {
      var _this4 = this;

      var type = domEvt.type,
          state = this.eventState,
          eventTargets = [targetMorph].concat(targetMorph.ownerChain()),
          hand = "pointerId" in domEvt ? this.world.handForPointerId(domEvt.pointerId) : this.world.firstHand,
          halo = domEvt.pointerId ? this.world.haloForPointerId(domEvt.pointerId) : null,
          layoutHalo = domEvt.pointerId ? this.world.layoutHaloForPointerId(domEvt.pointerId) : null,
          klass = keyLikeEvents.includes(type) ? KeyEvent : Event,
          defaultEvent = new klass(type, domEvt, this, eventTargets, hand, halo, layoutHalo),
          events = [defaultEvent],
          later = [];
      switch (type) {
        case "click":
          var _processDOMEvent = this.processDOMEvent(Object.assign({}, domEvt, { type: "pointerdown" }), targetMorph),
              downEvents = _processDOMEvent.events,
              _processDOMEvent2 = this.processDOMEvent(Object.assign({}, domEvt, { type: "pointerup" }), targetMorph),
              upEvents = _processDOMEvent2.events;

          events = downEvents.concat(upEvents);
          break;
        case "pointerdown":
          if (typeof domEvt.target.setPointerCapture === "function") {
            try {} catch (e) {}
          }
          defaultEvent.onDispatch(function () {
            _this4.focusMorph(targetMorph);
            state.clickedOnMorph = targetMorph;
            state.clickedOnPosition = defaultEvent.position;
            var repeatedClick = false,
                prevClickCount = 0;
            if (state.prevClick) {
              var _state$prevClick = state.prevClick,
                  clickedOnMorph = _state$prevClick.clickedOnMorph,
                  clickedOnPosition = _state$prevClick.clickedOnPosition,
                  clickedAtTime = _state$prevClick.clickedAtTime,
                  clickCount = _state$prevClick.clickCount,
                  clickInterval = Date.now() - clickedAtTime;

              repeatedClick = clickedOnMorph === targetMorph && clickInterval < config.repeatClickInterval;
              prevClickCount = clickCount;
            }
            state.clickCount = repeatedClick ? prevClickCount + 1 : 1;
          });
          break;
        case "pointerup":
          defaultEvent.onAfterDispatch(function () {
            var clickedOnMorph = state.clickedOnMorph,
                clickedOnPosition = state.clickedOnPosition,
                clickCount = state.clickCount,
                clickedAtTime = Date.now();

            state.prevClick = {
              clickedOnMorph: clickedOnMorph,
              clickedOnPosition: clickedOnPosition,
              clickedAtTime: clickedAtTime,
              clickCount: clickCount
            };
            state.clickedOnMorph = null;
            state.clickCount = 0;
          });
          if (state.draggedMorph) {
            events.push(dragEndEvent(domEvt, this, targetMorph, state, hand, halo, layoutHalo));
            defaultEvent.targetMorphs = [this.world];
          } else if (hand.carriesMorphs()) {
            if (hand.isAncestorOf(targetMorph)) {
              targetMorph = this.world.morphsContainingPoint(defaultEvent.position).filter(function (m) {
                return !hand.isAncestorOf(m);
              })[0] || this.world;
            }
            events.push(new Event("drop", domEvt, this, [targetMorph], hand, halo, layoutHalo));
            defaultEvent.targetMorphs = [this.world];
          }
          break;
        case "pointermove":
          if (hand.carriesMorphs()) {
            defaultEvent.targetMorphs = [this.world];
          } else if (state.draggedMorph) {
            defaultEvent.targetMorphs = [this.world];
            events.push(dragEvent(domEvt, this, targetMorph, state, hand, halo, layoutHalo));
          } else if (state.clickedOnMorph && state.clickedOnPosition && targetMorph.draggable && !state.draggedMorph && !hand.carriesMorphs() && state.clickedOnPosition) {
            var dist = state.clickedOnPosition.dist(defaultEvent.position),
                dragTarget = state.clickedOnMorph;
            if (dist > dragTarget.dragTriggerDistance) {
              if (dragTarget.grabbable) {
                events.push(new Event("grab", domEvt, this, [dragTarget], hand, halo, layoutHalo));
              } else if (dragTarget.draggable) {
                events.push(dragStartEvent(domEvt, this, dragTarget, state, hand, halo, layoutHalo));
              }
              defaultEvent.targetMorphs = [this.world];
            }
          }
          break;
        case "pointerover":
          if (state.hover.unresolvedPointerOut) state.hover.unresolvedPointerOut = false;
          var hoveredOverMorphs = [targetMorph].concat(targetMorph.ownerChain()).reverse(),
              hoverOutEvents = lively_lang.arr.withoutAll(state.hover.hoveredOverMorphs, hoveredOverMorphs).map(function (m) {
            return new Event("hoverout", domEvt, _this4, [m], hand, halo, layoutHalo).onDispatch(function () {
              return lively_lang.arr.remove(state.hover.hoveredOverMorphs, m);
            });
          }),
              hoverInEvents = lively_lang.arr.withoutAll(hoveredOverMorphs, state.hover.hoveredOverMorphs).map(function (m) {
            return new Event("hoverin", domEvt, _this4, [m], hand, halo, layoutHalo).onDispatch(function () {
              return lively_lang.arr.pushIfNotIncluded(state.hover.hoveredOverMorphs, m);
            });
          });
          events = hoverOutEvents.concat(hoverInEvents);
          break;
        case "pointerout":
          events = [];
          state.hover.unresolvedPointerOut = true;
          later.push(function () {
            if (state.hover.unresolvedPointerOut) {
              return Promise.all(state.hover.hoveredOverMorphs.map(function (m) {
                return _this4.schedule(new Event("hoverout", domEvt, _this4, [m], hand, halo, layoutHalo).onAfterDispatch(function () {
                  return lively_lang.arr.remove(state.hover.hoveredOverMorphs, m);
                }));
              }));
            }
          });
          break;
        case "blur":
          events = [new Event(type, domEvt, this, [targetMorph], hand, halo, layoutHalo).onDispatch(function () {
            return state.focusedMorph = null;
          })];
          break;
        case "focus":
          events = focusEvents(this, targetMorph);
          break;
        case "scroll":
          events = [new Event(type, domEvt, this, [targetMorph], hand, halo, layoutHalo).onDispatch(function () {
            return targetMorph.scroll = lively_graphics.pt(domEvt.target.scrollLeft, domEvt.target.scrollTop);
          })];
          break;
        case "input":
        case "compositionstart":
        case "compositionupdate":
        case "compositionend":
          if (!targetMorph.isText) events = [];else defaultEvent.targetMorphs = [targetMorph];
          break;
      }
      return {
        events: events,
        later: later
      };
    }
  }, {
    key: "schedule",
    value: function EventDispatcher_schedule_(evt) {
      var _this5 = this;

      this.activations++;
      return Promise.resolve().then(function () {
        return _this5.dispatchEvent(evt);
      }).then(function () {
        return _this5.activations--;
      }, function (err) {
        _this5.activations--;
        throw err;
      });
    }
  }, {
    key: "dispatchEvent",
    value: function EventDispatcher_dispatchEvent_(evt, method) {
      method = method || typeToMethodMap[evt.type];
      if (!method) throw new Error("dispatchEvent: " + evt.type + " not yet supported!");
      evt.onDispatchCallbacks.forEach(function (ea) {
        return ea();
      });
      this.activations++;
      var err;
      for (var j = evt.targetMorphs.length - 1; j >= 0; j--) {
        try {
          evt.targetMorphs[j][method](evt);
        } catch (e) {
          err = new Error("Error in event handler " + evt.targetMorphs[j] + "." + method + ": " + (e.stack || e));
          err.originalError = e;
          typeof this.world !== "undefined" ? this.world.logError(err) : console.error(err);
        }
        if (err || evt.stopped) break;
      }
      this.activations--;
      evt.onAfterDispatchCallbacks.forEach(function (ea) {
        return ea();
      });
      if (err) throw err;
    }
  }, {
    key: "dispatchDOMEvent",
    value: function EventDispatcher_dispatchDOMEvent_(domEvt, targetMorph, morphMethod) {
      var _this6 = this;

      if (!targetMorph && focusTargetingEvents.includes(domEvt.type)) {
        targetMorph = this.eventState.focusedMorph || this.world;
      } else if (!targetMorph) {
        var targetNode = domEvt.target;
        while (true) {
          var cssClasses = targetNode.className || "";
          if (typeof cssClasses !== "string" && "baseVal" in cssClasses) cssClasses = cssClasses.baseVal;
          if (cssClasses && cssClasses.includes("Morph")) break;
          if (!(targetNode = targetNode.parentNode)) return;
        }
        var targetId = targetNode.id;
        targetMorph = this.world.withAllSubmorphsDetect(function (sub) {
          return sub.id === targetId;
        });
      }
      if (!targetMorph) {
        return;
      }

      var _processDOMEvent3 = this.processDOMEvent(domEvt, targetMorph),
          events = _processDOMEvent3.events,
          later = _processDOMEvent3.later;

      later.map(function (callback) {
        _this6.activations++;
        return lively_lang.promise.delay(0).then(callback).then(function () {
          return _this6.activations--;
        }, function (err) {
          _this6.activations--;
          throw err;
        });
      });
      events.forEach(function (evt) {
        return _this6.dispatchEvent(evt, morphMethod);
      });
    }
  }, {
    key: "simulateDOMEvents",
    value: function EventDispatcher_simulateDOMEvents_() {
      var doc = this.emitter.document || this.emitter.ownerDocument;
      var events = [];

      for (var _len = arguments.length, eventSpecs = Array(_len), _key = 0; _key < _len; _key++) {
        eventSpecs[_key] = arguments[_key];
      }

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = eventSpecs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var spec = _step.value;
          var _spec = spec,
              target = _spec.target,
              position = _spec.position,
              type = _spec.type;

          if (focusTargetingEvents.includes(type)) {
            if (!this.keyInputHelper.domState.textareaNode) throw new Error("Cannot simulate event of type " + type + ", no keyInputHelper installed!");
            spec = Object.assign({}, spec, { target: this.keyInputHelper.textareaNode });
          }
          if (!target) {
            if (!position) target = this.world;else target = this.world.morphsContainingPoint(position)[0];
          }
          if (target.isMorph) spec = Object.assign({}, spec, { target: doc.getElementById(target.id) });
          if (spec.position) {
            var _cumulativeElementOff = cumulativeElementOffset(doc.getElementById(this.world.id)),
                offsetLeft = _cumulativeElementOff.offsetLeft,
                offsetTop = _cumulativeElementOff.offsetTop;

            spec.position = spec.position.addXY(offsetLeft, offsetTop);
          }
          if (type === "scroll" && ("scrollLeft" in spec || "scrollRight" in spec)) {
            spec.target.scrollLeft = spec.scrollLeft || 0;
            spec.target.scrollTop = spec.scrollTop || 0;
          }
          var evt = new SimulatedDOMEvent(spec);
          events.push(evt);
          this.dispatchDOMEvent(evt);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return events;
    }
  }, {
    key: "doCopy",
    value: function EventDispatcher_doCopy_(content) {
      return this.keyInputHelper.doCopy(content);
    }
  }, {
    key: "doPaste",
    value: function EventDispatcher_doPaste_() {
      return this.keyInputHelper.doPaste();
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 5970,
    end: 21861
  });
}(undefined);

var MorphicEnv = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("MorphicEnv") && typeof __lively_classholder__.MorphicEnv === "function" ? __lively_classholder__.MorphicEnv : __lively_classholder__.MorphicEnv = function MorphicEnv(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function MorphicEnv_initialize_() {
      var _this = this;

      var domEnv = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultDOMEnv();

      this.fontMetric = null;
      this.renderer = null;
      this.eventDispatcher = null;
      this.world = null;
      this.systemChangeHandlers = null;
      this.objPool = null;
      this.synchronizer = null;
      if (typeof domEnv.then === "function") {
        this._waitForDOMEnv = domEnv.then(function (env) {
          _this._waitForDOMEnv = null;
          _this.initWithDOMEnv(env);
        }).catch(function (err) {
          return console.error("Error initializing MorphicEnv with dom env: " + err.stack);
        });
      } else this.initWithDOMEnv(domEnv);
      this.changeManager = new ChangeManager();
      this.undoManager = new UndoManager();
      this.installSystemChangeHandlers();
    }
  }, {
    key: "initWithDOMEnv",
    value: function MorphicEnv_initWithDOMEnv_(domEnv) {
      this.domEnv = domEnv;
      this.fontMetric = FontMetric.forDOMEnv(domEnv);
    }
  }, {
    key: "uninstallWorldRelated",
    value: function MorphicEnv_uninstallWorldRelated_() {
      this.renderer && this.renderer.clear();
      this.eventDispatcher && this.eventDispatcher.uninstall();
    }
  }, {
    key: "uninstall",
    value: function MorphicEnv_uninstall_() {
      this.deleteHistory();
      this.uninstallWorldRelated();
      if (this.fontMetric) {
        this.fontMetric.uninstall();
        this.fontMetric = null;
      }
      this.domEnv && this.domEnv.destroy();
    }
  }, {
    key: "setWorld",
    value: function MorphicEnv_setWorld_(world) {
      var _this2 = this;

      if (this._waitForDOMEnv) {
        return this._waitForDOMEnv.then(function () {
          return _this2.setWorld(world);
        });
      }
      return this.setWorldRenderedOn(world, this.domEnv.document.body);
    }
  }, {
    key: "setWorldRenderedOn",
    value: function MorphicEnv_setWorldRenderedOn_(world, rootNode) {
      var _this3 = this;

      if (this._waitForDOMEnv) {
        return this._waitForDOMEnv.then(function () {
          return _this3.setWorldRenderedOn(world, rootNode);
        });
      }
      this.uninstallWorldRelated();
      this.world = world;
      this.renderer = new Renderer(world, rootNode, this.domEnv).startRenderWorldLoop();
      this.eventDispatcher = new EventDispatcher(this.domEnv.window, world).install(rootNode);
      world.makeDirty();
      return world.whenRendered().then(function () {
        return _this3;
      });
    }
  }, {
    key: "installSystemChangeHandlers",
    value: function MorphicEnv_installSystemChangeHandlers_() {
      var _this4 = this;

      if (this.systemChangeHandlers) return;
      var handlers = this.systemChangeHandlers = {};
      handlers["lively.modules/moduleloaded"] = [lively_notifications.subscribe("lively.modules/moduleloaded", function (evt) {
        return _this4.getSystemChangeTargets().forEach(function (ea) {
          return ea.onModuleLoaded(evt);
        });
      })];
      handlers["lively.modules/modulechanged"] = [lively_notifications.subscribe("lively.modules/modulechanged", function (evt) {
        return _this4.getSystemChangeTargets().forEach(function (ea) {
          return ea.onModuleChanged(evt);
        });
      })];
    }
  }, {
    key: "uninstallSystemChangeHandlers",
    value: function MorphicEnv_uninstallSystemChangeHandlers_() {
      if (!this.systemChangeHandlers) return;
      var handlers = this.systemChangeHandlers;
      this.systemChangeHandlers = null;
      Object.keys(handlers).forEach(function (name) {
        return handlers[name].forEach(function (handler) {
          return lively_notifications.unsubscribe(name, handler);
        });
      });
    }
  }, {
    key: "getSystemChangeTargets",
    value: function MorphicEnv_getSystemChangeTargets_() {
      var world = this.world,
          targets = [];
      if (!world) return targets;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = world.getWindows()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var win = _step.value;

          win.isBrowser && targets.push(win);
          win.targetMorph && win.targetMorph.isObjectEditor && targets.push(win.targetMorph);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return targets;
    }
  }, {
    key: "deleteHistory",
    value: function MorphicEnv_deleteHistory_() {
      var changeManager = this.changeManager,
          world = this.world,
          fontMetric = this.fontMetric;

      changeManager && (changeManager.changes.length = 0);
      world && world.withAllSubmorphsDo(function (ea) {
        return ea.undoManager && ea.undoManager.reset();
      });
      fontMetric && fontMetric.reset();
    }
  }, {
    key: "printStatus",
    value: function MorphicEnv_printStatus_() {
      var changeManager = this.changeManager,
          world = this.world,
          fontMetric = this.fontMetric,
          morphsWithUndo = 0,
          undoChanges = 0;

      world && world.withAllSubmorphsDo(function (ea) {
        if (!ea.undoManager) return;
        morphsWithUndo++;
        undoChanges += ea.undoManager.undos.length + ea.undoManager.redos.length;
      });
      return changeManager.changes.length + " changes recorded\n" + morphsWithUndo + " morphs with undos\n" + undoChanges + " undo changes";
    }
  }], [{
    key: "reset",
    value: function MorphicEnv_reset_() {
      while (true) {
        var env = this.popDefault();
        if (!env) break;
        try {
          env.uninstall();
        } catch (err) {
          console.error("Error uninstalling MorphicEnv: " + (err.stack || err));
        }
      }
    }
  }, {
    key: "default",
    value: function MorphicEnv_default_() {
      if (!this._envs || !this._envs.length) this.pushDefault(new this());
      return this._envs[this._envs.length - 1];
    }
  }, {
    key: "pushDefault",
    value: function MorphicEnv_pushDefault_(env) {
      if (!this._envs) this._envs = [];
      this._envs.push(env);
      return env;
    }
  }, {
    key: "popDefault",
    value: function MorphicEnv_popDefault_() {
      if (!this._envs) this._envs = [];
      return this._envs.pop();
    }
  }], __lively_classholder__, undefined, {
    start: 406,
    end: 4652
  });
}(undefined);

function Label$$1_Builder() { 
              if (Label$$1) return Label$$1;
              if (!Morph$1) {
                 setTimeout(Label$$1_Builder, 0);
                 return;
              }
        Label$$1 = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("Label") && typeof __lively_classholder__.Label === "function" ? __lively_classholder__.Label : __lively_classholder__.Label = function Label$$1(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function Label_initialize_() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var fontMetric = props.fontMetric,
          position = props.position,
          rightCenter = props.rightCenter,
          leftCenter = props.leftCenter,
          topCenter = props.topCenter,
          bottom = props.bottom,
          top = props.top,
          right = props.right,
          left = props.left,
          bottomCenter = props.bottomCenter,
          bottomLeft = props.bottomLeft,
          bottomRight = props.bottomRight,
          topRight = props.topRight,
          topLeft = props.topLeft,
          center = props.center,
          extent = props.extent;

      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, lively_lang.obj.dissoc(props, ["fontMetric"]));
      if (fontMetric) this._fontMetric = fontMetric;
      this._cachedTextBounds = null;
      this.fit();
      if (extent !== undefined) this.extent = extent;
      if (position !== undefined) this.position = position;
      if (rightCenter !== undefined) this.rightCenter = rightCenter;
      if (leftCenter !== undefined) this.leftCenter = leftCenter;
      if (topCenter !== undefined) this.topCenter = topCenter;
      if (bottom !== undefined) this.bottom = bottom;
      if (top !== undefined) this.top = top;
      if (right !== undefined) this.right = right;
      if (left !== undefined) this.left = left;
      if (bottomCenter !== undefined) this.bottomCenter = bottomCenter;
      if (bottomLeft !== undefined) this.bottomLeft = bottomLeft;
      if (bottomRight !== undefined) this.bottomRight = bottomRight;
      if (topRight !== undefined) this.topRight = topRight;
      if (topLeft !== undefined) this.topLeft = topLeft;
      if (center !== undefined) this.center = center;
    }
  }, {
    key: "isLabel",
    get: function get() {
      return true;
    }
  }, {
    key: "textStyle",
    get: function get() {
      return lively_lang.obj.select(this, ["textStyleClasses", "textDecoration", "fontStyle", "fontWeight", "fontColor", "fontSize", "fontFamily"]);
    }
  }, {
    key: "fit",
    value: function Label_fit_() {
      this.extent = this.textBounds().extent();
      this._needsFit = false;
      return this;
    }
  }, {
    key: "textAndAttributesOfLines",
    get: function get() {
      var lines = [[]],
          textAndAttributes = this.textAndAttributes;
      for (var i = 0; i < textAndAttributes.length; i++) {
        var _textAndAttributes$i = slicedToArray(textAndAttributes[i], 2),
            text = _textAndAttributes$i[0],
            style = _textAndAttributes$i[1],
            style = style || {},
            textLines = lively_lang.string.lines(text);

        if (textLines[0].length) lively_lang.arr.last(lines).push([textLines[0], style]);
        for (var j = 1; j < textLines.length; j++) {
          lines.push(textLines[j].length ? [[textLines[j], style]] : []);
        }
      }
      return lines;
    }
  }, {
    key: "textBoundsSingleChunk",
    value: function Label_textBoundsSingleChunk_() {
      var fm = this._fontMetric || this.env.fontMetric,
          _textAndAttributes = slicedToArray(this.textAndAttributes, 1),
          _textAndAttributes$ = slicedToArray(_textAndAttributes[0], 2),
          text = _textAndAttributes$[0],
          chunkStyle = _textAndAttributes$[1],
          style = Object.assign({}, this.textStyle, {}, chunkStyle),
          padding = this.padding,
          width,
          height;
      if (!fm.isProportional(style.fontFamily)) {
        var _fm$sizeFor = fm.sizeFor(style, "x"),
            charWidth = _fm$sizeFor.width,
            charHeight = _fm$sizeFor.height;

        width = text.length * charWidth;
        height = charHeight;
      } else {
        var _fm$sizeFor2 = fm.sizeFor(style, text);

        width = _fm$sizeFor2.width;
        height = _fm$sizeFor2.height;
      }
      return new lively_graphics.Rectangle(0, 0, padding.left() + padding.right() + width, padding.top() + padding.bottom() + height);
    }
  }, {
    key: "textBoundsAllChunks",
    value: function Label_textBoundsAllChunks_() {
      var fm = this._fontMetric || this.env.fontMetric,
          padding = this.padding,
          defaultStyle$$1 = this.textStyle,
          lines = this.textAndAttributesOfLines,
          defaultIsMonospaced = !fm.isProportional(defaultStyle$$1.fontFamily),
          _fm$sizeFor3 = fm.sizeFor(defaultStyle$$1, "x"),
          defaultHeight = _fm$sizeFor3.height,
          height = 0,
          width = 0;
      for (var i = 0; i < lines.length; i++) {
        var textAndAttributes = lines[i];
        if (!textAndAttributes.length) {
          height += defaultHeight;
          continue;
        }
        var lineHeight = 0,
            lineWidth = 0;
        for (var j = 0; j < textAndAttributes.length; j++) {
          var _textAndAttributes$j = slicedToArray(textAndAttributes[j], 2),
              text = _textAndAttributes$j[0],
              style = _textAndAttributes$j[1],
              mergedStyle = Object.assign({}, defaultStyle$$1, {}, style),
              isMonospaced = defaultIsMonospaced && !style.fontFamily || !fm.isProportional(mergedStyle.fontFamily);

          if (isMonospaced) {
            var fontId = mergedStyle.fontFamily + "-" + mergedStyle.fontSize,
                _fm$sizeFor4 = fm.sizeFor(mergedStyle, "x"),
                charWidth = _fm$sizeFor4.width,
                charHeight = _fm$sizeFor4.height;
            lineWidth += text.length * charWidth;
            lineHeight = Math.max(lineHeight, charHeight);
          } else {
            var _fm$sizeFor5 = fm.sizeFor(mergedStyle, text),
                textWidth = _fm$sizeFor5.width,
                textHeight = _fm$sizeFor5.height;

            lineWidth += textWidth;
            lineHeight = Math.max(lineHeight, textHeight);
          }
        }
        height += lineHeight;
        width = Math.max(width, lineWidth);
      }
      return new lively_graphics.Rectangle(0, 0, padding.left() + padding.right() + width, padding.top() + padding.bottom() + height);
    }
  }, {
    key: "textBounds",
    value: function Label_textBounds_() {
      var textAndAttributes = this.textAndAttributes,
          _cachedTextBounds = this._cachedTextBounds;

      return _cachedTextBounds ? _cachedTextBounds : this._cachedTextBounds = textAndAttributes.length <= 1 ? this.textBoundsSingleChunk() : this.textBoundsAllChunks();
    }
  }, {
    key: "forceRerender",
    value: function Label_forceRerender_() {
      this._cachedTextBounds = null;
      this.makeDirty();
    }
  }, {
    key: "render",
    value: function Label_render_(renderer) {
      if (this._needsFit) this.fit();
      var renderedText = [],
          nLines = this.textAndAttributesOfLines.length;
      for (var i = 0; i < nLines; i++) {
        var line = this.textAndAttributesOfLines[i];
        for (var j = 0; j < line.length; j++) {
          var _line$j = slicedToArray(line[j], 2),
              text = _line$j[0],
              style = _line$j[1];

          renderedText.push(this.renderChunk(text, style));
        }
        if (i < nLines - 1) renderedText.push(vdom.h("br"));
      }
      var _textStyle = this.textStyle,
          fontColor = _textStyle.fontColor,
          fontFamily = _textStyle.fontFamily,
          fontSize = _textStyle.fontSize,
          fontStyle = _textStyle.fontStyle,
          fontWeight = _textStyle.fontWeight,
          textDecoration = _textStyle.textDecoration,
          textStyleClasses = _textStyle.textStyleClasses,
          padding = this.padding,
          style = {
        fontFamily: fontFamily,
        fontSize: typeof fontSize === "number" ? fontSize + "px" : fontSize,
        color: fontColor ? String(fontColor) : "transparent",
        position: "absolute",
        paddingLeft: padding.left() + "px",
        paddingRight: padding.right() + "px",
        paddingTop: padding.top() + "px",
        paddingBottom: padding.bottom() + "px",
        cursor: this.nativeCursor
      },
          attrs = defaultAttributes(this, renderer);

      if (fontWeight !== "normal") style.fontWeight = fontWeight;
      if (fontStyle !== "normal") style.fontStyle = fontStyle;
      if (textDecoration !== "none") style.textDecoration = textDecoration;
      if (textStyleClasses && textStyleClasses.length) attrs.className = (attrs.className || "") + " " + textStyleClasses.join(" ");
      attrs.style = Object.assign({}, defaultStyle(this), {}, style);
      return vdom.h("div", attrs, [].concat(renderedText, [renderer.renderSubmorphs(this)]));
    }
  }, {
    key: "renderChunk",
    value: function Label_renderChunk_(text, chunkStyle) {
      var _ref = chunkStyle || {},
          backgroundColor = _ref.backgroundColor,
          fontColor = _ref.fontColor,
          fontFamily = _ref.fontFamily,
          fontStyle = _ref.fontStyle,
          fontWeight = _ref.fontWeight,
          textDecoration = _ref.textDecoration,
          textStyleClasses = _ref.textStyleClasses,
          textAlign = _ref.textAlign,
          style = {},
          attrs = { style: style };

      if (backgroundColor) style.backgroundColor = String(backgroundColor);
      if (fontFamily) style.fontFamily = fontFamily;
      if (fontColor) style.fontColor = String(fontColor);
      if (fontWeight !== "normal") style.fontWeight = fontWeight;
      if (fontStyle !== "normal") style.fontStyle = fontStyle;
      if (textDecoration !== "none") style.textDecoration = textDecoration;
      if (textAlign) style.textAlign = textAlign;
      if (textStyleClasses && textStyleClasses.length) attrs.className = textStyleClasses.join(" ");
      var lengthAttrs = ["fontSize", "width", "height", "maxWidth", "maxHeight", "top", "left", "padding", "paddingLeft", "paddingRight", "paddingBottom", "paddingTop"];
      for (var i = 0; i < lengthAttrs.length; i++) {
        var name = lengthAttrs[i];
        if (!chunkStyle.hasOwnProperty(name)) continue;
        var value = chunkStyle[name];
        style[name] = typeof value === "number" ? value + "px" : value;
      }
      return vdom.h("span", attrs, text);
    }
  }], [{
    key: "properties",
    get: function get() {
      return {
        fill: { defaultValue: null },
        draggable: { defaultValue: false },
        nativeCursor: { defaultValue: "default" },
        value: {
          derived: true,
          after: ["textAndAttributes", "textString"],
          get: function get() {
            var textAndAttributes = this.textAndAttributes;

            if (textAndAttributes.length === 1) {
              var _textAndAttributes$2 = slicedToArray(textAndAttributes[0], 2),
                  text = _textAndAttributes$2[0],
                  style = _textAndAttributes$2[1];

              if (!Object.keys(style || {}).length) return text;
            }
            return textAndAttributes;
          },
          set: function set(value) {
            typeof value === "string" ? this.textString = value : this.textAndAttributes = value;
          }
        },
        textString: {
          derived: true,
          after: ["textAndAttributes"],
          get: function get() {
            return this.textAndAttributes.map(function (_ref2) {
              var _ref3 = slicedToArray(_ref2, 1),
                  text = _ref3[0];

              return text;
            }).join("");
          },
          set: function set(value) {
            this.textAndAttributes = [[value, {}]];
          }
        },
        textAndAttributes: {
          get: function get() {
            var val = this.getProperty("textAndAttributes");
            if (!val || val.length < 1) val = [[""]];
            return val;
          },
          set: function set(value) {
            if (!Array.isArray(value)) value = [[String(value), {}]];
            if (value.length === 0) value = [["", {}]];
            this._cachedTextBounds = null;
            this.setProperty("textAndAttributes", value);
            if (this.autofit) this._needsFit = true;
            lively_bindings.signal(this, "value", value);
          }
        },
        valueAndAnnotation: {
          derived: true,
          after: ["textAndAttributes"],
          get: function get() {
            var value = this.textAndAttributes,
                annotation = null;
            if (value.length > 1) {
              var _arr$last = lively_lang.arr.last(value),
                  _arr$last2 = slicedToArray(_arr$last, 2),
                  string$$1 = _arr$last2[0],
                  props = _arr$last2[1];

              if (props && props.textStyleClasses && props.textStyleClasses.includes("annotation")) {
                value = value.slice(0, -1);
                annotation = [string$$1, props];
              }
            }
            return {
              value: value,
              annotation: annotation
            };
          },
          set: function set(valueAndAnnotation) {
            var value = valueAndAnnotation.value,
                annotation = valueAndAnnotation.annotation;

            if (!value) value = "";
            if (typeof value === "string") value = [[value, {}]];
            if (!Array.isArray(value)) value = String(value);else if (value.length === 2 && typeof value[0] === "string") value = [value];
            var textAndAttributes = value.slice();
            if (annotation) {
              if (typeof annotation === "string") annotation = [annotation, {}];
              textAndAttributes.push(annotation);
              var annAttr = annotation[1];
              if (!annAttr) annAttr = annotation[1] = {};
              annAttr.textStyleClasses = (annAttr.textStyleClasses || []).concat("annotation");
              if (!annAttr.textStyleClasses.includes("annotation")) annAttr.textStyleClasses.push("annotation");
            }
            this.textAndAttributes = textAndAttributes;
          }
        },
        autofit: {
          defaultValue: true,
          set: function set(value) {
            this.setProperty("autofit", value);
            if (value) this._needsFit = true;
          }
        },
        padding: {
          defaultValue: lively_graphics.Rectangle.inset(0),
          initialize: function initialize(value) {
            this.padding = value;
          },
          set: function set(value) {
            this._cachedTextBounds = null;
            this.setProperty("padding", typeof value === "number" ? lively_graphics.Rectangle.inset(value) : value);
            if (this.autofit) this._needsFit = true;
          }
        },
        fontFamily: {
          defaultValue: "Sans-Serif",
          set: function set(fontFamily) {
            this._cachedTextBounds = null;
            this.setProperty("fontFamily", fontFamily);
            if (this.autofit) this._needsFit = true;
          }
        },
        fontSize: {
          defaultValue: 12,
          set: function set(fontSize) {
            this._cachedTextBounds = null;
            this.setProperty("fontSize", fontSize);
            if (this.autofit) this._needsFit = true;
          }
        },
        fontColor: { defaultValue: lively_graphics.Color.black },
        fontWeight: {
          defaultValue: "normal",
          set: function set(fontWeight) {
            this._cachedTextBounds = null;
            this.setProperty("fontWeight", fontWeight);
            if (this.autofit) this._needsFit = true;
          }
        },
        fontStyle: {
          defaultValue: "normal",
          set: function set(fontStyle) {
            this._cachedTextBounds = null;
            this.setProperty("fontStyle", fontStyle);
            if (this.autofit) this._needsFit = true;
          }
        },
        textDecoration: { defaultValue: "none" },
        textStyleClasses: {
          defaultValue: undefined,
          set: function set(textStyleClasses) {
            this._cachedTextBounds = null;
            this.setProperty("textStyleClasses", textStyleClasses);
            if (this.autofit) this._needsFit = true;
          }
        }
      };
    }
  }, {
    key: "icon",
    value: function Label_icon_(iconName) {
      var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        prefix: "",
        suffix: ""
      };

      return Icon$$1.makeLabel(iconName, props);
    }
  }], __lively_classholder__, undefined, {
    start: 351,
    end: 13654
  });
}(Morph$1);
        return Label$$1}

var Icon$$1 = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("Icon") && typeof __lively_classholder__.Icon === "function" ? __lively_classholder__.Icon : __lively_classholder__.Icon = function Icon$$1(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, undefined, [{
    key: "makeLabel",
    value: function Icon_makeLabel_(iconName) {
      var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        prefix: "",
        suffix: ""
      };
      var prefix = props.prefix,
          suffix = props.suffix;

      var textAndAttributes = [];
      if (prefix) textAndAttributes.push(typeof prefix === "string" ? [prefix || "", {}] : prefix);
      textAndAttributes.push(this.textAttribute(iconName));
      if (suffix) textAndAttributes.push(typeof suffix === "string" ? [suffix || "", {}] : suffix);
      return new Label$$1(Object.assign({ value: textAndAttributes }, lively_lang.obj.dissoc(props, ["prefix", "suffix"])));
    }
  }, {
    key: "textAttribute",
    value: function Icon_textAttribute_(iconName) {
      return [Icons[iconName].code || "icon " + iconName + " not found", {
        fontFamily: "",
        textStyleClasses: ["fa"]
      }];
    }
  }, {
    key: "setIcon",
    value: function Icon_setIcon_(label, iconName) {
      label.textAndAttributes = [this.textAttribute(iconName)];
    }
  }], __lively_classholder__, undefined, {
    start: 731,
    end: 1616
  });
}(undefined);
var Icons = {
  "500px": { code: "\uF26E" },
  "address-book": { code: "\uF2B9" },
  "address-book-o": { code: "\uF2BA" },
  "address-card": { code: "\uF2BB" },
  "address-card-o": { code: "\uF2BC" },
  "adjust": { code: "\uF042" },
  "adn": { code: "\uF170" },
  "align-center": { code: "\uF037" },
  "align-justify": { code: "\uF039" },
  "align-left": { code: "\uF036" },
  "align-right": { code: "\uF038" },
  "amazon": { code: "\uF270" },
  "ambulance": { code: "\uF0F9" },
  "american-sign-language-interpreting": { code: "\uF2A3" },
  "anchor": { code: "\uF13D" },
  "android": { code: "\uF17B" },
  "angellist": { code: "\uF209" },
  "angle-double-down": { code: "\uF103" },
  "angle-double-left": { code: "\uF100" },
  "angle-double-right": { code: "\uF101" },
  "angle-double-up": { code: "\uF102" },
  "angle-down": { code: "\uF107" },
  "angle-left": { code: "\uF104" },
  "angle-right": { code: "\uF105" },
  "angle-up": { code: "\uF106" },
  "apple": { code: "\uF179" },
  "archive": { code: "\uF187" },
  "area-chart": { code: "\uF1FE" },
  "arrow-circle-down": { code: "\uF0AB" },
  "arrow-circle-left": { code: "\uF0A8" },
  "arrow-circle-o-down": { code: "\uF01A" },
  "arrow-circle-o-left": { code: "\uF190" },
  "arrow-circle-o-right": { code: "\uF18E" },
  "arrow-circle-o-up": { code: "\uF01B" },
  "arrow-circle-right": { code: "\uF0A9" },
  "arrow-circle-up": { code: "\uF0AA" },
  "arrow-down": { code: "\uF063" },
  "arrow-left": { code: "\uF060" },
  "arrow-right": { code: "\uF061" },
  "arrow-up": { code: "\uF062" },
  "arrows": { code: "\uF047" },
  "arrows-alt": { code: "\uF0B2" },
  "arrows-h": { code: "\uF07E" },
  "arrows-v": { code: "\uF07D" },
  "asl-interpreting": { code: "\uF2A3" },
  "assistive-listening-systems": { code: "\uF2A2" },
  "asterisk": { code: "\uF069" },
  "at": { code: "\uF1FA" },
  "audio-description": { code: "\uF29E" },
  "automobile": { code: "\uF1B9" },
  "backward": { code: "\uF04A" },
  "balance-scale": { code: "\uF24E" },
  "ban": { code: "\uF05E" },
  "bandcamp": { code: "\uF2D5" },
  "bank": { code: "\uF19C" },
  "bar-chart": { code: "\uF080" },
  "bar-chart-o": { code: "\uF080" },
  "barcode": { code: "\uF02A" },
  "bars": { code: "\uF0C9" },
  "bath": { code: "\uF2CD" },
  "bathtub": { code: "\uF2CD" },
  "battery": { code: "\uF240" },
  "battery-0": { code: "\uF244" },
  "battery-1": { code: "\uF243" },
  "battery-2": { code: "\uF242" },
  "battery-3": { code: "\uF241" },
  "battery-4": { code: "\uF240" },
  "battery-empty": { code: "\uF244" },
  "battery-full": { code: "\uF240" },
  "battery-half": { code: "\uF242" },
  "battery-quarter": { code: "\uF243" },
  "battery-three-quarters": { code: "\uF241" },
  "bed": { code: "\uF236" },
  "beer": { code: "\uF0FC" },
  "behance": { code: "\uF1B4" },
  "behance-square": { code: "\uF1B5" },
  "bell": { code: "\uF0F3" },
  "bell-o": { code: "\uF0A2" },
  "bell-slash": { code: "\uF1F6" },
  "bell-slash-o": { code: "\uF1F7" },
  "bicycle": { code: "\uF206" },
  "binoculars": { code: "\uF1E5" },
  "birthday-cake": { code: "\uF1FD" },
  "bitbucket": { code: "\uF171" },
  "bitbucket-square": { code: "\uF172" },
  "bitcoin": { code: "\uF15A" },
  "black-tie": { code: "\uF27E" },
  "blind": { code: "\uF29D" },
  "bluetooth": { code: "\uF293" },
  "bluetooth-b": { code: "\uF294" },
  "bold": { code: "\uF032" },
  "bolt": { code: "\uF0E7" },
  "bomb": { code: "\uF1E2" },
  "book": { code: "\uF02D" },
  "bookmark": { code: "\uF02E" },
  "bookmark-o": { code: "\uF097" },
  "braille": { code: "\uF2A1" },
  "briefcase": { code: "\uF0B1" },
  "btc": { code: "\uF15A" },
  "bug": { code: "\uF188" },
  "building": { code: "\uF1AD" },
  "building-o": { code: "\uF0F7" },
  "bullhorn": { code: "\uF0A1" },
  "bullseye": { code: "\uF140" },
  "bus": { code: "\uF207" },
  "buysellads": { code: "\uF20D" },
  "cab": { code: "\uF1BA" },
  "calculator": { code: "\uF1EC" },
  "calendar": { code: "\uF073" },
  "calendar-check-o": { code: "\uF274" },
  "calendar-minus-o": { code: "\uF272" },
  "calendar-o": { code: "\uF133" },
  "calendar-plus-o": { code: "\uF271" },
  "calendar-times-o": { code: "\uF273" },
  "camera": { code: "\uF030" },
  "camera-retro": { code: "\uF083" },
  "car": { code: "\uF1B9" },
  "caret-down": { code: "\uF0D7" },
  "caret-left": { code: "\uF0D9" },
  "caret-right": { code: "\uF0DA" },
  "caret-square-o-down": { code: "\uF150" },
  "caret-square-o-left": { code: "\uF191" },
  "caret-square-o-right": { code: "\uF152" },
  "caret-square-o-up": { code: "\uF151" },
  "caret-up": { code: "\uF0D8" },
  "cart-arrow-down": { code: "\uF218" },
  "cart-plus": { code: "\uF217" },
  "cc": { code: "\uF20A" },
  "cc-amex": { code: "\uF1F3" },
  "cc-diners-club": { code: "\uF24C" },
  "cc-discover": { code: "\uF1F2" },
  "cc-jcb": { code: "\uF24B" },
  "cc-mastercard": { code: "\uF1F1" },
  "cc-paypal": { code: "\uF1F4" },
  "cc-stripe": { code: "\uF1F5" },
  "cc-visa": { code: "\uF1F0" },
  "certificate": { code: "\uF0A3" },
  "chain": { code: "\uF0C1" },
  "chain-broken": { code: "\uF127" },
  "check": { code: "\uF00C" },
  "check-circle": { code: "\uF058" },
  "check-circle-o": { code: "\uF05D" },
  "check-square": { code: "\uF14A" },
  "check-square-o": { code: "\uF046" },
  "chevron-circle-down": { code: "\uF13A" },
  "chevron-circle-left": { code: "\uF137" },
  "chevron-circle-right": { code: "\uF138" },
  "chevron-circle-up": { code: "\uF139" },
  "chevron-down": { code: "\uF078" },
  "chevron-left": { code: "\uF053" },
  "chevron-right": { code: "\uF054" },
  "chevron-up": { code: "\uF077" },
  "child": { code: "\uF1AE" },
  "chrome": { code: "\uF268" },
  "circle": { code: "\uF111" },
  "circle-o": { code: "\uF10C" },
  "circle-o-notch": { code: "\uF1CE" },
  "circle-thin": { code: "\uF1DB" },
  "clipboard": { code: "\uF0EA" },
  "clock-o": { code: "\uF017" },
  "clone": { code: "\uF24D" },
  "close": { code: "\uF00D" },
  "cloud": { code: "\uF0C2" },
  "cloud-download": { code: "\uF0ED" },
  "cloud-upload": { code: "\uF0EE" },
  "cny": { code: "\uF157" },
  "code": { code: "\uF121" },
  "code-fork": { code: "\uF126" },
  "codepen": { code: "\uF1CB" },
  "codiepie": { code: "\uF284" },
  "coffee": { code: "\uF0F4" },
  "cog": { code: "\uF013" },
  "cogs": { code: "\uF085" },
  "columns": { code: "\uF0DB" },
  "comment": { code: "\uF075" },
  "comment-o": { code: "\uF0E5" },
  "commenting": { code: "\uF27A" },
  "commenting-o": { code: "\uF27B" },
  "comments": { code: "\uF086" },
  "comments-o": { code: "\uF0E6" },
  "compass": { code: "\uF14E" },
  "compress": { code: "\uF066" },
  "connectdevelop": { code: "\uF20E" },
  "contao": { code: "\uF26D" },
  "copy": { code: "\uF0C5" },
  "copyright": { code: "\uF1F9" },
  "creative-commons": { code: "\uF25E" },
  "credit-card": { code: "\uF09D" },
  "credit-card-alt": { code: "\uF283" },
  "crop": { code: "\uF125" },
  "crosshairs": { code: "\uF05B" },
  "css3": { code: "\uF13C" },
  "cube": { code: "\uF1B2" },
  "cubes": { code: "\uF1B3" },
  "cut": { code: "\uF0C4" },
  "cutlery": { code: "\uF0F5" },
  "dashboard": { code: "\uF0E4" },
  "dashcube": { code: "\uF210" },
  "database": { code: "\uF1C0" },
  "deaf": { code: "\uF2A4" },
  "deafness": { code: "\uF2A4" },
  "dedent": { code: "\uF03B" },
  "delicious": { code: "\uF1A5" },
  "desktop": { code: "\uF108" },
  "deviantart": { code: "\uF1BD" },
  "diamond": { code: "\uF219" },
  "digg": { code: "\uF1A6" },
  "dollar": { code: "\uF155" },
  "dot-circle-o": { code: "\uF192" },
  "download": { code: "\uF019" },
  "dribbble": { code: "\uF17D" },
  "drivers-license": { code: "\uF2C2" },
  "drivers-license-o": { code: "\uF2C3" },
  "dropbox": { code: "\uF16B" },
  "drupal": { code: "\uF1A9" },
  "edge": { code: "\uF282" },
  "edit": { code: "\uF044" },
  "eercast": { code: "\uF2DA" },
  "eject": { code: "\uF052" },
  "ellipsis-h": { code: "\uF141" },
  "ellipsis-v": { code: "\uF142" },
  "empire": { code: "\uF1D1" },
  "envelope": { code: "\uF0E0" },
  "envelope-o": { code: "\uF003" },
  "envelope-open": { code: "\uF2B6" },
  "envelope-open-o": { code: "\uF2B7" },
  "envelope-square": { code: "\uF199" },
  "envira": { code: "\uF299" },
  "eraser": { code: "\uF12D" },
  "etsy": { code: "\uF2D7" },
  "eur": { code: "\uF153" },
  "euro": { code: "\uF153" },
  "exchange": { code: "\uF0EC" },
  "exclamation": { code: "\uF12A" },
  "exclamation-circle": { code: "\uF06A" },
  "exclamation-triangle": { code: "\uF071" },
  "expand": { code: "\uF065" },
  "expeditedssl": { code: "\uF23E" },
  "external-link": { code: "\uF08E" },
  "external-link-square": { code: "\uF14C" },
  "eye": { code: "\uF06E" },
  "eye-slash": { code: "\uF070" },
  "eyedropper": { code: "\uF1FB" },
  "fa": { code: "\uF2B4" },
  "facebook": { code: "\uF09A" },
  "facebook-f": { code: "\uF09A" },
  "facebook-official": { code: "\uF230" },
  "facebook-square": { code: "\uF082" },
  "fast-backward": { code: "\uF049" },
  "fast-forward": { code: "\uF050" },
  "fax": { code: "\uF1AC" },
  "feed": { code: "\uF09E" },
  "female": { code: "\uF182" },
  "fighter-jet": { code: "\uF0FB" },
  "file": { code: "\uF15B" },
  "file-archive-o": { code: "\uF1C6" },
  "file-audio-o": { code: "\uF1C7" },
  "file-code-o": { code: "\uF1C9" },
  "file-excel-o": { code: "\uF1C3" },
  "file-image-o": { code: "\uF1C5" },
  "file-movie-o": { code: "\uF1C8" },
  "file-o": { code: "\uF016" },
  "file-pdf-o": { code: "\uF1C1" },
  "file-photo-o": { code: "\uF1C5" },
  "file-picture-o": { code: "\uF1C5" },
  "file-powerpoint-o": { code: "\uF1C4" },
  "file-sound-o": { code: "\uF1C7" },
  "file-text": { code: "\uF15C" },
  "file-text-o": { code: "\uF0F6" },
  "file-video-o": { code: "\uF1C8" },
  "file-word-o": { code: "\uF1C2" },
  "file-zip-o": { code: "\uF1C6" },
  "files-o": { code: "\uF0C5" },
  "film": { code: "\uF008" },
  "filter": { code: "\uF0B0" },
  "fire": { code: "\uF06D" },
  "fire-extinguisher": { code: "\uF134" },
  "firefox": { code: "\uF269" },
  "first-order": { code: "\uF2B0" },
  "flag": { code: "\uF024" },
  "flag-checkered": { code: "\uF11E" },
  "flag-o": { code: "\uF11D" },
  "flash": { code: "\uF0E7" },
  "flask": { code: "\uF0C3" },
  "flickr": { code: "\uF16E" },
  "floppy-o": { code: "\uF0C7" },
  "folder": { code: "\uF07B" },
  "folder-o": { code: "\uF114" },
  "folder-open": { code: "\uF07C" },
  "folder-open-o": { code: "\uF115" },
  "font": { code: "\uF031" },
  "font-awesome": { code: "\uF2B4" },
  "fonticons": { code: "\uF280" },
  "fort-awesome": { code: "\uF286" },
  "forumbee": { code: "\uF211" },
  "forward": { code: "\uF04E" },
  "foursquare": { code: "\uF180" },
  "free-code-camp": { code: "\uF2C5" },
  "frown-o": { code: "\uF119" },
  "futbol-o": { code: "\uF1E3" },
  "gamepad": { code: "\uF11B" },
  "gavel": { code: "\uF0E3" },
  "gbp": { code: "\uF154" },
  "ge": { code: "\uF1D1" },
  "gear": { code: "\uF013" },
  "gears": { code: "\uF085" },
  "genderless": { code: "\uF22D" },
  "get-pocket": { code: "\uF265" },
  "gg": { code: "\uF260" },
  "gg-circle": { code: "\uF261" },
  "gift": { code: "\uF06B" },
  "git": { code: "\uF1D3" },
  "git-square": { code: "\uF1D2" },
  "github": { code: "\uF09B" },
  "github-alt": { code: "\uF113" },
  "github-square": { code: "\uF092" },
  "gitlab": { code: "\uF296" },
  "gittip": { code: "\uF184" },
  "glass": { code: "\uF000" },
  "glide": { code: "\uF2A5" },
  "glide-g": { code: "\uF2A6" },
  "globe": { code: "\uF0AC" },
  "google": { code: "\uF1A0" },
  "google-plus": { code: "\uF0D5" },
  "google-plus-circle": { code: "\uF2B3" },
  "google-plus-official": { code: "\uF2B3" },
  "google-plus-square": { code: "\uF0D4" },
  "google-wallet": { code: "\uF1EE" },
  "graduation-cap": { code: "\uF19D" },
  "gratipay": { code: "\uF184" },
  "grav": { code: "\uF2D6" },
  "group": { code: "\uF0C0" },
  "h-square": { code: "\uF0FD" },
  "hacker-news": { code: "\uF1D4" },
  "hand-grab-o": { code: "\uF255" },
  "hand-lizard-o": { code: "\uF258" },
  "hand-o-down": { code: "\uF0A7" },
  "hand-o-left": { code: "\uF0A5" },
  "hand-o-right": { code: "\uF0A4" },
  "hand-o-up": { code: "\uF0A6" },
  "hand-paper-o": { code: "\uF256" },
  "hand-peace-o": { code: "\uF25B" },
  "hand-pointer-o": { code: "\uF25A" },
  "hand-rock-o": { code: "\uF255" },
  "hand-scissors-o": { code: "\uF257" },
  "hand-spock-o": { code: "\uF259" },
  "hand-stop-o": { code: "\uF256" },
  "handshake-o": { code: "\uF2B5" },
  "hard-of-hearing": { code: "\uF2A4" },
  "hashtag": { code: "\uF292" },
  "hdd-o": { code: "\uF0A0" },
  "header": { code: "\uF1DC" },
  "headphones": { code: "\uF025" },
  "heart": { code: "\uF004" },
  "heart-o": { code: "\uF08A" },
  "heartbeat": { code: "\uF21E" },
  "history": { code: "\uF1DA" },
  "home": { code: "\uF015" },
  "hospital-o": { code: "\uF0F8" },
  "hotel": { code: "\uF236" },
  "hourglass": { code: "\uF254" },
  "hourglass-1": { code: "\uF251" },
  "hourglass-2": { code: "\uF252" },
  "hourglass-3": { code: "\uF253" },
  "hourglass-end": { code: "\uF253" },
  "hourglass-half": { code: "\uF252" },
  "hourglass-o": { code: "\uF250" },
  "hourglass-start": { code: "\uF251" },
  "houzz": { code: "\uF27C" },
  "html5": { code: "\uF13B" },
  "i-cursor": { code: "\uF246" },
  "id-badge": { code: "\uF2C1" },
  "id-card": { code: "\uF2C2" },
  "id-card-o": { code: "\uF2C3" },
  "ils": { code: "\uF20B" },
  "image": { code: "\uF03E" },
  "imdb": { code: "\uF2D8" },
  "inbox": { code: "\uF01C" },
  "indent": { code: "\uF03C" },
  "industry": { code: "\uF275" },
  "info": { code: "\uF129" },
  "info-circle": { code: "\uF05A" },
  "inr": { code: "\uF156" },
  "instagram": { code: "\uF16D" },
  "institution": { code: "\uF19C" },
  "internet-explorer": { code: "\uF26B" },
  "intersex": { code: "\uF224" },
  "ioxhost": { code: "\uF208" },
  "italic": { code: "\uF033" },
  "joomla": { code: "\uF1AA" },
  "jpy": { code: "\uF157" },
  "jsfiddle": { code: "\uF1CC" },
  "key": { code: "\uF084" },
  "keyboard-o": { code: "\uF11C" },
  "krw": { code: "\uF159" },
  "language": { code: "\uF1AB" },
  "laptop": { code: "\uF109" },
  "lastfm": { code: "\uF202" },
  "lastfm-square": { code: "\uF203" },
  "leaf": { code: "\uF06C" },
  "leanpub": { code: "\uF212" },
  "legal": { code: "\uF0E3" },
  "lemon-o": { code: "\uF094" },
  "level-down": { code: "\uF149" },
  "level-up": { code: "\uF148" },
  "life-bouy": { code: "\uF1CD" },
  "life-buoy": { code: "\uF1CD" },
  "life-ring": { code: "\uF1CD" },
  "life-saver": { code: "\uF1CD" },
  "lightbulb-o": { code: "\uF0EB" },
  "line-chart": { code: "\uF201" },
  "link": { code: "\uF0C1" },
  "linkedin": { code: "\uF0E1" },
  "linkedin-square": { code: "\uF08C" },
  "linode": { code: "\uF2B8" },
  "linux": { code: "\uF17C" },
  "list": { code: "\uF03A" },
  "list-alt": { code: "\uF022" },
  "list-ol": { code: "\uF0CB" },
  "list-ul": { code: "\uF0CA" },
  "location-arrow": { code: "\uF124" },
  "lock": { code: "\uF023" },
  "long-arrow-down": { code: "\uF175" },
  "long-arrow-left": { code: "\uF177" },
  "long-arrow-right": { code: "\uF178" },
  "long-arrow-up": { code: "\uF176" },
  "low-vision": { code: "\uF2A8" },
  "magic": { code: "\uF0D0" },
  "magnet": { code: "\uF076" },
  "mail-forward": { code: "\uF064" },
  "mail-reply": { code: "\uF112" },
  "mail-reply-all": { code: "\uF122" },
  "male": { code: "\uF183" },
  "map": { code: "\uF279" },
  "map-marker": { code: "\uF041" },
  "map-o": { code: "\uF278" },
  "map-pin": { code: "\uF276" },
  "map-signs": { code: "\uF277" },
  "mars": { code: "\uF222" },
  "mars-double": { code: "\uF227" },
  "mars-stroke": { code: "\uF229" },
  "mars-stroke-h": { code: "\uF22B" },
  "mars-stroke-v": { code: "\uF22A" },
  "maxcdn": { code: "\uF136" },
  "meanpath": { code: "\uF20C" },
  "medium": { code: "\uF23A" },
  "medkit": { code: "\uF0FA" },
  "meetup": { code: "\uF2E0" },
  "meh-o": { code: "\uF11A" },
  "mercury": { code: "\uF223" },
  "microchip": { code: "\uF2DB" },
  "microphone": { code: "\uF130" },
  "microphone-slash": { code: "\uF131" },
  "minus": { code: "\uF068" },
  "minus-circle": { code: "\uF056" },
  "minus-square": { code: "\uF146" },
  "minus-square-o": { code: "\uF147" },
  "mixcloud": { code: "\uF289" },
  "mobile": { code: "\uF10B" },
  "mobile-phone": { code: "\uF10B" },
  "modx": { code: "\uF285" },
  "money": { code: "\uF0D6" },
  "moon-o": { code: "\uF186" },
  "mortar-board": { code: "\uF19D" },
  "motorcycle": { code: "\uF21C" },
  "mouse-pointer": { code: "\uF245" },
  "music": { code: "\uF001" },
  "navicon": { code: "\uF0C9" },
  "neuter": { code: "\uF22C" },
  "newspaper-o": { code: "\uF1EA" },
  "object-group": { code: "\uF247" },
  "object-ungroup": { code: "\uF248" },
  "odnoklassniki": { code: "\uF263" },
  "odnoklassniki-square": { code: "\uF264" },
  "opencart": { code: "\uF23D" },
  "openid": { code: "\uF19B" },
  "opera": { code: "\uF26A" },
  "optin-monster": { code: "\uF23C" },
  "outdent": { code: "\uF03B" },
  "pagelines": { code: "\uF18C" },
  "paint-brush": { code: "\uF1FC" },
  "paper-plane": { code: "\uF1D8" },
  "paper-plane-o": { code: "\uF1D9" },
  "paperclip": { code: "\uF0C6" },
  "paragraph": { code: "\uF1DD" },
  "paste": { code: "\uF0EA" },
  "pause": { code: "\uF04C" },
  "pause-circle": { code: "\uF28B" },
  "pause-circle-o": { code: "\uF28C" },
  "paw": { code: "\uF1B0" },
  "paypal": { code: "\uF1ED" },
  "pencil": { code: "\uF040" },
  "pencil-square": { code: "\uF14B" },
  "pencil-square-o": { code: "\uF044" },
  "percent": { code: "\uF295" },
  "phone": { code: "\uF095" },
  "phone-square": { code: "\uF098" },
  "photo": { code: "\uF03E" },
  "picture-o": { code: "\uF03E" },
  "pie-chart": { code: "\uF200" },
  "pied-piper": { code: "\uF2AE" },
  "pied-piper-alt": { code: "\uF1A8" },
  "pied-piper-pp": { code: "\uF1A7" },
  "pinterest": { code: "\uF0D2" },
  "pinterest-p": { code: "\uF231" },
  "pinterest-square": { code: "\uF0D3" },
  "plane": { code: "\uF072" },
  "play": { code: "\uF04B" },
  "play-circle": { code: "\uF144" },
  "play-circle-o": { code: "\uF01D" },
  "plug": { code: "\uF1E6" },
  "plus": { code: "\uF067" },
  "plus-circle": { code: "\uF055" },
  "plus-square": { code: "\uF0FE" },
  "plus-square-o": { code: "\uF196" },
  "podcast": { code: "\uF2CE" },
  "power-off": { code: "\uF011" },
  "print": { code: "\uF02F" },
  "product-hunt": { code: "\uF288" },
  "puzzle-piece": { code: "\uF12E" },
  "qq": { code: "\uF1D6" },
  "qrcode": { code: "\uF029" },
  "question": { code: "\uF128" },
  "question-circle": { code: "\uF059" },
  "question-circle-o": { code: "\uF29C" },
  "quora": { code: "\uF2C4" },
  "quote-left": { code: "\uF10D" },
  "quote-right": { code: "\uF10E" },
  "ra": { code: "\uF1D0" },
  "random": { code: "\uF074" },
  "ravelry": { code: "\uF2D9" },
  "rebel": { code: "\uF1D0" },
  "recycle": { code: "\uF1B8" },
  "reddit": { code: "\uF1A1" },
  "reddit-alien": { code: "\uF281" },
  "reddit-square": { code: "\uF1A2" },
  "refresh": { code: "\uF021" },
  "registered": { code: "\uF25D" },
  "remove": { code: "\uF00D" },
  "renren": { code: "\uF18B" },
  "reorder": { code: "\uF0C9" },
  "repeat": { code: "\uF01E" },
  "reply": { code: "\uF112" },
  "reply-all": { code: "\uF122" },
  "resistance": { code: "\uF1D0" },
  "retweet": { code: "\uF079" },
  "rmb": { code: "\uF157" },
  "road": { code: "\uF018" },
  "rocket": { code: "\uF135" },
  "rotate-left": { code: "\uF0E2" },
  "rotate-right": { code: "\uF01E" },
  "rouble": { code: "\uF158" },
  "rss": { code: "\uF09E" },
  "rss-square": { code: "\uF143" },
  "rub": { code: "\uF158" },
  "ruble": { code: "\uF158" },
  "rupee": { code: "\uF156" },
  "s15": { code: "\uF2CD" },
  "safari": { code: "\uF267" },
  "save": { code: "\uF0C7" },
  "scissors": { code: "\uF0C4" },
  "scribd": { code: "\uF28A" },
  "search": { code: "\uF002" },
  "search-minus": { code: "\uF010" },
  "search-plus": { code: "\uF00E" },
  "sellsy": { code: "\uF213" },
  "send": { code: "\uF1D8" },
  "send-o": { code: "\uF1D9" },
  "server": { code: "\uF233" },
  "share": { code: "\uF064" },
  "share-alt": { code: "\uF1E0" },
  "share-alt-square": { code: "\uF1E1" },
  "share-square": { code: "\uF14D" },
  "share-square-o": { code: "\uF045" },
  "shekel": { code: "\uF20B" },
  "sheqel": { code: "\uF20B" },
  "shield": { code: "\uF132" },
  "ship": { code: "\uF21A" },
  "shirtsinbulk": { code: "\uF214" },
  "shopping-bag": { code: "\uF290" },
  "shopping-basket": { code: "\uF291" },
  "shopping-cart": { code: "\uF07A" },
  "shower": { code: "\uF2CC" },
  "sign-in": { code: "\uF090" },
  "sign-language": { code: "\uF2A7" },
  "sign-out": { code: "\uF08B" },
  "signal": { code: "\uF012" },
  "signing": { code: "\uF2A7" },
  "simplybuilt": { code: "\uF215" },
  "sitemap": { code: "\uF0E8" },
  "skyatlas": { code: "\uF216" },
  "skype": { code: "\uF17E" },
  "slack": { code: "\uF198" },
  "sliders": { code: "\uF1DE" },
  "slideshare": { code: "\uF1E7" },
  "smile-o": { code: "\uF118" },
  "snapchat": { code: "\uF2AB" },
  "snapchat-ghost": { code: "\uF2AC" },
  "snapchat-square": { code: "\uF2AD" },
  "snowflake-o": { code: "\uF2DC" },
  "soccer-ball-o": { code: "\uF1E3" },
  "sort": { code: "\uF0DC" },
  "sort-alpha-asc": { code: "\uF15D" },
  "sort-alpha-desc": { code: "\uF15E" },
  "sort-amount-asc": { code: "\uF160" },
  "sort-amount-desc": { code: "\uF161" },
  "sort-asc": { code: "\uF0DE" },
  "sort-desc": { code: "\uF0DD" },
  "sort-down": { code: "\uF0DD" },
  "sort-numeric-asc": { code: "\uF162" },
  "sort-numeric-desc": { code: "\uF163" },
  "sort-up": { code: "\uF0DE" },
  "soundcloud": { code: "\uF1BE" },
  "space-shuttle": { code: "\uF197" },
  "spinner": { code: "\uF110" },
  "spoon": { code: "\uF1B1" },
  "spotify": { code: "\uF1BC" },
  "square": { code: "\uF0C8" },
  "square-o": { code: "\uF096" },
  "stack-exchange": { code: "\uF18D" },
  "stack-overflow": { code: "\uF16C" },
  "star": { code: "\uF005" },
  "star-half": { code: "\uF089" },
  "star-half-empty": { code: "\uF123" },
  "star-half-full": { code: "\uF123" },
  "star-half-o": { code: "\uF123" },
  "star-o": { code: "\uF006" },
  "steam": { code: "\uF1B6" },
  "steam-square": { code: "\uF1B7" },
  "step-backward": { code: "\uF048" },
  "step-forward": { code: "\uF051" },
  "stethoscope": { code: "\uF0F1" },
  "sticky-note": { code: "\uF249" },
  "sticky-note-o": { code: "\uF24A" },
  "stop": { code: "\uF04D" },
  "stop-circle": { code: "\uF28D" },
  "stop-circle-o": { code: "\uF28E" },
  "street-view": { code: "\uF21D" },
  "strikethrough": { code: "\uF0CC" },
  "stumbleupon": { code: "\uF1A4" },
  "stumbleupon-circle": { code: "\uF1A3" },
  "subscript": { code: "\uF12C" },
  "subway": { code: "\uF239" },
  "suitcase": { code: "\uF0F2" },
  "sun-o": { code: "\uF185" },
  "superpowers": { code: "\uF2DD" },
  "superscript": { code: "\uF12B" },
  "support": { code: "\uF1CD" },
  "table": { code: "\uF0CE" },
  "tablet": { code: "\uF10A" },
  "tachometer": { code: "\uF0E4" },
  "tag": { code: "\uF02B" },
  "tags": { code: "\uF02C" },
  "tasks": { code: "\uF0AE" },
  "taxi": { code: "\uF1BA" },
  "telegram": { code: "\uF2C6" },
  "television": { code: "\uF26C" },
  "tencent-weibo": { code: "\uF1D5" },
  "terminal": { code: "\uF120" },
  "text-height": { code: "\uF034" },
  "text-width": { code: "\uF035" },
  "th": { code: "\uF00A" },
  "th-large": { code: "\uF009" },
  "th-list": { code: "\uF00B" },
  "themeisle": { code: "\uF2B2" },
  "thermometer": { code: "\uF2C7" },
  "thermometer-0": { code: "\uF2CB" },
  "thermometer-1": { code: "\uF2CA" },
  "thermometer-2": { code: "\uF2C9" },
  "thermometer-3": { code: "\uF2C8" },
  "thermometer-4": { code: "\uF2C7" },
  "thermometer-empty": { code: "\uF2CB" },
  "thermometer-full": { code: "\uF2C7" },
  "thermometer-half": { code: "\uF2C9" },
  "thermometer-quarter": { code: "\uF2CA" },
  "thermometer-three-quarters": { code: "\uF2C8" },
  "thumb-tack": { code: "\uF08D" },
  "thumbs-down": { code: "\uF165" },
  "thumbs-o-down": { code: "\uF088" },
  "thumbs-o-up": { code: "\uF087" },
  "thumbs-up": { code: "\uF164" },
  "ticket": { code: "\uF145" },
  "times": { code: "\uF00D" },
  "times-circle": { code: "\uF057" },
  "times-circle-o": { code: "\uF05C" },
  "times-rectangle": { code: "\uF2D3" },
  "times-rectangle-o": { code: "\uF2D4" },
  "tint": { code: "\uF043" },
  "toggle-down": { code: "\uF150" },
  "toggle-left": { code: "\uF191" },
  "toggle-off": { code: "\uF204" },
  "toggle-on": { code: "\uF205" },
  "toggle-right": { code: "\uF152" },
  "toggle-up": { code: "\uF151" },
  "trademark": { code: "\uF25C" },
  "train": { code: "\uF238" },
  "transgender": { code: "\uF224" },
  "transgender-alt": { code: "\uF225" },
  "trash": { code: "\uF1F8" },
  "trash-o": { code: "\uF014" },
  "tree": { code: "\uF1BB" },
  "trello": { code: "\uF181" },
  "tripadvisor": { code: "\uF262" },
  "trophy": { code: "\uF091" },
  "truck": { code: "\uF0D1" },
  "try": { code: "\uF195" },
  "tty": { code: "\uF1E4" },
  "tumblr": { code: "\uF173" },
  "tumblr-square": { code: "\uF174" },
  "turkish-lira": { code: "\uF195" },
  "tv": { code: "\uF26C" },
  "twitch": { code: "\uF1E8" },
  "twitter": { code: "\uF099" },
  "twitter-square": { code: "\uF081" },
  "umbrella": { code: "\uF0E9" },
  "underline": { code: "\uF0CD" },
  "undo": { code: "\uF0E2" },
  "universal-access": { code: "\uF29A" },
  "university": { code: "\uF19C" },
  "unlink": { code: "\uF127" },
  "unlock": { code: "\uF09C" },
  "unlock-alt": { code: "\uF13E" },
  "unsorted": { code: "\uF0DC" },
  "upload": { code: "\uF093" },
  "usb": { code: "\uF287" },
  "usd": { code: "\uF155" },
  "user": { code: "\uF007" },
  "user-circle": { code: "\uF2BD" },
  "user-circle-o": { code: "\uF2BE" },
  "user-md": { code: "\uF0F0" },
  "user-o": { code: "\uF2C0" },
  "user-plus": { code: "\uF234" },
  "user-secret": { code: "\uF21B" },
  "user-times": { code: "\uF235" },
  "users": { code: "\uF0C0" },
  "vcard": { code: "\uF2BB" },
  "vcard-o": { code: "\uF2BC" },
  "venus": { code: "\uF221" },
  "venus-double": { code: "\uF226" },
  "venus-mars": { code: "\uF228" },
  "viacoin": { code: "\uF237" },
  "viadeo": { code: "\uF2A9" },
  "viadeo-square": { code: "\uF2AA" },
  "video-camera": { code: "\uF03D" },
  "vimeo": { code: "\uF27D" },
  "vimeo-square": { code: "\uF194" },
  "vine": { code: "\uF1CA" },
  "vk": { code: "\uF189" },
  "volume-control-phone": { code: "\uF2A0" },
  "volume-down": { code: "\uF027" },
  "volume-off": { code: "\uF026" },
  "volume-up": { code: "\uF028" },
  "warning": { code: "\uF071" },
  "wechat": { code: "\uF1D7" },
  "weibo": { code: "\uF18A" },
  "weixin": { code: "\uF1D7" },
  "whatsapp": { code: "\uF232" },
  "wheelchair": { code: "\uF193" },
  "wheelchair-alt": { code: "\uF29B" },
  "wifi": { code: "\uF1EB" },
  "wikipedia-w": { code: "\uF266" },
  "window-close": { code: "\uF2D3" },
  "window-close-o": { code: "\uF2D4" },
  "window-maximize": { code: "\uF2D0" },
  "window-minimize": { code: "\uF2D1" },
  "window-restore": { code: "\uF2D2" },
  "windows": { code: "\uF17A" },
  "won": { code: "\uF159" },
  "wordpress": { code: "\uF19A" },
  "wpbeginner": { code: "\uF297" },
  "wpexplorer": { code: "\uF2DE" },
  "wpforms": { code: "\uF298" },
  "wrench": { code: "\uF0AD" },
  "xing": { code: "\uF168" },
  "xing-square": { code: "\uF169" },
  "y-combinator": { code: "\uF23B" },
  "y-combinator-square": { code: "\uF1D4" },
  "yahoo": { code: "\uF19E" },
  "yc": { code: "\uF23B" },
  "yc-square": { code: "\uF1D4" },
  "yelp": { code: "\uF1E9" },
  "yen": { code: "\uF157" },
  "yoast": { code: "\uF2B1" },
  "youtube": { code: "\uF167" },
  "youtube-play": { code: "\uF16A" },
  "youtube-square": { code: "\uF166" }
};

LoadingIndicator = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("LoadingIndicator") && typeof __lively_classholder__.LoadingIndicator === "function" ? __lively_classholder__.LoadingIndicator : __lively_classholder__.LoadingIndicator = function LoadingIndicator(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function LoadingIndicator_initialize_() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, props);
      this.relayout();
      lively_bindings.connect(this, "extent", this, "relayout");
      lively_bindings.connect(this.get("label"), "extent", this, "relayout");
      lively_bindings.connect(this.get("label"), "value", this, "updateLabel");
      lively_bindings.connect(this.get("label"), "fontSize", this, "updateLabel");
      lively_bindings.connect(this.get("label"), "fontFamily", this, "updateLabel");
      lively_bindings.connect(this.get("closeButton"), "fire", this, "remove");
      this.get("closeButton").fit();
    }
  }, {
    key: "isEpiMorph",
    get: function get() {
      return true;
    }
  }, {
    key: "updateLabel",
    value: function LoadingIndicator_updateLabel_() {
      var _this = this;

      var center = this.center;
      this.relayout();
      setTimeout(function () {
        return _this.center = center;
      }, 0);
    }
  }, {
    key: "relayout",
    value: function LoadingIndicator_relayout_() {
      var padding = lively_graphics.Rectangle.inset(20, 12),
          _submorphs = slicedToArray(this.submorphs, 3),
          spinner = _submorphs[0],
          label = _submorphs[1],
          closeButton = _submorphs[2],
          w = Math.max(spinner.width, label.width, 120) + padding.left() + padding.right(),
          h$$1 = spinner.height + label.height + padding.top() + padding.bottom();
      this.extent = lively_graphics.pt(w, h$$1);
      spinner.width = 100;
      spinner.topCenter = this.innerBounds().topCenter().addXY(0, padding.top());
      label.topCenter = spinner.bottomCenter.addXY(0, 4);
      closeButton.width = 20;
      closeButton.right = w;
    }
  }, {
    key: "onHoverIn",
    value: function LoadingIndicator_onHoverIn_(evt) {
      this.get("closeButton").visible = true;
    }
  }, {
    key: "onHoverOut",
    value: function LoadingIndicator_onHoverOut_(evt) {
      this.get("closeButton").visible = false;
    }
  }], [{
    key: "open",
    value: function LoadingIndicator_open_(label, props) {
      return new this(Object.assign({}, props, { label: label })).openInWorld();
    }
  }, {
    key: "forPromise",
    value: function LoadingIndicator_forPromise_(p, label, props) {
      var i = this.open(label, props);
      lively_lang.promise.finally(Promise.resolve(p), function () {
        return i.remove();
      });
      return i;
    }
  }, {
    key: "runFn",
    value: function () {
      var _ref = asyncToGenerator(regeneratorRuntime.mark(function _callee(fn, label, props) {
        var i;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                i = this.open(label, props);
                _context.next = 3;
                return i.whenRendered();

              case 3:
                _context.prev = 3;
                _context.next = 6;
                return fn();

              case 6:
                return _context.abrupt("return", _context.sent);

              case 7:
                _context.prev = 7;

                i.remove();
                return _context.finish(7);

              case 10:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[3,, 7, 10]]);
      }));

      function LoadingIndicator_runFn_(_x2, _x3, _x4) {
        return _ref.apply(this, arguments);
      }

      return LoadingIndicator_runFn_;
    }()
  }, {
    key: "properties",
    get: function get() {
      var _ref2;

      return _ref2 = {
        fill: { defaultValue: lively_graphics.Color.rgbHex("#555").withA(0.9) },
        fontSize: { defaultValue: 16 },
        fontFamily: { defaultValue: "Arial" },
        name: { defaultValue: "LoadingIndicator" },
        borderRadius: { defaultValue: 10 },
        label: {
          derived: true,
          after: ["submorphs"],
          get: function get() {
            return this.getSubmorphNamed("label").value;
          },
          set: function set(val) {
            this.getSubmorphNamed("label").value = val;
          }
        }
      }, defineProperty(_ref2, "fontFamily", {
        derived: true,
        after: ["submorphs"],
        get: function get() {
          return this.getSubmorphNamed("label").fontFamily;
        },
        set: function set(val) {
          this.getSubmorphNamed("label").fontFamily = val;
        }
      }), defineProperty(_ref2, "fontSize", {
        derived: true,
        after: ["submorphs"],
        get: function get() {
          return this.getSubmorphNamed("label").fontSize;
        },
        set: function set(val) {
          this.getSubmorphNamed("label").fontSize = val;
        }
      }), defineProperty(_ref2, "submorphs", {
        initialize: function initialize() {
          this.submorphs = [new Image$$1({
            imageUrl: System.decanonicalize("lively.morphic/") + "lively-web-logo-small-animate.svg",
            name: "spinner",
            fill: lively_graphics.Color.transparent,
            extent: lively_graphics.pt(100, 104),
            topLeft: lively_graphics.pt(0, 0),
            halosEnabled: false
          }), {
            type: "label",
            name: "label",
            value: "",
            fontSize: 16,
            fontFamily: "Helvetica Neue, Arial",
            fontColor: lively_graphics.Color.white,
            styleClasses: ["center-text"],
            halosEnabled: false
          }, {
            type: "button",
            name: "closeButton",
            label: [Icon$$1.textAttribute("times")],
            fontFamily: "FontAwesome",
            fontColor: lively_graphics.Color.white,
            activeStyle: {
              extent: lively_graphics.pt(20, 20),
              fill: lively_graphics.Color.transparent,
              borderWidth: 0,
              fontColor: lively_graphics.Color.white
            },
            visible: false
          }];
        }
      }), _ref2;
    }
  }], __lively_classholder__, undefined, {
    start: 296,
    end: 3995
  });
}(Morph$1);

function printArg$1(x) {
  return lively_lang.obj.inspect(x, { maxDepth: 1 }).replace(/\n/g, "").replace(/\s+/g, " ");
}
var CommandHandler = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("CommandHandler") && typeof __lively_classholder__.CommandHandler === "function" ? __lively_classholder__.CommandHandler : __lively_classholder__.CommandHandler = function CommandHandler(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function CommandHandler_initialize_() {
      this.history = [];
      this.maxHistorySize = 300;
    }
  }, {
    key: "addToHistory",
    value: function CommandHandler_addToHistory_(cmdName) {
      this.history.push(cmdName);
      if (this.history.length > this.maxHistorySize) this.history.splice(0, this.history.length - this.maxHistorySize);
    }
  }, {
    key: "printHistory",
    value: function CommandHandler_printHistory_() {
      return this.history.map(function (_ref) {
        var name = _ref.name,
            targetName = _ref.target.string,
            args = _ref.args,
            count = _ref.count;
        return name + " " + (args ? printArg$1(args) : "") + (typeof count === "number" ? " x" + count : "") + " " + targetName;
      }).join("\n");
    }
  }, {
    key: "lookupCommand",
    value: function CommandHandler_lookupCommand_(commandOrName, morph$$1) {
      var name, command;
      if (!commandOrName) return {};
      if (typeof commandOrName === "string") name = commandOrName;
      if (typeof commandOrName.command === "string") name = commandOrName.command;
      if (commandOrName.exec) {
        command = commandOrName;
        name = command.name;
      }
      if (!command) command = morph$$1.commands.find(function (ea) {
        return ea.name === name;
      });
      return {
        name: name,
        command: command
      };
    }
  }, {
    key: "exec",
    value: function CommandHandler_exec_(commandOrName, morph$$1, args, count, evt) {
      var _this = this;

      var _ref2 = this.lookupCommand(commandOrName, morph$$1) || {},
          name = _ref2.name,
          command = _ref2.command;

      if (!command) {
        console.warn("Cannot find command " + (name || commandOrName));
        return null;
      }
      name && this.addToHistory({
        name: name,
        target: {
          string: String(morph$$1),
          id: morph$$1.id
        },
        args: args,
        count: count,
        time: Date.now()
      });
      var world = morph$$1.world(),
          progressIndicator,
          result;
      if (typeof command.progressIndicator === "string") progressIndicator = LoadingIndicator.open(command.progressIndicator);
      if (typeof command.exec === "function") {
        try {
          result = command.exec(morph$$1, args, command.handlesCount ? count : undefined, evt);
        } catch (err) {
          result = err;
          var msg = "Error in interactive command " + name + ": " + (err.stack || err);
          world ? world.logError(msg) : console.error(msg);
        }
      } else {
        console.error("command " + name + " has no exec function!");
      }
      if (result && typeof result.catch === "function") {
        result.catch(function (err) {
          var msg = "Error in interactive command " + name + ": " + err + "\n" + (err.stack || err);
          world ? world.logError(msg) : console.error(msg);
          throw err;
        });
        progressIndicator && lively_lang.promise.finally(result, function () {
          return progressIndicator.remove();
        });
      } else {
        progressIndicator && progressIndicator.remove();
      }
      if (result && typeof count === "number" && count > 1 && !command.handlesCount) {
        result = typeof result.then === "function" ? result.then(function () {
          return _this.exec(command, morph$$1, args, count - 1, evt, null);
        }) : this.exec(command, morph$$1, args, count - 1, evt, null);
      }
      return result;
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 237,
    end: 3231
  });
}(undefined);

var simulateKeys = function () {
  var _ref = asyncToGenerator(regeneratorRuntime.mark(function _callee(morph$$1, keyComboString) {
    var keyInputState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      keyChain: undefined,
      count: undefined
    };

    var pressedKeys, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, keys;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            pressedKeys = keyComboString.length === 1 ? [keyComboString] : keyComboString.split(/ /g).map(ensureSpaces);
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _iteratorError = undefined;
            _context.prev = 4;
            _iterator = pressedKeys[Symbol.iterator]();

          case 6:
            if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
              _context.next = 13;
              break;
            }

            keys = _step.value;
            _context.next = 10;
            return simulateKey(morph$$1, keys, keyInputState);

          case 10:
            _iteratorNormalCompletion = true;
            _context.next = 6;
            break;

          case 13:
            _context.next = 19;
            break;

          case 15:
            _context.prev = 15;
            _context.t0 = _context["catch"](4);
            _didIteratorError = true;
            _iteratorError = _context.t0;

          case 19:
            _context.prev = 19;
            _context.prev = 20;

            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }

          case 22:
            _context.prev = 22;

            if (!_didIteratorError) {
              _context.next = 25;
              break;
            }

            throw _iteratorError;

          case 25:
            return _context.finish(22);

          case 26:
            return _context.finish(19);

          case 27:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this, [[4, 15, 19, 27], [20,, 22, 26]]);
  }));

  return function simulateKeys(_x2, _x3) {
    return _ref.apply(this, arguments);
  };
}();

function ensureSpaces(s) {
  return s.length ? s : " ";
}
function invokeKeyHandlers(morph$$1, evt) {
  var noInputEvents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  evt = Keys.canonicalizeEvent(evt);
  var _evt = evt,
      keyCombo = _evt.keyCombo,
      key = _evt.key,
      data = _evt.data,
      toExecute = void 0,
      executed = false,
      keyhandlers = morph$$1.keyhandlers,
      keyInputState = evt.keyInputState || {},
      isInputEvent = keyCombo.startsWith("input-"),
      nullCommand = false,
      carryOverCount = keyInputState.count,
      carryOverKeyChain = keyInputState.keyChain || "",
      keyInputStateNeedsUpdate = false;

  if (!keyhandlers || noInputEvents && isInputEvent) return false;
  for (var i = keyhandlers.length; i--;) {
    toExecute = keyhandlers[i].eventCommandLookup(morph$$1, evt);
    if (!toExecute || !toExecute.command) continue;
    var _toExecute = toExecute,
        command = _toExecute.command,
        args = _toExecute.args,
        passEvent = _toExecute.passEvent,
        _count = _toExecute.count,
        keyChain = _toExecute.keyChain,
        onlyWhenFocused = _toExecute.onlyWhenFocused;

    keyInputStateNeedsUpdate = true;
    carryOverCount = _count;
    carryOverKeyChain = keyChain;
    nullCommand = command === "null";
    if (onlyWhenFocused) {
      var world = morph$$1.world();
      if (world && world.focusedMorph && world.focusedMorph !== morph$$1) continue;
    }
    executed = nullCommand ? false : morph$$1.execCommand(command, args, _count, evt);
    if (executed && (!isInputEvent || command !== "insertstring") && !passEvent && typeof evt.stop === "function") evt.stop();
    if (executed || nullCommand) break;
  }
  if (!executed && !nullCommand && isInputEvent && morph$$1.onTextInput && !carryOverKeyChain) {
    var count = keyInputState.count;
    executed = morph$$1.execCommand("insertstring", {
      string: data || key,
      undoGroup: config.text.undoGroupDelay
    }, count, evt);
  }
  if (keyInputStateNeedsUpdate) {
    if (typeof evt.onAfterDispatch === "function") {
      evt.onAfterDispatch(function () {
        keyInputState.count = executed ? undefined : carryOverCount;
        keyInputState.keyChain = executed ? "" : carryOverKeyChain;
      });
    } else {
      keyInputState.count = executed ? undefined : carryOverCount;
      keyInputState.keyChain = executed ? "" : carryOverKeyChain;
    }
  }
  return executed && !nullCommand;
}

function simulateKey(morph$$1, keyComboString, keyInputState) {
  return invokeKeyHandlers(morph$$1, Object.assign({}, Keys.keyComboToEventSpec(keyComboString), { keyInputState: keyInputState }));
}
function bowserOS() {
  if (bowser.mac) return "mac";
  if (bowser.windows) return "windows";
  
  if (bowser.windowsphone) return "windowsphone";
  if (bowser.linux) return "linux";
  
  if (bowser.chromeos) return "chromeos";
  if (bowser.android) return "android";
  if (bowser.ios) return "ios";
  
  if (bowser.blackberry) return "blackberry";
  if (bowser.firefoxos) return "firefoxos";
  if (bowser.webos) return "webos";
  
  if (bowser.bada) return "bada";
  if (bowser.tizen) return "tizen";
  if (bowser.sailfish) return "sailfish";
  return "unknown";
}
function findKeysForPlatform(binding, platform) {
  if (typeof binding === "string") return binding;
  if (!binding || (typeof binding === "undefined" ? "undefined" : _typeof(binding)) !== "object") return null;
  switch (platform) {
    case "ios":
      return binding.ios || binding.mac;
    case "mac":
      return binding.mac || binding.ios;
    case "win":
    case "windows":
    case "windowsphone":
      return binding.win || binding.windows;
    case "linux":
      return binding.linux || binding.win || binding.windows;
    case "chromeos":
      return binding.chromeos || binding.linux || binding.win || binding.windows;
    case "android":
      return binding.android || binding.linux || binding.win || binding.windows;
    default:
      return binding.linux || binding.win || binding.windows;
  }
}
var regexps = {
  meta: /Meta|Cmd|Command/gi,
  alt: /Alt/gi,
  ctrl: /Ctrl|Control/gi,
  tab: /Tab/gi,
  enter: /Enter|Return/gi,
  shift: /Shift/gi,
  backspace: /Backspace/gi,
  delete: /del(ete)?/gi,
  left: /left/gi,
  right: /right/gi,
  up: /up/gi,
  down: /down/gi,
  keySpacer: /([^-])-/g,
  seqSpacer: /([^\s])\s/g
};
var KeyHandler = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("KeyHandler") && typeof __lively_classholder__.KeyHandler === "function" ? __lively_classholder__.KeyHandler : __lively_classholder__.KeyHandler = function KeyHandler(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function KeyHandler_initialize_() {
      var platform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : bowserOS();

      this.platform = platform;
      this.keyBindings = {};
    }
  }, {
    key: "eventCommandLookup",
    value: function KeyHandler_eventCommandLookup_(morph$$1, evt) {
      var keyCombo = evt.keyCombo,
          keyInputState = evt.keyInputState;

      return this.lookup(keyCombo, keyInputState);
    }
  }, {
    key: "lookup",
    value: function KeyHandler_lookup_(keyCombo) {
      var _this = this;

      var keyInputState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        keyChain: undefined,
        count: undefined
      };

      keyCombo = Keys.canonicalizeKeyCombo(keyCombo);
      var keyChain = keyInputState.keyChain || "",
          count = keyInputState.count;
      if (!keyChain && keyCombo.startsWith("Ctrl-")) {
        var countMatch = keyCombo.match(/^Ctrl-([0-9]+)/);
        if (countMatch) {
          var numArg = parseInt((typeof count === "number" ? count : "") + countMatch[1]);
          return {
            command: "null",
            count: numArg
          };
        }
        if (keyCombo === "Ctrl-U") return {
          command: "null",
          count: 4,
          keyChain: "Ctrl-U"
        };
      }
      var combos = [keyCombo];
      if (!command && keyCombo.startsWith("input-")) {
        var upper = keyCombo.replace(/^(input-)(.*)$/, function (_, before, key) {
          return before + key.toUpperCase();
        }),
            lower = keyCombo.replace(/^(input-)(.*)$/, function (_, before, key) {
          return before + key.toLowerCase();
        });
        combos.push(upper, lower);
      }
      var command = combos.map(function (keyCombo) {
        return _this.keyBindings[keyCombo];
      })[0];
      if (keyChain) {
        var chainCombo = combos.find(function (keyCombo) {
          return _this.keyBindings[keyChain + " " + keyCombo];
        });
        if (chainCombo) {
          keyChain += " " + chainCombo;
          command = this.keyBindings[keyChain] || command;
        }
      }
      if (command && command === "chainKeys") {
        keyChain = keyChain || keyCombo;
        var result = {
          command: "null",
          keyChain: keyChain
        };
        if (count !== undefined) result.count = count;
        return result;
      }
      if (!command) return undefined;
      var result = (typeof command === "undefined" ? "undefined" : _typeof(command)) === "object" ? Object.assign({}, command) : { command: command };
      if (count !== undefined) result.count = count;
      return result;
    }
  }, {
    key: "bindKey",
    value: function KeyHandler_bindKey_(keyCombo, command) {
      var _this2 = this;

      if ((typeof keyCombo === "undefined" ? "undefined" : _typeof(keyCombo)) == "object" && keyCombo && !Array.isArray(keyCombo)) keyCombo = findKeysForPlatform(keyCombo, this.platform);
      if (!keyCombo) return;
      if (typeof command == "function") return this.addCommand({
        exec: command,
        bindKey: keyCombo,
        name: command.name || keyCombo
      });
      var allCombos = Array.isArray(keyCombo) ? keyCombo : keyCombo.includes("|") ? keyCombo.split("|") : [keyCombo];
      allCombos.forEach(function (keyPart) {
        var chain$$1 = "";
        if (keyPart.indexOf(" ") != -1) {
          var parts = keyPart.split(/\s+/);
          keyPart = parts.pop();
          parts.forEach(function (keyPart) {
            var binding = Keys.canonicalizeKeyCombo(keyPart);
            chain$$1 += (chain$$1 ? " " : "") + binding;
            _this2.addCommandToBinding(chain$$1, "chainKeys");
          });
          chain$$1 += " ";
        }
        _this2.addCommandToBinding(chain$$1 + Keys.canonicalizeKeyCombo(keyPart), command);
      });
      this.cleanupUnusedKeyChains();
    }
  }, {
    key: "unbindKey",
    value: function KeyHandler_unbindKey_(keyCombo) {
      this.bindKey(keyCombo, null);
    }
  }, {
    key: "cleanupUnusedKeyChains",
    value: function KeyHandler_cleanupUnusedKeyChains_() {
      var _this3 = this;

      var keys = Object.keys(this.keyBindings),
          chainedKeys = keys.filter(function (key) {
        return _this3.keyBindings[key] === "chainKeys";
      });
      chainedKeys = lively_lang.arr.sortBy(chainedKeys, function (ea) {
        return ea.length;
      }).reverse();
      chainedKeys.forEach(function (key) {
        if (keys.some(function (other) {
          return key !== other && other.startsWith(key);
        })) return;
        delete _this3.keyBindings[key];
        lively_lang.arr.remove(keys, key);
        lively_lang.arr.remove(chainedKeys, key);
      });
    }
  }, {
    key: "addCommand",
    value: function KeyHandler_addCommand_(command) {
      return !command || !command.bindKey ? undefined : this.addCommandToBinding(command.bindKey, command);
    }
  }, {
    key: "addCommandToBinding",
    value: function KeyHandler_addCommandToBinding_(keyCombo, command) {
      var _this4 = this;

      var prev = this.keyBindings[keyCombo];
      if (prev === "chainKeys" && command != "chainKeys") {
        Object.keys(this.keyBindings).forEach(function (key) {
          if (key.startsWith(keyCombo)) delete _this4.keyBindings[key];
        });
      }
      if (!command) delete this.keyBindings[keyCombo];else this.keyBindings[keyCombo] = command;
      if (command !== "chainKeys") this.cleanupUnusedKeyChains();
    }
  }], [{
    key: "invokeKeyHandlers",
    value: function KeyHandler_invokeKeyHandlers_(morph$$1, evt) {
      var noInputEvents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      return invokeKeyHandlers(morph$$1, evt, noInputEvents);
    }
  }, {
    key: "simulateKeys",
    value: function KeyHandler_simulateKeys_(morph$$1, keyCombo, keyInputState) {
      return simulateKeys(morph$$1, keyCombo, keyInputState);
    }
  }, {
    key: "withBindings",
    value: function KeyHandler_withBindings_(listOfBindings, platform) {
      var handler = new this(platform);
      listOfBindings.forEach(function (_ref2) {
        var command = _ref2.command,
            keys = _ref2.keys;
        return handler.bindKey(keys, command);
      });
      return handler;
    }
  }, {
    key: "prettyCombo",
    value: function KeyHandler_prettyCombo_(combo) {
      var map = this._prettyCombos || (this._prettyCombos = {});
      if (this._prettyCombos[combo]) return map[combo];
      return map[combo] = combo.replace(regexps.meta, "\u2318").replace(regexps.alt, "\u2325").replace(regexps.ctrl, "\u2303").replace(regexps.tab, "\u21E5").replace(regexps.enter, "\u23CE").replace(regexps.shift, "\u21E7").replace(regexps.backspace, "\u232B").replace(regexps.delete, "\u2326").replace(regexps.left, "\u2192").replace(regexps.right, "\u2190").replace(regexps.up, "\u2191").replace(regexps.down, "\u2193").replace(regexps.keySpacer, "$1").replace(regexps.seqSpacer, "$1-");
    }
  }, {
    key: "generateCommandToKeybindingMap",
    value: function KeyHandler_generateCommandToKeybindingMap_(morph$$1) {
      var _this5 = this;

      var includeOwnerCommands = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var prettyKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      var keyMaps = {},
          commandsToKeys = {},
          commands = includeOwnerCommands ? morph$$1.commandsIncludingOwners : morph$$1.commands.map(function (command) {
        return {
          command: command,
          target: morph$$1
        };
      });
      return commands.map(function (_ref3) {
        var target = _ref3.target,
            command = _ref3.command;

        var keys = commandsToKeysFor(target)[command.name];
        return {
          keys: keys,
          target: target,
          command: command,
          prettyKeys: keys && prettyKeys ? keys.map(function (ea) {
            return _this5.prettyCombo(ea);
          }) : null
        };
      });
      function commandsToKeysFor(target) {
        if (commandsToKeys[target.id]) return commandsToKeys[target.id];
        var keyMap = keyMaps[target.id] || (keyMaps[target.id] = target.keyCommandMap);
        return commandsToKeys[target.id] = lively_lang.arr.groupBy(Object.keys(keyMap), function (combo) {
          return keyMap[combo].name;
        });
      }
    }
  }], __lively_classholder__, undefined, {
    start: 6204,
    end: 13073
  });
}(undefined);

var Script = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("Script") && typeof __lively_classholder__.Script === "function" ? __lively_classholder__.Script : __lively_classholder__.Script = function Script(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function Script_initialize_() {
      this.suspended = false;
      this.stopped = true;
      this.tickTime = null;
      this.type = null;
      this.currentTimeout = null;
    }
  }, {
    key: "__additionally_serialize__",
    value: function Script___additionally_serialize___(snapshot, ref, snapshotFn) {
      snapshot.props.suspended.value = true;
    }
  }, {
    key: "isScript",
    get: function get() {
      return true;
    }
  }, {
    key: "global",
    get: function get() {
      return System.global;
    }
  }, {
    key: "execute",
    value: function Script_execute_() {
      throw new Error("subclass responsibility");
    }
  }, {
    key: "tick",
    value: function Script_tick_() {
      try {
        this.execute();
      } catch (e) {
        console.error("Error executing script " + this + ": " + e + "\n" + e.stack);
        return;
      }
      if (!this.stopped) this.startTicking(this.tickTime);
    }
  }, {
    key: "startTicking",
    value: function Script_startTicking_(ms) {
      this.stopped = false;
      this.tickTime = ms;
      this.type = typeof ms === "number" ? "setTimeout" : "requestAnimationFrame";
      this.currentTimeout = this.type === "setTimeout" ? this.global.setTimeout(this.tick.bind(this), ms) : this.global.requestAnimationFrame(this.tick.bind(this));
    }
  }, {
    key: "stop",
    value: function Script_stop_() {
      var sel = this.type === "setTimeout" ? "clearTimeout" : "cancelAnimationFrame";
      this.global[sel](this.currentTimeout);
    }
  }, {
    key: "resume",
    value: function Script_resume_() {
      var ms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.tickTime;

      if (!this.suspended) return;
      this.suspended = false;
      this.startTicking(this.tickTime = ms);
    }
  }, {
    key: "suspend",
    value: function Script_suspend_() {
      this.stop();
      this.suspended = true;
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 0,
    end: 1315
  });
}(undefined);
var TargetScript = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("TargetScript") && typeof __lively_classholder__.TargetScript === "function" ? __lively_classholder__.TargetScript : __lively_classholder__.TargetScript = function TargetScript(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function TargetScript_initialize_(target, selector, args) {
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this);
      this.target = target;
      this.selector = selector;
      this.args = args || [];
    }
  }, {
    key: "execute",
    value: function TargetScript_execute_() {
      typeof this.target[this.selector] === "function" && this.target[this.selector].apply(this.target, this.args);
    }
  }, {
    key: "equals",
    value: function TargetScript_equals_(other) {
      return other.isScript && this.target == other.target && this.selector == other.selector;
    }
  }, {
    key: "toString",
    value: function TargetScript_toString_() {
      return "Script(" + this.target + ">>" + this.selector + "(" + this.args.join(",") + "))";
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 1317,
    end: 1861
  });
}(Script);
var FunctionScript = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("FunctionScript") && typeof __lively_classholder__.FunctionScript === "function" ? __lively_classholder__.FunctionScript : __lively_classholder__.FunctionScript = function FunctionScript(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function FunctionScript_initialize_(callback) {
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this);
      this.callback = callback;
    }
  }, {
    key: "execute",
    value: function FunctionScript_execute_() {
      this.callback();
    }
  }, {
    key: "equals",
    value: function FunctionScript_equals_(other) {
      return other.isScript && this.callback == other.callback;
    }
  }, {
    key: "toString",
    value: function FunctionScript_toString_() {
      return "Script(" + (this.callback.toString().replace(/\n/g, "").slice(0, 40) + "...") + ")";
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 1863,
    end: 2197
  });
}(Script);

function normalizeOptions(options) {
  options = Object.assign({ reinitializeIds: false }, options);
  if (options.reinitializeIds) options.reinitializeIds = typeof options.reinitializeIds === "function" ? options.reinitializeIds : function (id, ref) {
    return ref.realObj.isMorph ? newMorphId$$1(ref.realObj.constructor) : null;
  };
  return options;
}
function serializeMorph(m, options) {
  return lively_serializer2.serialize(m, normalizeOptions(options));
}
function deserializeMorph(idAndSnapshot, options) {
  return lively_serializer2.deserialize(idAndSnapshot, normalizeOptions(options));
}


function copyMorph(morph$$1) {
  return deserializeMorph(serializeMorph(morph$$1), { reinitializeIds: true });
}

var defaultCommandHandler = new CommandHandler();
function newMorphId$$1(classOrClassName) {
  var prefix = typeof classOrClassName === "function" ? classOrClassName.name : typeof classOrClassName === "string" ? classOrClassName.toLowerCase() : "";
  return prefix.replace(new RegExp("[$0-9]", "g"), "") + "_" + lively_lang.string.newUUID().replace(/-/g, "_");
}
var Morph$1 = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("Morph") && typeof __lively_classholder__.Morph === "function" ? __lively_classholder__.Morph : __lively_classholder__.Morph = function Morph$1(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function Morph_initialize_() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var env = props.env || MorphicEnv.default();
      this._env = env;
      this._rev = env.changeManager.revision;
      this._owner = null;
      this._dirty = true;
      this._rendering = false;
      this._submorphOrderChanged = false;
      this._id = newMorphId$$1(this.constructor.name);
      this._animationQueue = new AnimationQueue(this);
      this._cachedPaths = {};
      this._pathDependants = [];
      this._tickingScripts = [];
      this.initializeProperties;
      this.initializeProperties(props);
      if (props.bounds) this.setBounds(props.bounds);
      var dontAssign = ["env", "type", "submorphs", "bounds", "layout"],
          properties$$1 = this.propertiesAndPropertySettings().properties;
      for (var key in properties$$1) {
        dontAssign.push(key);
      }Object.assign(this, lively_lang.obj.dissoc(props, dontAssign));
      if (props.layout) this.layout = props.layout;
    }
  }, {
    key: "__serialization_id_property__",
    get: function get() {
      return "_id";
    }
  }, {
    key: "__deserialize__",
    value: function Morph___deserialize___(snapshot, objRef) {
      this._env = MorphicEnv.default();
      this._rev = snapshot.rev;
      this._owner = null;
      this._dirty = true;
      this._rendering = false;
      this._submorphOrderChanged = false;
      this._id = objRef.id;
      this._animationQueue = new AnimationQueue(this);
      this._cachedPaths = {};
      this._pathDependants = [];
      this._tickingScripts = [];
      this.initializeProperties();
    }
  }, {
    key: "__after_deserialize__",
    value: function Morph___after_deserialize___() {
      this.resumeStepping();
    }
  }, {
    key: "__only_serialize__",
    get: function get() {
      var defaults$$1 = this.defaultProperties;
      var properties$$1 = this.propertiesAndPropertySettings().properties;
      var propsToSerialize = ["_tickingScripts", "attributeConnections"];
      for (var key in properties$$1) {
        var descr = properties$$1[key];
        if (descr.readOnly || descr.derived || this[key] === defaults$$1[key]) continue;
        propsToSerialize.push(key);
      }
      return propsToSerialize;
    }
  }, {
    key: "isMorph",
    get: function get() {
      return true;
    }
  }, {
    key: "id",
    get: function get() {
      return this._id;
    }
  }, {
    key: "env",
    get: function get() {
      return this._env;
    }
  }, {
    key: "defaultProperties",
    get: function get() {
      if (!this.constructor._morphicDefaultPropertyValues) {
        var defaults$$1 = this.constructor._morphicDefaultPropertyValues = {},
            propDescriptors = this.propertiesAndPropertySettings().properties;
        for (var key in propDescriptors) {
          var descr = propDescriptors[key];
          if (descr.hasOwnProperty("defaultValue")) {
            var val = descr.defaultValue;
            if (Array.isArray(val)) val = val.slice();
            defaults$$1[key] = val;
          }
        }
      }
      return this.constructor._morphicDefaultPropertyValues;
    }
  }, {
    key: "defaultProperty",
    value: function Morph_defaultProperty_(key) {
      return this.defaultProperties[key];
    }
  }, {
    key: "getProperty",
    value: function Morph_getProperty_(key) {
      return this._morphicState[key];
    }
  }, {
    key: "setProperty",
    value: function Morph_setProperty_(key, value, meta) {
      return this.addValueChange(key, value, meta);
    }
  }, {
    key: "toString",
    value: function Morph_toString_() {
      return "<" + this.constructor.name + " - " + (this.name ? this.name : this.id) + ">";
    }
  }, {
    key: "edit",
    value: function Morph_edit_() {
      return this.env.world.execCommand("open object editor", { target: this });
    }
  }, {
    key: "livelyCustomInspect",
    value: function Morph_livelyCustomInspect_() {
      var _this = this;

      var properties$$1 = [],
          ignored = [],
          seen = {},
          wellKnown = Object.keys(this._morphicState);
      wellKnown.push("id", "owner");
      ignored.push("_id", "_owner");
      properties$$1.push.apply(properties$$1, toConsumableArray(wellKnown.map(function (key) {
        seen[key] = true;
        return {
          key: key,
          value: _this[key]
        };
      }).sort(function (a, b) {
        var aK = a.key.toLowerCase(),
            bK = b.key.toLowerCase();
        return aK < bK ? -1 : aK === bK ? 0 : 1;
      })));
      var morphInternals = ["attributeConnections", "_animationQueue", "_morphicState", "_dirty", "doNotCopyProperties", "doNotSerialize", "_env", "_cachedPaths", "_pathDependants", "_rendering", "_rev", "_submorphOrderChanged", "_tickingScripts", "_transform", "_invTransform", "layout"];
      if (this.attributeConnections) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this.attributeConnections[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var c = _step.value;

            ignored.push("$$" + c.sourceAttrName, "" + c.sourceAttrName);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = ignored[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var ignore = _step2.value;

          seen[ignore] = true;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = morphInternals[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var _key = _step3.value;

          if (!(_key in this)) continue;
          seen[_key] = true;
          properties$$1.push({
            key: _key,
            value: this[_key],
            keyString: "[internal] " + _key
          });
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      for (var key in this) {
        if (seen[key] || !this.hasOwnProperty(key)) continue;
        properties$$1.unshift({
          key: key,
          value: this[key],
          keyString: "[UNKNOWN PROPERTY] " + key
        });
      }
      return {
        sort: false,
        includeDefault: false,
        properties: properties$$1
      };
    }
  }, {
    key: "show",
    value: function Morph_show_() {
      return show$$1(this);
    }
  }, {
    key: "setStatusMessage",
    value: function Morph_setStatusMessage_(msg, color, delay, opts) {
      var w = this.world();
      opts = Object.assign({ maxLines: 7 }, opts);
      return w ? w.setStatusMessageFor(this, msg, color, delay, opts) : console.log(msg);
    }
  }, {
    key: "showError",
    value: function Morph_showError_(err) {
      var w = this.world();
      return w ? w.showErrorFor(this, err) : console.error(err);
    }
  }, {
    key: "onChange",
    value: function Morph_onChange_(change) {
      var anim = change.meta && change.meta.animation;
      if (["position", "rotation", "scale", "origin", "reactsToPointer"].includes(change.prop)) this.updateTransform(defineProperty({}, change.prop, change.value));
      if (change.prop == "layout") {
        if (anim) {
          change.value && change.value.attachAnimated(anim.duration, this, anim.easing);
        } else {
          change.value && change.value.apply();
        }
      }
      this.layout && this.layout.onChange(change);
      this.styleRules && this.styleRules.onMorphChange(this, change);
    }
  }, {
    key: "onSubmorphChange",
    value: function Morph_onSubmorphChange_(change, submorph) {
      this.layout && this.layout.onSubmorphChange(submorph, change);
      this.styleRules && this.styleRules.onMorphChange(submorph, change);
    }
  }, {
    key: "changes",
    get: function get() {
      return this.env.changeManager.changesFor(this);
    }
  }, {
    key: "applyChange",
    value: function Morph_applyChange_(change) {
      this.env.changeManager.apply(this, change);
    }
  }, {
    key: "addValueChange",
    value: function Morph_addValueChange_(prop, value, meta) {
      return this.env.changeManager.addValueChange(this, prop, value, meta);
    }
  }, {
    key: "addMethodCallChangeDoing",
    value: function Morph_addMethodCallChangeDoing_(spec, doFn) {
      return this.env.changeManager.addMethodCallChangeDoing(spec, this, doFn);
    }
  }, {
    key: "groupChangesWhile",
    value: function Morph_groupChangesWhile_(groupChange, whileFn) {
      return this.env.changeManager.groupChangesWhile(this, groupChange, whileFn);
    }
  }, {
    key: "dontRecordChangesWhile",
    value: function Morph_dontRecordChangesWhile_(whileFn) {
      return this.env.changeManager.dontRecordChangesWhile(this, whileFn);
    }
  }, {
    key: "recordChangesWhile",
    value: function Morph_recordChangesWhile_(whileFn, optFilter) {
      return this.env.changeManager.recordChangesWhile(whileFn, optFilter);
    }
  }, {
    key: "recordChangesStart",
    value: function Morph_recordChangesStart_(optFilter) {
      return this.env.changeManager.recordChangesStartForMorph(this, optFilter);
    }
  }, {
    key: "recordChangesStop",
    value: function Morph_recordChangesStop_(id) {
      return this.env.changeManager.recordChangesStopForMorph(this, id);
    }
  }, {
    key: "withMetaDo",
    value: function Morph_withMetaDo_(meta, doFn) {
      return this.env.changeManager.doWithValueChangeMeta(meta, this, doFn);
    }
  }, {
    key: "undoStart",
    value: function Morph_undoStart_(name) {
      return this.env.undoManager.undoStart(this, name);
    }
  }, {
    key: "undoStop",
    value: function Morph_undoStop_(name) {
      return this.env.undoManager.undoStop(this, name);
    }
  }, {
    key: "undoInProgress",
    get: function get() {
      return this.env.undoManager.undoInProgress;
    }
  }, {
    key: "animate",
    value: function () {
      var _ref = asyncToGenerator(regeneratorRuntime.mark(function _callee(config$$1) {
        var anim;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                anim = this._animationQueue.registerAnimation(config$$1);

                if (this._animationQueue.animationsActive) {
                  _context.next = 4;
                  break;
                }

                anim && anim.finish();
                return _context.abrupt("return", this);

              case 4:
                return _context.abrupt("return", anim ? anim.asPromise() : this);

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function Morph_animate_(_x2) {
        return _ref.apply(this, arguments);
      }

      return Morph_animate_;
    }()
  }, {
    key: "isClip",
    value: function Morph_isClip_() {
      return this.clipMode !== "visible";
    }
  }, {
    key: "scrollExtent",
    get: function get() {
      return (this.submorphs.length ? this.innerBounds().union(this.submorphBounds()) : this.innerBounds()).extent();
    }
  }, {
    key: "scrollDown",
    value: function Morph_scrollDown_(n) {
      this.scroll = this.scroll.addXY(0, n);
    }
  }, {
    key: "scrollUp",
    value: function Morph_scrollUp_(n) {
      this.scrollDown(-n);
    }
  }, {
    key: "scrollLeft",
    value: function Morph_scrollLeft_(n) {
      this.scroll = this.scroll.addXY(n, 0);
    }
  }, {
    key: "scrollRight",
    value: function Morph_scrollRight_(n) {
      this.scrollLeft(-n);
    }
  }, {
    key: "scrollPageDown",
    value: function Morph_scrollPageDown_(n) {
      this.scrollDown(this.height);
    }
  }, {
    key: "scrollPageUp",
    value: function Morph_scrollPageUp_(n) {
      this.scrollUp(this.height);
    }
  }, {
    key: "addStyleClass",
    value: function Morph_addStyleClass_(className) {
      this.styleClasses = lively_lang.arr.uniq(this.styleClasses.concat(className));
    }
  }, {
    key: "removeStyleClass",
    value: function Morph_removeStyleClass_(className) {
      this.styleClasses = this.styleClasses.filter(function (ea) {
        return ea != className;
      });
    }
  }, {
    key: "adjustOrigin",
    value: function Morph_adjustOrigin_(newOrigin) {
      var oldOrigin = this.origin,
          oldPos = this.globalBounds().topLeft();
      this.origin = newOrigin;
      this.submorphs.forEach(function (m) {
        return m.position = m.position.subPt(newOrigin.subPt(oldOrigin));
      });
      var newPos = this.globalBounds().topLeft(),
          globalDelta = oldPos.subPt(newPos);
      this.globalPosition = this.globalPosition.addPt(globalDelta);
    }
  }, {
    key: "setBounds",
    value: function Morph_setBounds_(bounds) {
      this.position = bounds.topLeft().addPt(this.origin);
      this.extent = bounds.extent();
    }
  }, {
    key: "innerBounds",
    value: function Morph_innerBounds_() {
      var _extent = this.extent,
          w = _extent.x,
          h$$1 = _extent.y;

      return lively_graphics.rect(0, 0, w, h$$1);
    }
  }, {
    key: "relativeBounds",
    value: function Morph_relativeBounds_(other) {
      var other = other || this.world(),
          bounds = this.origin.negated().extent(this.extent);
      if (other) {
        bounds = this.transformRectToMorph(other, bounds);
      } else {
        bounds = this.getGlobalTransform().transformRectToRect(bounds);
      }
      if (!this.isClip()) {
        this.submorphs.forEach(function (submorph) {
          bounds = bounds.union(submorph.relativeBounds(other));
        });
      }
      return bounds;
    }
  }, {
    key: "bounds",
    value: function Morph_bounds_() {
      return this.relativeBounds(this.owner);
    }
  }, {
    key: "globalBounds",
    value: function Morph_globalBounds_() {
      return this.relativeBounds(this.world());
    }
  }, {
    key: "submorphBounds",
    value: function Morph_submorphBounds_() {
      return this.submorphs.map(function (submorph) {
        return submorph.bounds();
      }).reduce(function (a, b) {
        return a.union(b);
      });
    }
  }, {
    key: "align",
    value: function Morph_align_(p1, p2) {
      return this.moveBy(p2.subPt(p1));
    }
  }, {
    key: "moveBy",
    value: function Morph_moveBy_(delta) {
      this.position = this.position.addPt(delta);
    }
  }, {
    key: "rotateBy",
    value: function Morph_rotateBy_(delta) {
      this.rotation += delta;
    }
  }, {
    key: "resizeBy",
    value: function Morph_resizeBy_(delta) {
      this.extent = this.extent.addPt(delta);
    }
  }, {
    key: "width",
    get: function get() {
      return this.extent.x;
    }
  }, {
    key: "width",
    set: function set(v) {
      return this.extent = lively_graphics.pt(v, this.extent.y);
    }
  }, {
    key: "height",
    get: function get() {
      return this.extent.y;
    }
  }, {
    key: "height",
    set: function set(v) {
      return this.extent = lively_graphics.pt(this.extent.x, v);
    }
  }, {
    key: "left",
    get: function get() {
      return this.bounds().left();
    }
  }, {
    key: "left",
    set: function set(v) {
      return this.moveBy(lively_graphics.pt(v - this.left), 0);
    }
  }, {
    key: "right",
    get: function get() {
      return this.bounds().right();
    }
  }, {
    key: "right",
    set: function set(v) {
      return this.moveBy(lively_graphics.pt(v - this.right), 0);
    }
  }, {
    key: "top",
    get: function get() {
      return this.bounds().top();
    }
  }, {
    key: "top",
    set: function set(v) {
      return this.moveBy(lively_graphics.pt(0, v - this.top));
    }
  }, {
    key: "bottom",
    get: function get() {
      return this.bounds().bottom();
    }
  }, {
    key: "bottom",
    set: function set(v) {
      return this.moveBy(lively_graphics.pt(0, v - this.bottom));
    }
  }, {
    key: "center",
    get: function get() {
      return this.bounds().center();
    }
  }, {
    key: "center",
    set: function set(v) {
      return this.align(this.center, v);
    }
  }, {
    key: "topLeft",
    get: function get() {
      return this.bounds().topLeft();
    }
  }, {
    key: "topLeft",
    set: function set(v) {
      return this.align(this.topLeft, v);
    }
  }, {
    key: "topRight",
    get: function get() {
      return this.bounds().topRight();
    }
  }, {
    key: "topRight",
    set: function set(v) {
      return this.align(this.topRight, v);
    }
  }, {
    key: "bottomRight",
    get: function get() {
      return this.bounds().bottomRight();
    }
  }, {
    key: "bottomRight",
    set: function set(v) {
      return this.align(this.bottomRight, v);
    }
  }, {
    key: "bottomLeft",
    get: function get() {
      return this.bounds().bottomLeft();
    }
  }, {
    key: "bottomLeft",
    set: function set(v) {
      return this.align(this.bottomLeft, v);
    }
  }, {
    key: "bottomCenter",
    get: function get() {
      return this.bounds().bottomCenter();
    }
  }, {
    key: "bottomCenter",
    set: function set(v) {
      return this.align(this.bottomCenter, v);
    }
  }, {
    key: "topCenter",
    get: function get() {
      return this.bounds().topCenter();
    }
  }, {
    key: "topCenter",
    set: function set(v) {
      return this.align(this.topCenter, v);
    }
  }, {
    key: "leftCenter",
    get: function get() {
      return this.bounds().leftCenter();
    }
  }, {
    key: "leftCenter",
    set: function set(v) {
      return this.align(this.leftCenter, v);
    }
  }, {
    key: "rightCenter",
    get: function get() {
      return this.bounds().rightCenter();
    }
  }, {
    key: "rightCenter",
    set: function set(v) {
      return this.align(this.rightCenter, v);
    }
  }, {
    key: "isEpiMorph",
    get: function get() {
      return this.getProperty("epiMorph");
    }
  }, {
    key: "isUsedAsEpiMorph",
    value: function Morph_isUsedAsEpiMorph_() {
      var m = this;
      while (m) {
        if (m.isEpiMorph) return true;
        m = m.owner;
      }
      return false;
    }
  }, {
    key: "replaceWith",
    value: function Morph_replaceWith_(other, indexForOtherMorph) {
      if (this === other || !other) return this;
      if (this === other.owner) {
        other.replaceWith(this);
        return this;
      }
      var myOwner = this.owner,
          mySubmorphs = this.submorphs,
          myTfm = this.getTransform().copy(),
          myIndex = typeof indexForOtherMorph === "number" ? indexForOtherMorph : myOwner ? myOwner.submorphs.indexOf(this) : -1,
          otherOwner = other.owner,
          otherSubmorphs = lively_lang.arr.without(other.submorphs, this),
          otherTfm = other.getTransform().copy(),
          otherIndex = otherOwner ? otherOwner.submorphs.indexOf(other) : -1;
      myOwner && this.remove();
      otherOwner && other.remove();
      this.submorphs = [];
      other.submorphs = [];
      if (myOwner === other) {
        otherOwner && otherOwner.addMorphAt(this, otherIndex);
        this.submorphs = otherSubmorphs.slice(0, myIndex).concat(other).concat(otherSubmorphs.slice(myIndex));
        other.submorphs = mySubmorphs;
      } else {
        myOwner && myOwner.addMorphAt(other, myIndex);
        otherOwner && otherOwner.addMorphAt(this, otherIndex);
        other.submorphs = mySubmorphs;
        this.submorphs = otherSubmorphs;
      }
      other.setTransform(myTfm);
      this.setTransform(otherTfm);
      return this;
    }
  }, {
    key: "addMorphAt",
    value: function Morph_addMorphAt_(submorph, index) {
      var _this2 = this;

      if (!submorph || (typeof submorph === "undefined" ? "undefined" : _typeof(submorph)) !== "object") throw new Error(submorph + " cannot be added as a submorph to " + this);
      if (submorph.isMorph) {
        if (submorph.isAncestorOf(this)) {
          this.env.world.logError(new Error("addMorph: Circular relationships between morphs not allowed\ntried to add " + submorph + " to " + this));
          return null;
        }
        if (submorph === this) {
          this.env.world.logError(new Error("addMorph: Trying to add itself as a submorph: " + this));
          return null;
        }
      }
      if (!submorph.isMorph) submorph = morph$1(submorph);
      var existingIndex = this.submorphs.indexOf(submorph);
      if (existingIndex > -1 && existingIndex === index) return;
      this.addMethodCallChangeDoing({
        target: this,
        selector: "addMorphAt",
        args: [submorph, index],
        undo: {
          target: this,
          selector: "removeMorph",
          args: [submorph]
        }
      }, function () {
        var prevOwner = submorph.owner,
            submorphs = _this2.submorphs,
            tfm;
        if (prevOwner && prevOwner !== _this2) {
          tfm = submorph.transformForNewOwner(_this2);
          submorph.remove();
        }
        if (submorph._env !== _this2._env) submorph._env = _this2._env;
        index = Math.min(submorphs.length, Math.max(0, index));
        if (existingIndex > -1) {
          submorphs.splice(existingIndex, 1);
          if (existingIndex < index) index--;
        }
        submorphs.splice(index, 0, submorph);
        submorph._owner = _this2;
        submorph._cachedPaths = {};
        if (tfm) submorph.setTransform(tfm);
        _this2._morphicState["submorphs"] = submorphs;
        _this2._submorphOrderChanged = true;
        _this2.makeDirty();
        submorph.resumeSteppingAll();
      });
      return submorph;
    }
  }, {
    key: "addMorph",
    value: function Morph_addMorph_(submorph, insertBeforeMorph) {
      var submorphs = this.submorphs,
          insertBeforeMorphIndex = insertBeforeMorph ? submorphs.indexOf(insertBeforeMorph) : -1,
          insertionIndex = insertBeforeMorphIndex === -1 ? submorphs.length : insertBeforeMorphIndex;
      return this.addMorphAt(submorph, insertionIndex);
    }
  }, {
    key: "addMorphBack",
    value: function Morph_addMorphBack_(other) {
      var next = other === this.submorphs[0] ? this.submorphs[1] : this.submorphs[0];
      return this.addMorph(other, next);
    }
  }, {
    key: "removeMorph",
    value: function Morph_removeMorph_(morph$$1) {
      var index = this.submorphs.indexOf(morph$$1);
      if (index === -1) return;
      var submorphs = this.getProperty("submorphs") || [];
      submorphs.splice(index, 1);
      this.addMethodCallChangeDoing({
        target: this,
        selector: "removeMorph",
        args: [morph$$1],
        undo: {
          target: this,
          selector: "addMorphAt",
          args: [morph$$1, index]
        }
      }, function () {
        morph$$1.suspendSteppingAll();
        morph$$1._owner = null;
      });
    }
  }, {
    key: "remove",
    value: function Morph_remove_() {
      if (this.owner) this.owner.removeMorph(this);
      this._cachedPaths = {};
      this._pathDependants.forEach(function (dep) {
        return dep._cachedPaths = {};
      });
      this._pathDependants = [];
      return this;
    }
  }, {
    key: "fadeOut",
    value: function () {
      var _ref2 = asyncToGenerator(regeneratorRuntime.mark(function _callee2() {
        var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.animate({
                  opacity: 0,
                  duration: duration,
                  easing: "easeOut"
                });

              case 2:
                this.remove();
                this.opacity = 1;

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function Morph_fadeOut_() {
        return _ref2.apply(this, arguments);
      }

      return Morph_fadeOut_;
    }()
  }, {
    key: "fadeIn",
    value: function () {
      var _ref3 = asyncToGenerator(regeneratorRuntime.mark(function _callee3() {
        var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                this.opacity = 0;
                this.animate({
                  opacity: 1,
                  duration: duration
                });
                return _context3.abrupt("return", this);

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function Morph_fadeIn_() {
        return _ref3.apply(this, arguments);
      }

      return Morph_fadeIn_;
    }()
  }, {
    key: "fadeIntoWorld",
    value: function () {
      var _ref4 = asyncToGenerator(regeneratorRuntime.mark(function _callee4(pos) {
        var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 300;
        var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.innerBounds().topCenter();
        var w, world;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                w = new Morph$1({
                  extent: this.extent,
                  opacity: 0,
                  scale: 0,
                  fill: lively_graphics.Color.transparent,
                  submorphs: [this]
                }), world = this.env.world;

                w.openInWorldNearHand();
                w.adjustOrigin(origin);
                w.position = pos || world.visibleBounds().center();
                _context4.next = 6;
                return w.animate({
                  opacity: 1,
                  scale: 1,
                  duration: duration
                });

              case 6:
                world.addMorph(this);
                w.remove();
                return _context4.abrupt("return", this);

              case 9:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function Morph_fadeIntoWorld_(_x5) {
        return _ref4.apply(this, arguments);
      }

      return Morph_fadeIntoWorld_;
    }()
  }, {
    key: "removeAllMorphs",
    value: function Morph_removeAllMorphs_() {
      this.submorphs = [];
    }
  }, {
    key: "bringToFront",
    value: function Morph_bringToFront_() {
      if (this.owner && lively_lang.arr.last(this.owner.submorphs) !== this) this.owner.addMorph(this);
      return this;
    }
  }, {
    key: "owner",
    get: function get() {
      return this._owner;
    }
  }, {
    key: "withAllSubmorphsDetect",
    value: function Morph_withAllSubmorphsDetect_(testerFunc) {
      if (testerFunc(this)) return this;
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = this.submorphs[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var m = _step4.value;

          var found = m.withAllSubmorphsDetect(testerFunc);
          if (found) return found;
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return undefined;
    }
  }, {
    key: "withAllSubmorphsDo",
    value: function Morph_withAllSubmorphsDo_(func) {
      var result = [func(this)];
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = this.submorphs[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var m = _step5.value;

          lively_lang.arr.pushAll(result, m.withAllSubmorphsDo(func));
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      return result;
    }
  }, {
    key: "withAllSubmorphsSelect",
    value: function Morph_withAllSubmorphsSelect_(testerFunc) {
      var result = [];
      this.withAllSubmorphsDo(function (m) {
        return testerFunc(m) && result.push(m);
      });
      return result;
    }
  }, {
    key: "ownerChain",
    value: function Morph_ownerChain_() {
      return this.owner ? [this.owner].concat(this.owner.ownerChain()) : [];
    }
  }, {
    key: "world",
    value: function Morph_world_() {
      return this.owner ? this.owner.world() : null;
    }
  }, {
    key: "getWindow",
    value: function Morph_getWindow_() {
      return this.isWindow ? this : this.ownerChain().find(function (_ref5) {
        var isWindow = _ref5.isWindow;
        return isWindow;
      });
    }
  }, {
    key: "openInWorldNear",
    value: function Morph_openInWorldNear_(pos, optWorld) {
      var world = optWorld || this.world() || this.env.world;
      if (!world) return;
      this.center = pos;
      this.setBounds(world.visibleBounds().translateForInclusion(this.bounds()));
      return this.openInWorld(this.position);
    }
  }, {
    key: "openInWorldNearHand",
    value: function Morph_openInWorldNearHand_(optWorld) {
      var world = optWorld || this.world() || this.env.world,
          pos = world.firstHand ? world.firstHand.position : lively_graphics.pt(0, 0);
      return world ? this.openInWorldNear(pos) : undefined;
    }
  }, {
    key: "openInWorld",
    value: function Morph_openInWorld_(pos, optWorld) {
      var world = optWorld || this.world() || this.env.world;
      if (!world) {
        console.warn("Cannot open morph " + this + ", world morph not found;");
        return this;
      }
      world.addMorph(this);
      if (pos) this.position = pos;else this.center = world.visibleBounds().center();
      return this;
    }
  }, {
    key: "openInWindow",
    value: function Morph_openInWindow_() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        title: this.name,
        name: "window for " + this.name,
        world: null
      };

      var world = opts.world || this.world() || this.env.world;
      return world.openInWindow(this, lively_lang.obj.dissoc(opts, ["world"]));
    }
  }, {
    key: "isAncestorOf",
    value: function Morph_isAncestorOf_(aMorph) {
      var owner = aMorph.owner;
      while (owner) {
        if (owner === this) return true;
        owner = owner.owner;
      }
      return false;
    }
  }, {
    key: "morphsContainingPoint",
    value: function Morph_morphsContainingPoint_(point, list) {
      if (!list) list = [];
      if (!this.fullContainsWorldPoint(point)) return list;
      for (var i = this.submorphs.length - 1; i >= 0; i--) {
        this.submorphs[i].morphsContainingPoint(point, list);
      }if (this.innerBoundsContainsWorldPoint(point)) list.push(this);
      return list;
    }
  }, {
    key: "morphBeneath",
    value: function Morph_morphBeneath_(pos) {
      var someOwner = this.world() || this.owner;
      if (!someOwner) return null;
      var morphs = someOwner.morphsContainingPoint(pos),
          myIdx = morphs.indexOf(this),
          morphBeneath = morphs[myIdx + 1];
      return morphBeneath;
    }
  }, {
    key: "transformTillMorph",
    value: function Morph_transformTillMorph_(other) {
      var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "up";

      if (direction == "down") return other.transformTillMorph(this, "up").inverse();
      var tfm = new lively_graphics.Transform();
      for (var morph$$1 = this; morph$$1 != other && morph$$1 != undefined; morph$$1 = morph$$1.owner) {
        tfm.preConcatenate(new lively_graphics.Transform(morph$$1.origin)).preConcatenate(morph$$1.getTransform());
      }
      return tfm;
    }
  }, {
    key: "localize",
    value: function Morph_localize_(p) {
      var world = this.world(),
          x = p.x,
          y = p.y;
      return world ? world.transformPointToMorph(this, lively_graphics.pt(x, y)) : p;
    }
  }, {
    key: "worldPoint",
    value: function Morph_worldPoint_(p) {
      var world = this.world(),
          x = p.x,
          y = p.y;
      return world ? this.transformPointToMorph(world, lively_graphics.pt(x, y)) : p;
    }
  }, {
    key: "transformToMorph",
    value: function Morph_transformToMorph_(other) {
      var tfm = this.getGlobalTransform(),
          inv = other.getGlobalTransform().inverse();
      tfm.preConcatenate(inv);
      return tfm;
    }
  }, {
    key: "transformPointToMorph",
    value: function Morph_transformPointToMorph_(other, p) {
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = this.pathToMorph(other)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var _step6$value = slicedToArray(_step6.value, 2),
              d = _step6$value[0],
              m = _step6$value[1];

          if (this != m && d == "up") {
            p.x -= m.scroll.x;
            p.y -= m.scroll.y;
          }
          this.applyTransform(d, m, p);
          if (this != m && d == "down") {
            p.x += m.scroll.x;
            p.y += m.scroll.y;
          }
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      return p;
    }
  }, {
    key: "transformRectToMorph",
    value: function Morph_transformRectToMorph_(other, r) {
      var _this3 = this;

      var tl, tr, br, bl;
      [tl = r.topLeft(), tr = r.topRight(), br = r.bottomRight(), bl = r.bottomLeft()].forEach(function (corner) {
        _this3.transformPointToMorph(other, corner);
      });
      return lively_graphics.Rectangle.unionPts([tl, tr, br, bl]);
    }
  }, {
    key: "applyTransform",
    value: function Morph_applyTransform_(d, m, p) {
      if (d == "up") {
        p.x += m.origin.x;
        p.y += m.origin.y;
        p.matrixTransform(m.getTransform(), p);
      } else {
        p.matrixTransform(m.getInverseTransform(), p);
        p.x -= m.origin.x;
        p.y -= m.origin.y;
      }
    }
  }, {
    key: "_addPathDependant",
    value: function Morph__addPathDependant_(morph$$1) {
      if (!this._pathDependants.includes(morph$$1)) this._pathDependants.push(morph$$1);
    }
  }, {
    key: "pathToMorph",
    value: function Morph_pathToMorph_(other) {
      var path;
      if (path = this._cachedPaths[other.id]) return path;
      var commonRoot = this.closestCommonAncestor(other) || this,
          morph$$1 = this,
          down = [],
          up = [];
      commonRoot._addPathDependant(this);
      while (morph$$1 && morph$$1 != commonRoot) {
        up.push(["up", morph$$1]);
        morph$$1._addPathDependant(this);
        morph$$1 = morph$$1.owner;
      }
      morph$$1 = other;
      while (morph$$1 && morph$$1 != commonRoot) {
        down.push(["down", morph$$1]);
        morph$$1._addPathDependant(this);
        morph$$1 = morph$$1.owner;
      }
      this._cachedPaths[other.id] = path = [].concat(up, toConsumableArray(down.reverse()));
      return path;
    }
  }, {
    key: "closestCommonAncestor",
    value: function Morph_closestCommonAncestor_(other) {
      return lively_lang.arr.intersect([this].concat(toConsumableArray(this.ownerChain())), [other].concat(toConsumableArray(other.ownerChain())))[0];
    }
  }, {
    key: "transformForNewOwner",
    value: function Morph_transformForNewOwner_(newOwner) {
      return new lively_graphics.Transform(this.transformToMorph(newOwner));
    }
  }, {
    key: "localizePointFrom",
    value: function Morph_localizePointFrom_(pt$$1, otherMorph) {
      try {
        return pt$$1.matrixTransform(otherMorph.transformToMorph(this));
      } catch (er) {
        console.warn("problem " + er + " in localizePointFrom");
        return pt$$1;
      }
    }
  }, {
    key: "getGlobalTransform",
    value: function Morph_getGlobalTransform_() {
      return this.transformTillMorph(this.world());
    }
  }, {
    key: "globalPosition",
    get: function get() {
      return this.worldPoint(lively_graphics.pt(0, 0));
    }
  }, {
    key: "globalPosition",
    set: function set(p) {
      return this.position = this.owner ? this.owner.localize(p) : p;
    }
  }, {
    key: "getTransform",
    value: function Morph_getTransform_() {
      if (!this._transform) this.updateTransform();
      return this._transform;
    }
  }, {
    key: "getInverseTransform",
    value: function Morph_getInverseTransform_() {
      if (!this._invTransform) this.updateTransform();
      return this._invTransform;
    }
  }, {
    key: "updateTransform",
    value: function Morph_updateTransform_() {
      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          position = _ref6.position,
          scale = _ref6.scale,
          origin = _ref6.origin,
          rotation = _ref6.rotation;

      var tfm = this._transform || new lively_graphics.Transform(),
          tfm_inv = this._invTransform || new lively_graphics.Transform();
      position = position || this.position;
      origin = origin || this.origin;
      scale = scale || this.scale;
      rotation = rotation || this.rotation;
      tfm.a = scale * Math.cos(rotation);
      tfm.b = scale * Math.sin(rotation);
      tfm.c = scale * -Math.sin(rotation);
      tfm.d = scale * Math.cos(rotation);
      tfm.e = tfm.a * -origin.x + tfm.c * -origin.y + position.x;
      tfm.f = tfm.b * -origin.x + tfm.d * -origin.y + position.y;
      var a = tfm.a,
          b = tfm.b,
          c = tfm.c,
          d = tfm.d,
          e = tfm.e,
          f = tfm.f,
          det = a * d - c * b,
          invdet = 1 / det;

      tfm_inv.a = d * invdet;
      tfm_inv.b = -b * invdet;
      tfm_inv.c = -c * invdet;
      tfm_inv.d = a * invdet;
      tfm_inv.e = (c * f - e * d) * invdet;
      tfm_inv.f = -(a * f - b * e) * invdet;
      this._transform = tfm;
      this._invTransform = tfm_inv;
    }
  }, {
    key: "setTransform",
    value: function Morph_setTransform_(tfm) {
      this.position = tfm.getTranslation();
      this.rotation = lively_lang.num.toRadians(tfm.getRotation());
      this.scale = tfm.getScalePoint().x;
      this.updateTransform(this);
    }
  }, {
    key: "fullContainsWorldPoint",
    value: function Morph_fullContainsWorldPoint_(p) {
      return this.fullContainsPoint(this.owner == null ? p : this.owner.localize(p));
    }
  }, {
    key: "fullContainsPoint",
    value: function Morph_fullContainsPoint_(p) {
      return this.bounds().containsPoint(p);
    }
  }, {
    key: "innerBoundsContainsWorldPoint",
    value: function Morph_innerBoundsContainsWorldPoint_(p) {
      return this.innerBoundsContainsPoint(this.owner == null ? p : this.localize(p));
    }
  }, {
    key: "innerBoundsContainsPoint",
    value: function Morph_innerBoundsContainsPoint_(p) {
      return this.innerBounds().containsPoint(p.addPt(this.origin));
    }
  }, {
    key: "get",
    value: function Morph_get_(name) {
      if (!name) return null;
      try {
        return this.getSubmorphNamed(name) || this.getNameTest(this, name) && this || this.getOwnerOrOwnerSubmorphNamed(name);
      } catch (e) {
        if (e.constructor == RangeError && e.message == "Maximum call stack size exceeded") {
          throw new Error("'get' failed due to a stack overflow. The most\n" + "likely source of the problem is using 'get' as part of\n" + "toString, because 'get' calls 'getOwnerOrOwnerSubmorphNamed', which\n" + "calls 'toString' on this. Try using 'getSubmorphNamed' instead,\n" + "which only searches in this' children.\nOriginal error:\n" + e.stack);
        }
        throw e;
      }
    }
  }, {
    key: "getNameTest",
    value: function Morph_getNameTest_(morph$$1, expectedName) {
      var isRe = lively_lang.obj.isRegExp(expectedName);
      if (isRe) {
        if (expectedName.test(morph$$1.name) || expectedName.test(String(morph$$1))) return true;
      } else {
        if (morph$$1.name === expectedName || String(morph$$1) === expectedName) return true;
      }
      return false;
    }
  }, {
    key: "getSubmorphNamed",
    value: function Morph_getSubmorphNamed_(name) {
      if (!this._morphicState || !this.submorphs.length) return null;
      var isRe = lively_lang.obj.isRegExp(name);
      for (var i = 0; i < this.submorphs.length; i++) {
        var _morph = this.submorphs[i];
        if (this.getNameTest(_morph, name)) return _morph;
      }
      for (var _i = 0; _i < this.submorphs.length; _i++) {
        var _morph2 = this.submorphs[_i].getSubmorphNamed(name);
        if (_morph2) return _morph2;
      }
      return null;
    }
  }, {
    key: "getOwnerNamed",
    value: function Morph_getOwnerNamed_(name) {
      return this.ownerChain().find(function (ea) {
        return ea.name === name;
      });
    }
  }, {
    key: "getOwnerOrOwnerSubmorphNamed",
    value: function Morph_getOwnerOrOwnerSubmorphNamed_(name) {
      var owner = this.owner;
      if (!owner) return null;
      if (owner.name === name) return owner;
      for (var i = 0; i < owner.submorphs.length; i++) {
        var morph$$1 = owner.submorphs[i];
        if (morph$$1 === this) continue;
        if (this.getNameTest(morph$$1, name)) return morph$$1;
        var foundInMorph = morph$$1.getSubmorphNamed(name);
        if (foundInMorph) return foundInMorph;
      }
      return this.owner.getOwnerOrOwnerSubmorphNamed(name);
    }
  }, {
    key: "getMorphWithId",
    value: function Morph_getMorphWithId_(id) {
      return this.withAllSubmorphsDetect(function (_ref7) {
        var morphId = _ref7.id;
        return id === morphId;
      });
    }
  }, {
    key: "dragTriggerDistance",
    get: function get() {
      return 0;
    }
  }, {
    key: "onMouseDown",
    value: function Morph_onMouseDown_(evt) {
      var _this4 = this;

      if (this === evt.targetMorph) {
        setTimeout(function () {
          if (_this4.grabbable && !evt.state.draggedMorph && evt.state.clickedOnMorph === _this4 && !evt.hand.carriesMorphs()) evt.hand.grab(_this4);
        }, 800);
      }
    }
  }, {
    key: "onMouseUp",
    value: function Morph_onMouseUp_(evt) {}
  }, {
    key: "onMouseMove",
    value: function Morph_onMouseMove_(evt) {}
  }, {
    key: "addKeyBindings",
    value: function Morph_addKeyBindings_(bindings) {
      var _this5 = this;

      this.addMethodCallChangeDoing({
        target: this,
        selector: "addKeyBindings",
        args: [bindings],
        undo: null
      }, function () {
        var _keybindings;

        if (!_this5._keybindings) _this5._keybindings = [];
        (_keybindings = _this5._keybindings).unshift.apply(_keybindings, toConsumableArray(bindings));
      });
    }
  }, {
    key: "keybindings",
    get: function get() {
      return this._keybindings || [];
    }
  }, {
    key: "keybindings",
    set: function set(bndgs) {
      return this._keybindings = bndgs;
    }
  }, {
    key: "keyhandlers",
    get: function get() {
      return [KeyHandler.withBindings(this.keybindings)];
    }
  }, {
    key: "keyCommandMap",
    get: function get() {
      var platform = this.keyhandlers[0].platform;
      return this.keybindings.reduce(function (keyMap, binding) {
        var keys = binding.keys,
            platformKeys = findKeysForPlatform(keys, platform),
            command = binding.command,
            name = typeof command === "string" ? command : command.command || command.name;
        if (typeof platformKeys !== "string") return keyMap;
        return platformKeys.split("|").reduce(function (keyMap, combo) {
          return Object.assign(keyMap, defineProperty({}, combo, {
            name: name,
            command: command,
            prettyKeys: KeyHandler.prettyCombo(combo)
          }));
        }, keyMap);
      }, {});
    }
  }, {
    key: "keysForCommand",
    value: function Morph_keysForCommand_(commandName) {
      var pretty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      var map = this.keyCommandMap,
          rawKey = Object.keys(map).find(function (key) {
        return map[key].name === commandName;
      });
      return rawKey && pretty ? map[rawKey].prettyKeys : rawKey;
    }
  }, {
    key: "simulateKeys",
    value: function Morph_simulateKeys_(keyString) {
      return KeyHandler.simulateKeys(this, keyString);
    }
  }, {
    key: "onKeyDown",
    value: function Morph_onKeyDown_(evt) {
      if (KeyHandler.invokeKeyHandlers(this, evt, false)) {
        evt.stop();
      }
    }
  }, {
    key: "onKeyUp",
    value: function Morph_onKeyUp_(evt) {}
  }, {
    key: "onContextMenu",
    value: function Morph_onContextMenu_(evt) {
      if (evt.targetMorph !== this) return;
      evt.stop();
      this.openMenu(this.menuItems(), evt);
    }
  }, {
    key: "openMenu",
    value: function Morph_openMenu_(items, optEvt) {
      return items && items.length ? this.world().openWorldMenu(optEvt, items) : null;
    }
  }, {
    key: "menuItems",
    value: function Morph_menuItems_() {}
  }, {
    key: "onCut",
    value: function Morph_onCut_(evt) {}
  }, {
    key: "onCopy",
    value: function Morph_onCopy_(evt) {}
  }, {
    key: "onPaste",
    value: function Morph_onPaste_(evt) {}
  }, {
    key: "onDragStart",
    value: function Morph_onDragStart_(evt) {
      this.undoStart("drag-move");
    }
  }, {
    key: "onDragEnd",
    value: function Morph_onDragEnd_(evt) {
      this.undoStop("drag-move");
    }
  }, {
    key: "onDrag",
    value: function Morph_onDrag_(evt) {
      this.moveBy(evt.state.dragDelta);
    }
  }, {
    key: "onGrab",
    value: function Morph_onGrab_(evt) {
      evt.hand.grab(this);
    }
  }, {
    key: "onDrop",
    value: function Morph_onDrop_(evt) {
      evt.hand.dropMorphsOn(this);
    }
  }, {
    key: "onHoverIn",
    value: function Morph_onHoverIn_(evt) {}
  }, {
    key: "onHoverOut",
    value: function Morph_onHoverOut_(evt) {}
  }, {
    key: "onScroll",
    value: function Morph_onScroll_(evt) {}
  }, {
    key: "onMouseWheel",
    value: function Morph_onMouseWheel_(evt) {
      var scrollTarget = evt.targetMorphs.find(function (ea) {
        return ea.isClip();
      });
      if (this !== scrollTarget) return;
      var _evt$domEvt = evt.domEvt,
          deltaY = _evt$domEvt.deltaY,
          deltaX = _evt$domEvt.deltaX,
          magnX = Math.abs(deltaX),
          magnY = Math.abs(deltaY);

      var kind = "both directions";
      if (magnX <= 2 && magnY <= 2) kind = "tiny";else if (magnY / magnX <= 0.2) kind = "horizontal";else if (magnX / magnY <= 0.2) kind = "vertical";
      if (kind === "tiny") return;
      var _scroll = this.scroll,
          scrollX = _scroll.x,
          scrollY = _scroll.y,
          newScrollTop = deltaY + scrollY,
          newScrollLeft = deltaX + scrollX,
          newScrollBottom = newScrollTop + this.height,
          newScrollRight = newScrollLeft + this.width,
          newScrollX,
          newScrollY;

      if (kind === "vertical" || kind === "both directions") {
        if (newScrollBottom >= this.scrollExtent.y) newScrollY = this.scrollExtent.y - 1;else if (newScrollTop <= 0) newScrollY = 1;
        if (newScrollY !== undefined) {
          this.scroll = lively_graphics.pt(scrollX, newScrollY);
          evt.stop();
        }
      } else if (kind === "horizontal" || kind === "both directions") {
        if (newScrollRight >= this.scrollExtent.x) newScrollX = this.scrollExtent.x - 1;else if (newScrollLeft <= 0) newScrollX = 1;
        if (newScrollX !== undefined) {
          this.scroll = lively_graphics.pt(newScrollX, scrollY);
          evt.stop();
        }
      }
      if (!evt.state.scroll.interactiveScrollInProgress) {
        var _promise$deferred = lively_lang.promise.deferred(),
            p = _promise$deferred.promise,
            resolve = _promise$deferred.resolve;

        evt.state.scroll.interactiveScrollInProgress = p;
        p.debounce = lively_lang.fun.debounce(250, function () {
          evt.state.scroll.interactiveScrollInProgress = null;
          resolve();
        });
      }
      evt.state.scroll.interactiveScrollInProgress.debounce();
    }
  }, {
    key: "focus",
    value: function Morph_focus_() {
      var eventDispatcher = this.env.eventDispatcher;
      eventDispatcher && eventDispatcher.focusMorph(this);
    }
  }, {
    key: "onFocus",
    value: function Morph_onFocus_(evt) {}
  }, {
    key: "onBlur",
    value: function Morph_onBlur_(evt) {}
  }, {
    key: "isFocused",
    value: function Morph_isFocused_() {
      var eventDispatcher = this.env.eventDispatcher;
      return eventDispatcher && eventDispatcher.isMorphFocused(this);
    }
  }, {
    key: "exportToJSON",
    value: function Morph_exportToJSON_() {
      var _this6 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { keepFunctions: true };

      var exported = Object.keys(this._morphicState).reduce(function (exported, name) {
        var val = _this6[name];
        if (name === "submorphs") val = val.map(function (ea) {
          return ea.exportToJSON();
        });
        exported[name] = val;
        return exported;
      }, {});
      if (!exported.name) exported.name = this.name;
      exported._id = this._id;
      exported.type = this.constructor;
      if (options.keepFunctions) {
        Object.keys(this).forEach(function (name) {
          return typeof _this6[name] === "function" && (exported[name] = _this6[name]);
        });
      }
      return exported;
    }
  }, {
    key: "initFromJSON",
    value: function Morph_initFromJSON_(spec) {
      this._env = MorphicEnv.default();
      this._rev = 0;
      this._owner = null;
      this._dirty = true;
      this._rendering = false;
      this._submorphOrderChanged = false;
      this._id = newMorphId$$1(this.constructor.name);
      this._animationQueue = new AnimationQueue(this);
      this._cachedPaths = {};
      this._pathDependants = [];
      this._tickingScripts = [];
      this.initializeProperties();
      Object.assign(this, spec);
      return this;
    }
  }, {
    key: "copyViaJSON",
    value: function Morph_copyViaJSON_() {
      var exported = this.exportToJSON();
      lively_lang.tree.prewalk(exported, function (spec) {
        return spec._id = newMorphId$$1(spec.type);
      }, function (_ref8) {
        var submorphs = _ref8.submorphs;
        return submorphs;
      });
      exported.name = exported.name.replace(/copy( [0-9]+)?$/, function (_, num$$1) {
        return "copy " + (num$$1 && num$$1.trim() ? Number(num$$1) + 1 : "1");
      });
      return morph$1(Object.assign({ attributeConnections: [] }, exported));
    }
  }, {
    key: "copy",
    value: function Morph_copy_() {
      return copyMorph(this);
    }
  }, {
    key: "makeDirty",
    value: function Morph_makeDirty_() {
      if (this._dirty) return;
      this._dirty = true;
      if (this.owner) this.owner.makeDirty();
    }
  }, {
    key: "needsRerender",
    value: function Morph_needsRerender_() {
      return this._dirty;
    }
  }, {
    key: "aboutToRender",
    value: function Morph_aboutToRender_(renderer) {
      this._dirty = false;
      this._rendering = true;
    }
  }, {
    key: "whenRendered",
    value: function Morph_whenRendered_() {
      var _this7 = this;

      return lively_lang.promise.waitFor(function () {
        return !_this7._dirty && !_this7._rendering;
      }).then(function () {
        return _this7;
      });
    }
  }, {
    key: "render",
    value: function Morph_render_(renderer) {
      return renderer.renderMorph(this);
    }
  }, {
    key: "renderAsRoot",
    value: function Morph_renderAsRoot_(renderer) {
      return renderRootMorph(this, renderer);
    }
  }, {
    key: "renderPreview",
    value: function Morph_renderPreview_(opts) {
      opts = Object.assign({
        width: 100,
        height: 100,
        center: true
      }, opts);
      var goalWidth = opts.width,
          goalHeight = opts.height,
          scale = this.scale,
          position = this.position,
          origin = this.origin,
          rotation = this.rotation,
          invTfm = new lively_graphics.Transform(position.negated(), 0, lively_graphics.pt(1 / this.scale, 1 / scale)),
          bbox = invTfm.transformRectToRect(this.bounds()),
          w = bbox.width,
          h$$1 = bbox.height,
          ratio = Math.min(goalWidth / w, goalHeight / h$$1),
          node = renderMorph$1(this),
          tfm = new lively_graphics.Transform(bbox.topLeft().negated().scaleBy(ratio).subPt(origin), rotation, lively_graphics.pt(ratio, ratio));
      if (opts.center) {
        var previewBounds = tfm.transformRectToRect(this.extent.extentAsRectangle()),
            offsetX = previewBounds.width < goalWidth ? (goalWidth - previewBounds.width) / 2 : 0,
            offsetY = previewBounds.height < goalHeight ? (goalHeight - previewBounds.height) / 2 : 0;
        tfm = tfm.preConcatenate(new lively_graphics.Transform(lively_graphics.pt(offsetX, offsetY)));
      }
      node.style.transform = tfm.toCSSTransformString();
      node.style.pointerEvents = "";
      var html = node.outerHTML;
      html = html.replace(/(id|class)=\"[^\"]+\"/g, "").replace(/pointer-events: [^;]+;/g, "");
      return html;
    }
  }, {
    key: "startStepping",
    value: function Morph_startStepping_() {
      var args = Array.from(arguments),
          stepTime = typeof args[0] === "number" ? args.shift() : null,
          scriptName = args.shift(),
          script = new TargetScript(this, scriptName, args);
      this.removeEqualScripts(script);
      this._tickingScripts.push(script);
      script.startTicking(stepTime);
      return script;
    }
  }, {
    key: "tickingScripts",
    get: function get() {
      return this._tickingScripts;
    }
  }, {
    key: "stopStepping",
    value: function Morph_stopStepping_() {
      lively_lang.arr.invoke(this._tickingScripts, "stop");
      this._tickingScripts.length = [];
    }
  }, {
    key: "stopSteppingScriptNamed",
    value: function Morph_stopSteppingScriptNamed_(selector) {
      var scriptsToStop = this._tickingScripts.filter(function (ea) {
        return ea.selector === selector;
      });
      this.stopScripts(scriptsToStop);
    }
  }, {
    key: "stopScripts",
    value: function Morph_stopScripts_(scripts) {
      lively_lang.arr.invoke(scripts, "stop");
      this._tickingScripts = lively_lang.arr.withoutAll(this._tickingScripts, scripts);
    }
  }, {
    key: "suspendStepping",
    value: function Morph_suspendStepping_() {
      if (this._tickingScripts) lively_lang.arr.invoke(this._tickingScripts, "suspend");
    }
  }, {
    key: "suspendSteppingAll",
    value: function Morph_suspendSteppingAll_() {
      this.withAllSubmorphsDo(function (ea) {
        return ea.suspendStepping();
      });
    }
  }, {
    key: "resumeStepping",
    value: function Morph_resumeStepping_() {
      lively_lang.arr.invoke(this._tickingScripts, "resume");
    }
  }, {
    key: "resumeSteppingAll",
    value: function Morph_resumeSteppingAll_() {
      this.withAllSubmorphsDo(function (ea) {
        return lively_lang.arr.invoke(ea._tickingScripts, "resume");
      });
    }
  }, {
    key: "removeEqualScripts",
    value: function Morph_removeEqualScripts_(script) {
      this.stopScripts(this._tickingScripts.filter(function (ea) {
        return ea.equals(script);
      }));
    }
  }, {
    key: "commands",
    get: function get() {
      return this._commands || [];
    }
  }, {
    key: "commands",
    set: function set(cmds) {
      if (this._commands) this.removeCommands(this._commands);
      this.addCommands(cmds);
    }
  }, {
    key: "commandsIncludingOwners",
    get: function get() {
      return lively_lang.arr.flatmap([this].concat(this.ownerChain()), function (morph$$1) {
        return lively_lang.arr.sortByKey(morph$$1.commands, "name").map(function (command) {
          return {
            target: morph$$1,
            command: command
          };
        });
      });
    }
  }, {
    key: "addCommands",
    value: function Morph_addCommands_(cmds) {
      var _this8 = this;

      this.addMethodCallChangeDoing({
        target: this,
        selector: "addCommands",
        args: [cmds],
        undo: {
          target: this,
          selector: "removeCommands",
          args: [cmds]
        }
      }, function () {
        _this8.removeCommands(cmds);
        _this8._commands = (_this8._commands || []).concat(cmds);
      });
    }
  }, {
    key: "removeCommands",
    value: function Morph_removeCommands_(cmdsOrNames) {
      var _this9 = this;

      this.addMethodCallChangeDoing({
        target: this,
        selector: "removeCommands",
        args: [cmdsOrNames],
        undo: {
          target: this,
          selector: "addCommands",
          args: [cmdsOrNames]
        }
      }, function () {
        var names = cmdsOrNames.map(function (ea) {
          return typeof ea === "string" ? ea : ea.name;
        }),
            commands = (_this9._commands || []).filter(function (_ref9) {
          var name = _ref9.name;
          return !names.includes(name);
        });
        if (!commands.length) delete _this9._commands;else _this9._commands = commands;
      });
    }
  }, {
    key: "commandHandler",
    get: function get() {
      return this._commandHandler || defaultCommandHandler;
    }
  }, {
    key: "lookupCommand",
    value: function Morph_lookupCommand_(commandOrName) {
      var result = this.commandHandler.lookupCommand(commandOrName, this);
      return result && result.command ? result : null;
    }
  }, {
    key: "execCommand",
    value: function Morph_execCommand_(command, args, count, evt) {
      return this.commandHandler.exec(command, this, args, count, evt);
    }
  }], [{
    key: "propertySettings",
    get: function get() {
      return {
        defaultGetter: function defaultGetter(key) {
          return this.getProperty(key);
        },
        defaultSetter: function defaultSetter(key, value) {
          this.setProperty(key, value);
        },

        valueStoreProperty: "_morphicState"
      };
    }
  }, {
    key: "properties",
    get: function get() {
      return {
        clipMode: {
          defaultValue: "visible",
          set: function set(value) {
            this.setProperty("clipMode", value);
            if (!this.isClip()) this.scroll = lively_graphics.pt(0, 0);
          }
        },
        draggable: { defaultValue: true },
        dropShadow: {
          defaultValue: false,
          set: function set(value) {
            if (value && !value.isShadowObject) {
              value = new ShadowObject$$1(value);
              value.morph = this;
            }
            this.setProperty("dropShadow", value);
          }
        },
        epiMorph: { defaultValue: false },
        extent: { defaultValue: lively_graphics.pt(10, 10) },
        fill: { defaultValue: lively_graphics.Color.white },
        focusable: { defaultValue: true },
        grabbable: { defaultValue: false },
        halosEnabled: { defaultValue: !!config.halosEnabled },
        isLayoutable: { defaultValue: true },
        name: { defaultValue: "aMorph" },
        nativeCursor: { defaultValue: "auto" },
        opacity: { defaultValue: 1 },
        origin: { defaultValue: lively_graphics.pt(0, 0) },
        position: { defaultValue: lively_graphics.pt(0, 0) },
        reactsToPointer: { defaultValue: true },
        rotation: { defaultValue: 0 },
        scale: { defaultValue: 1 },
        scroll: {
          defaultValue: lively_graphics.pt(0, 0),
          set: function set(_ref10) {
            var x = _ref10.x,
                y = _ref10.y;

            if (!this.isClip()) return;

            var _scrollExtent$subPt = this.scrollExtent.subPt(this.extent),
                maxScrollX = _scrollExtent$subPt.x,
                maxScrollY = _scrollExtent$subPt.y;

            x = Math.max(0, Math.min(maxScrollX, x));
            y = Math.max(0, Math.min(maxScrollY, y));
            this.setProperty("scroll", lively_graphics.pt(x, y));
            this.makeDirty();
          }
        },
        styleClasses: {
          defaultValue: ["morph"],
          get: function get() {
            return this.constructor.styleClasses.concat(this.getProperty("styleClasses"));
          },
          set: function set(value) {
            this.setProperty("styleClasses", lively_lang.arr.withoutAll(value, this.constructor.styleClasses));
          }
        },
        tooltip: { defaultValue: null },
        visible: { defaultValue: true },
        layout: {
          after: ["submorphs", "extent", "origin", "position", "isLayoutable"],
          set: function set(value) {
            if (value) value.container = this;
            this.setProperty("layout", value);
          }
        },
        submorphs: {
          defaultValue: [],
          after: ["isLayoutable", "origin", "position", "rotation", "scale"],
          get: function get() {
            return (this.getProperty("submorphs") || []).slice();
          },
          set: function set(newSubmorphs) {
            var _this10 = this;

            this.layout && this.layout.disable();
            this.submorphs.forEach(function (m) {
              return newSubmorphs.includes(m) || m.remove();
            });
            newSubmorphs.forEach(function (m, i) {
              return _this10.submorphs[i] !== m && _this10.addMorph(m, _this10.submorphs[i]);
            });
            this.layout && this.layout.enable();
          }
        },
        borderColorBottom: { defaultValue: lively_graphics.Color.white },
        borderColorLeft: { defaultValue: lively_graphics.Color.white },
        borderColorRight: { defaultValue: lively_graphics.Color.white },
        borderColorTop: { defaultValue: lively_graphics.Color.white },
        borderRadiusBottom: { defaultValue: 0 },
        borderRadiusLeft: { defaultValue: 0 },
        borderRadiusRight: { defaultValue: 0 },
        borderRadiusTop: { defaultValue: 0 },
        borderStyleBottom: { defaultValue: "solid" },
        borderStyleLeft: { defaultValue: "solid" },
        borderStyleRight: { defaultValue: "solid" },
        borderStyleTop: { defaultValue: "solid" },
        borderWidthBottom: { defaultValue: 0 },
        borderWidthLeft: { defaultValue: 0 },
        borderWidthRight: { defaultValue: 0 },
        borderWidthTop: { defaultValue: 0 },
        borderLeft: {
          derived: true,
          after: ["borderStyleLeft", "borderWidthLeft", "borderColorLeft"],
          get: function get() {
            return {
              style: this.borderStyleLeft,
              width: this.borderWidthLeft,
              color: this.borderColorLeft
            };
          },
          set: function set(x) {
            if ("style" in x) this.borderStyleLeft = x.style;
            if ("width" in x) this.borderWidthLeft = x.width;
            if ("color" in x) this.borderColorLeft = x.color;
            if ("radius" in x) this.borderRadiusLeft = x.radius;
          }
        },
        borderRight: {
          derived: true,
          after: ["borderStyleRight", "borderWidthRight", "borderColorRight"],
          get: function get() {
            return {
              style: this.borderStyleRight,
              width: this.borderWidthRight,
              color: this.borderColorRight
            };
          },
          set: function set(x) {
            if ("style" in x) this.borderStyleRight = x.style;
            if ("width" in x) this.borderWidthRight = x.width;
            if ("color" in x) this.borderColorRight = x.color;
            if ("radius" in x) this.borderRadiusRight = x.radius;
          }
        },
        borderBottom: {
          derived: true,
          after: ["borderStyleBottom", "borderWidthBottom", "borderColorBottom"],
          get: function get() {
            return {
              style: this.borderStyleBottom,
              width: this.borderWidthBottom,
              color: this.borderColorBottom
            };
          },
          set: function set(x) {
            if ("style" in x) this.borderStyleBottom = x.style;
            if ("width" in x) this.borderWidthBottom = x.width;
            if ("color" in x) this.borderColorBottom = x.color;
            if ("radius" in x) this.borderRadiusBottom = x.radius;
          }
        },
        borderTop: {
          derived: true,
          after: ["borderStyleTop", "borderWidthTop", "borderColorTop"],
          get: function get() {
            return {
              style: this.borderStyleTop,
              width: this.borderWidthTop,
              color: this.borderColorTop
            };
          },
          set: function set(x) {
            if ("style" in x) this.borderStyleTop = x.style;
            if ("width" in x) this.borderWidthTop = x.width;
            if ("color" in x) this.borderColorTop = x.color;
            if ("radius" in x) this.borderRadiusTop = x.radius;
          }
        },
        borderWidth: {
          derived: true,
          after: ["borderWidthLeft", "borderWidthRight", "borderWidthTop", "borderWidthBottom"],
          get: function get() {
            return this.borderWidthLeft;
          },
          set: function set(value) {
            this.borderWidthLeft = this.borderWidthRight = this.borderWidthTop = this.borderWidthBottom = value;
          }
        },
        borderRadius: {
          derived: true,
          after: ["borderRadiusLeft", "borderRadiusRight", "borderRadiusTop", "borderRadiusBottom"],
          get: function get() {
            return this.borderRadiusLeft;
          },
          set: function set(value) {
            if (!value) value = 0;
            var left = value,
                right = value,
                top = value,
                bottom = value;
            if (value.isRectangle) {
              left = value.left();
              right = value.right();
              top = value.top();
              bottom = value.bottom();
            }
            this.borderRadiusLeft = left;
            this.borderRadiusRight = right;
            this.borderRadiusTop = top;
            this.borderRadiusBottom = bottom;
          }
        },
        borderStyle: {
          derived: true,
          after: ["borderStyleLeft", "borderStyleRight", "borderStyleTop", "borderStyleBottom"],
          get: function get() {
            return this.borderStyleLeft;
          },
          set: function set(value) {
            this.borderStyleLeft = this.borderStyleRight = this.borderStyleTop = this.borderStyleBottom = value;
          }
        },
        borderColor: {
          derived: true,
          after: ["borderColorLeft", "borderColorRight", "borderColorTop", "borderColorBottom"],
          get: function get() {
            return this.borderColorLeft;
          },
          set: function set(value) {
            this.borderColorLeft = this.borderColorRight = this.borderColorTop = this.borderColorBottom = value;
          }
        },
        border: {
          derived: true,
          after: ["borderStyle", "borderWidth", "borderColor"],
          get: function get() {
            return {
              style: this.borderStyle,
              width: this.borderWidth,
              color: this.borderColor
            };
          },
          set: function set(x) {
            if ("style" in x) this.borderStyle = x.style;
            if ("width" in x) this.borderWidth = x.width;
            if ("color" in x) this.borderColor = x.color;
            if ("radius" in x) this.borderRadius = x.radius;
          }
        },
        morphClasses: {},
        styleRules: {
          set: function set(rules) {
            this.setProperty("styleRules", rules);
            if (rules) rules.applyToAll(this);
          }
        }
      };
    }
  }, {
    key: "styleClasses",
    get: function get() {
      if (this.hasOwnProperty("_styclassNames")) return this._styleClasses;
      var klass = this,
          classNames = [];
      while (klass) {
        if (klass === Object) break;
        classNames.push(klass.name);
        klass = klass[Symbol.for("lively-instance-superclass")];
      }
      return this._styleClasses = classNames;
    }
  }], __lively_classholder__, undefined, {
    start: 962,
    end: 53034
  });
}(undefined);
var Ellipse$$1 = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("Ellipse") && typeof __lively_classholder__.Ellipse === "function" ? __lively_classholder__.Ellipse : __lively_classholder__.Ellipse = function Ellipse$$1(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, undefined, [{
    key: "properties",
    get: function get() {
      return {
        borderRadiusLeft: {
          get: function get() {
            return this.height;
          },
          set: function set() {}
        },
        borderRadiusRight: {
          get: function get() {
            return this.height;
          },
          set: function set() {}
        },
        borderRadiusTop: {
          get: function get() {
            return this.width;
          },
          set: function set() {}
        },
        borderRadiusBottom: {
          get: function get() {
            return this.width;
          },
          set: function set() {}
        }
      };
    }
  }], __lively_classholder__, undefined, {
    start: 53044,
    end: 53460
  });
}(Morph$1);
var Triangle$$1 = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("Triangle") && typeof __lively_classholder__.Triangle === "function" ? __lively_classholder__.Triangle : __lively_classholder__.Triangle = function Triangle$$1(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function Triangle_initialize_() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, props);
      this.update();
    }
  }, {
    key: "onChange",
    value: function Triangle_onChange_(change) {
      if (change.prop == "extent" || change.prop == "direction" || change.prop == "fill" && change.value) this.update();
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "onChange", this).call(this, change);
    }
  }, {
    key: "update",
    value: function Triangle_update_() {
      var _Object$assign2;

      var _extent2 = this.extent,
          width = _extent2.x,
          height = _extent2.y;

      if (width != height) this.extent = lively_graphics.pt(Math.max(width, height), Math.max(width, height));
      this.origin = lively_graphics.pt(width / 2, height / 2);
      var color = this.triangleFill = this.fill || this.triangleFill;
      this.fill = null;
      var base = {
        width: width / 2,
        style: "solid",
        color: color
      },
          side = {
        width: height / 2,
        style: "solid",
        color: lively_graphics.Color.transparent
      },
          side1,
          side2,
          bottom;
      switch (this.direction) {
        case "down":
          side1 = "borderLeft";
          side2 = "borderRight";
          bottom = "borderTop";
          break;
        case "up":
          side1 = "borderLeft";
          side2 = "borderRight";
          bottom = "borderBottom";
          break;
        case "left":
          side1 = "borderBottom";
          side2 = "borderTop";
          bottom = "borderRight";
          break;
        case "right":
          side1 = "borderBottom";
          side2 = "borderTop";
          bottom = "borderLeft";
          break;
      }
      Object.assign(this, (_Object$assign2 = {}, defineProperty(_Object$assign2, side1, side), defineProperty(_Object$assign2, side2, side), defineProperty(_Object$assign2, bottom, base), _Object$assign2));
    }
  }], [{
    key: "properties",
    get: function get() {
      return {
        direction: { defaultValue: "up" },
        triangleFill: {
          after: ["fill"],
          initialize: function initialize() {
            this.triangleFill = this.fill;
          }
        }
      };
    }
  }], __lively_classholder__, undefined, {
    start: 53469,
    end: 54884
  });
}(Morph$1);
var Image$$1 = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("Image") && typeof __lively_classholder__.Image === "function" ? __lively_classholder__.Image : __lively_classholder__.Image = function Image$$1(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: "isImage",
    get: function get() {
      return true;
    }
  }, {
    key: "naturalExtent",
    value: function () {
      var _ref11 = asyncToGenerator(regeneratorRuntime.mark(function _callee5() {
        var _this11 = this;

        var image, width, height;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                image = document.createElement("img");
                return _context5.abrupt("return", new Promise(function (resolve) {
                  image.onload = function () {
                    var width = this.width,
                        height = this.height;

                    resolve(lively_graphics.pt(width, height));
                  };
                  image.src = _this11.imageUrl;
                }));

              case 2:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function Image_naturalExtent_() {
        return _ref11.apply(this, arguments);
      }

      return Image_naturalExtent_;
    }()
  }, {
    key: "render",
    value: function Image_render_(renderer) {
      return renderer.renderImage(this);
    }
  }], [{
    key: "properties",
    get: function get() {
      return { imageUrl: { defaultValue: System.decanonicalize("lively.morphic/lively-web-logo-small.png") } };
    }
  }], __lively_classholder__, undefined, {
    start: 54893,
    end: 55449
  });
}(Morph$1);
var PathPoint = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("PathPoint") && typeof __lively_classholder__.PathPoint === "function" ? __lively_classholder__.PathPoint : __lively_classholder__.PathPoint = function PathPoint(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function PathPoint_initialize_(path) {
      var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this.path = path;
      Object.assign(this, lively_lang.obj.dissoc(props, "path"));
    }
  }, {
    key: "isSmooth",
    get: function get() {
      return this._isSmooth;
    }
  }, {
    key: "isSmooth",
    set: function set(smooth) {
      this._isSmooth = smooth;
      this.adaptControlPoints(smooth);
    }
  }, {
    key: "position",
    get: function get() {
      return lively_graphics.pt(this.x, this.y);
    }
  }, {
    key: "position",
    set: function set(_ref12) {
      var x = _ref12.x,
          y = _ref12.y;

      this.x = x;
      this.y = y;
    }
  }, {
    key: "moveBy",
    value: function PathPoint_moveBy_(delta) {
      this.position = this.position.addPt(delta);
      this.path.onVertexChanged(this);
    }
  }, {
    key: "controlPoints",
    get: function get() {
      return this._controlPoints || {
        next: lively_graphics.pt(0, 0),
        previous: lively_graphics.pt(0, 0)
      };
    }
  }, {
    key: "controlPoints",
    set: function set(cps) {
      this._controlPoints = cps;
    }
  }, {
    key: "moveNextControlPoint",
    value: function PathPoint_moveNextControlPoint_(delta) {
      this.moveControlPoint("next", delta);
    }
  }, {
    key: "movePreviousControlPoint",
    value: function PathPoint_movePreviousControlPoint_(delta) {
      this.moveControlPoint("previous", delta);
    }
  }, {
    key: "moveControlPoint",
    value: function PathPoint_moveControlPoint_(name, delta) {
      var _controlPoints;

      var acp = this.controlPoints[name],
          acp = acp ? acp.addPt(delta) : delta,
          other = name == "next" ? "previous" : "next",
          bcp = this.controlPoints[other];
      if (this.isSmooth) {
        bcp = acp.negated().normalized().scaleBy(bcp.r());
      }
      this.controlPoints = (_controlPoints = {}, defineProperty(_controlPoints, name, acp), defineProperty(_controlPoints, other, bcp), _controlPoints);
      this.path.onVertexChanged(this);
    }
  }, {
    key: "pointOnLine",
    value: function PathPoint_pointOnLine_(a, b, pos, bw) {
      var v0 = lively_graphics.pt(a.x, a.y),
          v1 = lively_graphics.pt(b.x, b.y),
          l = v1.subPt(v0),
          ln = l.scaleBy(1 / l.r()),
          dot = v1.subPt(pos).dotProduct(ln);
      return v1.subPt(ln.scaleBy(Math.max(1, Math.min(dot, l.r())))).addXY(bw, bw);
    }
  }, {
    key: "nextVertex",
    get: function get() {
      return this.path.vertexAfter(this);
    }
  }, {
    key: "previousVertex",
    get: function get() {
      return this.path.vertexBefore(this);
    }
  }, {
    key: "adaptControlPoints",
    value: function PathPoint_adaptControlPoints_(smooth) {
      var nextPos = this.nextVertex.position,
          previousPos = this.previousVertex.position;
      if (smooth) {
        var p = this.pointOnLine(previousPos, nextPos, this.position, this.borderWidth);
        this.controlPoints = {
          next: p.subPt(previousPos),
          previous: p.subPt(nextPos)
        };
      } else {
        this.controlPoints = {
          previous: previousPos.subPt(this.position).scaleBy(0.5),
          next: nextPos.subPt(this.position).scaleBy(0.5)
        };
      }
      this.path.onVertexChanged(this);
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 55451,
    end: 57634
  });
}(undefined);
var Path$1 = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("Path") && typeof __lively_classholder__.Path === "function" ? __lively_classholder__.Path : __lively_classholder__.Path = function Path$1(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function Path_initialize_() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, Object.assign({}, lively_lang.obj.dissoc(props, "origin")));
      this.adjustOrigin(props.origin || this.origin);
      this.position = props.position || this.position;
    }
  }, {
    key: "isPath",
    get: function get() {
      return true;
    }
  }, {
    key: "isSvgMorph",
    get: function get() {
      return true;
    }
  }, {
    key: "onVertexChanged",
    value: function Path_onVertexChanged_(vertex) {
      this.makeDirty();
      this.updateBounds(this.vertices);
    }
  }, {
    key: "updateBounds",
    value: function Path_updateBounds_(vertices) {
      var b = lively_graphics.Rectangle.unionPts([lively_graphics.pt(0, 0)].concat(toConsumableArray(lively_lang.arr.flatmap(vertices, function (_ref13) {
        var position = _ref13.position,
            controlPoints = _ref13.controlPoints;

        var _ref14 = controlPoints || {},
            next = _ref14.next,
            previous = _ref14.previous;

        if (next) next = position.addPt(next);
        if (previous) previous = position.addPt(previous);
        return lively_lang.arr.compact([next, position, previous]);
      }))));
      this.adjustingVertices = true;
      this.extent = b.extent();
      this.origin = b.topLeft().negated();
      this.adjustingVertices = false;
    }
  }, {
    key: "onChange",
    value: function Path_onChange_(change) {
      if (change.prop == "extent" && change.value && change.prevValue && !this.adjustingVertices) this.adjustVertices(change.value.scaleByPt(change.prevValue.inverted()));
      if (!this.adjustingOrigin && ["vertices", "borderWidthLeft"].includes(change.prop)) this.updateBounds(change.prop == "vertices" ? change.value : this.vertices);
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "onChange", this).call(this, change);
    }
  }, {
    key: "vertexBefore",
    value: function Path_vertexBefore_(v) {
      var i = this.vertices.indexOf(v) - 1;
      return this.vertices[i > 0 ? i : this.vertices.length - 1];
    }
  }, {
    key: "vertexAfter",
    value: function Path_vertexAfter_(v) {
      var i = this.vertices.indexOf(v) + 1;
      return this.vertices[i > this.vertices.length - 1 ? 0 : i];
    }
  }, {
    key: "adjustVertices",
    value: function Path_adjustVertices_(delta) {
      var _this12 = this;

      this.vertices && this.vertices.forEach(function (v) {
        var _v$controlPoints = v.controlPoints,
            next = _v$controlPoints.next,
            previous = _v$controlPoints.previous;

        next = next.scaleByPt(delta);
        previous = previous.scaleByPt(delta);
        v.position = v.position.addPt(_this12.origin).scaleByPt(delta).subPt(_this12.origin);
        v.controlPoints = {
          next: next,
          previous: previous
        };
      });
    }
  }, {
    key: "adjustOrigin",
    value: function Path_adjustOrigin_(newOrigin) {
      var _this13 = this;

      this.adjustingOrigin = true;
      this.vertices.forEach(function (v) {
        return v.position = _this13.origin.subPt(newOrigin).addXY(v.x, v.y);
      });
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "adjustOrigin", this).call(this, newOrigin);
      this.adjustingOrigin = false;
    }
  }, {
    key: "addVertex",
    value: function Path_addVertex_(v) {
      var before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (before) {
        var insertIndex = this.vertices.indexOf(before);
        this.vertices = this.vertices.splice(insertIndex, 0, v);
      } else {
        this.vertices = this.vertices.concat(v);
      }
    }
  }, {
    key: "render",
    value: function Path_render_(renderer) {
      return renderer.renderPath(this);
    }
  }], [{
    key: "properties",
    get: function get() {
      return {
        vertices: {
          defaultValue: [],
          set: function set(vs) {
            var _this14 = this;

            vs = vs.map(function (v) {
              return new PathPoint(_this14, Object.assign({}, v, { borderWidth: _this14.borderWidth }));
            });
            this.setProperty("vertices", vs);
          }
        }
      };
    }
  }], __lively_classholder__, undefined, {
    start: 57643,
    end: 60390
  });
}(Morph$1);
var Polygon$$1 = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("Polygon") && typeof __lively_classholder__.Polygon === "function" ? __lively_classholder__.Polygon : __lively_classholder__.Polygon = function Polygon$$1(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function Polygon_initialize_(props) {
      if (props.vertices && props.vertices.length > 2) {
        lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, props);
      } else {
        throw new Error("A polygon requires 3 or more vertices!");
      }
    }
  }, {
    key: "isPolygon",
    get: function get() {
      return true;
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 60399,
    end: 60653
  });
}(Path$1);

function show$$1(target) {
  var world = MorphicEnv.default().world;
  if (target === null || target === undefined) target = String(target);
  if (target.isMorph) return showRect(target.world(), target.globalBounds());
  if (target.isPoint) return showRect(world, new lively_graphics.Rectangle(target.x - 5, target.y - 5, 10, 10));
  if (target.isRectangle) return showRect(world, target);
  if (typeof Element !== "undefined" && target instanceof Element) return showRect(world, lively_graphics.Rectangle.fromElement(target));
  if (typeof target === "number" || (typeof target === "undefined" ? "undefined" : _typeof(target)) === "symbol" || typeof target === "boolean" || typeof Node !== "undefined" && target instanceof Node || target instanceof RegExp) target = String(target);
  if ((typeof target === "undefined" ? "undefined" : _typeof(target)) === "object") target = lively_lang.obj.inspect(target, { maxDepth: 1 });
  if (typeof target === "string" && arguments.length === 1) return world.setStatusMessage(target);
  return world.setStatusMessage(lively_lang.string.formatFromArray(Array.from(arguments)));
}
function showRect(world, rect$$1) {
  var marker = BoundsMarker.highlightBounds(rect$$1);
  return showThenHide(world, marker);
}
function showThenHide(world, morphOrMorphs) {
  var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;

  if (!world) return;
  var morphs = Array.isArray(morphOrMorphs) ? morphOrMorphs : [morphOrMorphs];
  morphs.forEach(function (ea) {
    return world.addMorph(ea);
  });
  if (duration) {
    setTimeout(function () {
      return morphs.forEach(function (ea) {
        return ea.fadeOut(2000);
      });
    }, duration * 1000);
  }
  return morphOrMorphs;
}
var BoundsMarker = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("BoundsMarker") && typeof __lively_classholder__.BoundsMarker === "function" ? __lively_classholder__.BoundsMarker : __lively_classholder__.BoundsMarker = function BoundsMarker(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function BoundsMarker_initialize_() {
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, {
        borderWidth: 0,
        fill: lively_graphics.Color.transparent,
        reactsToPointer: false
      });
    }
  }, {
    key: "isEpiMorph",
    get: function get() {
      return true;
    }
  }, {
    key: "markerLength",
    value: function BoundsMarker_markerLength_(forBounds) {
      forBounds = forBounds.insetBy(-2);
      var length = Math.min(forBounds.width, forBounds.height);
      return Math.max(4, Math.floor(length / 10 < 10 ? length / 2 - 5 : length / 10));
    }
  }, {
    key: "createMarkerEdge",
    value: function BoundsMarker_createMarkerEdge_() {
      var b = morph$1({
        fill: lively_graphics.Color.red,
        reactsToPointer: false
      });
      return b;
    }
  }, {
    key: "ensureMarkerCorners",
    value: function BoundsMarker_ensureMarkerCorners_() {
      var topLeftH = this.topLeftH || (this.topLeftH = this.addMorph(this.createMarkerEdge())),
          topLeftV = this.topLeftV || (this.topLeftV = this.addMorph(this.createMarkerEdge())),
          topRightH = this.topRightH || (this.topRightH = this.addMorph(this.createMarkerEdge())),
          topRightV = this.topRightV || (this.topRightV = this.addMorph(this.createMarkerEdge())),
          bottomRightH = this.bottomRightH || (this.bottomRightH = this.addMorph(this.createMarkerEdge())),
          bottomRightV = this.bottomRightV || (this.bottomRightV = this.addMorph(this.createMarkerEdge())),
          bottomLeftH = this.bottomLeftH || (this.bottomLeftH = this.addMorph(this.createMarkerEdge())),
          bottomLeftV = this.bottomLeftV || (this.bottomLeftV = this.addMorph(this.createMarkerEdge()));
      return [topLeftH, topLeftV, topRightH, topRightV, bottomRightH, bottomRightV, bottomLeftH, bottomLeftV];
    }
  }, {
    key: "alignWithMorph",
    value: function BoundsMarker_alignWithMorph_(otherMorph) {
      return this.alignWithBounds(otherMorph.globalBounds());
    }
  }, {
    key: "alignWithBounds",
    value: function BoundsMarker_alignWithBounds_(bounds) {
      this.alignWithRect(bounds.insetBy(-20));
      return this.alignWithRect(bounds, true);
    }
  }, {
    key: "alignWithRect",
    value: function BoundsMarker_alignWithRect_(r, animated) {
      var markerWidth = 5,
          corners = this.ensureMarkerCorners(),
          markerLength = this.markerLength(r),
          boundsForMarkers = [r.topLeft().addXY(0, 0).extent(lively_graphics.pt(markerLength, markerWidth)), r.topLeft().addXY(0, 0).extent(lively_graphics.pt(markerWidth, markerLength)), r.topRight().addXY(-markerLength, 0).extent(lively_graphics.pt(markerLength, markerWidth)), r.topRight().addXY(-markerWidth, 0).extent(lively_graphics.pt(markerWidth, markerLength)), r.bottomRight().addXY(-markerWidth, -markerLength).extent(lively_graphics.pt(markerWidth, markerLength)), r.bottomRight().addXY(-markerLength, -markerWidth).extent(lively_graphics.pt(markerLength, markerWidth)), r.bottomLeft().addXY(0, -markerWidth).extent(lively_graphics.pt(markerLength, markerWidth)), r.bottomLeft().addXY(0, -markerLength).extent(lively_graphics.pt(markerWidth, markerLength))];
      corners.forEach(function (corner, i) {
        return corner.setBounds(boundsForMarkers[i]);
      });
      if (animated) {
        this.adjustOrigin(r.center());
        this.opacity = 0, this.scale = 1.5;
        this.animate({
          opacity: 1,
          scale: 1,
          duration: 300
        });
      }
      return this;
    }
  }], [{
    key: "highlightMorph",
    value: function BoundsMarker_highlightMorph_(morph$$1) {
      return new this().alignWithMorph(morph$$1);
    }
  }, {
    key: "highlightBounds",
    value: function BoundsMarker_highlightBounds_(bounds) {
      return new this().alignWithBounds(bounds);
    }
  }], __lively_classholder__, undefined, {
    start: 1726,
    end: 5117
  });
}(Morph$1);
var StatusMessage = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("StatusMessage") && typeof __lively_classholder__.StatusMessage === "function" ? __lively_classholder__.StatusMessage : __lively_classholder__.StatusMessage = function StatusMessage(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: "relayout",
    value: function StatusMessage_relayout_() {
      this.getSubmorphNamed("messageText").setBounds(this.innerBounds().insetBy(10));
      this.getSubmorphNamed("closeButton").topRight = this.innerBounds().topRight().addXY(-6, 6);
    }
  }, {
    key: "isEpiMorph",
    value: function StatusMessage_isEpiMorph_() {
      return true;
    }
  }, {
    key: "isStatusMessage",
    value: function StatusMessage_isStatusMessage_() {
      return true;
    }
  }, {
    key: "setMessage",
    value: function StatusMessage_setMessage_(msg, color) {
      this.message = msg;
      this.color = color;
    }
  }, {
    key: "slideTo",
    value: function () {
      var _ref = asyncToGenerator(regeneratorRuntime.mark(function _callee(pos) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.sliding = this.animate({
                  position: pos,
                  duration: 500
                });
                _context.next = 3;
                return this.sliding;

              case 3:
                this.sliding = false;

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function StatusMessage_slideTo_(_x2) {
        return _ref.apply(this, arguments);
      }

      return StatusMessage_slideTo_;
    }()
  }, {
    key: "expand",
    value: function () {
      var _ref2 = asyncToGenerator(regeneratorRuntime.mark(function _callee2() {
        var world, text, ext, visibleBounds;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (this.expandable) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt("return");

              case 2:
                if (!this.sliding) {
                  _context2.next = 5;
                  break;
                }

                _context2.next = 5;
                return this.sliding;

              case 5:
                world = this.world();

                if (!(!world || this.isMaximized)) {
                  _context2.next = 8;
                  break;
                }

                return _context2.abrupt("return");

              case 8:
                this.isMaximized = true;
                this.stayOpen = true;
                text = this.getSubmorphNamed("messageText");

                Object.assign(text, {
                  readOnly: false,
                  fixedWidth: false,
                  selectable: true
                });
                if (this.expandedContent) text.value = this.expandedContent;
                text.fit();
                ext = text.extent.addXY(20, 20), visibleBounds = world.visibleBounds();

                if (ext.y > visibleBounds.extent().y) ext.y = visibleBounds.extent().y - 20;
                if (ext.x > visibleBounds.extent().x) ext.x = visibleBounds.extent().x - 20;
                ext = this.extent.maxPt(ext);
                this.animate({
                  extent: ext,
                  center: visibleBounds.center(),
                  duration: 200
                });
                this.relayout();
                this.focus();

              case 21:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function StatusMessage_expand_() {
        return _ref2.apply(this, arguments);
      }

      return StatusMessage_expand_;
    }()
  }, {
    key: "fit",
    value: function StatusMessage_fit_() {
      var text = this.getSubmorphNamed("messageText");
      if (!text) return;
      var minHeight = 40,
          minWidth = 100;
      this.extent = lively_graphics.pt(minWidth, minHeight).maxPt(text.textBounds().extent());
      this.relayout();
    }
  }, {
    key: "focus",
    value: function StatusMessage_focus_() {
      var text = this.getSubmorphNamed("messageText");
      text && text.focus();
    }
  }, {
    key: "onMouseUp",
    value: function StatusMessage_onMouseUp_(evt) {
      this.expand();
    }
  }], [{
    key: "properties",
    get: function get() {
      return {
        stayOpen: { defaultValue: false },
        slidable: { defaultValue: true },
        isMaximized: { defaultValue: false },
        expandable: {
          initialize: function initialize() {
            this.expandable = true;
          }
        },
        maxLines: { defaultValue: Infinity },
        name: { defaultValue: "messageMorph" },
        extent: { defaultValue: lively_graphics.pt(240, 65) },
        clipMode: { defaultValue: "hidden" },
        grabbing: { defaultValue: false },
        dragging: { defaultValue: false },
        borderRadius: { defaultValue: 20 },
        borderWidth: { defaultValue: 5 },
        fill: { defaultValue: lively_graphics.Color.white },
        dropShadow: { defaultValue: new ShadowObject$$1(true) },
        message: {
          after: ["submorphs"],
          set: function set(value) {
            this.setProperty("message", value);
            var text = this.getSubmorphNamed("messageText");
            if (!text) return;
            text.value = value;
            var textEnd = text.documentEndPosition;
            if (textEnd.row > this.maxLines) {
              text.replace({
                start: {
                  row: this.maxLines,
                  column: 0
                },
                end: textEnd
              }, "...\n");
              if (!this.expandedContent) this.expandedContent = value;
            }
            textEnd = text.documentEndPosition;
            if (textEnd.column !== 0) text.insertText("\n", textEnd);
          }
        },
        color: {
          after: ["borderColor"],
          derived: true,
          get: function get() {
            return this.borderColor;
          },
          set: function set(value) {
            this.borderColor = value;
          }
        },
        submorphs: {
          after: ["extent"],
          initialize: function initialize() {
            this.submorphs = [{
              name: "messageText",
              type: "text",
              draggable: false,
              readOnly: true,
              selectable: true,
              fixedWidth: false,
              fixedHeight: false,
              clipMode: "visible",
              fontSize: 14,
              fontFamily: "Inconsolata, 'DejaVu Sans Mono', monospace"
            }, {
              name: "closeButton",
              type: "button",
              extent: lively_graphics.pt(22, 22),
              activeStyle: { fill: lively_graphics.Color.white },
              label: Icon$$1.makeLabel("close")
            }];
            this.relayout();
            lively_bindings.connect(this.getSubmorphNamed("closeButton"), "fire", this, "remove");
          }
        }
      };
    }
  }], __lively_classholder__, undefined, {
    start: 5127,
    end: 9233
  });
}(Morph$1);
var StatusMessageForMorph = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("StatusMessageForMorph") && typeof __lively_classholder__.StatusMessageForMorph === "function" ? __lively_classholder__.StatusMessageForMorph : __lively_classholder__.StatusMessageForMorph = function StatusMessageForMorph(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: "relayout",
    value: function StatusMessageForMorph_relayout_() {
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "relayout", this).call(this);
      var expandBtn = this.getSubmorphNamed("expandButton");
      if (expandBtn) {
        expandBtn.topRight = this.getSubmorphNamed("closeButton").topLeft.addXY(-3, 0);
      }
    }
  }, {
    key: "alignAtBottomOf",
    value: function StatusMessageForMorph_alignAtBottomOf_(forMorph) {
      var world = this.world();
      if (!world) return;
      this.bringToFront();
      this.fit();
      this.width = forMorph.width;
      this.relayout();
      if (forMorph.world()) this.position = forMorph.owner.worldPoint(forMorph.bounds().bottomLeft());
      var visibleBounds = world.visibleBounds(),
          bounds = this.bounds(),
          overlapY = bounds.top() + this.height - visibleBounds.bottom();
      if (overlapY > 0) this.moveBy(lively_graphics.pt(0, -overlapY));
    }
  }, {
    key: "onMouseUp",
    value: function StatusMessageForMorph_onMouseUp_(evt) {}
  }], [{
    key: "properties",
    get: function get() {
      return {
        slidable: { defaultValue: false },
        removeOnTargetMorphChange: { defaultValue: true },
        targetMorph: {
          defaultValue: null,
          get: function get() {
            var id = this.getProperty("targetMorph");
            return id && $world.getMorphWithId(id);
          },
          set: function set(morph$$1) {
            this.setProperty("targetMorph", morph$$1 ? morph$$1.id : null);
            this.alignAtBottomOf(morph$$1);
          }
        },
        expandable: {
          after: ["submorphs"],
          set: function set(val) {
            this.setProperty("expandable", val);
            if (val) {
              if (!this.getSubmorphNamed("expandButton")) {
                var btn = this.addMorph({
                  name: "expandButton",
                  type: "button",
                  extent: lively_graphics.pt(22, 22),
                  activeStyle: { fill: lively_graphics.Color.white },
                  label: Icon$$1.makeLabel("expand")
                });
                lively_bindings.connect(btn, "fire", this, "expand");
              }
            } else {
              if (this.getSubmorphNamed("expandButton")) {
                this.getSubmorphNamed("expandButton").remove();
                lively_bindings.disconnect(btn, "fire", this, "expand");
              }
            }
            this.relayout();
          }
        }
      };
    }
  }], __lively_classholder__, undefined, {
    start: 9460,
    end: 11644
  });
}(StatusMessage);

var TooltipViewer$$1 = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("TooltipViewer") && typeof __lively_classholder__.TooltipViewer === "function" ? __lively_classholder__.TooltipViewer : __lively_classholder__.TooltipViewer = function TooltipViewer$$1(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function TooltipViewer_initialize_(world) {
      this.currenMorph = world;
    }
  }, {
    key: "notPartOfCurrentTooltip",
    value: function TooltipViewer_notPartOfCurrentTooltip_(newTarget) {
      return !newTarget.ownerChain().includes(this.currentMorph);
    }
  }, {
    key: "invalidatesCurrentTooltip",
    value: function TooltipViewer_invalidatesCurrentTooltip_(newTarget) {
      return newTarget.tooltip || this.notPartOfCurrentTooltip(newTarget);
    }
  }, {
    key: "mouseMove",
    value: function TooltipViewer_mouseMove_(_ref) {
      var targetMorph = _ref.targetMorph,
          hand = _ref.hand;

      if (this.currentMorph === targetMorph || !this.invalidatesCurrentTooltip(targetMorph)) return;
      this.hoverOutOfMorph(this.currentMorph);
      this.hoverIntoMorph(targetMorph, hand);
      this.currentMorph = targetMorph;
    }
  }, {
    key: "mouseDown",
    value: function TooltipViewer_mouseDown_(_ref2) {
      var targetMorph = _ref2.targetMorph;

      this.currentTooltip && this.currentTooltip.remove();
      this.currentTooltip = null;
    }
  }, {
    key: "hoverIntoMorph",
    value: function TooltipViewer_hoverIntoMorph_(morph$$1, hand) {
      this.clearScheduledTooltip();
      if (this.currentTooltip) {
        this.showTooltipFor(morph$$1, hand);
      } else {
        this.scheduleTooltipFor(morph$$1, hand);
      }
    }
  }, {
    key: "hoverOutOfMorph",
    value: function TooltipViewer_hoverOutOfMorph_(morph$$1) {
      var _this = this;

      var current = this.currentTooltip;
      this.currentTooltip && this.currentTooltip.softRemove(function (tooltip) {
        return _this.currentTooltip == tooltip && (_this.currentTooltip = null);
      });
    }
  }, {
    key: "scheduleTooltipFor",
    value: function TooltipViewer_scheduleTooltipFor_(morph$$1, hand) {
      var _this2 = this;

      this.timer = setTimeout(function () {
        return _this2.showTooltipFor(morph$$1, hand);
      }, config.showTooltipsAfter * 1000);
    }
  }, {
    key: "clearScheduledTooltip",
    value: function TooltipViewer_clearScheduledTooltip_() {
      clearTimeout(this.timer);
    }
  }, {
    key: "showTooltipFor",
    value: function TooltipViewer_showTooltipFor_(morph$$1, hand) {
      if (!morph$$1.tooltip || !morph$$1.world()) return;
      this.currentTooltip && this.currentTooltip.remove();
      var position = hand ? hand.position.addXY(10, 7) : morph$$1.globalBounds().bottomRight();
      this.currentTooltip = new Tooltip$$1({
        position: position,
        description: morph$$1.tooltip
      });
      morph$$1.world().addMorph(this.currentTooltip);
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 119,
    end: 1822
  });
}(undefined);
var Tooltip$$1 = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("Tooltip") && typeof __lively_classholder__.Tooltip === "function" ? __lively_classholder__.Tooltip : __lively_classholder__.Tooltip = function Tooltip$$1(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function Tooltip_initialize_(props) {
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, Object.assign({}, props, {
        draggable: false,
        fill: lively_graphics.Color.black.withA(0.5),
        borderRadius: 4,
        layout: new HorizontalLayout({ spacing: 5 }),
        submorphs: [new Label$$1({
          width: 200,
          fixedWidth: props.description.length > 40,
          value: props.description,
          fill: lively_graphics.Color.transparent,
          fontColor: lively_graphics.Color.white
        })]
      }));
    }
  }, {
    key: "description",
    set: function set(stringOrAttributes) {
      var _submorphs = slicedToArray(this.submorphs, 1),
          descriptor = _submorphs[0];

      descriptor.value = stringOrAttributes;
    }
  }, {
    key: "softRemove",
    value: function () {
      var _ref3 = asyncToGenerator(regeneratorRuntime.mark(function _callee(cb) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.animate({ opacity: 0 });

              case 2:
                cb && cb(this);
                this.remove();

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function Tooltip_softRemove_(_x) {
        return _ref3.apply(this, arguments);
      }

      return Tooltip_softRemove_;
    }()
  }], undefined, __lively_classholder__, undefined, {
    start: 1831,
    end: 2505
  });
}(Morph$1);

var _this$1 = undefined;

function asItem(obj$$1) {
  if (obj$$1 && obj$$1.isListItem && typeof obj$$1.string === "string") return obj$$1;
  if (!obj$$1 || !obj$$1.isListItem) return {
    isListItem: true,
    string: String(obj$$1),
    value: obj$$1
  };
  var label = obj$$1.string || obj$$1.label || "no item.string";
  obj$$1.string = typeof label === "string" ? label : Array.isArray(label) ? label.map(function (ea) {
    return String(ea[0]);
  }).join("") : String(label);
  return obj$$1;
}
function ListItemMorph_Builder() { 
              if (ListItemMorph) return ListItemMorph;
              if (!Label$$1) {
                 setTimeout(ListItemMorph_Builder, 0);
                 return;
              }
        ListItemMorph = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("ListItemMorph") && typeof __lively_classholder__.ListItemMorph === "function" ? __lively_classholder__.ListItemMorph : __lively_classholder__.ListItemMorph = function ListItemMorph(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: "displayItem",
    value: function ListItemMorph_displayItem_(item, itemIndex, goalWidth, itemHeight, pos) {
      var isSelected = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
      var props = arguments[6];

      if (props.fontFamily) this.fontFamily = props.fontFamily;
      if (props.selectionColor) this.selectionColor = props.selectionColor;
      if (props.selectionFontColor) this.selectionFontColor = props.selectionFontColor;
      if (props.nonSelectionFontColor) this.nonSelectionFontColor = props.nonSelectionFontColor;
      if (props.fontSize) this.fontSize = props.fontSize;
      if (props.padding) this.padding = props.padding;
      var label = item.label || item.string || "no item.string";
      if (item.annotation) this.valueAndAnnotation = {
        value: label,
        annotation: item.annotation
      };else if (typeof label === "string") this.textString = label;else this.value = label;
      this.tooltip = this.textString;
      this.itemIndex = itemIndex;
      this.position = pos;
      this.extent = lively_graphics.pt(Math.max(goalWidth, this.textBounds().width), itemHeight);
      this.fill = isSelected ? this.selectionColor : null;
      this.fontColor = isSelected ? this.selectionFontColor : this.nonSelectionFontColor;
    }
  }, {
    key: "onMouseDown",
    value: function ListItemMorph_onMouseDown_(evt) {
      this.owner.owner.onItemMorphClicked(evt, this);
    }
  }], [{
    key: "properties",
    get: function get() {
      return {
        autofit: { defaultValue: false },
        fill: { defaultValue: null },
        itemIndex: { defaultValue: undefined },
        selectionFontColor: { defaultValue: lively_graphics.Color.white },
        selectionColor: { defaultValue: lively_graphics.Color.blue },
        nonSelectionFontColor: { defaultValue: lively_graphics.Color.rgbHex("333") },
        fontColor: { defaultValue: lively_graphics.Color.rgbHex("333") }
      };
    }
  }], __lively_classholder__, undefined, {
    start: 772,
    end: 2468
  });
}(Label$$1);
        return ListItemMorph}
var listCommands = [{
  name: "page up",
  exec: function exec(list) {
    var index = list.selectedIndex,
        newIndex = Math.max(0, index - Math.round(list.height / list.itemHeight));
    list.gotoIndex(newIndex);
    return true;
  }
}, {
  name: "page down",
  exec: function exec(list) {
    var index = list.selectedIndex,
        newIndex = Math.min(list.items.length - 1, index + Math.round(list.height / list.itemHeight));
    list.gotoIndex(newIndex);
    return true;
  }
}, {
  name: "goto first item",
  exec: function exec(list) {
    list.gotoIndex(0);
    return true;
  }
}, {
  name: "goto last item",
  exec: function exec(list) {
    list.gotoIndex(list.items.length - 1);
    return true;
  }
}, {
  name: "arrow up",
  exec: function exec(list) {
    list.gotoIndex(list.indexUp());
    return true;
  }
}, {
  name: "arrow down",
  exec: function exec(list) {
    list.gotoIndex(list.indexDown());
    return true;
  }
}, {
  name: "select up",
  exec: function exec(list) {
    var selected = list.selectedIndexes;
    if (!list.multiSelect || !selected.length) return list.execCommand("arrow up");
    var current = selected[0];
    if (typeof current !== "number") list.selectedIndexes = [current];else {
      var up = list.indexUp(current);
      if (selected.includes(current) && selected.includes(up)) {
        list.selectedIndexes = selected.filter(function (ea) {
          return ea !== current;
        });
      } else {
        list.selectedIndexes = [up].concat(selected.filter(function (ea) {
          return ea !== up;
        }));
      }
    }
    return true;
  }
}, {
  name: "select down",
  exec: function exec(list) {
    var selected = list.selectedIndexes;
    if (!list.multiSelect || !selected.length) return list.execCommand("arrow down");
    var current = selected[0],
        down = list.indexDown(current);
    if (selected.includes(current) && selected.includes(down)) {
      list.selectedIndexes = selected.filter(function (ea) {
        return ea !== current;
      });
    } else {
      list.selectedIndexes = [down].concat(selected.filter(function (ea) {
        return ea !== down;
      }));
    }
    return true;
  }
}, {
  name: "select all",
  exec: function exec(list) {
    list.selectedIndexes = lively_lang.arr.range(list.items.length - 1, 0);
    list.scrollIndexIntoView(list.selectedIndexes[0]);
    return true;
  }
}, {
  name: "select via filter",
  exec: function () {
    var _ref = asyncToGenerator(regeneratorRuntime.mark(function _callee(list) {
      var preselect, _ref2, selected;

      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              preselect = list.selectedIndex || 0;
              _context.next = 3;
              return list.world().filterableListPrompt("Select item", list.items, {
                preselect: preselect,
                requester: list.getWindow() || list,
                itemPadding: lively_graphics.Rectangle.inset(0, 2),
                multiSelect: true
              });

            case 3:
              _ref2 = _context.sent;
              selected = _ref2.selected;

              if (selected.length) {
                if (list.multiSelect) list.selections = selected;else list.selection = selected[0];
                list.scrollSelectionIntoView();
                list.update();
              }
              return _context.abrupt("return", true);

            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, _this$1);
    }));

    return function exec(_x2) {
      return _ref.apply(this, arguments);
    };
  }()
}, {
  name: "realign top-bottom-center",
  exec: function exec(list) {
    if (!list.selection) return;
    var padding = list.padding,
        idx = list.selectedIndex,
        itemHeight = list.itemHeight,
        _list$scroll = list.scroll,
        scrollX = _list$scroll.x,
        scrollY = _list$scroll.y,
        pos = lively_graphics.pt(0, idx * itemHeight),
        offsetX = 0,
        offsetY = 0,
        h$$1 = list.height - itemHeight - padding.top() - padding.bottom();

    if (Math.abs(pos.y - scrollY) < 2) {
      scrollY = pos.y - h$$1;
    } else if (Math.abs(pos.y - scrollY - h$$1 * 0.5) < 2) {
      scrollY = pos.y;
    } else {
      scrollY = pos.y - h$$1 * 0.5;
    }
    list.scroll = lively_graphics.pt(scrollX, scrollY);
    return true;
  }
}, {
  name: "print contents in text window",
  exec: function exec(list) {
    var title = "items of " + list.name,
        content = list.items.map(function (item) {
      if (typeof item === "string") return item;
      var string$$1 = item.string,
          label = item.label,
          annotation = item.annotation,
          result = "";

      if (label) {
        if (typeof label === "string") result += label;else result += label.map(function (_ref3) {
          var _ref4 = slicedToArray(_ref3, 1),
              ea = _ref4[0];

          return ea;
        }).join("");
      } else if (string$$1) result += string$$1;
      if (annotation) {
        result += " ";
        if (typeof annotation === "string") result += annotation;else result += annotation[0];
      }
      return result;
    }).join("\n");
    return list.world().execCommand("open text window", {
      title: title,
      content: content,
      name: title,
      fontFamily: "Inconsolata, monospace"
    });
  }
}];
var List$$1 = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("List") && typeof __lively_classholder__.List === "function" ? __lively_classholder__.List : __lively_classholder__.List = function List$$1(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function List_initialize_() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (!props.bounds && !props.extent) props.extent = lively_graphics.pt(400, 360);
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, props);
      this.update();
    }
  }, {
    key: "listStyle",
    value: function List_listStyle_(theme) {
      if (theme == "dark") {
        return new StyleRules({
          list: {
            fill: lively_graphics.Color.transparent,
            hideScrollbars: true,
            nonSelectionFontColor: lively_graphics.Color.gray,
            selectionFontColor: lively_graphics.Color.black,
            selectionColor: lively_graphics.Color.gray.lighter(),
            padding: lively_graphics.Rectangle.inset(2, 0)
          }
        });
      } else {
        return new StyleRules({ list: { padding: lively_graphics.Rectangle.inset(2, 0) } });
      }
    }
  }, {
    key: "isList",
    get: function get() {
      return true;
    }
  }, {
    key: "onChange",
    value: function List_onChange_(change) {
      var prop = change.prop;

      if (prop === "fontFamily" || prop === "fontSize" || prop === "padding" || prop === "itemPadding" || prop === "items") this.update();
      return lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "onChange", this).call(this, change);
    }
  }, {
    key: "connections",
    get: function get() {
      return { selection: { signalOnAssignment: false } };
    }
  }, {
    key: "invalidateCache",
    value: function List_invalidateCache_() {
      delete this._itemHeight;
    }
  }, {
    key: "find",
    value: function List_find_(itemOrValue) {
      return this.items.find(function (item) {
        return item === itemOrValue || item.value === itemOrValue;
      });
    }
  }, {
    key: "findIndex",
    value: function List_findIndex_(itemOrValue) {
      return this.items.findIndex(function (item) {
        return item === itemOrValue || item.value === itemOrValue;
      });
    }
  }, {
    key: "addItem",
    value: function List_addItem_(item) {
      return this.addItemAt(item);
    }
  }, {
    key: "addItemAt",
    value: function List_addItemAt_(item) {
      var _this2 = this;

      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.items.length;

      var items = this.items,
          index = Math.min(items.length, Math.max(0, index));
      items.splice(index, 0, asItem(item));
      this.addMethodCallChangeDoing({
        target: this,
        selector: "addItemAt",
        args: [item, index],
        undo: {
          target: this,
          selector: "removeItem",
          args: [item]
        }
      }, function () {
        return _this2.update();
      });
    }
  }, {
    key: "removeItem",
    value: function List_removeItem_(itemOrValue) {
      var _this3 = this;

      var item = this.find(itemOrValue),
          items = this.items,
          index = items.indexOf(item);
      if (index === -1) return;
      items.splice(index, 1);
      this.addMethodCallChangeDoing({
        target: this,
        selector: "removeItem",
        args: [item],
        undo: {
          target: this,
          selector: "addItemAt",
          args: [item, index]
        }
      }, function () {
        return _this3.update();
      });
    }
  }, {
    key: "selectItemMorph",
    value: function List_selectItemMorph_(itemMorph) {
      this.selectedIndexes = [itemMorph.itemIndex];
    }
  }, {
    key: "gotoIndex",
    value: function List_gotoIndex_(i) {
      this.scrollIndexIntoView(this.selectedIndex = i);
    }
  }, {
    key: "indexUp",
    value: function List_indexUp_(from) {
      from = typeof from === "number" ? from : this.selectedIndex;
      return (from || this.items.length) - 1;
    }
  }, {
    key: "indexDown",
    value: function List_indexDown_() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.selectedIndex;

      index = typeof index === "number" ? index : -1;
      return (index + 1) % this.items.length;
    }
  }, {
    key: "update",
    value: function List_update_() {
      var _this4 = this;

      var items = this.items;
      if (!items) return;
      this.dontRecordChangesWhile(function () {
        var itemHeight = _this4.itemHeight,
            itemMorphs = _this4.itemMorphs,
            listItemContainer = _this4.listItemContainer,
            selectedIndexes = _this4.selectedIndexes,
            _scroll = _this4.scroll,
            left = _scroll.x,
            top = _scroll.y,
            _extent = _this4.extent,
            width = _extent.x,
            height = _extent.y,
            fontSize = _this4.fontSize,
            fontFamily = _this4.fontFamily,
            fontColor = _this4.fontColor,
            padding = _this4.padding,
            itemPadding = _this4.itemPadding,
            selectionColor = _this4.selectionColor,
            selectionFontColor = _this4.selectionFontColor,
            nonSelectionFontColor = _this4.nonSelectionFontColor,
            padding = padding || lively_graphics.Rectangle.inset(0),
            padTop = padding.top(),
            padLeft = padding.left(),
            padBottom = padding.bottom(),
            padRight = padding.right(),
            firstItemIndex = Math.floor((top + padTop) / itemHeight),
            lastItemIndex = Math.ceil((top + height + padTop) / itemHeight),
            maxWidth = 0,
            goalWidth = _this4.width - (padLeft + padRight);

        for (var i = 0; i < lastItemIndex - firstItemIndex; i++) {
          var itemIndex = firstItemIndex + i,
              item = items[itemIndex];
          if (!item) {
            itemMorphs.slice(i).forEach(function (itemMorph) {
              return itemMorph.remove();
            });
            break;
          }
          var itemMorph = itemMorphs[i] || (itemMorphs[i] = listItemContainer.addMorph(new ListItemMorph({
            fontFamily: fontFamily,
            fontSize: fontSize
          })));
          itemMorph.displayItem(item, itemIndex, goalWidth, itemHeight, lively_graphics.pt(0, 0 + itemHeight * itemIndex), selectedIndexes.includes(itemIndex), {
            fontFamily: fontFamily,
            selectionColor: selectionColor,
            selectionFontColor: selectionFontColor,
            nonSelectionFontColor: nonSelectionFontColor,
            fontSize: fontSize,
            padding: itemPadding || lively_graphics.Rectangle.inset(0)
          });
          maxWidth = Math.max(maxWidth, itemMorph.width);
        }
        itemMorphs.slice(lastItemIndex - firstItemIndex).forEach(function (ea) {
          return ea.remove();
        });
        listItemContainer.position = lively_graphics.pt(padLeft, padTop);
        listItemContainer.extent = lively_graphics.pt(maxWidth, Math.max(padTop + padBottom + itemHeight * items.length, _this4.height));
      });
    }
  }, {
    key: "scrollSelectionIntoView",
    value: function List_scrollSelectionIntoView_() {
      if (this.selection) this.scrollIndexIntoView(this.selectedIndex);
    }
  }, {
    key: "scrollIndexIntoView",
    value: function List_scrollIndexIntoView_(idx) {
      var itemHeight = this.itemHeight,
          width = this.width,
          scroll = this.scroll,
          itemBounds = new lively_graphics.Rectangle(0, idx * itemHeight, width, itemHeight),
          visibleBounds = this.innerBounds().insetByRect(this.padding).translatedBy(scroll),
          offsetX = 0,
          offsetY = 0;

      if (itemBounds.bottom() > visibleBounds.bottom()) offsetY = itemBounds.bottom() - visibleBounds.bottom();
      if (itemBounds.top() < visibleBounds.top()) offsetY = itemBounds.top() - visibleBounds.top();
      this.scroll = scroll.addXY(offsetX, offsetY);
    }
  }, {
    key: "onScroll",
    value: function List_onScroll_() {
      this.update();
    }
  }, {
    key: "onItemMorphClicked",
    value: function List_onItemMorphClicked_(evt, itemMorph) {
      var itemI = itemMorph.itemIndex,
          selectedIndexes = this.selectedIndexes,
          isClickOnSelected = selectedIndexes.includes(itemI),
          indexes = [];
      if (this.multiSelect) {
        if (evt.isCommandKey()) {
          if (isClickOnSelected) {
            indexes = selectedIndexes.filter(function (ea) {
              return ea != itemI;
            });
          } else {
            indexes = [itemI].concat(selectedIndexes.filter(function (ea) {
              return ea != itemI;
            }));
          }
        } else if (evt.isShiftDown()) {
          if (isClickOnSelected) {
            indexes = selectedIndexes.filter(function (ea) {
              return ea != itemI;
            });
          } else {
            var from = selectedIndexes[0],
                added = typeof from === "number" ? lively_lang.arr.range(itemI, from) : [itemI];
            indexes = added.concat(selectedIndexes.filter(function (ea) {
              return !added.includes(ea);
            }));
          }
        } else indexes = [itemI];
      } else indexes = [itemI];
      this.selectedIndexes = indexes;
    }
  }, {
    key: "keybindings",
    get: function get() {
      return [{
        keys: "Up|Ctrl-P",
        command: "arrow up"
      }, {
        keys: "Down|Ctrl-N",
        command: "arrow down"
      }, {
        keys: "Shift-Up",
        command: "select up"
      }, {
        keys: "Shift-Down",
        command: "select down"
      }, {
        keys: {
          win: "Ctrl-A",
          mac: "Meta-A"
        },
        command: "select all"
      }, {
        keys: "Alt-V|PageUp",
        command: "page up"
      }, {
        keys: "Ctrl-V|PageDown",
        command: "page down"
      }, {
        keys: "Alt-Shift-,",
        command: "goto first item"
      }, {
        keys: "Alt-Shift-.",
        command: "goto last item"
      }, {
        keys: "Enter",
        command: "accept input"
      }, {
        keys: "Escape|Ctrl-G",
        command: "cancel"
      }, {
        keys: "Alt-Space",
        command: "select via filter"
      }, {
        keys: "Ctrl-L",
        command: "realign top-bottom-center"
      }].concat(lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "keybindings", this));
    }
  }, {
    key: "commands",
    get: function get() {
      return listCommands;
    }
  }], [{
    key: "properties",
    get: function get() {
      return {
        morphClasses: { defaultValue: ["list"] },
        fill: { defaultValue: lively_graphics.Color.white },
        clipMode: { defaultValue: "auto" },
        theme: {
          after: ["styleRules"],
          set: function set(val) {
            this.setProperty("theme", val);
            this.styleRules = this.listStyle(val);
          }
        },
        extent: {
          set: function set(value) {
            if (value.eqPt(this.extent)) return;
            this.setProperty("extent", value);
            this.update();
          }
        },
        fontFamily: {
          defaultValue: "Helvetica Neue, Arial, sans-serif",
          set: function set(value) {
            this.setProperty("fontFamily", value);
            this.invalidateCache();
          }
        },
        fontSize: {
          defaultValue: 12,
          set: function set(value) {
            this.setProperty("fontSize", value);
            this.invalidateCache();
          }
        },
        padding: { defaultValue: lively_graphics.Rectangle.inset(3) },
        itemPadding: {
          defaultValue: lively_graphics.Rectangle.inset(1),
          set: function set(value) {
            this.setProperty("itemPadding", value);
            this.invalidateCache();
          }
        },
        items: {
          defaultValue: [],
          after: ["submorphs"],
          set: function set(items) {
            this.setProperty("items", items.map(asItem));
            this.update();
          }
        },
        multiSelect: { defaultValue: false },
        values: {
          after: ["items"],
          readOnly: true,
          get: function get() {
            return this.items.map(function (ea) {
              return ea.value;
            });
          }
        },
        selectedIndex: {
          defaultValue: [],
          after: ["selectedIndexes"],
          get: function get() {
            return this.selectedIndexes[0];
          },
          set: function set(i) {
            return this.selectedIndexes = typeof i === "number" ? [i] : [];
          }
        },
        selectedIndexes: {
          after: ["items"],
          get: function get() {
            return this.getProperty("selectedIndexes") || [];
          },
          set: function set(indexes) {
            var maxLength = this.items.length;
            this.setProperty("selectedIndexes", (indexes || []).filter(function (i) {
              return 0 <= i && i < maxLength;
            }));
            this.update();
            lively_bindings.signal(this, "selection", this.selection);
          }
        },
        selection: {
          after: ["selections"],
          get: function get() {
            return this.selections[0];
          },
          set: function set(itemOrValue) {
            this.selections = [itemOrValue];
          }
        },
        selections: {
          after: ["selectedIndexes"],
          get: function get() {
            var _this5 = this;

            return this.selectedIndexes.map(function (i) {
              return _this5.items[i] && _this5.items[i].value;
            });
          },
          set: function set(sels) {
            var _this6 = this;

            this.selectedIndexes = sels.map(function (ea) {
              return _this6.findIndex(ea);
            });
          }
        },
        selectedItems: {
          after: ["selectedIndexes"],
          readOnly: true,
          get: function get() {
            var _this7 = this;

            return this.selectedIndexes.map(function (i) {
              return _this7.items[i];
            });
          }
        },
        listItemContainer: {
          after: ["submorphs"],
          readOnly: true,
          get: function get() {
            return this.getSubmorphNamed("listItemContainer") || this.addMorph({
              name: "listItemContainer",
              fill: null,
              clipMode: "visible",
              halosEnabled: false
            });
          }
        },
        itemMorphs: {
          after: ["submorphs"],
          readOnly: true,
          get: function get() {
            return this.listItemContainer.submorphs;
          }
        },
        itemHeight: {
          after: ["fontFamily", "fontSize", "itemPadding"],
          readOnly: true,
          get: function get() {
            if (this._itemHeight) return this._itemHeight;
            var h$$1 = this.env.fontMetric.defaultLineHeight({
              fontFamily: this.fontFamily,
              fontSize: this.fontSize
            });
            var padding = this.itemPadding;
            if (padding) h$$1 += padding.top() + padding.bottom();
            return this._itemHeight = h$$1;
          }
        }
      };
    }
  }], __lively_classholder__, undefined, {
    start: 6848,
    end: 18306
  });
}(Morph$1);
var FilterableList$$1 = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("FilterableList") && typeof __lively_classholder__.FilterableList === "function" ? __lively_classholder__.FilterableList : __lively_classholder__.FilterableList = function FilterableList$$1(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function FilterableList_initialize_() {
      var _this8 = this;

      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (!props.bounds && !props.extent) props.extent = lively_graphics.pt(400, 360);
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, props);
      lively_bindings.connect(this.get("input"), "inputChanged", this, "updateFilter");
      lively_bindings.connect(this.listMorph, "selection", this, "selectionChanged");
      lively_bindings.connect(this, "extent", this, "relayout");
      this.relayout();
      setTimeout(function () {
        return _this8.relayout();
      });
    }
  }, {
    key: "relayout",
    value: function FilterableList_relayout_() {
      var inputMorph = this.inputMorph,
          listMorph = this.listMorph;

      listMorph.width = inputMorph.width = this.width;
      listMorph.setBounds(this.innerBounds().withTopLeft(inputMorph.bottomLeft.addXY(0, 5)));
    }
  }, {
    key: "isList",
    get: function get() {
      return true;
    }
  }, {
    key: "inputStyle",
    value: function FilterableList_inputStyle_(theme) {
      if (theme == "dark") {
        return new StyleRules({
          input: {
            borderWidth: 0,
            borderRadius: 20,
            fill: lively_graphics.Color.gray.withA(0.8),
            fontColor: lively_graphics.Color.gray.darker(),
            padding: lively_graphics.rect(10, 2)
          }
        });
      } else {
        return new StyleRules({
          input: {
            borderWidth: 1,
            borderColor: lively_graphics.Color.gray
          }
        });
      }
    }
  }, {
    key: "focus",
    value: function FilterableList_focus_() {
      this.get("input").focus();
    }
  }, {
    key: "selectionChanged",
    value: function FilterableList_selectionChanged_(sel) {
      lively_bindings.signal(this, "selection", sel);
    }
  }, {
    key: "scrollSelectionIntoView",
    value: function FilterableList_scrollSelectionIntoView_() {
      return this.listMorph.scrollSelectionIntoView();
    }
  }, {
    key: "parseInput",
    value: function FilterableList_parseInput_() {
      var filterText = this.get("input").textString,
          parsed = Array.from(filterText).reduce(function (state, char) {
        if (char === "\\" && !state.escaped) {
          state.escaped = true;
          return state;
        }
        if (char === " " && !state.escaped) {
          if (!state.spaceSeen && state.current) {
            state.tokens.push(state.current);
            state.current = "";
          }
          state.spaceSeen = true;
        } else {
          state.spaceSeen = false;
          state.current += char;
        }
        state.escaped = false;
        return state;
      }, {
        tokens: [],
        current: "",
        escaped: false,
        spaceSeen: false
      });
      parsed.current && parsed.tokens.push(parsed.current);
      var lowercasedTokens = parsed.tokens.map(function (ea) {
        return ea.toLowerCase();
      });
      return {
        tokens: parsed.tokens,
        lowercasedTokens: lowercasedTokens
      };
    }
  }, {
    key: "updateFilter",
    value: function FilterableList_updateFilter_() {
      var parsedInput = this.parseInput(),
          filterFunction = this.filterFunction,
          sortFunction = this.sortFunction,
          filteredItems = this.items.filter(function (item) {
        return filterFunction(parsedInput, item);
      });
      if (sortFunction) filteredItems = lively_lang.arr.sortBy(filteredItems, function (ea) {
        return sortFunction(parsedInput, ea);
      });
      var list = this.listMorph,
          newSelectedIndexes = this.updateSelectionsAfterFilter ? list.selectedIndexes.map(function (i) {
        return filteredItems.indexOf(list.items[i]);
      }).filter(function (i) {
        return i !== -1;
      }) : list.selectedIndexes;
      list.items = filteredItems;
      list.selectedIndexes = newSelectedIndexes.length ? newSelectedIndexes : filteredItems.length ? [0] : [];
      this.scrollSelectionIntoView();
    }
  }, {
    key: "acceptInput",
    value: function FilterableList_acceptInput_() {
      var list = this.listMorph;
      this.get("input").acceptInput();
      var result = {
        filtered: this.items,
        selected: list.selections,
        status: "accepted"
      };
      lively_bindings.signal(this, "accepted", result);
      return result;
    }
  }, {
    key: "keybindings",
    get: function get() {
      return [{
        keys: "Up|Ctrl-P",
        command: "arrow up"
      }, {
        keys: "Down|Ctrl-N",
        command: "arrow down"
      }, {
        keys: "Shift-Up",
        command: "select up"
      }, {
        keys: "Shift-Down",
        command: "select down"
      }, {
        keys: {
          win: "Ctrl-A",
          mac: "Meta-A"
        },
        command: "select all"
      }, {
        keys: "Alt-V|PageUp",
        command: "page up"
      }, {
        keys: "Ctrl-V|PageDown",
        command: "page down"
      }, {
        keys: "Alt-Shift-,",
        command: "goto first item"
      }, {
        keys: "Alt-Shift-.",
        command: "goto last item"
      }, {
        keys: "Enter",
        command: "accept input"
      }, {
        keys: "Escape|Ctrl-G",
        command: "cancel"
      }].concat(lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "keybindings", this));
    }
  }, {
    key: "commands",
    get: function get() {
      var _this9 = this;

      return lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "commands", this).concat([{
        name: "accept input",
        exec: function exec(morph$$1) {
          _this9.acceptInput();
          return true;
        }
      }, {
        name: "cancel",
        exec: function exec(morph$$1) {
          lively_bindings.signal(morph$$1, "canceled");
          return true;
        }
      }].concat(toConsumableArray(listCommands.map(function (cmd) {
        return Object.assign({}, cmd, { exec: function exec(morph$$1, opts, count) {
            return cmd.exec(_this9.listMorph, opts, count);
          } });
      }))));
    }
  }], [{
    key: "properties",
    get: function get() {
      return {
        fill: { defaultValue: lively_graphics.Color.transparent },
        borderColor: { defaultValue: lively_graphics.Color.gray },
        borderWidth: { borderWidth: 1 },
        updateSelectionsAfterFilter: { defaultValue: false },
        submorphs: {
          initialize: function initialize() {
            this.submorphs = [Text$1.makeInputLine({
              name: "input",
              fixedHeight: false,
              autofit: false
            }), new List$$1({
              name: "list",
              items: [],
              clipMode: "auto"
            })];
          }
        },
        listMorph: {
          derived: true,
          readOnly: true,
          after: ["submorphs"],
          get: function get() {
            return this.getSubmorphNamed("list");
          }
        },
        inputMorph: {
          derived: true,
          readOnly: true,
          after: ["submorphs"],
          get: function get() {
            return this.getSubmorphNamed("input");
          }
        },
        theme: {
          after: ["submorphs"],
          get: function get() {
            return this.listMorph.theme;
          },
          set: function set(val) {
            this.listMorph.theme = val;
            this.inputMorph.styleRules = this.inputStyle(val);
          }
        },
        fontFamily: {
          derived: true,
          after: ["submorphs"],
          defaultValue: "Helvetica Neue, Arial, sans-serif",
          get: function get() {
            return this.listMorph.fontFamily;
          },
          set: function set(val) {
            this.listMorph.fontFamily = val;
            this.inputMorph.fontFamily = val;
            this.relayout();
          }
        },
        padding: {
          derived: true,
          after: ["submorphs"],
          defaultValue: lively_graphics.Rectangle.inset(2, 0),
          get: function get() {
            return this.listMorph.padding;
          },
          set: function set(val) {
            this.listMorph.padding = val;
            this.inputMorph.padding = val;
            this.relayout();
          }
        },
        fontSize: {
          derived: true,
          after: ["submorphs"],
          defaultValue: 11,
          get: function get() {
            return this.listMorph.fontSize;
          },
          set: function set(val) {
            this.listMorph.fontSize = val;
            this.inputMorph.fontSize = val;
            this.relayout();
          }
        },
        itemPadding: {
          derived: true,
          after: ["submorphs"],
          get: function get() {
            return this.listMorph.itemPadding;
          },
          set: function set(val) {
            this.listMorph.itemPadding = val;
          }
        },
        input: {
          derived: true,
          after: ["submorphs"],
          defaultValue: "",
          get: function get() {
            return this.inputMorph.input;
          },
          set: function set(val) {
            this.inputMorph.input = val;
          }
        },
        historyId: {
          derived: true,
          after: ["submorphs"],
          defaultValue: null,
          get: function get() {
            return this.inputMorph.historyId;
          },
          set: function set(val) {
            this.inputMorph.historyId = val;
          }
        },
        multiSelect: {
          derived: true,
          after: ["submorphs"],
          get: function get() {
            return this.listMorph.multiSelect;
          },
          set: function set(multiSelect) {
            this.listMorph.multiSelect = multiSelect;
          }
        },
        items: {
          after: ["submorphs"],
          defaultValue: [],
          set: function set(items) {
            this.setProperty("items", items.map(asItem));
            this.updateFilter();
          }
        },
        visibleItems: {
          derived: true,
          after: ["submorphs"],
          get visibleItems() {
            return this.listMorph.items;
          }
        },
        selection: {
          derived: true,
          after: ["submorphs"],
          get: function get() {
            return this.listMorph.selection;
          },
          set: function set(x) {
            this.listMorph.selection = x;
          }
        },
        selectedIndex: {
          derived: true,
          after: ["submorphs"],
          get: function get() {
            return this.listMorph.selectedIndex;
          },
          set: function set(x) {
            this.listMorph.selectedIndex = x;
          }
        },
        fuzzy: {
          derived: true,
          after: ["filterFunction", "sortFunction"],
          set: function set(fuzzy) {
            this.setProperty("fuzzy", fuzzy);
            if (!fuzzy) {
              if (this.sortFunction === this.fuzzySortFunction) this.sortFunction = null;
              if (this.filterFunction === this.fuzzyFilterFunction) this.filterFunction = this.defaultFilterFunction;
            } else {
              if (!this.sortFunction) this.sortFunction = this.fuzzySortFunction;
              if (this.filterFunction == this.defaultFilterFunction) this.filterFunction = this.fuzzyFilterFunction;
            }
          }
        },
        filterFunction: {
          get: function get() {
            return this.getProperty("filterFunction") || this.defaultFilterFunction;
          }
        },
        sortFunction: {},
        defaultFilterFunction: {
          readOnly: true,
          get: function get() {
            return this._defaultFilterFunction || (this._defaultFilterFunction = function (parsedInput, item) {
              return parsedInput.lowercasedTokens.every(function (token) {
                return item.string.toLowerCase().includes(token);
              });
            });
          }
        },
        fuzzySortFunction: {
          get: function get() {
            var _this10 = this;

            return this._fuzzySortFunction || (this._fuzzySortFunction = function (parsedInput, item) {
              var prop = typeof _this10.fuzzy === "string" ? _this10.fuzzy : "string";
              var fuzzyValue = String(lively_lang.Path(prop).get(item)).toLowerCase();
              var base = 0;
              parsedInput.lowercasedTokens.forEach(function (t) {
                if (fuzzyValue.startsWith(t)) base -= 10;else if (fuzzyValue.includes(t)) base -= 5;
              });
              return lively_lang.arr.sum(parsedInput.lowercasedTokens.map(function (token) {
                return lively_lang.string.levenshtein(fuzzyValue.toLowerCase(), token);
              })) + base;
            });
          }
        },
        fuzzyFilterFunction: {
          get: function get() {
            var _this11 = this;

            return this._fuzzyFilterFunction || (this._fuzzyFilterFunction = function (parsedInput, item) {
              var prop = typeof _this11.fuzzy === "string" ? _this11.fuzzy : "string";
              var tokens = parsedInput.lowercasedTokens;
              if (tokens.every(function (token) {
                return item.string.toLowerCase().includes(token);
              })) return true;
              var fuzzyValue = String(lively_lang.Path(prop).get(item)).toLowerCase();
              return lively_lang.arr.sum(parsedInput.lowercasedTokens.map(function (token) {
                return lively_lang.string.levenshtein(fuzzyValue, token);
              })) <= 3;
            });
          }
        }
      };
    }
  }], __lively_classholder__, undefined, {
    start: 18419,
    end: 29158
  });
}(Morph$1);
function DropDownList$$1_Builder() { 
              if (DropDownList$$1) return DropDownList$$1;
              if (!Button$$1) {
                 setTimeout(DropDownList$$1_Builder, 0);
                 return;
              }
        DropDownList$$1 = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("DropDownList") && typeof __lively_classholder__.DropDownList === "function" ? __lively_classholder__.DropDownList : __lively_classholder__.DropDownList = function DropDownList$$1(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function DropDownList_initialize_() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, props);
      lively_bindings.connect(this, "fire", this, "toggleList");
    }
  }, {
    key: "isListVisible",
    value: function DropDownList_isListVisible_() {
      return this.list.owner === this;
    }
  }, {
    key: "toggleList",
    value: function DropDownList_toggleList_() {
      var list = this.list;
      if (this.isListVisible()) {
        lively_bindings.signal(this, "deactivated");
        this.selection = list.selection;
        list.remove();
      } else {
        lively_bindings.signal(this, "activated");
        this.addMorph(list);
        list.topLeft = this.innerBounds().bottomLeft();
        list.extent = lively_graphics.pt(this.width, 100);
        list.focus();
      }
    }
  }, {
    key: "commands",
    get: function get() {
      var _this12 = this;

      return [{
        name: "accept",
        exec: function exec() {
          if (_this12.isListVisible()) _this12.toggleList();
          return true;
        }
      }, {
        name: "cancel",
        exec: function exec() {
          if (_this12.isListVisible()) _this12.list.remove();
          return true;
        }
      }].concat(lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "commands", this));
    }
  }, {
    key: "keybindings",
    get: function get() {
      return lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "keybindings", this).concat([{
        keys: "Enter",
        command: "accept"
      }, {
        keys: "Escape|Ctrl-G",
        command: "cancel"
      }]);
    }
  }], [{
    key: "properties",
    get: function get() {
      return {
        borderRadius: { defaultValue: 2 },
        padding: { defaultValue: lively_graphics.Rectangle.inset(3, 2) },
        list: {
          readOnly: true,
          after: ["submorphs"],
          get: function get() {
            if (this._list) return this._list;
            return this._list = new List$$1({
              name: "list",
              fontSize: this.fontSize,
              fontFamily: this.fontFamily,
              fontColor: this.fontColor,
              border: this.border
            });
          }
        },
        items: {
          derived: true,
          after: ["list"],
          get: function get() {
            return this.list.items;
          },
          set: function set(value) {
            this.list.items = value;
          }
        },
        selection: {
          after: ["list"],
          set selection(value) {
            this.setProperty("selection", value);
            if (!value) {
              this.list.selection = null;
              this.label = "";
            } else {
              var item = this.list.find(value);
              this.label = item ? [[item.string || String(item), {}], [" ", {}], Icon$$1.textAttribute("caret-down")] : "selection not found in list";
              this.list.selection = value;
            }
          }
        }
      };
    }
  }], __lively_classholder__, undefined, {
    start: 29168,
    end: 31540
  });
}(Button$$1);
        return DropDownList$$1}

function comparePosition(pos1, pos2) {
  var row = pos1.row,
      column = pos1.column,
      row2 = pos2.row,
      column2 = pos2.column;

  if (row < row2) return -2;
  if (row === row2) {
    if (column < column2) return -1;
    if (column === column2) return 0;
    return 1;
  }
  return 2;
}
function lessPosition(p1, p2) {
  return comparePosition(p1, p2) < 0;
}
function lessEqPosition(p1, p2) {
  return comparePosition(p1, p2) <= 0;
}
function eqPosition(p1, p2) {
  return comparePosition(p1, p2) === 0;
}
function minPosition(p1, p2) {
  return lessPosition(p1, p2) ? p1 : p2;
}
function maxPosition(p1, p2) {
  return lessPosition(p1, p2) ? p2 : p1;
}

var Range = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("Range") && typeof __lively_classholder__.Range === "function" ? __lively_classholder__.Range : __lively_classholder__.Range = function Range(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function Range_initialize_() {
      var range = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        start: {
          row: 0,
          column: 0
        },
        end: {
          row: 0,
          column: 0
        }
      };
      var _range$start = range.start,
          startRow = _range$start.row,
          startColumn = _range$start.column,
          _range$end = range.end,
          endRow = _range$end.row,
          endColumn = _range$end.column;

      if (endRow < startRow || endRow === startRow && endColumn < startColumn) {
        
        var _ref = [startRow, startColumn, endRow, endColumn];
        endRow = _ref[0];
        endColumn = _ref[1];
        startRow = _ref[2];
        startColumn = _ref[3];
      }this.start = {
        row: startRow,
        column: startColumn
      };
      this.end = {
        row: endRow,
        column: endColumn
      };
    }
  }, {
    key: "isRange",
    get: function get() {
      return true;
    }
  }, {
    key: "isEmpty",
    value: function Range_isEmpty_() {
      return this.start.row === this.end.row && this.start.column === this.end.column;
    }
  }, {
    key: "equals",
    value: function Range_equals_(other) {
      if (!other || !other.start || !other.end) return false;
      return eqPosition(this.start, other.start) && eqPosition(this.end, other.end);
    }
  }, {
    key: "copy",
    value: function Range_copy_() {
      return new Range(this);
    }
  }, {
    key: "merge",
    value: function Range_merge_(otherRange) {
      if (!otherRange.isRange) otherRange = new Range(otherRange);
      if (lessPosition(this.end, otherRange.start) || lessPosition(otherRange.end, this.start)) return this;
      return Range.fromPositions(minPosition(this.start, otherRange.start), maxPosition(this.end, otherRange.end));
    }
  }, {
    key: "without",
    value: function Range_without_(otherRange) {
      if (!otherRange.isRange) otherRange = new Range(otherRange);
      var compared = Range.compare(this, otherRange);
      if (compared === 0) return Range.fromPositions(this.start, this.start);
      if (Math.abs(compared) >= 5) return this;
      if (compared < 0) return Range.fromPositions(this.start, otherRange.start);
      return Range.fromPositions(otherRange.end, this.end);
    }
  }, {
    key: "intersect",
    value: function Range_intersect_(that) {
      if (!that.isRange) that = new Range(that);
      var comparison = Range.compare(this, that),
          a = comparison < 0 ? this : that,
          b = comparison < 0 ? that : this;
      switch (Math.abs(comparison)) {
        case 0:
        case 1:
          return new Range(a);
        case 2:
        case 3:
          return new Range(b);
        case 4:
          return Range.fromPositions(b.start, a.end);
        case 5:
          return Range.at(b.start);
        case 6:
          return Range.at(a.end);
      }
    }
  }, {
    key: "subtract",
    value: function Range_subtract_(that) {
      if (!that.isRange) that = new Range(that);
      var comparison = Range.compare(this, that);
      switch (comparison) {
        case -6:
        case -5:
        case 5:
        case 6:
          return [new Range(this)];
        case -1:
        case 0:
        case 2:
        case 3:
          return [Range.at(this.start)];
        case 1:
        case 4:
          return [Range.fromPositions(that.end, this.end)];
        case -4:
        case -3:
          return [Range.fromPositions(this.start, that.start)];
        case -2:
          return [Range.fromPositions(this.start, that.start), Range.fromPositions(that.end, this.end)];
      }
    }
  }, {
    key: "containsPosition",
    value: function Range_containsPosition_(pos) {
      return lessEqPosition(this.start, pos) && lessEqPosition(pos, this.end);
    }
  }, {
    key: "toString",
    value: function Range_toString_() {
      var _start = this.start,
          row = _start.row,
          column = _start.column,
          _end = this.end,
          endRow = _end.row,
          endColumn = _end.column;

      return "Range(" + row + "/" + column + " -> " + endRow + "/" + endColumn + ")";
    }
  }], [{
    key: "sort",
    value: function Range_sort_(ranges) {
      return ranges.sort(Range.compare);
    }
  }, {
    key: "compare",
    value: function Range_compare_(a, b) {
      var startA = a.start,
          endA = a.end,
          startB = b.start,
          endB = b.end;

      if (lessPosition(startA, startB)) {
        if (lessPosition(endA, startB)) return -6;
        if (eqPosition(endA, startB)) return -5;
        if (lessPosition(endA, endB)) return -4;
        if (eqPosition(endA, endB)) return -3;
        return -2;
      }
      if (eqPosition(startA, startB)) {
        if (eqPosition(endA, endB)) return 0;
        return lessPosition(endA, endB) ? -1 : 1;
      }
      return -1 * Range.compare(b, a);
    }
  }, {
    key: "at",
    value: function Range_at_(position) {
      return new this({
        start: position,
        end: position
      });
    }
  }, {
    key: "fromPositions",
    value: function Range_fromPositions_(start, end) {
      return new this({
        start: start,
        end: end
      });
    }
  }, {
    key: "create",
    value: function Range_create_(startRow, startCol, endRow, endCol) {
      return new this({
        start: {
          row: startRow,
          column: startCol
        },
        end: {
          row: endRow,
          column: endCol
        }
      });
    }
  }, {
    key: "isValidLiteral",
    value: function Range_isValidLiteral_(rangeSpec) {
      if (!rangeSpec) return false;
      if (rangeSpec.isRange) return true;
      return rangeSpec.start && rangeSpec.end && typeof rangeSpec.start.row === "number" && typeof rangeSpec.start.column === "number" && typeof rangeSpec.end.row === "number" && typeof rangeSpec.end.column === "number";
    }
  }], __lively_classholder__, undefined, {
    start: 108,
    end: 5330
  });
}(undefined);
var defaultRange = new Range();

var Selection = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("Selection") && typeof __lively_classholder__.Selection === "function" ? __lively_classholder__.Selection : __lively_classholder__.Selection = function Selection(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function Selection_initialize_(textMorph, range) {
      this.textMorph = textMorph;
      this.initialize(range);
    }
  }, {
    key: "isSelection",
    get: function get() {
      return true;
    }
  }, {
    key: "initialize",
    value: function Selection_initialize_(range) {
      this._goalColumn = undefined;
      this._isReverse = false;
      var id = lively_lang.string.newUUID();
      this.startAnchor = this.textMorph.addAnchor("selection-start-" + id);
      this.endAnchor = this.textMorph.addAnchor("selection-end-" + id);
      this.range = Range.isValidLiteral(range) ? range : defaultRange;
      this._cursorVisible = true;
      this.cursorBlinkProcess = null;
    }
  }, {
    key: "isSelection",
    get: function get() {
      return true;
    }
  }, {
    key: "uninstall",
    value: function Selection_uninstall_() {
      this.cursorBlinkStop();
      this.textMorph.removeAnchor(this.startAnchor);
      this.textMorph.removeAnchor(this.endAnchor);
    }
  }, {
    key: "compareRangesForMerge",
    value: function Selection_compareRangesForMerge_(a, b) {
      var _a$start = a.start,
          startRowA = _a$start.row,
          startColA = _a$start.column,
          _a$end = a.end,
          endRowA = _a$end.row,
          endColA = _a$end.column,
          _b$start = b.start,
          startRowB = _b$start.row,
          startColB = _b$start.column,
          _b$end = b.end,
          endRowB = _b$end.row,
          endColB = _b$end.column;

      if (startRowA < startRowB || startRowA === startRowB && startColA < startColB) {
        if (endRowA < startRowB || endRowA === startRowB && endColA < startColB) return "separate";
        if (endRowA === startRowB && endColA === startColB) return startRowB === endRowB && startColB === endColB ? "overlapping" : "bordering";
        return "overlapping";
      }
      if (startRowA === startRowB && startColA === startColB) {
        if (endRowA === endRowB && endColA === endColB) return "equal";
        return "overlapping";
      }
      return this.compareRangesForMerge(b, a);
    }
  }, {
    key: "mergeWith",
    value: function Selection_mergeWith_(otherSel) {
      if (!otherSel || !otherSel.isSelection) return false;
      var compared = this.compareRangesForMerge(this.range, otherSel.range);
      if (compared === "separate" || compared === "bordering") return false;
      this.range = this.range.merge(otherSel.range);
      if (otherSel.isReverse() != this.isReverse()) this.reverse();
      return true;
    }
  }, {
    key: "range",
    get: function get() {
      return this._range;
    }
  }, {
    key: "range",
    set: function set(range) {
      if (!range) return;
      var _range = range,
          start = _range.start,
          end = _range.end;

      if (start === undefined || end === undefined) return;
      var d = this.textMorph.document;
      if (typeof start === "number") range.start = start = d.indexToPosition(start);
      if (typeof end === "number") range.end = end = d.indexToPosition(end);
      if (!Range.isValidLiteral(range)) return;
      start = d.clipPositionToLines(start);
      end = d.clipPositionToLines(end);
      var isReverse = this._isReverse = lessPosition(end, start);
      if (isReverse) {
        
        var _ref = [end, start];
        start = _ref[0];
        end = _ref[1];
      }range.start = start;
      range.end = end;
      if (!range.isRange) range = new Range(range);
      if (range.equals(this._range)) return;
      this._range = range;
      this._goalColumn = this.textMorph.lineWrapping ? this.textMorph.toScreenPosition(this.lead).column : this.lead.column;
      this.startAnchor.position = range.start;
      this.endAnchor.position = range.end;
      this.textMorph.makeDirty();
      lively_bindings.signal(this.textMorph, "selectionChange", this);
    }
  }, {
    key: "directedRange",
    get: function get() {
      return {
        end: this.lead,
        start: this.anchor
      };
    }
  }, {
    key: "updateFromAnchors",
    value: function Selection_updateFromAnchors_() {
      this.range = {
        start: this.startAnchor.position,
        end: this.endAnchor.position
      };
    }
  }, {
    key: "start",
    get: function get() {
      return this.range.start;
    }
  }, {
    key: "start",
    set: function set(val) {
      this.range = Range.fromPositions(val, this.end);
    }
  }, {
    key: "end",
    get: function get() {
      return this.range.end;
    }
  }, {
    key: "end",
    set: function set(val) {
      this.range = Range.fromPositions(this.start, val);
    }
  }, {
    key: "selectionColor",
    get: function get() {
      return this.textMorph.selectionColor || "#bed8f7";
    }
  }, {
    key: "anchor",
    get: function get() {
      return this.isReverse() ? this.range.end : this.range.start;
    }
  }, {
    key: "anchor",
    set: function set(pos) {
      this.range = {
        start: pos,
        end: this.lead
      };
    }
  }, {
    key: "lead",
    get: function get() {
      return this.isReverse() ? this.range.start : this.range.end;
    }
  }, {
    key: "lead",
    set: function set(pos) {
      this.range = {
        start: this.anchor,
        end: pos
      };
    }
  }, {
    key: "text",
    get: function get() {
      return this.textMorph.document.textInRange(this.range);
    }
  }, {
    key: "selectedRows",
    get: function get() {
      return {
        first: this.start.row,
        last: this.end.row
      };
    }
  }, {
    key: "text",
    set: function set(val) {
      var range = this.range,
          textMorph = this.textMorph,
          reversed = this.isReverse();

      this.range = textMorph.replace(range, val);
      if (reversed) this.reverse();
    }
  }, {
    key: "reverse",
    value: function Selection_reverse_() {
      this._isReverse = !this.isEmpty() && !this._isReverse;
      return this;
    }
  }, {
    key: "isReverse",
    value: function Selection_isReverse_() {
      return this._isReverse && !this.isEmpty();
    }
  }, {
    key: "isEmpty",
    value: function Selection_isEmpty_() {
      return this.range.isEmpty();
    }
  }, {
    key: "collapse",
    value: function Selection_collapse_() {
      var pos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.start;

      this.range = {
        start: pos,
        end: pos
      };
      return this;
    }
  }, {
    key: "collapseToEnd",
    value: function Selection_collapseToEnd_() {
      this.collapse(this.end);
      return this;
    }
  }, {
    key: "growLeft",
    value: function Selection_growLeft_(n) {
      var d = this.textMorph.document,
          endIndex = d.positionToIndex(this.end),
          startIndex = Math.min(endIndex, d.positionToIndex(this.start) - n),
          r = this.isReverse();
      this.start = d.indexToPosition(startIndex);
      this._isReverse = r;
      return this;
    }
  }, {
    key: "growRight",
    value: function Selection_growRight_(n) {
      var d = this.textMorph.document,
          startIndex = d.positionToIndex(this.start),
          endIndex = Math.max(startIndex, d.positionToIndex(this.end) + n),
          r = this.isReverse();
      this.end = d.indexToPosition(endIndex);
      this._isReverse = r;
      return this;
    }
  }, {
    key: "selectAll",
    value: function Selection_selectAll_() {
      this.range = {
        start: {
          row: 0,
          column: 0
        },
        end: this.textMorph.document.endPosition
      };
      return this;
    }
  }, {
    key: "selectLine",
    value: function Selection_selectLine_() {
      var row = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.lead.row;
      var includingLineEnd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      this.range = {
        start: {
          row: row,
          column: 0
        },
        end: {
          row: includingLineEnd ? row + 1 : row,
          column: includingLineEnd ? 0 : this.textMorph.getLine(row).length
        }
      };
      return this;
    }
  }, {
    key: "gotoLineEnd",
    value: function Selection_gotoLineEnd_() {
      var row = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.lead.row;

      var pos = {
        row: row,
        column: this.textMorph.getLine(row).length
      };
      this.range = {
        start: pos,
        end: pos
      };
    }
  }, {
    key: "selectLeft",
    value: function Selection_selectLeft_() {
      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

      if (this.isEmpty()) {
        this.growLeft(n);
        this.reverse();
      } else this.isReverse() ? this.growLeft(n) : this.growRight(-n);
      return this;
    }
  }, {
    key: "selectRight",
    value: function Selection_selectRight_() {
      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

      this.isReverse() ? this.growLeft(-n) : this.growRight(n);
      return this;
    }
  }, {
    key: "selectUp",
    value: function Selection_selectUp_() {
      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var useScreenPosition = arguments[1];

      return this.goUp(n, useScreenPosition, true);
    }
  }, {
    key: "selectDown",
    value: function Selection_selectDown_() {
      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var useScreenPosition = arguments[1];

      return this.selectUp(-n, useScreenPosition);
    }
  }, {
    key: "goUp",
    value: function Selection_goUp_() {
      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var useScreenPosition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var select = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      if (n === 0) return this;
      var goalColumn = this._goalColumn;
      this.lead = this.textMorph.getPositionAboveOrBelow(n, this.lead, useScreenPosition, goalColumn);
      if (!select) this.anchor = this.lead;
      this._goalColumn = goalColumn;
      return this;
    }
  }, {
    key: "goDown",
    value: function Selection_goDown_() {
      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var useScreenPosition = arguments[1];

      return this.goUp(-n, useScreenPosition);
    }
  }, {
    key: "goLeft",
    value: function Selection_goLeft_() {
      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

      this.isEmpty() && this.growLeft(n);
      this.collapse();
      return this;
    }
  }, {
    key: "goRight",
    value: function Selection_goRight_() {
      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

      this.isEmpty() && this.growRight(n);
      this.collapseToEnd();
      return this;
    }
  }, {
    key: "cursorVisible",
    get: function get() {
      return this._cursorVisible && this.textMorph.isFocused() && !this.textMorph.rejectsInput();
    }
  }, {
    key: "cursorBlinkStart",
    value: function Selection_cursorBlinkStart_() {
      var _this = this;

      this.cursorBlinkStop();
      var timeout = config.text.cursorBlinkPeriod;
      if (timeout) this.cursorBlinkProcess = setInterval(function () {
        _this._cursorVisible = !_this._cursorVisible;
        _this.textMorph.makeDirty();
      }, timeout * 1000);
    }
  }, {
    key: "cursorBlinkStop",
    value: function Selection_cursorBlinkStop_() {
      if (this.cursorBlinkProcess) clearInterval(this.cursorBlinkProcess);
      this.cursorBlinkProcess = null;
      this._cursorVisible = true;
    }
  }, {
    key: "toString",
    value: function Selection_toString_() {
      var _anchor = this.anchor,
          row = _anchor.row,
          column = _anchor.column,
          _lead = this.lead,
          endRow = _lead.row,
          endColumn = _lead.column;

      return "Selection(" + row + "/" + column + " -> " + endRow + "/" + endColumn + ")";
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 223,
    end: 7740
  });
}(undefined);
var MultiSelection = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("MultiSelection") && typeof __lively_classholder__.MultiSelection === "function" ? __lively_classholder__.MultiSelection : __lively_classholder__.MultiSelection = function MultiSelection(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: "initialize",
    value: function MultiSelection_initialize_(range) {
      this.selections = [new Selection(this.textMorph, range)];
    }
  }, {
    key: "isMultiSelection",
    get: function get() {
      return true;
    }
  }, {
    key: "uninstall",
    value: function MultiSelection_uninstall_() {
      this.selections.forEach(function (ea) {
        return ea.uninstall();
      });
    }
  }, {
    key: "defaultSelection",
    get: function get() {
      return lively_lang.arr.last(this.selections);
    }
  }, {
    key: "removeSelections",
    value: function MultiSelection_removeSelections_() {
      var startingAt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

      var toRemove = this.selections.slice(startingAt);
      toRemove.forEach(function (ea) {
        return ea.uninstall();
      });
      this.selections = lively_lang.arr.withoutAll(this.selections, toRemove);
    }
  }, {
    key: "disableMultiSelect",
    value: function MultiSelection_disableMultiSelect_() {
      lively_lang.arr.without(this.selections, this.defaultSelection).forEach(function (ea) {
        return ea.uninstall();
      });
      this.selections = [this.defaultSelection];
    }
  }, {
    key: "range",
    get: function get() {
      return this.defaultSelection.range;
    }
  }, {
    key: "range",
    set: function set(range) {
      this.disableMultiSelect();
      this.defaultSelection.range = range;
    }
  }, {
    key: "updateFromAnchors",
    value: function MultiSelection_updateFromAnchors_() {
      this.selections.forEach(function (ea) {
        return ea.updateFromAnchors();
      });
    }
  }, {
    key: "start",
    get: function get() {
      return this.defaultSelection.start;
    }
  }, {
    key: "start",
    set: function set(val) {
      this.defaultSelection.start = val;
    }
  }, {
    key: "end",
    get: function get() {
      return this.defaultSelection.end;
    }
  }, {
    key: "end",
    set: function set(val) {
      this.defaultSelection.end = val;
    }
  }, {
    key: "anchor",
    get: function get() {
      return this.defaultSelection.anchor;
    }
  }, {
    key: "anchor",
    set: function set(pos) {
      this.defaultSelection.anchor = pos;
    }
  }, {
    key: "lead",
    get: function get() {
      return this.defaultSelection.lead;
    }
  }, {
    key: "lead",
    set: function set(pos) {
      this.defaultSelection.lead = pos;
    }
  }, {
    key: "text",
    get: function get() {
      return this.selections.map(function (sel) {
        return sel.text;
      }).join("\n");
    }
  }, {
    key: "text",
    set: function set(val) {
      this.selections.forEach(function (sel) {
        return sel.text = val;
      });
    }
  }, {
    key: "selectedRows",
    get: function get() {
      return this.defaultSelection.selectedRows;
    }
  }, {
    key: "reverse",
    value: function MultiSelection_reverse_() {
      this.defaultSelection.reverse();
    }
  }, {
    key: "isReverse",
    value: function MultiSelection_isReverse_() {
      return this.defaultSelection.isReverse();
    }
  }, {
    key: "isEmpty",
    value: function MultiSelection_isEmpty_() {
      return this.defaultSelection.isEmpty();
    }
  }, {
    key: "collapse",
    value: function MultiSelection_collapse_(pos) {
      this.defaultSelection.collapse(pos);
      return this;
    }
  }, {
    key: "collapseToEnd",
    value: function MultiSelection_collapseToEnd_() {
      this.defaultSelection.collapseToEnd();
      return this;
    }
  }, {
    key: "growLeft",
    value: function MultiSelection_growLeft_(n) {
      this.defaultSelection.growLeft(n);
      return this;
    }
  }, {
    key: "growRight",
    value: function MultiSelection_growRight_(n) {
      this.defaultSelection.growRight(n);
      return this;
    }
  }, {
    key: "selectAll",
    value: function MultiSelection_selectAll_() {
      this.disableMultiSelect();
      this.defaultSelection.selectAll();
      return this;
    }
  }, {
    key: "selectLine",
    value: function MultiSelection_selectLine_(row, includingLineEnd) {
      this.defaultSelection.selectLine(row, includingLineEnd);
      return this;
    }
  }, {
    key: "gotoLineEnd",
    value: function MultiSelection_gotoLineEnd_(row) {
      this.defaultSelection.gotoLineEnd(row);
    }
  }, {
    key: "selectLeft",
    value: function MultiSelection_selectLeft_(n) {
      this.defaultSelection.selectLeft(n);
      return this;
    }
  }, {
    key: "selectRight",
    value: function MultiSelection_selectRight_(n) {
      this.defaultSelection.selectRight(n);
      return this;
    }
  }, {
    key: "selectUp",
    value: function MultiSelection_selectUp_(n, useScreenPosition) {
      this.defaultSelection.selectUp(n, useScreenPosition);
      return this;
    }
  }, {
    key: "selectDown",
    value: function MultiSelection_selectDown_(n, useScreenPosition) {
      this.defaultSelection.selectDown(n, useScreenPosition);
      return this;
    }
  }, {
    key: "goUp",
    value: function MultiSelection_goUp_(n, useScreenPosition) {
      return this.defaultSelection.goUp(n, useScreenPosition);
      return this;
    }
  }, {
    key: "goDown",
    value: function MultiSelection_goDown_(n, useScreenPosition) {
      return this.defaultSelection.goDown(n, useScreenPosition);
      return this;
    }
  }, {
    key: "goLeft",
    value: function MultiSelection_goLeft_(n) {
      return this.defaultSelection.goLeft(n);
      return this;
    }
  }, {
    key: "goRight",
    value: function MultiSelection_goRight_(n) {
      return this.defaultSelection.goRight(n);
      return this;
    }
  }, {
    key: "cursorVisible",
    get: function get() {
      return this.defaultSelection.cursorVisible;
    }
  }, {
    key: "cursorBlinkStart",
    value: function MultiSelection_cursorBlinkStart_() {
      var _this2 = this;

      this.cursorBlinkStop();
      var timeout = config.text.cursorBlinkPeriod;
      if (timeout) this.cursorBlinkProcess = setInterval(function () {
        _this2._cursorVisible = !_this2._cursorVisible;
        _this2.selections.forEach(function (sel) {
          return sel._cursorVisible = _this2._cursorVisible;
        });
        _this2.textMorph.makeDirty();
      }, timeout * 1000);
    }
  }, {
    key: "cursorBlinkStop",
    value: function MultiSelection_cursorBlinkStop_() {
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "cursorBlinkStop", this).call(this);
      this.selections.forEach(function (sel) {
        return sel._cursorVisible = true;
      });
    }
  }, {
    key: "style",
    set: function set(style) {
      this.defaultSelection.style = style;
    }
  }, {
    key: "getTextAttributes",
    value: function MultiSelection_getTextAttributes_() {
      return this.defaultSelection.getTextAttributes();
    }
  }, {
    key: "toString",
    value: function MultiSelection_toString_() {
      return "MultiSelection(" + this.selections.join(", ") + ")";
    }
  }, {
    key: "mergeSelections",
    value: function MultiSelection_mergeSelections_() {
      var sels = this.selections.slice();
      for (var i = sels.length - 1; i >= 0; i--) {
        for (var j = sels.length - 1; j >= 0; j--) {
          if (i === j) continue;
          if (sels[j].mergeWith(sels[i])) {
            sels.splice(i, 1);
            break;
          }
        }
      }
      this.selections = sels;
    }
  }, {
    key: "ranges",
    get: function get() {
      return this.selections.map(function (ea) {
        return ea.range;
      });
    }
  }, {
    key: "ranges",
    set: function set(ranges) {
      for (var i = 0; i < ranges.length; i++) {
        var sel = this.selections[i];
        if (sel) sel.range = ranges[i];else this.addRange(ranges[i], false);
      }
      this.removeSelections(i);
      this.mergeSelections();
    }
  }, {
    key: "addRange",
    value: function MultiSelection_addRange_(range) {
      var mergeSelections = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      this.selections.push(new Selection(this.textMorph, range));
      if (mergeSelections) this.mergeSelections();
      return lively_lang.arr.last(this.selections).range;
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 7749,
    end: 12460
  });
}(Selection);

var Anchor = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("Anchor") && typeof __lively_classholder__.Anchor === "function" ? __lively_classholder__.Anchor : __lively_classholder__.Anchor = function Anchor(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function Anchor_initialize_(id) {
      var pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        column: 0,
        row: 0
      };
      var insertBehavior = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "move";

      this.id = id || "" + (this.constructor._id = (this.constructor._id || 0) + 1);
      this.position = pos;
      this.insertBehavior = insertBehavior;
    }
  }, {
    key: "isAnchor",
    get: function get() {
      return true;
    }
  }, {
    key: "onDelete",
    value: function Anchor_onDelete_(range) {
      if (lessEqPosition(this.position, range.start)) return false;
      if (lessEqPosition(range.start, this.position) && lessEqPosition(this.position, range.end)) {
        this.position = range.start;
        return true;
        
      }
      var _position = this.position,
          row = _position.row,
          column = _position.column,
          _range$start = range.start,
          startRow = _range$start.row,
          startColumn = _range$start.column,
          _range$end = range.end,
          endRow = _range$end.row,
          endColumn = _range$end.column,
          newRow = row - (endRow - startRow),
          newColumn = endRow !== this.position.row ? column : startColumn === endColumn ? column - (endColumn - startColumn) : startColumn + (column - endColumn);

      this.position = {
        column: newColumn,
        row: newRow
      };
      return true;
    }
  }, {
    key: "onInsert",
    value: function Anchor_onInsert_(range) {
      if (lessPosition(this.position, range.start)) return false;
      if (eqPosition(this.position, range.start) && this.insertBehavior === "stay") return false;
      var _position2 = this.position,
          row = _position2.row,
          column = _position2.column,
          _range$start2 = range.start,
          startRow = _range$start2.row,
          startColumn = _range$start2.column,
          _range$end2 = range.end,
          endRow = _range$end2.row,
          endColumn = _range$end2.column,
          deltaRows = endRow - startRow,
          deltaColumns = startRow !== this.position.row ? 0 : endColumn - startColumn;

      this.position = {
        column: column + deltaColumns,
        row: row + deltaRows
      };
      return true;
    }
  }, {
    key: "equalsPosition",
    value: function Anchor_equalsPosition_(posOrAnchor) {
      if (!posOrAnchor) return false;
      if (posOrAnchor.isAnchor) return eqPosition(this.position, posOrAnchor.position);
      return eqPosition(this.position, posOrAnchor);
    }
  }, {
    key: "toString",
    value: function Anchor_toString_() {
      var id = this.id,
          _position3 = this.position,
          row = _position3.row,
          column = _position3.column;

      return "Anchor(" + id + " " + row + "/" + column + ")";
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 82,
    end: 3157
  });
}(undefined);

var TextAttribute = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("TextAttribute") && typeof __lively_classholder__.TextAttribute === "function" ? __lively_classholder__.TextAttribute : __lively_classholder__.TextAttribute = function TextAttribute(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function TextAttribute_initialize_() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var range = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        start: {
          row: 0,
          column: 0
        },
        end: {
          row: 0,
          column: 0
        }
      };

      this.data = data;
      this.range = range;
    }
  }, {
    key: "isTextAttribute",
    get: function get() {
      return true;
    }
  }, {
    key: "start",
    get: function get() {
      return this._startAnchor.position;
    }
  }, {
    key: "start",
    set: function set(start) {
      this._startAnchor = new Anchor(undefined, start);
    }
  }, {
    key: "end",
    get: function get() {
      return this._endAnchor.position;
    }
  }, {
    key: "end",
    set: function set(end) {
      this._endAnchor = new Anchor(undefined, end);
    }
  }, {
    key: "range",
    get: function get() {
      var start = this.start,
          end = this.end;

      return Range.fromPositions(start, end);
    }
  }, {
    key: "range",
    set: function set(range) {
      var start = range.start,
          end = range.end;

      this.start = start;
      this.end = end;
    }
  }, {
    key: "isEmpty",
    value: function TextAttribute_isEmpty_() {
      return this.range.isEmpty();
    }
  }, {
    key: "equals",
    value: function TextAttribute_equals_(other) {
      return this.range.equals(other.range) && lively_lang.obj.equals(this.data, other.data);
    }
  }, {
    key: "onInsert",
    value: function TextAttribute_onInsert_(range) {
      var changedStart = this._startAnchor.onInsert(range),
          changedEnd = this._endAnchor.onInsert(range);
      return changedStart || changedEnd;
    }
  }, {
    key: "onDelete",
    value: function TextAttribute_onDelete_(range) {
      var changedStart = this._startAnchor.onDelete(range),
          changedEnd = this._endAnchor.onDelete(range);
      return changedStart || changedEnd;
    }
  }, {
    key: "splitAt",
    value: function TextAttribute_splitAt_(pos) {
      var row = pos.row,
          column = pos.column;

      if (lessEqPosition(pos, this.start) || lessEqPosition(this.end, pos)) throw new Error("splitAt with position outside attribute: " + this + " vs " + row + "/" + column);
      return [new this.constructor(this.data, {
        start: this.start,
        end: pos
      }), new this.constructor(this.data, {
        start: pos,
        end: this.end
      })];
    }
  }, {
    key: "toString",
    value: function TextAttribute_toString_() {
      var range = String(this.range).replace("Range(", "").replace(")", "");
      return this.constructor.name + "(" + range + " " + lively_lang.obj.values(this.data) + ")";
    }
  }], [{
    key: "fromPositions",
    value: function TextAttribute_fromPositions_() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var start = arguments[1];
      var end = arguments[2];

      return new this(data, Range.fromPositions(start, end));
    }
  }, {
    key: "create",
    value: function TextAttribute_create_(data, startRow, startCol, endRow, endCol) {
      return new this(data, {
        start: {
          row: startRow,
          column: startCol
        },
        end: {
          row: endRow,
          column: endCol
        }
      });
    }
  }], __lively_classholder__, undefined, {
    start: 184,
    end: 2182
  });
}(undefined);
var TextStyleAttribute = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("TextStyleAttribute") && typeof __lively_classholder__.TextStyleAttribute === "function" ? __lively_classholder__.TextStyleAttribute : __lively_classholder__.TextStyleAttribute = function TextStyleAttribute(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: "addAdjacentAttribute",
    value: function TextStyleAttribute_addAdjacentAttribute_(other) {
      if (!eqPosition(this.end, other.start) || !lively_lang.obj.equals(this.data, other.data)) return false;
      this.end = other.end;
      return true;
    }
  }, {
    key: "isStyleAttribute",
    get: function get() {
      return true;
    }
  }], [{
    key: "mergeAdjacentAttributes",
    value: function TextStyleAttribute_mergeAdjacentAttributes_(attrs) {
      if (attrs.length <= 1) return attrs;
      var merged = attrs.slice(),
          i = 0;
      while (true) {
        var a = merged[i],
            b = merged[i + 1];
        if (!b) break;
        if (a.addAdjacentAttribute(b)) merged.splice(i + 1, 1);else i++;
      }
      return merged;
    }
  }, {
    key: "styleProps",
    get: function get() {
      return ["fontFamily", "fontSize", "fontColor", "fontWeight", "backgroundColor", "fontStyle", "textDecoration", "fixedCharacterSpacing", "textStyleClasses", "link", "nativeCursor"];
    }
  }, {
    key: "isStyleData",
    value: function TextStyleAttribute_isStyleData_(data) {
      return lively_lang.arr.withoutAll(Object.keys(data), this.styleProps).length === 0;
    }
  }], __lively_classholder__, undefined, {
    start: 2192,
    end: 3371
  });
}(TextAttribute);

function styleFromTextAttributes(textAttributes) {
  var s = {};
  for (var i = 0; i < textAttributes.length; i++) {
    var d = textAttributes[i].data;
    if ("fontFamily" in d) s.fontFamily = d.fontFamily;
    if ("fontSize" in d) s.fontSize = d.fontSize;
    if ("fontColor" in d) s.fontColor = d.fontColor;
    if ("backgroundColor" in d) s.backgroundColor = d.backgroundColor;
    if ("fontWeight" in d) s.fontWeight = d.fontWeight;
    if ("fontStyle" in d) s.fontStyle = d.fontStyle;
    if ("textDecoration" in d) s.textDecoration = d.textDecoration;
    if ("fixedCharacterSpacing" in d) s.fixedCharacterSpacing = d.fixedCharacterSpacing;
    if (d.textStyleClasses) s.textStyleClasses = (s.textStyleClasses || []).concat(d.textStyleClasses);
    if (d.nativeCursor) s.nativeCursor = d.nativeCursor;
    if (d.link) {
      s.link = d.link;
      s.nativeCursor = "auto";
      delete s.textDecoration;
      delete s.fontColor;
    }
    if (d.doit) {
      s.doit = d.doit;
    }
  }
  return s;
}
function chunksFrom(textOfLine, fontMetric, textAttributesOfLine) {
  var chunks = [];
  for (var i = 0; i < textAttributesOfLine.length; i += 3) {
    var startCol = textAttributesOfLine[i],
        endCol = textAttributesOfLine[i + 1],
        attributes = textAttributesOfLine[i + 2];
    chunks.push(new TextChunk(textOfLine.slice(startCol, endCol), fontMetric, attributes));
  }
  return chunks;
}
function updateChunks(oldChunks, newChunks) {
  if (!oldChunks.length && newChunks.length) {
    oldChunks.push.apply(oldChunks, toConsumableArray(newChunks));
    return true;
  }
  var oldChunkCount = oldChunks.length,
      newChunkCount = newChunks.length,
      changed = false;
  for (var i = 0; i < newChunks.length; i++) {
    var oldChunk = oldChunks[i],
        newChunk = newChunks[i],
        newText = newChunk.text,
        newFontMetric = newChunk.fontMetric,
        newTextAttributes = newChunk.textAttributes;
    if (!oldChunk || !oldChunk.compatibleWith(newText, newFontMetric, newTextAttributes)) {
      oldChunks[i] = newChunk;
      changed = true;
    }
  }
  if (newChunkCount < oldChunkCount) {
    oldChunks.splice(newChunkCount, oldChunkCount - newChunkCount);
    changed = true;
  }
  return changed;
}
var TextChunk = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("TextChunk") && typeof __lively_classholder__.TextChunk === "function" ? __lively_classholder__.TextChunk : __lively_classholder__.TextChunk = function TextChunk(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function TextChunk_initialize_(text, fontMetric, textAttributes) {
      this.fontMetric = fontMetric;
      this.textAttributes = textAttributes;
      this.text = text;
      this.rendered = undefined;
      this._style = undefined;
      this._charBounds = undefined;
      this._width = undefined;
      this._height = undefined;
      return this;
    }
  }, {
    key: "style",
    get: function get() {
      return this._style || (this._style = styleFromTextAttributes(this.textAttributes));
    }
  }, {
    key: "compatibleWith",
    value: function TextChunk_compatibleWith_(text2, fontMetric2, textAttributes2) {
      var text = this.text,
          fontMetric = this.fontMetric,
          style = this.style;

      return text === text2 && fontMetric === fontMetric2 && lively_lang.obj.equals(style, styleFromTextAttributes(textAttributes2));
    }
  }, {
    key: "height",
    get: function get() {
      if (!this._height === undefined) this.computeBounds();
      return this._height;
    }
  }, {
    key: "width",
    get: function get() {
      if (this._width === undefined) this.computeBounds();
      return this._width;
    }
  }, {
    key: "length",
    get: function get() {
      return this.text.length;
    }
  }, {
    key: "charBounds",
    get: function get() {
      if (this._charBounds === undefined) this.computeCharBounds();
      return this._charBounds;
    }
  }, {
    key: "computeBounds",
    value: function TextChunk_computeBounds_() {
      var width = 0,
          height = 0,
          bounds = this.charBounds,
          nBounds = bounds.length;
      if (nBounds === 0) {
        height = this.fontMetric.defaultLineHeight(this.style);
      } else {
        for (var i = 0; i < bounds.length; i++) {
          var char = bounds[i];
          width += char.width;
          height = Math.max(height, char.height);
        }
      }
      this._height = height;
      this._width = width;
      return this;
    }
  }, {
    key: "computeCharBounds",
    value: function TextChunk_computeCharBounds_() {
      var text = this.text,
          fontMetric = this.fontMetric,
          style = this.style;

      this._charBounds = text.length === 0 ? [] : fontMetric.charBoundsFor(style, text);
    }
  }, {
    key: "splitAt",
    value: function TextChunk_splitAt_(splitWidth) {
      var width = this.width;
      if (splitWidth <= 0 || width < splitWidth) return [this];
      var _charBounds = this._charBounds,
          _style = this._style,
          _height = this._height,
          text = this.text,
          fontMetric = this.fontMetric,
          textAttributes = this.textAttributes;

      if (!_charBounds.length) return [this];
      if (_charBounds[0].width > splitWidth) return [null, this];
      for (var i = 1; i < _charBounds.length; i++) {
        var _charBounds$i = _charBounds[i],
            x = _charBounds$i.x,
            w = _charBounds$i.width,
            currentWidth = x + w;

        if (currentWidth <= splitWidth) continue;
        var left = Object.assign(new TextChunk(text.slice(0, i), fontMetric, textAttributes), {
          _style: _style,
          _width: x,
          _height: _height,
          _charBounds: _charBounds.slice(0, i)
        }),
            nextWidth = 0,
            charBoundsSplitted = new Array(_charBounds.length - i);
        for (var j = i, k = 0; j < _charBounds.length; j++, k++) {
          var ea = _charBounds[j];
          nextWidth += ea.width;
          charBoundsSplitted[k] = Object.assign({}, ea, { x: ea.x - x });
        }
        var right = Object.assign(new TextChunk(text.slice(i), fontMetric, textAttributes), {
          _style: _style,
          _width: nextWidth,
          _height: _height,
          _charBounds: charBoundsSplitted
        });
        return [left, right];
      }
      return [null, this];
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 7142,
    end: 10092
  });
}(undefined);
var TextLayoutLine = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("TextLayoutLine") && typeof __lively_classholder__.TextLayoutLine === "function" ? __lively_classholder__.TextLayoutLine : __lively_classholder__.TextLayoutLine = function TextLayoutLine(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function TextLayoutLine_initialize_() {
      var chunks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      this.chunks = chunks;
      this.resetCache();
    }
  }, {
    key: "resetCache",
    value: function TextLayoutLine_resetCache_() {
      this.rendered = this._charBounds = this._height = this._width = undefined;
    }
  }, {
    key: "text",
    get: function get() {
      var text = "";
      for (var i = 0; i < this.chunks.length; i++) {
        text += this.chunks[i].text;
      }return text;
    }
  }, {
    key: "length",
    get: function get() {
      var l = 0;
      for (var i = 0; i < this.chunks.length; i++) {
        l += this.chunks[i].length;
      }return l;
    }
  }, {
    key: "height",
    get: function get() {
      if (this._height === undefined) this.computeBounds();
      return this._height;
    }
  }, {
    key: "width",
    get: function get() {
      if (this._width === undefined) this.computeBounds();
      return this._width;
    }
  }, {
    key: "computeBounds",
    value: function TextLayoutLine_computeBounds_() {
      this._width = this._height = 0;
      for (var i = 0; i < this.chunks.length; i++) {
        var chunk = this.chunks[i];
        this._width += chunk.width;
        this._height = Math.max(this._height, chunk.height);
      }
      return this;
    }
  }, {
    key: "boundsFor",
    value: function TextLayoutLine_boundsFor_(column) {
      var charBounds = this.charBounds;
      return charBounds[column] || charBounds[charBounds.length - 1] || {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      };
    }
  }, {
    key: "charBounds",
    get: function get() {
      if (this._charBounds === undefined) this.computeCharBounds();
      return this._charBounds;
    }
  }, {
    key: "computeCharBounds",
    value: function TextLayoutLine_computeCharBounds_() {
      var prefixWidth = 0,
          chunks = this.chunks,
          lineHeight = this.height,
          nChunks = chunks.length;
      this._charBounds = [];
      for (var i = 0; i < nChunks; i++) {
        var _chunks$i = chunks[i],
            charBounds = _chunks$i.charBounds,
            width = _chunks$i.width,
            height = _chunks$i.height;

        for (var j = 0; j < charBounds.length; j++) {
          var bounds = charBounds[j],
              x = bounds.x,
              y = bounds.y,
              _width = bounds.width;
          this._charBounds.push({
            x: x + prefixWidth,
            y: y,
            width: _width,
            height: lineHeight
          });
        }
        prefixWidth += width;
      }
      this._charBounds.push({
        x: prefixWidth,
        y: 0,
        width: 0,
        height: lineHeight
      });
    }
  }, {
    key: "rowColumnOffsetForPixelPos",
    value: function TextLayoutLine_rowColumnOffsetForPixelPos_(xInPixels, yInPixels) {
      var charBounds = this.charBounds,
          length = charBounds.length,
          first = charBounds[0],
          last = charBounds[length - 1],
          result = {
        row: 0,
        column: 0
      };
      if (!length || xInPixels <= first.x + Math.round(first.width / 2)) return result;
      if (xInPixels > last.x + Math.round(last.width / 2)) {
        result.column = length - 1;
        return result;
      }
      for (var i = length - 2; i >= 0; i--) {
        var _charBounds$i2 = charBounds[i],
            x = _charBounds$i2.x,
            width = _charBounds$i2.width;

        if (xInPixels >= x + Math.round(width / 2)) {
          result.column = i + 1;
          return result;
        }
      }
      return result;
    }
  }, {
    key: "chunkAtOffset",
    value: function TextLayoutLine_chunkAtOffset_(offsetX, offsetY) {
      var x = 0;
      for (var i = 0; i < this.chunks.length; i++) {
        var _chunks$i2 = this.chunks[i],
            charBounds = _chunks$i2.charBounds,
            width = _chunks$i2.width,
            height = _chunks$i2.height;

        if (offsetX >= x && offsetX <= x + width) return this.chunks[i];
        x += width;
      }
      return null;
    }
  }, {
    key: "chunkAtColumn",
    value: function TextLayoutLine_chunkAtColumn_(column) {
      var sumLength = 0;
      for (var i = 0; i < this.chunks.length; i++) {
        var length = this.chunks[i].length;

        if (column >= sumLength && column <= sumLength + length) return this.chunks[i];
        sumLength += length;
      }
      return null;
    }
  }, {
    key: "updateIfNecessary",
    value: function TextLayoutLine_updateIfNecessary_(newChunks) {
      var changed = updateChunks(this.chunks, newChunks);
      changed && this.resetCache();
      return changed;
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 10154,
    end: 13599
  });
}(undefined);
var WrappedTextLayoutLine = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("WrappedTextLayoutLine") && typeof __lively_classholder__.WrappedTextLayoutLine === "function" ? __lively_classholder__.WrappedTextLayoutLine : __lively_classholder__.WrappedTextLayoutLine = function WrappedTextLayoutLine(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function WrappedTextLayoutLine_initialize_() {
      this.chunks = [];
      this.wrappedLines = [];
      this._wrapAt = Infinity;
      this.resetCache();
    }
  }, {
    key: "resetCache",
    value: function WrappedTextLayoutLine_resetCache_() {
      this._charBounds = this._height = this._width = undefined;
    }
  }, {
    key: "text",
    get: function get() {
      var text = 0;
      for (var i = 0; i < this.wrappedLines.length; i++) {
        text += this.wrappedLines[i].text;
      }return text;
    }
  }, {
    key: "length",
    get: function get() {
      var l = 0;
      for (var i = 0; i < this.wrappedLines.length; i++) {
        l += this.wrappedLines[i].length;
      }return l;
    }
  }, {
    key: "wrapAt",
    get: function get() {
      return this._wrapAt;
    }
  }, {
    key: "wrapAt",
    set: function set(x) {
      var changed = this._wrapAt !== x;
      this._wrapAt = x;
      changed && this.resetCache();
    }
  }, {
    key: "height",
    get: function get() {
      if (this._height === undefined) this.computeBounds();
      return this._height;
    }
  }, {
    key: "width",
    get: function get() {
      if (this._width === undefined) this.computeBounds();
      return this._width;
    }
  }, {
    key: "computeBounds",
    value: function WrappedTextLayoutLine_computeBounds_() {
      this._width = this._height = 0;
      for (var i = 0; i < this.wrappedLines.length; i++) {
        var l = this.wrappedLines[i];
        this._width = Math.max(l.width, this._width);
        this._height += l.height;
      }
      return this;
    }
  }, {
    key: "updateIfNecessary",
    value: function WrappedTextLayoutLine_updateIfNecessary_(newChunks, wrapAt) {
      var chunks = this.chunks,
          changed = updateChunks(chunks, newChunks) || this.wrapAt !== wrapAt;
      if (!changed) return false;
      this.wrapAt = wrapAt;
      var chunksByLine = [[]],
          currentLineChunks = chunksByLine[0],
          x = 0;
      for (var i = 0; i < chunks.length; i++) {
        var nextChunk = chunks[i],
            nextW = nextChunk.width;
        if (x + nextW <= wrapAt) {
          x += nextW;
          currentLineChunks.push(nextChunk);
          continue;
        }
        var maybeNotSplittableChunk = null;
        while (true) {
          var _ref = x >= wrapAt ? [null, nextChunk] : nextChunk.splitAt(wrapAt - x),
              _ref2 = slicedToArray(_ref, 2),
              split1 = _ref2[0],
              split2 = _ref2[1];

          if (!split1 && split2 && split2 === maybeNotSplittableChunk) {
            split1 = split2;
            split2 = maybeNotSplittableChunk = null;
          }
          if (split1) {
            x += split1.width;
            currentLineChunks.push(split1);
          } else maybeNotSplittableChunk = split2;
          if (!split2) break;
          chunksByLine.push(currentLineChunks = []);
          x = 0;
          nextChunk = split2;
        }
      }
      var nLines = chunksByLine.length;
      for (var _i = 0; _i < nLines; _i++) {
        var _chunks = chunksByLine[_i],
            line = this.wrappedLines[_i] || (this.wrappedLines[_i] = new TextLayoutLine());
        line.updateIfNecessary(_chunks);
      }
      if (nLines !== this.wrappedLines.length) this.wrappedLines.splice(nLines, this.wrappedLines.length - nLines);
      this.resetCache();
      return true;
    }
  }, {
    key: "boundsFor",
    value: function WrappedTextLayoutLine_boundsFor_(column) {
      var charBounds = this.charBounds;
      return charBounds[column] || charBounds[charBounds.length - 1] || {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      };
    }
  }, {
    key: "rowColumnOffsetForPixelPos",
    value: function WrappedTextLayoutLine_rowColumnOffsetForPixelPos_(xInPixels, yInPixels) {
      var line,
          currentHeight = 0,
          lines = this.wrappedLines;
      for (var i = 0; i < lines.length; i++) {
        line = lines[i];
        currentHeight += line.height;
        if (currentHeight > yInPixels) break;
      }
      return {
        column: line.rowColumnOffsetForPixelPos(xInPixels, currentHeight - yInPixels).column,
        row: i
      };
    }
  }, {
    key: "charBounds",
    get: function get() {
      if (this._charBounds === undefined) this.computeCharBounds();
      return this._charBounds;
    }
  }, {
    key: "computeCharBounds",
    value: function WrappedTextLayoutLine_computeCharBounds_() {
      var currentX = 0,
          currentY = 0,
          wrappedLines = this.wrappedLines;
      this._charBounds = [];
      for (var i = 0; i < wrappedLines.length; i++) {
        var _wrappedLines$i = wrappedLines[i],
            charBounds = _wrappedLines$i.charBounds,
            lineHeight = _wrappedLines$i.height;

        for (var j = 0; j < charBounds.length; j++) {
          var bounds = charBounds[j],
              x = bounds.x,
              y = bounds.y,
              width = bounds.width,
              height = bounds.height;
          this._charBounds.push({
            x: x + currentX,
            y: y + currentY,
            width: width,
            height: height
          });
        }
        currentY += lineHeight;
      }
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 13602,
    end: 18774
  });
}(undefined);
var TextLayout = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("TextLayout") && typeof __lively_classholder__.TextLayout === "function" ? __lively_classholder__.TextLayout : __lively_classholder__.TextLayout = function TextLayout(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function TextLayout_initialize_(fontMetric) {
      this.lineWrapping = false;
      this.reset(fontMetric);
    }
  }, {
    key: "reset",
    value: function TextLayout_reset_(fontMetric) {
      this.layoutComputed = false;
      this.lines = [];
      this._wrappedLines = null;
      if (fontMetric) this.fontMetric = fontMetric;
      this.firstVisibleLine = undefined;
      this.lastVisibleLine = undefined;
    }
  }, {
    key: "wrappedLines",
    value: function TextLayout_wrappedLines_(morph$$1) {
      this.updateFromMorphIfNecessary(morph$$1);
      if (!this.lineWrapping) return this.lines;
      if (this._wrappedLines) return this._wrappedLines;
      var wrappedLines = [],
          lines = this.lines;
      for (var i = 0; i < lines.length; i++) {
        wrappedLines.push.apply(wrappedLines, toConsumableArray(lines[i].wrappedLines));
      }return this._wrappedLines = wrappedLines;
    }
  }, {
    key: "rangesOfWrappedLine",
    value: function TextLayout_rangesOfWrappedLine_(morph$$1, row) {
      this.updateFromMorphIfNecessary(morph$$1);
      var line = this.lines[row];
      if (!line) return [];
      if (!this.lineWrapping) return [{
        start: {
          column: 0,
          row: row
        },
        end: {
          column: line.length,
          row: row
        }
      }];
      var column = 0;
      return line.wrappedLines.map(function (wrappedLine) {
        var endColumn = column + wrappedLine.length,
            range = {
          start: {
            row: row,
            column: column
          },
          end: {
            row: row,
            column: column + wrappedLine.length
          }
        };
        column = endColumn;
        return range;
      });
    }
  }, {
    key: "firstFullVisibleLine",
    value: function TextLayout_firstFullVisibleLine_(morph$$1) {
      var selector = this.lineWrapping ? "boundsForScreenPos" : "boundsFor",
          bounds = this[selector](morph$$1, {
        row: this.firstVisibleLine,
        column: 0
      });
      return this.firstVisibleLine + (bounds.top() < morph$$1.scroll.y ? 1 : 0);
    }
  }, {
    key: "lastFullVisibleLine",
    value: function TextLayout_lastFullVisibleLine_(morph$$1) {
      var selector = this.lineWrapping ? "boundsForScreenPos" : "boundsFor",
          bounds = this[selector](morph$$1, {
        row: this.lastVisibleLine,
        column: 0
      });
      return this.lastVisibleLine + (bounds.bottom() > morph$$1.scroll.y + morph$$1.height ? -1 : 0);
    }
  }, {
    key: "isLineVisible",
    value: function TextLayout_isLineVisible_(morph$$1, row) {
      return row >= this.firstVisibleLine && row <= this.lastVisibleLine;
    }
  }, {
    key: "isLineFullyVisible",
    value: function TextLayout_isLineFullyVisible_(morph$$1, row) {
      return row >= this.firstFullVisibleLine(morph$$1) && row <= this.lastFullVisibleLine(morph$$1);
    }
  }, {
    key: "defaultCharSize",
    value: function TextLayout_defaultCharSize_(morph$$1) {
      return this.fontMetric.sizeFor(morph$$1.fontFamily, morph$$1.fontSize, "X");
    }
  }, {
    key: "shiftLinesIfNeeded",
    value: function TextLayout_shiftLinesIfNeeded_(morph$$1, _ref3, changeType) {
      var start = _ref3.start,
          end = _ref3.end;

      var nRows = end.row - start.row;
      if (nRows === 0) return;
      var nInsRows = changeType === "insertText" ? nRows : 0,
          nDelRows = changeType === "deleteText" ? nRows : 0,
          placeholderRows = Array(nInsRows),
          from = start.row + 1,
          to = from + nDelRows,
          lines = this.lines;
      this.lines = lines.slice(0, from).concat(placeholderRows).concat(lines.slice(to));
    }
  }, {
    key: "updateFromMorphIfNecessary",
    value: function TextLayout_updateFromMorphIfNecessary_(morph$$1) {
      if (this.layoutComputed) return false;
      this._wrappedLines = null;
      var doc = morph$$1.document,
          lineWrappingBefore = this.lineWrapping,
          lineWrapping = this.lineWrapping = morph$$1.lineWrapping,
          Line = lineWrapping ? WrappedTextLayoutLine : TextLayoutLine,
          paddingLeft = morph$$1.padding.left(),
          paddingRight = morph$$1.padding.right(),
          wrapAt = lineWrapping && morph$$1.fixedWidth ? morph$$1.width - paddingLeft - paddingRight : Infinity,
          fontMetric = this.fontMetric,
          docLines = doc.lines,
          nRows = docLines.length,
          textAttributesChunked = doc.textAttributesChunkedByLine(0, nRows - 1),
          morphBounds = morph$$1.innerBounds();
      if (lineWrapping !== lineWrappingBefore) this.lines = [];
      for (var row = 0; row < nRows; row++) {
        var textAttributesOfLine = textAttributesChunked[row],
            text = docLines[row],
            line = this.lines[row],
            chunksOfLine = chunksFrom(text, fontMetric, textAttributesOfLine);
        if (!line) line = this.lines[row] = new Line();
        line.updateIfNecessary(chunksOfLine, wrapAt);
      }
      this.lines.splice(nRows, this.lines.length - nRows);
      this.layoutComputed = true;
      return true;
    }
  }, {
    key: "pixelPositionFor",
    value: function TextLayout_pixelPositionFor_(morph$$1, docPos) {
      var _boundsFor = this.boundsFor(morph$$1, docPos),
          x = _boundsFor.x,
          y = _boundsFor.y;

      return lively_graphics.pt(x, y);
    }
  }, {
    key: "pixelPositionForIndex",
    value: function TextLayout_pixelPositionForIndex_(morph$$1, index) {
      var pos = morph$$1.document.indexToPosition(index);
      return this.pixelPositionFor(morph$$1, pos);
    }
  }, {
    key: "pixelPositionForScreenPos",
    value: function TextLayout_pixelPositionForScreenPos_(morph$$1, pos) {
      var _boundsForScreenPos = this.boundsForScreenPos(morph$$1, pos),
          x = _boundsForScreenPos.x,
          y = _boundsForScreenPos.y;

      return lively_graphics.pt(x, y);
    }
  }, {
    key: "boundsFor",
    value: function TextLayout_boundsFor_(morph$$1, docPos) {
      return this.boundsForScreenPos(morph$$1, this.docToScreenPos(morph$$1, docPos));
    }
  }, {
    key: "boundsForIndex",
    value: function TextLayout_boundsForIndex_(morph$$1, index) {
      this.updateFromMorphIfNecessary(morph$$1);
      var pos = morph$$1.document.indexToPosition(index);
      return this.boundsFor(morph$$1, pos);
    }
  }, {
    key: "boundsForScreenPos",
    value: function TextLayout_boundsForScreenPos_(morph$$1, _ref4) {
      var row = _ref4.row,
          column = _ref4.column;

      this.updateFromMorphIfNecessary(morph$$1);
      var lines = this.wrappedLines(morph$$1),
          maxLength = lines.length - 1,
          safeRow = Math.max(0, Math.min(maxLength, row)),
          line = lines[safeRow],
          paddingTop = morph$$1.padding.top(),
          paddingLeft = morph$$1.padding.left();
      if (!line) return new lively_graphics.Rectangle(paddingLeft, paddingTop, 0, 0);
      for (var y = 0, i = 0; i < safeRow; i++) {
        y += lines[i].height;
      }
      var _line$boundsFor = line.boundsFor(column),
          x = _line$boundsFor.x,
          width = _line$boundsFor.width,
          height = _line$boundsFor.height;

      return new lively_graphics.Rectangle(paddingLeft + x, paddingTop + y, width, height);
    }
  }, {
    key: "lineAndScreenPositionAtPoint",
    value: function TextLayout_lineAndScreenPositionAtPoint_(morph$$1, point) {
      this.updateFromMorphIfNecessary(morph$$1);
      var lines = this.wrappedLines(morph$$1);
      if (!lines.length) return {
        row: 0,
        column: 0,
        offsetX: 0,
        offsetY: 0,
        line: null
      };
      var x = point.x,
          remainingHeight = point.y,
          line = void 0,
          row = 0;

      x -= morph$$1.padding.left();
      remainingHeight -= morph$$1.padding.top();
      if (remainingHeight < 0) remainingHeight = 0;
      for (; row < lines.length; row++) {
        line = lines[row];
        if (remainingHeight < line.height) break;
        remainingHeight -= line.height;
      }
      row = Math.min(row, lines.length - 1);

      var _line$rowColumnOffset = line.rowColumnOffsetForPixelPos(x, remainingHeight),
          rowOffset = _line$rowColumnOffset.row,
          columnOffset = _line$rowColumnOffset.column;

      return {
        row: row + rowOffset,
        column: columnOffset,
        offsetX: x,
        offsetY: remainingHeight,
        line: line
      };
    }
  }, {
    key: "screenPositionFor",
    value: function TextLayout_screenPositionFor_(morph$$1, point) {
      return this.lineAndScreenPositionAtPoint(morph$$1, point);
    }
  }, {
    key: "textIndexFor",
    value: function TextLayout_textIndexFor_(morph$$1, point) {
      var pos = this.textPositionFor(morph$$1, point);
      return morph$$1.document.positionToIndex(pos);
    }
  }, {
    key: "textBounds",
    value: function TextLayout_textBounds_(morph$$1) {
      this.updateFromMorphIfNecessary(morph$$1);
      var textWidth = 0,
          textHeight = 0,
          lines = this.wrappedLines(morph$$1);
      for (var row = 0; row < lines.length; row++) {
        var _lines$row = lines[row],
            width = _lines$row.width,
            height = _lines$row.height;

        textWidth = Math.max(width, textWidth);
        textHeight += height;
      }
      return new lively_graphics.Rectangle(morph$$1.padding.left(), morph$$1.padding.top(), textWidth, textHeight);
    }
  }, {
    key: "chunkAtPoint",
    value: function TextLayout_chunkAtPoint_(morph$$1, point) {
      var _morph$textLayout$lin = morph$$1.textLayout.lineAndScreenPositionAtPoint(morph$$1, point),
          line = _morph$textLayout$lin.line,
          offsetX = _morph$textLayout$lin.offsetX,
          offsetY = _morph$textLayout$lin.offsetY;

      return line ? line.chunkAtOffset(offsetX) : null;
    }
  }, {
    key: "chunkAtScreenPos",
    value: function TextLayout_chunkAtScreenPos_(morph$$1, _ref5) {
      var row = _ref5.row,
          column = _ref5.column;

      this.updateFromMorphIfNecessary(morph$$1);
      var lines = this.wrappedLines(morph$$1);
      row = Math.max(0, Math.min(lines.length - 1, row));
      var line = lines[row];
      return line ? line.chunkAtColumn(column) : null;
    }
  }, {
    key: "docToScreenPos",
    value: function TextLayout_docToScreenPos_(morph$$1, _ref6) {
      var row = _ref6.row,
          column = _ref6.column;

      if (!this.lineWrapping) return {
        row: row,
        column: column
      };
      this.updateFromMorphIfNecessary(morph$$1);
      var screenRow = Math.max(0, row),
          line = this.lines[row];
      if (!line) line = this.lines[row = this.lines.length - 1];
      if (!line) return {
        row: 0,
        column: 0
      };
      var screenRows = 0;
      for (var j = 0; j < row; j++) {
        screenRows += this.lines[j] ? this.lines[j].wrappedLines.length : 0;
      }
      var columnLeft = column,
          nChars;
      for (var i = 0; i < line.wrappedLines.length; i++) {
        nChars = line.wrappedLines[i].length;
        if (columnLeft < nChars) return {
          row: screenRows + i,
          column: columnLeft
        };
        columnLeft -= nChars;
      }
      return {
        row: screenRows + i - 1,
        column: nChars
      };
    }
  }, {
    key: "screenToDocPos",
    value: function TextLayout_screenToDocPos_(morph$$1, _ref7) {
      var row = _ref7.row,
          column = _ref7.column;

      if (!this.lineWrapping) {
        row = Math.max(0, Math.min(row, this.lines.length - 1));
        column = Math.max(0, Math.min(column, this.lines[row].length));
        return {
          row: row,
          column: column
        };
      }
      this.updateFromMorphIfNecessary(morph$$1);
      var wrappedLines = [],
          lines = this.lines,
          targetLine = void 0,
          screenRow = 0,
          docCol = void 0,
          docRow = void 0,
          found = false;
      for (docRow = 0; docRow < lines.length; docRow++) {
        docCol = 0;
        var _wrappedLines = lines[docRow] && lines[docRow].wrappedLines || [];
        for (var i = 0; i < _wrappedLines.length; i++, screenRow++) {
          if (screenRow === row) {
            column = Math.min(column, _wrappedLines[i].length);
            docCol += column;
            found = true;
            break;
          }
          docCol += _wrappedLines[i].length;
        }
        if (found) break;
      }
      return found ? {
        row: docRow,
        column: docCol
      } : {
        row: docRow - 1,
        column: lines[docRow - 1].length
      };
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 18793,
    end: 29557
  });
}(undefined);

var TextDocument = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("TextDocument") && typeof __lively_classholder__.TextDocument === "function" ? __lively_classholder__.TextDocument : __lively_classholder__.TextDocument = function TextDocument(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function TextDocument_initialize_() {
      var _this = this;

      var lines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var textAttributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      this.lines = lines;
      this._textAttributes = [];
      this._textAttributesByLine = [];
      textAttributes.map(function (range) {
        return _this.addTextAttribute(range);
      });
    }
  }, {
    key: "textString",
    get: function get() {
      return this.lines.join(this.constructor.newline);
    }
  }, {
    key: "textString",
    set: function set(string$$1) {
      this.lines = this.constructor.parseIntoLines(string$$1);
    }
  }, {
    key: "stringLength",
    get: function get() {
      return this.textString.length;
    }
  }, {
    key: "endPosition",
    get: function get() {
      var lines = this.lines,
          length = lines.length;
      return length ? {
        row: lines.length - 1,
        column: lines[lines.length - 1].length
      } : {
        row: 0,
        column: 0
      };
    }
  }, {
    key: "textAttributes",
    get: function get() {
      return this._textAttributes;
    }
  }, {
    key: "textAttributes",
    set: function set(textAttributes) {
      this.setSortedTextAttributes(textAttributes.sort(Range.compare));
    }
  }, {
    key: "textAttributesByLine",
    get: function get() {
      return this._textAttributesByLine;
    }
  }, {
    key: "textAttributesChunkedByLine",
    value: function TextDocument_textAttributesChunkedByLine_() {
      var startRow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        row: 0,
        column: 0
      };
      var endRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.endPosition;
      var withLineEnding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      if (typeof startRow !== "number") startRow = 0;
      if (typeof endRow !== "number") endRow = this.lines.length - 1;
      if (withLineEnding === undefined) withLineEnding = false;
      var lines = new Array(endRow),
          newline = this.constructor.newline;
      var currentAttributes = [],
          attrsOfLine = this._textAttributesByLine[startRow] || [];
      for (var i = 0; i < attrsOfLine.length; i++) {
        var attr = attrsOfLine[i];
        if (attr.start.row < startRow || attr.start.column < 0) currentAttributes.push(attr);
      }
      for (var row = startRow; row <= endRow; row++) {
        attrsOfLine = this._textAttributesByLine[row] || [];
        var attributeChangesByColumn = [],
            content = this.lines[row] || "";
        if (withLineEnding) content += newline;
        for (var _i = 0; _i < attrsOfLine.length; _i++) {
          var _attr = attrsOfLine[_i],
              _attr$start = _attr.start,
              startColumn = _attr$start.column,
              _startRow = _attr$start.row,
              _attr$end = _attr.end,
              endColumn = _attr$end.column,
              _endRow = _attr$end.row;
          if (_startRow === row && startColumn >= 0) {
            var _change = attributeChangesByColumn[startColumn] || (attributeChangesByColumn[startColumn] = {
              starting: [],
              ending: []
            });
            _change.starting.push(_attr);
          }
          if (_endRow === row) {
            var _change2 = attributeChangesByColumn[endColumn] || (attributeChangesByColumn[endColumn] = {
              starting: [],
              ending: []
            });
            _change2.ending.push(_attr);
          }
        }
        var ranges = [],
            column = 0;
        if (!content.length) {
          ranges.push(0, 0, currentAttributes.slice());
        } else {
          var prevCol = 0,
              endColumn = content.length;
          for (column = 0; column <= endColumn; column++) {
            var change = attributeChangesByColumn[column];
            if (!change) {
              if (column === endColumn) ranges.push(prevCol, column, currentAttributes.slice());
              continue;
            }
            var starting = change.starting,
                ending = change.ending;

            if (column > 0) ranges.push(prevCol, column, currentAttributes.slice());
            prevCol = column;
            if (ending.length) for (var _i2 = 0; _i2 < ending.length; _i2++) {
              currentAttributes.splice(currentAttributes.indexOf(ending[_i2]), 1);
            }if (starting.length) currentAttributes.push.apply(currentAttributes, toConsumableArray(starting));
          }
        }
        lines[row] = ranges;
        if (column <= attributeChangesByColumn.length) {
          for (var _i3 = column; _i3 < attributeChangesByColumn.length; _i3++) {
            var _change3 = attributeChangesByColumn[_i3];
            if (!_change3) continue;
            var ending = _change3.ending,
                starting = _change3.starting;

            if (ending.length) for (var j = 0; j < ending.length; j++) {
              currentAttributes.splice(currentAttributes.indexOf(ending[j]), 1);
            }if (starting.length) currentAttributes.push.apply(currentAttributes, toConsumableArray(starting));
          }
        }
      }
      return lines;
    }
  }, {
    key: "textAttributesChunked",
    value: function TextDocument_textAttributesChunked_() {
      var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        row: 0,
        column: 0
      };
      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.endPosition;
      var filterFn = arguments[2];

      if (!filterFn) filterFn = function filterFn() {
        return true;
      };
      var starts = [],
          ends = [];
      for (var i = 0; i < this._textAttributes.length; i++) {
        var attr = this._textAttributes[i],
            startsOfRow = starts[attr.start.row] || (starts[attr.start.row] = []),
            startsOfColumn = startsOfRow[attr.start.column] || (startsOfRow[attr.start.column] = []),
            endsOfRow = ends[attr.end.row] || (ends[attr.end.row] = []),
            endsOfColumn = endsOfRow[attr.end.column] || (endsOfRow[attr.end.column] = []);
        if (filterFn(attr)) {
          startsOfColumn.push(attr);
          endsOfColumn.push(attr);
        }
      }
      var currentAttributes = [];
      for (var _i4 = 0; _i4 < this._textAttributes.length; _i4++) {
        var _attr2 = this._textAttributes[_i4];
        if (!lessPosition(_attr2.start, {
          row: 0,
          column: 0
        })) break;
        if (!lessPosition(_attr2.end, {
          row: 0,
          column: 0
        })) filterFn(_attr2) && currentAttributes.push(_attr2);
      }
      for (var row = 0; row <= from.row; row++) {
        var _startsOfRow = starts[row] || [],
            _endsOfRow = ends[row] || [];
        if (!_startsOfRow.length && !_endsOfRow.length) continue;
        var nCols = Math.max(_endsOfRow.length, _startsOfRow.length);
        for (var column = 0; column <= nCols; column++) {
          var _startsOfColumn = _startsOfRow[column] || [],
              _endsOfColumn = _endsOfRow[column] || [];
          if (!lessEqPosition({
            row: row,
            column: column
          }, from)) break;
          _startsOfColumn.forEach(function (attr) {
            return !currentAttributes.includes(attr) && currentAttributes.push(attr);
          });
          _endsOfColumn.forEach(function (attr) {
            return lively_lang.arr.remove(currentAttributes, attr);
          });
        }
      }
      var result = [],
          lastStart = {
        row: from.row,
        column: from.column
      };
      for (var _row = from.row; _row <= to.row; _row++) {
        var _startsOfRow2 = starts[_row] || [],
            _endsOfRow2 = ends[_row] || [];
        if (!_startsOfRow2.length && !_endsOfRow2.length) continue;
        var _nCols = Math.max(_endsOfRow2.length, _startsOfRow2.length);

        var _loop = function _loop(_column) {
          var pos = {
            row: _row,
            column: _column
          };
          if (lessEqPosition(pos, from)) return "continue";
          if (!lessEqPosition(pos, to)) return "break";
          var startsOfColumn = _startsOfRow2[_column] || [],
              endsOfColumn = _endsOfRow2[_column] || [],
              zeroLengthAttrs = [];
          if (!startsOfColumn.length && !endsOfColumn.length) return "continue";
          result.push([lastStart, pos, currentAttributes.slice()]);
          lastStart = pos;
          startsOfColumn.forEach(function (attr) {
            return !currentAttributes.includes(attr) && currentAttributes.push(attr);
          });
          endsOfColumn.forEach(function (attr) {
            if (startsOfColumn.includes(attr)) zeroLengthAttrs.push(attr);
            var i = currentAttributes.indexOf(attr);
            if (i > -1) currentAttributes.splice(i, 1);
          });
          if (zeroLengthAttrs.length) result.push([pos, pos, zeroLengthAttrs]);
        };

        _loop2: for (var _column = 0; _column <= _nCols; _column++) {
          var _ret = _loop(_column);

          switch (_ret) {
            case "continue":
              continue;

            case "break":
              break _loop2;}
        }
      }
      if (!eqPosition(lastStart, to)) result.push([lastStart, to, currentAttributes.slice()]);
      return result;
    }
  }, {
    key: "textAndAttributes",
    get: function get() {
      var _this2 = this;

      var newline = this.constructor.newline,
          maxRow = this.lines.length - 1;
      return lively_lang.arr.flatmap(this.textAttributesChunkedByLine(0, maxRow, true), function (chunked, row) {
        if (row === maxRow) newline = "";
        return lively_lang.arr.toTuples(chunked, 3).map(function (_ref) {
          var _ref2 = slicedToArray(_ref, 3),
              startCol = _ref2[0],
              endCol = _ref2[1],
              attrs = _ref2[2];

          return [(_this2.lines[row] + newline).slice(startCol, endCol), attrs];
        });
      });
    }
  }, {
    key: "textAndAttributes",
    set: function set(textAndAttributes) {
      var row = 0,
          column = 0,
          lines = [],
          currentLine = "",
          activeAttrs = [],
          attrs = [];
      while (textAndAttributes.length) {
        var _textAndAttributes$sh = textAndAttributes.shift(),
            _textAndAttributes$sh2 = slicedToArray(_textAndAttributes$sh, 2),
            text = _textAndAttributes$sh2[0],
            attrsOfRange = _textAndAttributes$sh2[1];

        for (var i = 0; i < activeAttrs.length; i++) {
          if (!attrsOfRange.includes(activeAttrs[i])) {
            var _activeAttrs$splice = activeAttrs.splice(i, 1),
                _activeAttrs$splice2 = slicedToArray(_activeAttrs$splice, 1),
                attr = _activeAttrs$splice2[0];

            attr.end = {
              row: row,
              column: column
            };
          }
        }
        for (var _i5 = 0; _i5 < attrsOfRange.length; _i5++) {
          var _attr3 = attrsOfRange[_i5];
          if (!attrs.includes(_attr3)) attrs.push(_attr3);
          if (!activeAttrs.includes(_attr3)) {
            activeAttrs.push(_attr3);
            _attr3.start = {
              row: row,
              column: column
            };
          }
        }
        for (var _i6 = 0; _i6 < text.length; _i6++) {
          var char = text[_i6];
          if (char === "\n") {
            lines.push(currentLine);
            currentLine = "";
            row++;
            column = 0;
          } else {
            currentLine += char;
            column++;
          }
        }
      }
      if (currentLine.length) lines.push(currentLine);
      activeAttrs.forEach(function (attr) {
        return attr.end = {
          row: row,
          column: column
        };
      });
      this.lines = lines;
      this.textAttributes = attrs;
    }
  }, {
    key: "setSortedTextAttributes",
    value: function TextDocument_setSortedTextAttributes_(attributes) {
      this._textAttributes = attributes;
      this._textAttributesByLine = new Array(this.lines.length);
      for (var i = 0; i < attributes.length; i++) {
        var attr = attributes[i],
            start = attr.start,
            end = attr.end;
        for (var row = start.row; row <= end.row; row++) {
          (this._textAttributesByLine[row] || (this._textAttributesByLine[row] = [])).push(attr);
        }
      }
    }
  }, {
    key: "addTextAttribute",
    value: function TextDocument_addTextAttribute_(textAttr) {
      this.addSortedTextAttributes([textAttr]);
      return textAttr;
    }
  }, {
    key: "addTextAttributes",
    value: function TextDocument_addTextAttributes_(attrs) {
      return this.addSortedTextAttributes(attrs.sort(Range.compare));
    }
  }, {
    key: "addSortedTextAttributes",
    value: function TextDocument_addSortedTextAttributes_(attrs) {
      if (!attrs.length) return [];
      var textAttributes = this._textAttributes,
          first = attrs[0],
          last = lively_lang.arr.last(attrs);
      var insertionStart = 0;
      while (insertionStart < textAttributes.length && (textAttributes[insertionStart].start.row < first.start.row || textAttributes[insertionStart].start.row === first.start.row && textAttributes[insertionStart].start.column < 0)) {
        insertionStart++;
      }var insertionEnd = insertionStart;
      while (insertionEnd < textAttributes.length && textAttributes[insertionEnd].start.row <= last.end.row) {
        insertionEnd++;
      }var newAttributes = textAttributes.slice(insertionStart, insertionEnd).concat(attrs).sort(Range.compare);
      this._textAttributes = textAttributes.slice(0, insertionStart).concat(newAttributes).concat(textAttributes.slice(insertionEnd));
      var endRow = lively_lang.arr.max(newAttributes, function (ea) {
        return ea.end.row;
      }).end.row;
      for (var row = first.start.row; row <= endRow; row++) {
        var byLine = this._textAttributesByLine[row] || (this._textAttributesByLine[row] = []),
            i = 0;
        while (i < byLine.length && (byLine[i].start.row < first.start.row || byLine[i].start.row === first.start.row && byLine[i].start.column < 0)) {
          i++;
        }byLine.length = i;
      }
      for (var _i7 = 0; _i7 < newAttributes.length; _i7++) {
        var attr = newAttributes[_i7],
            start = attr.start,
            end = attr.end;
        for (var _row2 = start.row; _row2 <= end.row; _row2++) {
          (this._textAttributesByLine[_row2] || (this._textAttributesByLine[_row2] = [])).push(attr);
        }
      }
      return attrs;
    }
  }, {
    key: "removeTextAttribute",
    value: function TextDocument_removeTextAttribute_(attr) {
      var idx = this._textAttributes.indexOf(attr);
      if (idx > -1) this._textAttributes.splice(idx, 1);
      for (var row = attr.start.row; row <= attr.end.row; row++) {
        var attrs = this._textAttributesByLine[row] || [],
            _idx = attrs.indexOf(attr);
        if (_idx > -1) attrs.splice(_idx, 1);
      }
    }
  }, {
    key: "removeTextAttributes",
    value: function TextDocument_removeTextAttributes_(attrs) {
      this.setSortedTextAttributes(lively_lang.arr.withoutAll(this._textAttributes, attrs));
    }
  }, {
    key: "resetTextAttributes",
    value: function TextDocument_resetTextAttributes_() {
      this._textAttributes = [];
      this._textAttributesByLine = [];
    }
  }, {
    key: "stylesChunked",
    value: function TextDocument_stylesChunked_() {
      var range = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var from = range.start,
          to = range.end;

      return this.textAttributesChunked(from, to).map(function (_ref3) {
        var _ref4 = slicedToArray(_ref3, 3),
            start = _ref4[0],
            end = _ref4[1],
            attrs = _ref4[2];

        return [start, end, Object.assign.apply(Object, [{}].concat(toConsumableArray(attrs.filter(function (ea) {
          return ea.isStyleAttribute;
        }).map(function (ea) {
          return ea.data;
        }))))];
      });
    }
  }, {
    key: "setStyleInRange",
    value: function TextDocument_setStyleInRange_() {
      var newStyle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var range = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        start: {
          row: 0,
          column: 0
        },
        end: this.endPosition
      };
      var defaultStyleAttribute = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { data: {} };
      var from = range.start,
          to = range.end,
          styleProps = Object.keys(newStyle),
          defaultStyle = defaultStyleAttribute.data,
          attributesSeen = [],
          toAdd = [],
          toRemove = [];

      this.textAttributesChunked(from, to, function (attr) {
        return attr !== defaultStyleAttribute && attr.isStyleAttribute;
      }).forEach(function (_ref5) {
        var _ref6 = slicedToArray(_ref5, 3),
            start = _ref6[0],
            end = _ref6[1],
            styleAttrs = _ref6[2];

        var _styleAttrs = toArray(styleAttrs),
            localStyleAttr = _styleAttrs[0],
            rest = _styleAttrs.slice(1);

        if (rest.length) {
          var _toRemove;

          (_toRemove = toRemove).push.apply(_toRemove, toConsumableArray(rest));
          toRemove = lively_lang.arr.uniq(toRemove);
        }
        var localStyle = Object.assign({}, defaultStyle, {}, localStyleAttr ? localStyleAttr.data : null);
        var propsToChange = styleProps.filter(function (key) {
          return newStyle[key] && typeof newStyle[key].equals === "function" ? !newStyle[key].equals(localStyle[key]) : newStyle[key] !== localStyle[key];
        });
        if (!propsToChange.length) return;
        var newStyleForRange = Object.assign({}, localStyleAttr ? localStyleAttr.data : null, {}, lively_lang.obj.select(newStyle, propsToChange));
        if (localStyleAttr) {
          lively_lang.arr.pushIfNotIncluded(toRemove, localStyleAttr);
          propsToChange.forEach(function (key) {
            if (newStyle[key] === defaultStyle[key]) delete newStyleForRange[key];
          });
          if (!attributesSeen.includes(localStyleAttr)) {
            attributesSeen.push(localStyleAttr);
            if (lessPosition(localStyleAttr.start, from)) toAdd.push(localStyleAttr.splitAt(from)[0]);
            if (lessPosition(to, localStyleAttr.end)) toAdd.push(localStyleAttr.splitAt(to)[1]);
          }
        }
        if (!localStyleAttr || Object.keys(newStyleForRange).length) toAdd.push(new TextStyleAttribute(newStyleForRange, {
          start: start,
          end: end
        }));
      });
      this.removeTextAttributes(toRemove);
      var merged = [this._textAttributes[0]].concat(TextStyleAttribute.mergeAdjacentAttributes(this._textAttributes.slice(1).concat(toAdd)).sort(Range.compare));
      this.setSortedTextAttributes(merged);
    }
  }, {
    key: "getLine",
    value: function TextDocument_getLine_(row) {
      var safeRow = Math.min(Math.max(0, row), this.lines.length - 1);
      return this.lines[safeRow];
    }
  }, {
    key: "positionToIndex",
    value: function TextDocument_positionToIndex_(pos) {
      var startRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      var _clipPositionToLines = this.clipPositionToLines(pos),
          row = _clipPositionToLines.row,
          column = _clipPositionToLines.column,
          index = 0,
          lines = this.lines,
          maxLength = lines.length - 1,
          newlineLength = this.constructor.newlineLength;

      for (var i = startRow; i < row; i++) {
        index += lines[i].length + (i === maxLength ? 0 : newlineLength);
      }return index + column;
    }
  }, {
    key: "indexToPosition",
    value: function TextDocument_indexToPosition_(index) {
      var startRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      if (index < 0) index = 0;
      var lines = this.lines,
          newlineLength = this.constructor.newlineLength;
      if (lines.length === 0) return {
        row: 0,
        column: 0
      };
      for (var i = startRow, l = lines.length; i < l; i++) {
        index -= lines[i].length + newlineLength;
        if (index < 0) return {
          row: i,
          column: index + lines[i].length + newlineLength
        };
      }
      return {
        row: l - 1,
        column: lines[l - 1].length
      };
    }
  }, {
    key: "clipPositionToLines",
    value: function TextDocument_clipPositionToLines_(_ref7) {
      var row = _ref7.row,
          column = _ref7.column;

      var lines = this.lines,
          nLines = lines.length;
      if (nLines === 0) return {
        row: 0,
        column: 0
      };
      if (row < 0) row = 0;else if (row >= nLines) row = nLines - 1;
      if (column < 0) column = 0;else if (column > lines[row].length) column = lines[row].length;
      return {
        row: row,
        column: column
      };
    }
  }, {
    key: "textInRange",
    value: function TextDocument_textInRange_(_ref8) {
      var start = _ref8.start,
          end = _ref8.end;

      start = this.clipPositionToLines(start);
      end = this.clipPositionToLines(end);
      if (lessPosition(end, start)) {
        
        var _ref9 = [end, start];
        start = _ref9[0];
        end = _ref9[1];
      }var _start = start,
          row = _start.row,
          column = _start.column,
          _end = end,
          endRow = _end.row,
          endColumn = _end.column,
          lines = this.lines,
          newline = this.constructor.newline;

      if (row === endRow) return column === endColumn ? "" : lines[row].slice(column, endColumn);
      var result = lines[row].slice(column);
      for (var i = row + 1; i < endRow; i++) {
        result += newline + lines[i];
      }return result + newline + lines[endRow].slice(0, endColumn);
    }
  }, {
    key: "setTextInRange",
    value: function TextDocument_setTextInRange_(string$$1, range) {
      this.remove(range);
      return this.insert(string$$1, range.start);
    }
  }, {
    key: "insert",
    value: function TextDocument_insert_(string$$1, pos) {
      var _this3 = this;

      var lines = this.lines,
          row = pos.row,
          column = pos.column,
          line = lines[row],
          insertionLines = this.constructor.parseIntoLines(string$$1);
      if (!line) line = lines[row] = "";
      if (column > line.length) line += " ".repeat(column - line.length);
      var end = {
        row: row,
        column: column
      },
          before = line.slice(0, column),
          after = line.slice(column),
          firstLine = insertionLines.shift() || "";
      end.column += firstLine.length;
      lines[row] = before + firstLine;
      for (var i = 0; i < insertionLines.length; i++) {
        end.row++;
        end.column = insertionLines[i].length;
        lines.splice(row + 1 + i, 0, insertionLines[i]);
        this._textAttributesByLine.splice(row + 1 + i, 0, []);
      }
      lines[row + insertionLines.length] = lines[row + insertionLines.length] + after;
      var insertionRange = {
        start: pos,
        end: end
      };
      for (var _i8 = this._textAttributes.length - 1; _i8 >= 0; _i8--) {
        var attr = this._textAttributes[_i8];
        if (attr.start.row <= row) break;
        attr.onInsert(insertionRange);
      }
      var attrsSeen = [];
      (this._textAttributesByLine[row] || (this._textAttributesByLine[row] = [])).forEach(function (attr) {
        if (attrsSeen.includes(attr)) return;
        attrsSeen.push(attr);
        if (!attr.onInsert(insertionRange)) return;
        for (var j = 0; j < insertionLines.length; j++) {
          var newRow = row + 1 + j,
              attrsInNewRow = _this3._textAttributesByLine[newRow];
          if (attr.end.row >= newRow) attrsInNewRow.push(attr);
        }
      });
      return insertionRange;
    }
  }, {
    key: "remove",
    value: function TextDocument_remove_(range) {
      var start = range.start,
          end = range.end,
          lines = this.lines;

      if (!lines.length) return;
      if (lessPosition(end, start)) {
        
        var _ref10 = [end, start];
        start = _ref10[0];
        end = _ref10[1];
      }
      var _maxPosition = maxPosition(start, {
        column: 0,
        row: 0
      }),
          fromRow = _maxPosition.row,
          fromCol = _maxPosition.column,
          _minPosition = minPosition(end, this.endPosition),
          toRow = _minPosition.row,
          toCol = _minPosition.column;

      if (fromCol < 0) fromCol = 0;
      if (toCol < 0) toCol = 0;
      lines[fromRow] = lines[fromRow].slice(0, fromCol) + lines[toRow].slice(toCol);
      lines.splice(fromRow + 1, toRow - fromRow);
      var rangesToRemove = [],
          currentRangeStart = undefined,
          currentRangeEnd = undefined,
          textAttributes = this._textAttributes;
      for (var i = 0; i < textAttributes.length; i++) {
        var ea = textAttributes[i];
        if (ea.onDelete(range) && ea.isEmpty()) {
          if (currentRangeStart === undefined) currentRangeStart = i;
          currentRangeEnd = i + 1;
        } else {
          if (currentRangeStart !== undefined) {
            rangesToRemove.push([currentRangeStart, currentRangeEnd]);
            currentRangeStart = currentRangeEnd = undefined;
          }
        }
      }
      if (currentRangeStart !== undefined) rangesToRemove.push([currentRangeStart, currentRangeEnd]);
      rangesToRemove.reverse().forEach(function (_ref11) {
        var _ref12 = slicedToArray(_ref11, 2),
            i = _ref12[0],
            j = _ref12[1];

        return textAttributes = textAttributes.slice(0, i).concat(textAttributes.slice(j));
      });
      this.setSortedTextAttributes(textAttributes);
    }
  }, {
    key: "wordsOfLine",
    value: function TextDocument_wordsOfLine_(row) {
      var line = this.lines[row] || "",
          words = [],
          word,
          isWordDelimiter = function isWordDelimiter(char) {
        return (/[^a-z0-9_]/i.test(char)
        );
      };
      for (var i = 0; i < line.length; i++) {
        if (isWordDelimiter(line[i])) {
          if (word) {
            word.range.end.column = i;
            words.push(word);
            word = null;
          }
        } else {
          word = word || {
            index: words.length,
            string: "",
            range: {
              start: {
                row: row,
                column: i
              },
              end: {
                row: row,
                column: i
              }
            }
          };
          word.string += line[i];
        }
      }
      if (word) {
        word.range.end.column = i;
        words.push(word);
      }
      return words;
    }
  }, {
    key: "wordAt",
    value: function TextDocument_wordAt_(_ref13) {
      var row = _ref13.row,
          column = _ref13.column;
      var words = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.wordsOfLine(row);

      return words.find(function (ea) {
        var _ea$range = ea.range,
            startCol = _ea$range.start.column,
            endCol = _ea$range.end.column;

        return startCol <= column && column <= endCol;
      }) || {
        range: {
          start: {
            column: column,
            row: row
          },
          end: {
            column: column,
            row: row
          }
        },
        string: ""
      };
    }
  }, {
    key: "wordLeft",
    value: function TextDocument_wordLeft_(pos) {
      var row = pos.row,
          column = pos.column,
          words = this.wordsOfLine(row);

      if (!words.length || lessEqPosition(pos, words[0].range.start)) {
        while (--row >= 0) {
          words = this.wordsOfLine(row);
          if (words.length) return lively_lang.arr.last(words);
        }
        return {
          range: {
            start: pos,
            end: pos
          },
          string: ""
        };
      }
      var word = this.wordAt(pos);
      if (word.string) return eqPosition(word.range.start, pos) ? words[word.index - 1] : word;
      return words.slice().reverse().find(function (word) {
        return word.range.end.column <= column;
      }) || {
        range: {
          start: pos,
          end: pos
        },
        string: ""
      };
    }
  }, {
    key: "wordRight",
    value: function TextDocument_wordRight_(pos) {
      var column = pos.column,
          row = pos.row,
          words = this.wordsOfLine(pos.row);

      if (!words.length || lessEqPosition(lively_lang.arr.last(words).range.end, pos)) {
        while (++row < this.lines.length) {
          words = this.wordsOfLine(row);
          if (words.length) return words[0];
        }
        return {
          range: {
            start: pos,
            end: pos
          },
          string: ""
        };
      }
      var word = this.wordAt(pos);
      if (word.string) {
        return eqPosition(word.range.end, pos) ? words[word.index + 1] : word;
      }
      return words.find(function (word) {
        return word.range.start.column >= column;
      }) || {
        range: {
          start: pos,
          end: pos
        },
        string: ""
      };
    }
  }, {
    key: "scanForward",
    value: function TextDocument_scanForward_(startPos, matchFn) {
      var lines = this.lines,
          row = startPos.row,
          column = startPos.column;
      for (var col = column, line = lines[row]; col < line.length; col++) {
        var char = line[col],
            pos = {
          row: row,
          column: col
        },
            result = matchFn(char, pos);
        if (result) return result;
      }
      for (var r = row + 1; r < lines.length; r++) {
        var _line = lines[r];
        for (var _col = 0; _col < _line.length; _col++) {
          var _char = _line[_col],
              _pos = {
            row: r,
            column: _col
          },
              _result = matchFn(_char, _pos);
          if (_result) return _result;
        }
      }
      return null;
    }
  }, {
    key: "scanBackward",
    value: function TextDocument_scanBackward_(startPos, matchFn) {
      var lines = this.lines,
          row = startPos.row,
          column = startPos.column;
      for (var col = column - 1, line = lines[row]; col >= 0; col--) {
        var char = line[col],
            pos = {
          row: row,
          column: col
        },
            result = matchFn(char, pos);
        if (result) return result;
      }
      for (var r = row - 1; r >= 0; r--) {
        var _line2 = lines[r];
        for (var _col2 = _line2.length - 1; _col2 >= 0; _col2--) {
          var _char2 = _line2[_col2],
              _pos2 = {
            row: r,
            column: _col2
          },
              _result2 = matchFn(_char2, _pos2);
          if (_result2) return _result2;
        }
      }
      return null;
    }
  }, {
    key: "copy",
    value: function TextDocument_copy_() {
      return new TextDocument(this.lines.slice());
    }
  }, {
    key: "toString",
    value: function TextDocument_toString_() {
      return "TextDocument(" + lively_lang.string.truncate(this.textString, 60) + ")";
    }
  }], [{
    key: "fromString",
    value: function TextDocument_fromString_(string$$1) {
      var doc = new TextDocument();
      doc.textString = string$$1;
      return doc;
    }
  }, {
    key: "newline",
    get: function get() {
      return "\n";
    }
  }, {
    key: "newlineLength",
    get: function get() {
      return 1;
    }
  }, {
    key: "parseIntoLines",
    value: function TextDocument_parseIntoLines_(text) {
      return text.split(this.newline);
    }
  }], __lively_classholder__, undefined, {
    start: 253,
    end: 30205
  });
}(undefined);

var occurKeyHandler = Object.assign(KeyHandler.withBindings([{
  keys: "Escape|Ctrl-G",
  command: "occur exit"
}, {
  keys: "Enter",
  command: "occur accept"
}]), { isOccurHandler: true });
var occurStartCommand = {
  name: "occur",
  exec: function exec(textMorph) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (opts.needle) textMorph.addPlugin(new Occur(opts));
    return !!opts.needle;
  }
};
function findOccurPlugin(textMorph) {
  return textMorph.plugins.slice().reverse().find(function (ea) {
    return ea.isOccurPlugin;
  });
}
var occurCommands = [{
  name: "occur exit",
  exec: function exec(textMorph) {
    var occur = findOccurPlugin(textMorph);
    if (!occur) return false;
    occur.options.translatePosition = true;
    textMorph.removePlugin(occur);
    var otherOccur = findOccurPlugin(textMorph);
    if (otherOccur) otherOccur.highlight();
    return true;
  },
  readOnly: true
}, {
  name: "occur accept",
  bindKey: "Enter",
  exec: function exec(textMorph) {
    var occur = findOccurPlugin(textMorph);
    if (!occur) return false;
    occur.options.translatePosition = true;
    textMorph.removePlugin(occur);
    var otherOccur = findOccurPlugin(textMorph);
    if (otherOccur) otherOccur.highlight();
    return true;
  },
  readOnly: true
}];
var Occur = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("Occur") && typeof __lively_classholder__.Occur === "function" ? __lively_classholder__.Occur : __lively_classholder__.Occur = function Occur(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function Occur_initialize_() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.options = options;
      if (options.textMorph) this.textMorph = options.textMorph;
    }
  }, {
    key: "isOccurPlugin",
    get: function get() {
      return true;
    }
  }, {
    key: "attach",
    value: function Occur_attach_(textMorph) {
      this.textMorph = textMorph;
      var pos = this.textMorph.cursorPosition;
      var notEmpty = this.displayOccurContent(this.options);
      if (notEmpty) {
        var translatedPos = this.originalToOccurPosition(pos);
        this.textMorph.cursorPosition = translatedPos;
      }
      return this;
    }
  }, {
    key: "detach",
    value: function Occur_detach_(textMorph) {
      this.removeHighlight();
      var pos = this.options.translatePosition && this.textMorph.cursorPosition,
          translatedPos = pos && this.occurToOriginalPosition(pos);
      this.displayOriginalContent();
      if (translatedPos) this.textMorph.cursorPosition = translatedPos;
      this.textMorph = null;
      return this;
    }
  }, {
    key: "getKeyHandlers",
    value: function Occur_getKeyHandlers_(morphKeyHandlers) {
      return morphKeyHandlers.concat(occurKeyHandler);
    }
  }, {
    key: "getCommands",
    value: function Occur_getCommands_(morphCommands) {
      return occurCommands.concat(morphCommands);
    }
  }, {
    key: "matchingLines",
    value: function Occur_matchingLines_() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { needle: "" };

      if (!options.needle) return [];
      var lines = this.textMorph.document.lines,
          search = new TextSearcher(this.textMorph),
          found = search.searchForAll(Object.assign({}, options, {
        start: {
          column: 0,
          row: 0
        }
      }));
      return lively_lang.arr.groupBy(found, function (_ref) {
        var row = _ref.range.start.row;
        return row;
      }).mapGroups(function (_, foundInRow) {
        var row = foundInRow[0].range.start.row;
        return {
          row: row,
          ranges: foundInRow.map(function (_ref2) {
            var range = _ref2.range;
            return range;
          }),
          line: lines[row]
        };
      }).toArray();
    }
  }, {
    key: "displayOccurContent",
    value: function Occur_displayOccurContent_(options) {
      this._originalDocument = this.textMorph.document;
      var found = this.matchingLines(options),
          lines = found.map(function (_ref3) {
        var line = _ref3.line;
        return line;
      }),
          occurDocument = this._document = new TextDocument(lines);
      occurDocument._occurMatchingLines = found;
      if (found.length > 0) {
        this.textMorph.changeDocument(occurDocument, true);
        this.highlight(options.needle);
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: "displayOriginalContent",
    value: function Occur_displayOriginalContent_() {
      this.textMorph.changeDocument(this._originalDocument);
    }
  }, {
    key: "occurToOriginalPosition",
    value: function Occur_occurToOriginalPosition_(pos) {
      var lines = this._document._occurMatchingLines;
      if (!lines || !lines[pos.row]) return pos;
      return {
        row: lines[pos.row].row,
        column: pos.column
      };
    }
  }, {
    key: "originalToOccurPosition",
    value: function Occur_originalToOccurPosition_(pos) {
      var lines = this._document._occurMatchingLines,
          nullPos = {
        row: 0,
        column: 0
      };
      if (!lines) return nullPos;
      for (var i = 0; i < lines.length; i++) {
        if (lines[i].row === pos.row) return {
          row: i,
          column: pos.column
        };
      }return nullPos;
    }
  }, {
    key: "highlight",
    value: function Occur_highlight_(needle) {
      var _this = this;

      this.removeHighlight();
      var style = {
        borderRadius: "4px",
        backgroundColor: "rgba(87, 255, 8, 0.25)",
        position: "absolute",
        "-moz-box-sizing": "border-box",
        "-webkit-box-sizing": "border-box",
        "box-sizing": "border-box",
        "box-shadow": "0 0 4px rgb(91, 255, 50)"
      };
      var ranges = lively_lang.arr.flatmap(this._document._occurMatchingLines, function (_ref4, row) {
        var ranges = _ref4.ranges;
        return ranges.map(function (_ref5) {
          var column = _ref5.start.column,
              endColumn = _ref5.end.column;
          return {
            start: {
              column: column,
              row: row
            },
            end: {
              column: endColumn,
              row: row
            }
          };
        });
      });
      ranges.map(function (range, i) {
        return {
          id: "occur-" + i,
          range: range,
          style: style
        };
      }).forEach(function (m) {
        return _this.textMorph.addMarker(m);
      });
    }
  }, {
    key: "removeHighlight",
    value: function Occur_removeHighlight_() {
      var _this2 = this;

      (this.textMorph.markers || []).filter(function (_ref6) {
        var id = _ref6.id;
        return id.indexOf("occur-") === 0;
      }).forEach(function (m) {
        return _this2.textMorph.removeMarker(m);
      });
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 1848,
    end: 5848
  });
}(undefined);

var Button$$1 = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("Button") && typeof __lively_classholder__.Button === "function" ? __lively_classholder__.Button : __lively_classholder__.Button = function Button$$1(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function Button_initialize_(props) {
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, props);
      this.updateButtonStyle();
      this.relayout();
      lively_bindings.connect(this, "extent", this, "relayout");
      lively_bindings.connect(this, "padding", this, "relayout");
      lively_bindings.connect(this, "fontSize", this, "relayout");
      lively_bindings.connect(this, "fontFamily", this, "relayout");
      lively_bindings.connect(this, "active", this, "updateButtonStyle");
      lively_bindings.connect(this, "activeStyle", this, "updateButtonStyle");
      lively_bindings.connect(this, "inactiveStyle", this, "updateButtonStyle");
    }
  }, {
    key: "isButton",
    get: function get() {
      return true;
    }
  }, {
    key: "relayout",
    value: function Button_relayout_() {
      var label = this.labelMorph;
      if (!label) return;
      var padding = this.padding,
          padT = padding.top(),
          padB = padding.bottom(),
          padL = padding.left(),
          padR = padding.right(),
          minHeight = label.height + padT + padB,
          minWidth = label.width + padL + padR;
      if (minHeight > this.height) this.height = minHeight;
      if (minWidth > this.width) this.width = minWidth;
      label.center = this.innerBounds().insetByRect(padding).center();
      return this;
    }
  }, {
    key: "updateButtonStyle",
    value: function Button_updateButtonStyle_() {
      var isActive = this.active;
      Object.assign(this, isActive ? this.activeStyle : this.inactiveStyle);
      this.labelMorph.nativeCursor = this.nativeCursor;
    }
  }, {
    key: "fit",
    value: function Button_fit_() {
      var padding = this.padding,
          label = this.labelMorph;
      label.fit();
      this.extent = padding.bottomLeft().addPt(padding.bottomRight()).addPt(label.extent);
      this.relayout();
      return this;
    }
  }, {
    key: "trigger",
    value: function Button_trigger_() {
      try {
        lively_bindings.signal(this, "fire");
        typeof this.action == "function" && this.action();
      } catch (err) {
        var w = this.world();
        if (w) w.logError(err);else console.error(err);
      }
    }
  }, {
    key: "onMouseDown",
    value: function Button_onMouseDown_(evt) {
      if (this.active) Object.assign(this, this.triggerStyle);
    }
  }, {
    key: "onMouseUp",
    value: function Button_onMouseUp_(evt) {
      if (evt.isClickTarget(this) && this.active) {
        Object.assign(this, this.activeStyle);
        this.trigger();
      }
    }
  }, {
    key: "onHoverOut",
    value: function Button_onHoverOut_(evt) {
      if (this.active && evt.isClickTarget(this)) Object.assign(this, this.activeStyle);
    }
  }, {
    key: "onHoverIn",
    value: function Button_onHoverIn_(evt) {
      if (this.active && evt.isClickTarget(this)) Object.assign(this, this.triggerStyle);
    }
  }], [{
    key: "properties",
    get: function get() {
      return {
        padding: { defaultValue: lively_graphics.Rectangle.inset(4, 2) },
        borderWidth: { defaultValue: 1 },
        extent: { defaultValue: lively_graphics.pt(100, 24) },
        borderRadius: { defaultValue: 15 },
        draggable: { defaultValue: false },
        labelMorph: {
          after: ["submorphs"],
          derived: true,
          initialize: function initialize() {
            this.labelMorph = this.addMorph({
              type: "label",
              name: "label",
              value: "no label yet",
              fill: lively_graphics.Color.white.withA(0),
              padding: lively_graphics.Rectangle.inset(0)
            });
          },
          get: function get() {
            return this.getSubmorphNamed("label");
          },
          set: function set(labelMorph) {
            var existing = this.labelMorph;
            if (existing) {
              lively_bindings.disconnect(this.labelMorph, "extent", this, "relayout");
              existing.remove();
            }
            labelMorph.name = "label";
            this.addMorphAt(labelMorph, 0);
            lively_bindings.connect(this.labelMorph, "extent", this, "relayout");
          }
        },
        label: {
          after: ["labelMorph"],
          derived: true,
          get: function get() {
            return this.labelMorph.textString;
          },
          set: function set(stringOrAttributesOrMorph) {
            if (stringOrAttributesOrMorph.isMorph) {
              this.labelMorph = stringOrAttributesOrMorph;
            } else {
              this.labelMorph.value = stringOrAttributesOrMorph;
            }
          }
        },
        active: {
          after: ["labelMorph", "activeStyle", "inactiveStyle"],
          defaultValue: true
        },
        fontFamily: {
          after: ["labelMorph"],
          derived: true,
          get: function get() {
            return this.labelMorph.fontFamily;
          },
          set: function set(fontFamily) {
            this.labelMorph.fontFamily = fontFamily;
          }
        },
        fontSize: {
          after: ["labelMorph"],
          derived: true,
          get: function get() {
            return this.labelMorph.fontSize;
          },
          set: function set(fontSize) {
            this.labelMorph.fontSize = fontSize;
          }
        },
        fontColor: {
          after: ["labelMorph"],
          derived: true,
          get: function get() {
            return this.labelMorph.fontColor;
          },
          set: function set(fontColor) {
            this.labelMorph.fontColor = fontColor;
          }
        },
        labelWithTextAttributes: {
          after: ["labelMorph"],
          derived: true,
          get: function get() {
            return this.labelMorph.textAndAttributes;
          },
          set: function set(val) {
            this.labelMorph.textAndAttributes = val;
          }
        },
        defaultActiveStyle: {
          defaultValue: {
            borderColor: lively_graphics.Color.gray,
            fill: lively_graphics.Color.rgb(240, 240, 240),
            fontColor: lively_graphics.Color.almostBlack,
            nativeCursor: "pointer"
          }
        },
        activeStyle: {
          after: ["labelMorph"],
          initialize: function initialize() {
            this.activeStyle = this.defaultActiveStyle;
          },
          set: function set(value) {
            this.setProperty("activeStyle", Object.assign({}, this.defaultActiveStyle, {}, value));
          }
        },
        defaultInactiveStyle: {
          defaultValue: {
            borderColor: lively_graphics.Color.gray.withA(0.5),
            fill: lively_graphics.Color.rgba(240, 240, 240, 0.5),
            fontColor: lively_graphics.Color.almostBlack.withA(0.5),
            nativeCursor: "not-allowed"
          }
        },
        inactiveStyle: {
          after: ["labelMorph"],
          initialize: function initialize() {
            this.inactiveStyle = this.defaultInactiveStyle;
          },
          set: function set(value) {
            this.setProperty("inactiveStyle", Object.assign({}, this.defaultInactiveStyle, {}, value));
          }
        },
        defaultTriggerStyle: { defaultValue: { fill: lively_graphics.Color.rgb(161, 161, 161) } },
        triggerStyle: {
          after: ["labelMorph"],
          initialize: function initialize() {
            this.triggerStyle = this.defaultTriggerStyle;
          },
          set: function set(value) {
            this.setProperty("triggerStyle", Object.assign({}, this.defaultTriggerStyle, {}, value));
          }
        }
      };
    }
  }], __lively_classholder__, undefined, {
    start: 410,
    end: 6383
  });
}(Morph$1);

var TextSearcher = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("TextSearcher") && typeof __lively_classholder__.TextSearcher === "function" ? __lively_classholder__.TextSearcher : __lively_classholder__.TextSearcher = function TextSearcher(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function TextSearcher_initialize_(morph$$1) {
      this.morph = morph$$1;
      this.STOP = {};
    }
  }, {
    key: "doc",
    get: function get() {
      return this.morph.document;
    }
  }, {
    key: "processFind",
    value: function TextSearcher_processFind_(start, match) {
      var i = this.doc.positionToIndex(start),
          end = this.doc.indexToPosition(i + match.length);
      return {
        range: {
          start: start,
          end: end
        },
        match: match
      };
    }
  }, {
    key: "stringSearch",
    value: function TextSearcher_stringSearch_(lines, needle, caseSensitive, nLines, inRange, char, pos) {
      if (inRange) {
        if (lessPosition(pos, inRange.start) || lessPosition(inRange.end, pos)) return this.STOP;
      }
      if (!caseSensitive) char = char.toLowerCase();
      if (char !== needle[0]) return null;
      var row = pos.row,
          column = pos.column,
          chunk = lines[row].slice(column) + (nLines > 1 ? "\n" + lines.slice(row + 1, row + 1 + (nLines - 1)).join("\n") : ""),
          chunkToTest = caseSensitive ? chunk : chunk.toLowerCase();

      return chunkToTest.indexOf(needle) !== 0 ? null : this.processFind({
        row: row,
        column: column
      }, chunk.slice(0, needle.length));
    }
  }, {
    key: "reSearch",
    value: function TextSearcher_reSearch_(lines, needle, multiline, inRange, char, pos) {
      if (inRange) {
        if (lessPosition(pos, inRange.start) || lessPosition(inRange.end, pos)) return this.STOP;
      }
      var row = pos.row,
          column = pos.column,
          chunk = lines[row].slice(column) + (multiline ? "\n" + lines.slice(row + 1).join("\n") : ""),
          reMatch = chunk.match(needle);

      return reMatch ? this.processFind({
        row: row,
        column: column
      }, reMatch[0]) : null;
    }
  }, {
    key: "search",
    value: function TextSearcher_search_(options) {
      var _Object$assign = Object.assign({
        start: this.morph.cursorPosition,
        needle: "",
        backwards: false,
        caseSensitive: false,
        inRange: null
      }, options),
          start = _Object$assign.start,
          needle = _Object$assign.needle,
          backwards = _Object$assign.backwards,
          caseSensitive = _Object$assign.caseSensitive,
          inRange = _Object$assign.inRange;

      if (!needle) return null;
      if (inRange) start = backwards ? minPosition(inRange.end, start) : maxPosition(inRange.start, start);
      var search;
      if (needle instanceof RegExp) {
        var flags = (needle.flags || "").split(""),
            multiline = !!needle.multiline;
        flags.splice(flags.indexOf("m"), 1);
        if (!caseSensitive && !flags.includes("i")) flags.push("i");
        needle = new RegExp("^" + needle.source.replace(/^\^+/, ""), flags.join(""));
        search = this.reSearch.bind(this, this.doc.lines, needle, multiline, inRange);
      } else {
        needle = String(needle);
        if (!caseSensitive) needle = needle.toLowerCase();
        var nLines = needle.split(this.doc.constructor.newline).length;
        search = this.stringSearch.bind(this, this.doc.lines, needle, caseSensitive, nLines, inRange);
      }
      var result = this.doc[backwards ? "scanBackward" : "scanForward"](start, search);
      return result === this.STOP ? null : result;
    }
  }, {
    key: "searchForAll",
    value: function TextSearcher_searchForAll_(options) {
      var results = [];
      var i = 0;
      while (true) {
        if (i++ > 10000) throw new Error("endless loop");
        var found = this.search(options);
        if (!found) return results;
        results.push(found);
        options = Object.assign({}, options, { start: options.backwards ? found.range.start : found.range.end });
      }
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 536,
    end: 3528
  });
}(undefined);
var SearchWidget = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("SearchWidget") && typeof __lively_classholder__.SearchWidget === "function" ? __lively_classholder__.SearchWidget : __lively_classholder__.SearchWidget = function SearchWidget(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function SearchWidget_initialize_() {
      var _this = this;

      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (props.targetText) props.target = props.targetText;
      if (!props.target) throw new Error("SearchWidget needs a target text morph!");
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, props);
      var replaceButton = this.getSubmorphNamed("replaceButton"),
          replaceInput = this.getSubmorphNamed("replaceInput"),
          searchInput = this.getSubmorphNamed("searchInput"),
          prevButton = this.getSubmorphNamed("prevButton"),
          nextButton = this.getSubmorphNamed("nextButton"),
          cancelButton = this.getSubmorphNamed("cancelButton"),
          acceptButton = this.getSubmorphNamed("acceptButton");
      lively_bindings.connect(acceptButton, "fire", this, "execCommand", { converter: function converter() {
          return "accept search";
        } });
      lively_bindings.connect(cancelButton, "fire", this, "execCommand", { converter: function converter() {
          return "cancel search";
        } });
      lively_bindings.connect(nextButton, "fire", this, "execCommand", { converter: function converter() {
          return "search next";
        } });
      lively_bindings.connect(prevButton, "fire", this, "execCommand", { converter: function converter() {
          return "search prev";
        } });
      lively_bindings.connect(searchInput, "inputChanged", this, "search");
      lively_bindings.connect(replaceButton, "fire", this, "execCommand", { converter: function converter() {
          return "replace and go to next";
        } });
      this.relayout();
      this.state = {
        backwards: false,
        before: null,
        position: null,
        inProgress: null,
        last: null
      };
      searchInput.addCommands([{
        name: "realign top-bottom-center",
        exec: function () {
          var _ref = asyncToGenerator(regeneratorRuntime.mark(function _callee() {
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _this.target.execCommand("realign top-bottom-center");
                    _this.addSearchMarkersForPreview(_this.state.inProgress && _this.state.inProgress.found, false);
                    return _context.abrupt("return", true);

                  case 3:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, _this);
          }));

          return function exec() {
            return _ref.apply(this, arguments);
          };
        }()
      }]);
    }
  }, {
    key: "relayout",
    value: function SearchWidget_relayout_() {
      var acceptButton = this.getSubmorphNamed("acceptButton"),
          cancelButton = this.getSubmorphNamed("cancelButton"),
          prevButton = this.getSubmorphNamed("prevButton"),
          nextButton = this.getSubmorphNamed("nextButton"),
          searchInput = this.getSubmorphNamed("searchInput"),
          replaceButton = this.getSubmorphNamed("replaceButton"),
          replaceInput = this.getSubmorphNamed("replaceInput");
      acceptButton.top = prevButton.top = nextButton.top = cancelButton.top = 2;
      cancelButton.right = this.innerBounds().right() - 2;
      acceptButton.right = cancelButton.left;
      prevButton.right = acceptButton.left;
      nextButton.right = prevButton.left;
      searchInput.topLeft = lively_graphics.pt(4, 4);
      replaceInput.topLeft = searchInput.bottomLeft.addXY(0, 4);
      replaceInput.width = searchInput.width = nextButton.left - 4;
      replaceButton.top = replaceInput.top;
      replaceButton.center = lively_graphics.pt(nextButton.left + (cancelButton.right - nextButton.left) / 2, replaceInput.center.y);
      this.height = replaceInput.bottom + 3;
    }
  }, {
    key: "focus",
    value: function SearchWidget_focus_() {
      this.get("searchInput").focus();
    }
  }, {
    key: "cleanup",
    value: function SearchWidget_cleanup_() {
      this.removeSearchMarkers();
      this.state.inProgress = null;
    }
  }, {
    key: "cancelSearch",
    value: function SearchWidget_cancelSearch_() {
      if (this.state.inProgress) this.state.last = this.state.inProgress;
      this.cleanup();
      if (this.state.before) {
        var _state$before = this.state.before,
            scroll = _state$before.scroll,
            selectionRange = _state$before.selectionRange;

        this.target.selection = selectionRange;
        this.target.scroll = scroll;
        this.state.before = null;
      }
      this.remove();
      this.target.focus();
    }
  }, {
    key: "acceptSearch",
    value: function SearchWidget_acceptSearch_() {
      if (this.state.inProgress) this.state.last = this.state.inProgress;
      if (this.applySearchResult(this.state.inProgress)) this.state.before && this.target.saveMark(this.state.before.position);
      this.get("searchInput").acceptInput();
      this.cleanup();
      this.state.before = null;
      this.remove();
      this.target.focus();
    }
  }, {
    key: "applySearchResult",
    value: function SearchWidget_applySearchResult_(searchResult) {
      if (!searchResult || !searchResult.found) return null;
      var text = this.target,
          sel = text.selection,
          select = !!text.activeMark || !sel.isEmpty(),
          backwards = searchResult.backwards,
          _searchResult$found$r = searchResult.found.range,
          start = _searchResult$found$r.start,
          end = _searchResult$found$r.end,
          pos = backwards ? start : end;
      select ? sel.lead = pos : text.cursorPosition = pos;
      if (!text.isLineVisible(pos.row)) text.centerRow();
      return searchResult;
    }
  }, {
    key: "removeSearchMarkers",
    value: function SearchWidget_removeSearchMarkers_() {
      var _this2 = this;

      (this.target.markers || []).forEach(function (_ref2) {
        var id = _ref2.id;
        return id.startsWith("search-highlight") && _this2.target.removeMarker(id);
      });
    }
  }, {
    key: "addSearchMarkers",
    value: function SearchWidget_addSearchMarkers_(found) {
      this.removeSearchMarkers();
      var text = this.target,
          _text$whatsVisible = text.whatsVisible,
          startRow = _text$whatsVisible.startRow,
          endRow = _text$whatsVisible.endRow,
          lines = text.document.lines,
          i = 0;
      for (var row = startRow; row <= endRow; row++) {
        var line = lines[row] || "";
        for (var col = 0; col < line.length; col++) {
          if (line.slice(col).toLowerCase().indexOf(found.match.toLowerCase()) === 0) {
            text.addMarker({
              id: "search-highlight-" + i++,
              range: {
                start: {
                  row: row,
                  column: col
                },
                end: {
                  row: row,
                  column: col + found.match.length
                }
              },
              style: {
                "border-radius": "4px",
                "background-color": "rgba(255, 200, 0, 0.3)",
                "box-shadow": "0 0 4px rgba(255, 200, 0, 0.3)",
                "pointer-events": "none"
              }
            });
            col += found.match.length;
          }
        }
      }
      var positionRange;
      if (this.state.backwards) {
        var _found$range$start = found.range.start,
            _row = _found$range$start.row,
            column = _found$range$start.column;

        positionRange = {
          start: {
            row: _row,
            column: column
          },
          end: {
            row: _row,
            column: column + 1
          }
        };
      } else {
        var _found$range$end = found.range.end,
            _row2 = _found$range$end.row,
            _column = _found$range$end.column;

        positionRange = {
          start: {
            row: _row2,
            column: _column - 1
          },
          end: {
            row: _row2,
            column: _column
          }
        };
      }
      text.addMarker({
        id: "search-highlight-cursor",
        range: positionRange,
        style: defineProperty({
          "pointer-events": "none",
          "box-sizing": "border-box"
        }, this.state.backwards ? "border-left" : "border-right", "3px red solid")
      });
    }
  }, {
    key: "addSearchMarkersForPreview",
    value: function SearchWidget_addSearchMarkersForPreview_(found) {
      var _this3 = this;

      var noCursor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      found && this.whenRendered().then(function () {
        return lively_lang.promise.delay(20);
      }).then(function () {
        _this3.addSearchMarkers(found);
        noCursor && _this3.target.removeMarker("search-highlight-cursor");
      });
    }
  }, {
    key: "prepareForNewSearch",
    value: function SearchWidget_prepareForNewSearch_() {
      var _this4 = this;

      var text = this.target,
          world = text.world(),
          state = this.state;
      world.addMorph(this);
      this.topRight = text.globalBounds().topRight();
      this.whenRendered().then(function () {
        return _this4.relayout();
      });
      var scroll = text.scroll,
          sel = text.selection;

      state.position = sel.lead;
      state.before = {
        scroll: scroll,
        position: sel.lead,
        selectionRange: sel.range,
        selectionReverse: sel.isReverse()
      };
      if (state.last && state.last.found) {
        var inputMorph = this.get("searchInput");
        lively_bindings.disconnect(inputMorph, "inputChanged", this, "search");
        this.input = state.last.needle;
        lively_bindings.connect(inputMorph, "inputChanged", this, "search");
        this.addSearchMarkersForPreview(state.last.found);
      }
      this.get("searchInput").selectAll();
      this.focus();
    }
  }, {
    key: "advance",
    value: function SearchWidget_advance_(backwards) {
      var inProgress = this.state.inProgress;

      if (inProgress && inProgress.found) {
        var dirChange = backwards !== this.state.backwards,
            _inProgress$found$ran = inProgress.found.range,
            start = _inProgress$found$ran.start,
            end = _inProgress$found$ran.end;
        this.state.position = dirChange ? backwards ? end : start : backwards ? start : end;
      }
      this.state.backwards = backwards;
      return this.search();
    }
  }, {
    key: "searchNext",
    value: function SearchWidget_searchNext_() {
      return this.advance(false);
    }
  }, {
    key: "searchPrev",
    value: function SearchWidget_searchPrev_() {
      return this.advance(true);
    }
  }, {
    key: "search",
    value: function SearchWidget_search_() {
      var _this5 = this;

      if (!this.input) {
        this.cleanup();
        return null;
      }
      var state = this.state,
          backwards = state.backwards,
          inProgress = state.inProgress,
          position = state.position,
          opts = {
        backwards: backwards,
        start: position
      },
          found = this.target.search(this.input, opts);
      var result = this.state.inProgress = Object.assign({}, opts, {
        needle: this.input,
        found: found
      });
      this.applySearchResult(result);
      found && this.whenRendered().then(function () {
        return _this5.addSearchMarkers(found, backwards);
      });
      return result;
    }
  }, {
    key: "keybindings",
    get: function get() {
      return [{
        keys: "Enter",
        command: "accept search or replace and go to next"
      }, {
        keys: "Tab",
        command: "change focus"
      }, {
        keys: "Ctrl-O",
        command: "occur with search term"
      }, {
        keys: "Ctrl-W",
        command: "yank next word from text"
      }, {
        keys: "Escape|Ctrl-G",
        command: "cancel search"
      }, {
        keys: {
          win: "Ctrl-F|Ctrl-S|Ctrl-G",
          mac: "Meta-F|Ctrl-S|Meta-G"
        },
        command: "search next"
      }, {
        keys: {
          win: "Ctrl-Shift-F|Ctrl-R|Ctrl-Shift-G",
          mac: "Meta-Shift-F|Ctrl-R|Meta-Shift-G"
        },
        command: "search prev"
      }];
    }
  }, {
    key: "commands",
    get: function get() {
      var _this6 = this;

      return [{
        name: "occur with search term",
        exec: function exec() {
          _this6.target.addCommands([occurStartCommand]);
          _this6.execCommand("accept search");
          return _this6.target.execCommand("occur", { needle: _this6.input });
        }
      }, {
        name: "accept search",
        exec: function exec() {
          _this6.acceptSearch();
          return true;
        }
      }, {
        name: "cancel search",
        exec: function exec() {
          _this6.cancelSearch();
          return true;
        }
      }, {
        name: "search next",
        exec: function exec() {
          _this6.searchNext();
          return true;
        }
      }, {
        name: "search prev",
        exec: function exec() {
          _this6.searchPrev();
          return true;
        }
      }, {
        name: "accept search or replace and go to next",
        exec: function exec(_, args, count) {
          return _this6.execCommand(_this6.get("replaceInput").isFocused() ? "replace and go to next" : "accept search", args, count);
        }
      }, {
        name: "replace current search location with replace input",
        exec: function exec() {
          var search = lively_lang.Path("state.inProgress").get(_this6);
          if (search.found) {
            var replacement = _this6.get("replaceInput").textString;
            _this6.get("replaceInput").get("replaceInput").acceptInput();
            if (search.needle instanceof RegExp) {
              replacement = search.found.match.replace(search.needle, replacement);
            }
            _this6.target.replace(search.found.range, replacement);
          }
          return true;
        }
      }, {
        name: "replace and go to next",
        exec: function exec() {
          _this6.execCommand("replace current search location with replace input");
          _this6.execCommand(_this6.state.backwards ? "search prev" : "search next");
          return true;
        }
      }, {
        name: "change focus",
        exec: function exec() {
          if (_this6.get("searchInput").isFocused()) _this6.get("replaceInput").focus();else _this6.get("searchInput").focus();
          return true;
        }
      }, {
        name: "yank next word from text",
        exec: function exec() {
          var text = _this6.target,
              word = text.wordRight(),
              input = _this6.get("searchInput");
          if (!input.selection.isEmpty()) input.selection.text = "";
          var string$$1 = text.textInRange({
            start: text.cursorPosition,
            end: word.range.end
          });
          input.textString += string$$1;
          return true;
        }
      }];
    }
  }], [{
    key: "properties",
    get: function get() {
      return {
        name: { defaultValue: "search widget" },
        borderWidth: { defaultValue: 1 },
        borderColor: { defaultValue: lively_graphics.Color.gray },
        borderRadius: { defaultValue: 3 },
        fill: { defaultValue: lively_graphics.Color.white.withA(0.8) },
        target: {},
        input: {
          after: ["submorphs"],
          get: function get() {
            var text = this.get("searchInput").textString,
                reMatch = text.match(/^\/(.*)\/([a-z]*)$/);
            return reMatch ? new RegExp(reMatch[1], reMatch[2]) : text;
          },
          set: function set(v) {
            this.get("searchInput").textString = String(v);
          }
        },
        fontSize: {
          after: ["submorphs"],
          get: function get() {
            return this.get("searchInput").fontSize;
          },
          set: function set(v) {
            this.get("replaceInput").fontSize = v;
          }
        },
        fontFamily: {
          after: ["submorphs"],
          get: function get() {
            return this.get("searchInput").fontFamily;
          },
          set: function set(v) {
            this.get("searchInput").fontFamily = v;
            this.get("replaceInput").fontFamily = v;
          }
        },
        submorphs: {
          after: ["extent"],
          initialize: function initialize() {
            var btnStyle = {
              fontSize: 18,
              extent: lively_graphics.pt(24, 24),
              activeStyle: {
                borderWidth: 0,
                fill: null,
                fontColor: lively_graphics.Color.gray.darker()
              }
            },
                fontSize = 14,
                fontFamily = "Inconsolata, monospace";
            this.submorphs = [new Button$$1(Object.assign({
              name: "acceptButton",
              label: [Icon$$1.textAttribute("check-circle-o")]
            }, btnStyle)).fit(), new Button$$1(Object.assign({
              name: "cancelButton",
              label: [Icon$$1.textAttribute("times-circle-o")]
            }, btnStyle)).fit(), new Button$$1(Object.assign({
              name: "nextButton",
              label: [Icon$$1.textAttribute("arrow-circle-o-down")]
            }, btnStyle)).fit(), new Button$$1(Object.assign({
              name: "prevButton",
              label: [Icon$$1.textAttribute("arrow-circle-o-up")]
            }, btnStyle)).fit(), Text$1.makeInputLine({
              name: "searchInput",
              width: this.width,
              fill: lively_graphics.Color.white,
              fontSize: fontSize,
              fontFamily: fontFamily,
              borderWidth: 1,
              borderColor: lively_graphics.Color.gray,
              padding: lively_graphics.Rectangle.inset(2),
              placeholder: "search input",
              historyId: "lively.morphic-text search"
            }), Text$1.makeInputLine({
              name: "replaceInput",
              width: this.width,
              fill: lively_graphics.Color.white,
              fontSize: fontSize,
              fontFamily: fontFamily,
              borderWidth: 1,
              borderColor: lively_graphics.Color.gray,
              padding: lively_graphics.Rectangle.inset(2),
              placeholder: "replace input",
              historyId: "lively.morphic-text replace"
            }), new Button$$1({
              name: "replaceButton",
              label: "replace",
              extent: lively_graphics.pt(80, 20),
              fontColor: lively_graphics.Color.gray.darker(),
              activeStyle: {
                border: {
                  width: 2,
                  color: lively_graphics.Color.gray.darker()
                },
                fill: null
              }
            })];
          }
        }
      };
    }
  }], __lively_classholder__, undefined, {
    start: 3648,
    end: 17617
  });
}(Morph$1);
var searchCommands = [{
  name: "search in text",
  exec: function exec(morph$$1) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { backwards: false };

    var search = morph$$1._searchWidget || (morph$$1._searchWidget = new SearchWidget({
      target: morph$$1,
      extent: lively_graphics.pt(300, 20)
    }));
    search.state.backwards = opts.backwards;
    search.prepareForNewSearch();
    return true;
  }
}];

var commands$2 = {
  activate: {
    name: "[IyGotoChar] activate",
    exec: function exec(morph$$1) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { backwards: false };

      IyGotoCharKeyHandler.installInto(morph$$1, opts.backwards);
      return true;
    }
  },
  moveTo: {
    name: "[IyGotoChar] move to",
    exec: function exec(morph$$1, options) {
      morph$$1.saveMark();
      var sel = morph$$1.selection,
          _sel$lead = sel.lead,
          row = _sel$lead.row,
          column = _sel$lead.column,
          select = !!morph$$1.activeMark || !sel.isEmpty(),
          start = {
        row: row,
        column: column - 1
      },
          pos = morph$$1.document[options.backwards ? "scanBackward" : "scanForward"](start, function (char, pos) {
        return char === options.needle && !eqPosition(start, pos) ? pos : null;
      });
      if (!pos) return true;
      pos.column++;
      sel.lead = pos;
      if (!select) sel.anchor = pos;
      return true;
    },
    multiSelectAction: "forEach",
    readOnly: true
  }
};
var activate = commands$2.activate;
var IyGotoCharKeyHandler = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("IyGotoCharKeyHandler") && typeof __lively_classholder__.IyGotoCharKeyHandler === "function" ? __lively_classholder__.IyGotoCharKeyHandler : __lively_classholder__.IyGotoCharKeyHandler = function IyGotoCharKeyHandler(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function IyGotoCharKeyHandler_initialize_() {
      var backwards = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this);
      this.charToFind = undefined;
      this.backwards = backwards;
    }
  }, {
    key: "isIyGoToChar",
    get: function get() {
      return true;
    }
  }, {
    key: "uninstallFrom",
    value: function IyGotoCharKeyHandler_uninstallFrom_(morph$$1) {
      lively_lang.arr.remove(morph$$1._keyhandlers || [], this);
    }
  }, {
    key: "eventCommandLookup",
    value: function IyGotoCharKeyHandler_eventCommandLookup_(morph$$1, evt) {
      var debug = false,
          keyCombo = evt.keyCombo,
          isInputKey = keyCombo.startsWith("input-");
      debug && console.log("[iy] " + keyCombo);
      if (evt.onlyModifiers || keyCombo.startsWith("Shift-") || evt.isFunctionKey && !keyCombo === "Escape" && !keyCombo === "Backspace" || !isInputKey && !evt.isModified && !evt.isFunctionKey) {
        debug && console.log("[iy] => pass");
        return {
          command: "null",
          passEvent: true
        };
      }
      var key = isInputKey && keyCombo.slice("input-".length);
      if (!this.charToFind) {
        if (isInputKey) {
          debug && console.log("[iy] find: \"" + key + "\"");
          this.charToFind = key;
        } else {
          debug && console.log("[iy] uninstall, before key set");
          this.uninstallFrom(morph$$1);
          return null;
        }
      }
      if (key !== this.charToFind) {
        debug && console.log("[iy] uninstall, other key pressed");
        this.uninstallFrom(morph$$1);
        return null;
      }
      return {
        command: commands$2.moveTo,
        args: {
          backwards: this.backwards,
          needle: key
        }
      };
    }
  }], [{
    key: "installInto",
    value: function IyGotoCharKeyHandler_installInto_(textMorph) {
      var backwards = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      textMorph.keyhandlers.filter(function (h$$1) {
        return h$$1.isIyGoToChar;
      }).forEach(function (ea) {
        return ea.uninstallFrom(textMorph);
      });
      textMorph._keyhandlers = (textMorph._keyhandlers || []).concat(new this(backwards));
    }
  }], __lively_classholder__, undefined, {
    start: 1049,
    end: 2942
  });
}(KeyHandler);

var Completer = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("Completer") && typeof __lively_classholder__.Completer === "function" ? __lively_classholder__.Completer : __lively_classholder__.Completer = function Completer(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: "compute",
    value: function Completer_compute_() {
      return [];
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 193,
    end: 239
  });
}(undefined);
var WordCompleter = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("WordCompleter") && typeof __lively_classholder__.WordCompleter === "function" ? __lively_classholder__.WordCompleter : __lively_classholder__.WordCompleter = function WordCompleter(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: "compute",
    value: function WordCompleter_compute_(textMorph, prefix) {
      var words = [],
          completions = [],
          lines = textMorph.document.lines,
          row = textMorph.cursorPosition.row,
          basePriority = 1000;
      for (var i = row; i >= 0; i--) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = lines[i].split(/[^0-9a-z@_]+/i)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var word = _step.value;

            if (!word || words.includes(word) || word === prefix) continue;
            words.push(word);
            completions.push({
              priority: basePriority - (row - i),
              completion: word
            });
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }for (var i = row + 1; i < lines.length; i++) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = lines[i].split(/[^0-9a-z_@]+/i)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var word = _step2.value;

            if (!word || words.includes(word) || word === prefix) continue;
            words.push(word);
            completions.push({
              priority: basePriority - (i - row),
              completion: word
            });
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }return completions;
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 248,
    end: 1062
  });
}(undefined);
var defaultCompleters = [new WordCompleter()];
var CompletionController = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("CompletionController") && typeof __lively_classholder__.CompletionController === "function" ? __lively_classholder__.CompletionController : __lively_classholder__.CompletionController = function CompletionController(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function CompletionController_initialize_(textMorph) {
      var completers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      this.textMorph = textMorph;
      completers = textMorph.pluginCollect("getCompleters", completers);
      this.completers = completers;
    }
  }, {
    key: "computeCompletions",
    value: function () {
      var _ref = asyncToGenerator(regeneratorRuntime.mark(function _callee(prefix) {
        var completions, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, c, groups, withHighestPriority, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, val, maxCol, sorted, highestPriority, items;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                completions = [];
                _iteratorNormalCompletion3 = true;
                _didIteratorError3 = false;
                _iteratorError3 = undefined;
                _context.prev = 4;
                _iterator3 = this.completers[Symbol.iterator]();

              case 6:
                if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
                  _context.next = 22;
                  break;
                }

                c = _step3.value;
                _context.prev = 8;
                _context.t0 = completions;
                _context.next = 12;
                return c.compute(this.textMorph, prefix);

              case 12:
                _context.t1 = _context.sent;
                completions = _context.t0.concat.call(_context.t0, _context.t1);
                _context.next = 19;
                break;

              case 16:
                _context.prev = 16;
                _context.t2 = _context["catch"](8);

                console.warn("Error in completer " + c + ": " + (_context.t2.stack || _context.t2));

              case 19:
                _iteratorNormalCompletion3 = true;
                _context.next = 6;
                break;

              case 22:
                _context.next = 28;
                break;

              case 24:
                _context.prev = 24;
                _context.t3 = _context["catch"](4);
                _didIteratorError3 = true;
                _iteratorError3 = _context.t3;

              case 28:
                _context.prev = 28;
                _context.prev = 29;

                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                  _iterator3.return();
                }

              case 31:
                _context.prev = 31;

                if (!_didIteratorError3) {
                  _context.next = 34;
                  break;
                }

                throw _iteratorError3;

              case 34:
                return _context.finish(31);

              case 35:
                return _context.finish(28);

              case 36:
                groups = new Map();

                completions.forEach(function (ea) {
                  var group = groups.get(ea.completion);
                  if (!group) {
                    group = [];
                    groups.set(ea.completion, group);
                  }
                  group.push(ea);
                });
                withHighestPriority = [];
                _iteratorNormalCompletion4 = true;
                _didIteratorError4 = false;
                _iteratorError4 = undefined;
                _context.prev = 42;

                for (_iterator4 = groups.values()[Symbol.iterator](); !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                  val = _step4.value;

                  withHighestPriority.push(lively_lang.arr.last(lively_lang.arr.sortByKey(val, "priority")));
                }_context.next = 50;
                break;

              case 46:
                _context.prev = 46;
                _context.t4 = _context["catch"](42);
                _didIteratorError4 = true;
                _iteratorError4 = _context.t4;

              case 50:
                _context.prev = 50;
                _context.prev = 51;

                if (!_iteratorNormalCompletion4 && _iterator4.return) {
                  _iterator4.return();
                }

              case 53:
                _context.prev = 53;

                if (!_didIteratorError4) {
                  _context.next = 56;
                  break;
                }

                throw _iteratorError4;

              case 56:
                return _context.finish(53);

              case 57:
                return _context.finish(50);

              case 58:
                maxCol = 0, sorted = lively_lang.arr.sortByKey(withHighestPriority, "priority").reverse(), highestPriority = sorted[0].priority || 0, items = sorted.map(function (ea) {
                  ea.highestPriority = highestPriority;
                  var string$$1 = ea.completion.replace(/\n/g, ""),
                      annotation = String((ea.info || "").replace(/\n/g, ""));
                  maxCol = Math.max(maxCol, string$$1.length + annotation.length);
                  return {
                    isListItem: true,
                    string: string$$1,
                    annotation: annotation,
                    value: ea
                  };
                });
                return _context.abrupt("return", {
                  items: items,
                  maxCol: maxCol
                });

              case 60:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[4, 24, 28, 36], [8, 16], [29,, 31, 35], [42, 46, 50, 58], [51,, 53, 57]]);
      }));

      function CompletionController_computeCompletions_(_x2) {
        return _ref.apply(this, arguments);
      }

      return CompletionController_computeCompletions_;
    }()
  }, {
    key: "prefix",
    value: function CompletionController_prefix_() {
      var m = this.textMorph,
          sel = m.selection,
          roughPrefix = sel.isEmpty() ? m.getLine(sel.lead.row).slice(0, sel.lead.column) : sel.text;
      return roughPrefix.match(/[a-z0-9@_]*$/i)[0];
    }
  }, {
    key: "positionForMenu",
    value: function CompletionController_positionForMenu_() {
      var m = this.textMorph,
          cursorBounds = m.charBoundsFromTextPosition(m.cursorPosition).translatedBy(m.scroll.negated()),
          globalCursorBounds = m.getGlobalTransform().transformRectToRect(cursorBounds);
      return globalCursorBounds.topLeft().addXY(m.padding.left() - 1, -m.padding.top());
    }
  }, {
    key: "completionListSpec",
    value: function () {
      var _ref2 = asyncToGenerator(regeneratorRuntime.mark(function _callee2() {
        var m, fontSize, fontFamily, position, prefix, _ref3, items, maxCol, charBounds, minWidth, textWidth, width, minHeight, maxHeight, fullHeight, height, bounds, world, visibleBounds, delta;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                m = this.textMorph;
                fontSize = m.fontSize;
                fontFamily = m.fontFamily;
                position = this.positionForMenu();
                prefix = this.prefix();
                _context2.next = 7;
                return this.computeCompletions(prefix);

              case 7:
                _ref3 = _context2.sent;
                items = _ref3.items;
                maxCol = _ref3.maxCol;
                charBounds = m.env.fontMetric.sizeFor(fontFamily, fontSize, "M");
                minWidth = 80;
                textWidth = charBounds.width * maxCol;
                width = Math.max(minWidth, textWidth < m.width ? textWidth : m.width);
                minHeight = 70;
                maxHeight = 700;
                fullHeight = charBounds.height * items.length + charBounds.height + 10;
                height = Math.max(minHeight, Math.min(maxHeight, fullHeight));
                bounds = position.extent(lively_graphics.pt(width, height));
                world = m.world();

                if (world) {
                  visibleBounds = world.visibleBounds().insetBy(5);

                  if (bounds.bottom() > visibleBounds.bottom()) {
                    delta = bounds.bottom() - visibleBounds.bottom();

                    if (delta > bounds.height - 50) delta = bounds.height - 50;
                    bounds.height -= delta;
                  }
                  if (!visibleBounds.containsRect(bounds)) bounds = bounds.withTopLeft(visibleBounds.translateForInclusion(bounds).topLeft());
                }
                return _context2.abrupt("return", {
                  fontFamily: fontFamily,
                  fontSize: fontSize,
                  position: bounds.topLeft(),
                  extent: bounds.extent(),
                  items: items,
                  input: prefix,
                  name: "text completion menu",
                  borderColor: lively_graphics.Color.gray,
                  borderWidth: 1,
                  historyId: "lively.morphic-text completion",
                  filterFunction: function filterFunction(parsedInput, item) {
                    var tokens = parsedInput.lowercasedTokens;
                    if (tokens.every(function (token) {
                      return item.string.toLowerCase().includes(token);
                    })) return true;
                    var completion = item.value.completion.replace(/\([^\)]*\)$/, "").toLowerCase();
                    return lively_lang.arr.sum(parsedInput.lowercasedTokens.map(function (token) {
                      return lively_lang.string.levenshtein(completion, token);
                    })) <= 3;
                  },
                  sortFunction: function sortFunction(parsedInput, item) {
                    var _item$value = item.value,
                        highestPriority = _item$value.highestPriority,
                        completion = _item$value.completion,
                        priority = _item$value.priority,
                        completion = completion.replace(/\([^\)]*\)$/, "").toLowerCase(),
                        n = String(highestPriority).length - 2,
                        adjustedPriority = priority / Math.pow(10, n),
                        base = -adjustedPriority;

                    parsedInput.lowercasedTokens.forEach(function (t) {
                      if (completion.startsWith(t)) base -= 12;else if (completion.includes(t)) base -= 5;
                    });
                    return lively_lang.arr.sum(parsedInput.lowercasedTokens.map(function (token) {
                      return lively_lang.string.levenshtein(completion.toLowerCase(), token);
                    })) + base;
                  }
                });

              case 22:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function CompletionController_completionListSpec_() {
        return _ref2.apply(this, arguments);
      }

      return CompletionController_completionListSpec_;
    }()
  }, {
    key: "openCompletionList",
    value: function () {
      var _ref4 = asyncToGenerator(regeneratorRuntime.mark(function _callee3() {
        var spec, menu, prefix, world;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.completionListSpec();

              case 2:
                spec = _context3.sent;
                menu = new FilterableList$$1(spec);
                prefix = spec.input;

                lively_bindings.connect(menu, "accepted", this, "insertCompletion", {
                  updater: function updater($upd) {
                    var textToInsert,
                        customInsertionFn = null,
                        completion = this.sourceObj.selection;
                    if (completion) {
                      if (completion.prefix) prefix = completion.prefix;
                      textToInsert = completion.completion;
                      customInsertionFn = completion.customInsertionFn;
                    } else {
                      textToInsert = this.sourceObj.get("input").textString;
                    }
                    $upd(textToInsert, prefix, customInsertionFn);
                  },
                  varMapping: { prefix: prefix }
                });
                lively_bindings.connect(menu, "accepted", menu, "remove");
                lively_bindings.connect(menu, "canceled", menu, "remove");
                lively_bindings.connect(menu, "remove", this.textMorph, "focus");
                world = this.textMorph.world();

                world.addMorph(menu);
                menu.selectedIndex = 0;
                prefix.length && menu.get("input").gotoDocumentEnd();
                menu.get("input").focus();

              case 14:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function CompletionController_openCompletionList_() {
        return _ref4.apply(this, arguments);
      }

      return CompletionController_openCompletionList_;
    }()
  }, {
    key: "insertCompletion",
    value: function CompletionController_insertCompletion_(completion, prefix, customInsertionFn) {
      var m = this.textMorph,
          doc = m.document,
          selections = m.selection.isMultiSelection ? m.selection.selections : [m.selection];
      m.undoManager.group();
      selections.forEach(function (sel) {
        sel.collapseToEnd();
        var end = sel.lead,
            start = prefix ? doc.indexToPosition(doc.positionToIndex(end) - prefix.length) : end;
        typeof customInsertionFn === "function" ? customInsertionFn(completion, prefix, m, {
          start: start,
          end: end
        }, sel) : m.replace({
          start: start,
          end: end
        }, completion);
      });
      m.undoManager.group();
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 1189,
    end: 7765
  });
}(undefined);
var completionCommands = [{
  name: "text completion",
  handlesCount: true,
  multiSelectAction: "single",
  exec: function exec(morph$$1, opts, count) {
    var _this = this;

    return asyncToGenerator(regeneratorRuntime.mark(function _callee4() {
      var completer;
      return regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              completer = new CompletionController(morph$$1, defaultCompleters);
              _context4.next = 3;
              return completer.openCompletionList();

            case 3:
              return _context4.abrupt("return", true);

            case 4:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, _this);
    }))();
  }
}];

var _this$3 = undefined;

var multiSelectCommands = [{
  name: "[multi select] add cursor above",
  multiSelectAction: "single",
  exec: function exec(morph$$1) {
    var start = morph$$1.selection.start;
    if (start.row > 0) {
      var pos = morph$$1.getPositionAboveOrBelow(1, start, true);
      morph$$1.selection.addRange({
        start: pos,
        end: pos
      });
    }
    return true;
  }
}, {
  name: "[multi select] add cursor below",
  multiSelectAction: "single",
  exec: function exec(morph$$1) {
    var _morph$selection$star = morph$$1.selection.start,
        row = _morph$selection$star.row,
        column = _morph$selection$star.column,
        endRow = morph$$1.documentEndPosition.row;

    if (row < endRow) morph$$1.selection.addRange({
      start: {
        row: row + 1,
        column: column
      },
      end: {
        row: row + 1,
        column: column
      }
    });
    return true;
  }
}, {
  name: "[multi select] all like this",
  multiSelectAction: "single",
  exec: function exec(morph$$1) {
    var idx = morph$$1.selection.selections.length - 1,
        last = morph$$1.selection.selections[idx];
    if (last.isEmpty()) return true;
    var found = morph$$1.searchForAll(last.text, {
      start: {
        column: 0,
        row: 0
      }
    });
    found.forEach(function (_ref) {
      var range = _ref.range;
      return morph$$1.selection.addRange(range, false);
    });
    morph$$1.selection.mergeSelections();
    lively_lang.arr.remove(morph$$1.selection.selections, last);
    morph$$1.selection.selections.push(last);
    return true;
  }
}, {
  name: "[multi select] more like this forward",
  multiSelectAction: "single",
  exec: function exec(morph$$1) {
    var idx = morph$$1.selection.selections.length - 1,
        last = morph$$1.selection.selections[idx];
    if (last.isEmpty()) return true;
    var pos = last.end,
        found = morph$$1.search(last.text, {
      start: pos,
      backwards: false
    });
    if (found) {
      var existing = morph$$1.selection.selections.findIndex(function (ea) {
        return ea.range.equals(found.range);
      });
      if (existing > -1) lively_lang.arr.swap(morph$$1.selection.selections, existing, idx);else morph$$1.selection.addRange(found.range);
    }
    return true;
  }
}, {
  name: "[multi select] more like this backward",
  multiSelectAction: "single",
  exec: function exec(morph$$1) {
    var idx = morph$$1.selection.selections.length - 1,
        last = morph$$1.selection.selections[idx];
    if (last.isEmpty()) return true;
    var _last$start = last.start,
        row = _last$start.row,
        column = _last$start.column,
        found = morph$$1.search(last.text, {
      start: {
        row: row,
        column: column - (last.text.length - 1)
      },
      backwards: true
    });

    if (found) {
      var existing = morph$$1.selection.selections.findIndex(function (ea) {
        return ea.range.equals(found.range);
      });
      if (existing > -1) lively_lang.arr.swap(morph$$1.selection.selections, existing, idx);else morph$$1.selection.addRange(found.range);
    }
    return true;
  }
}, {
  name: "[multi select] remove focused cursor",
  multiSelectAction: "single",
  exec: function exec(morph$$1) {
    var l = morph$$1.selection.selections.length;
    if (l > 1) morph$$1.selection.removeSelections(l - 1);
    return true;
  }
}, {
  name: "[multi select] goto previous focused cursor",
  multiSelectAction: "single",
  exec: function exec(morph$$1) {
    morph$$1.selection.selections = lively.lang.arr.rotate(morph$$1.selection.selections, -1);
    return true;
  }
}, {
  name: "[multi select] goto next focused cursor",
  multiSelectAction: "single",
  exec: function exec(morph$$1) {
    morph$$1.selection.selections = lively.lang.arr.rotate(morph$$1.selection.selections, 1);
    return true;
  }
}, {
  name: "[multi select] align cursors",
  multiSelectAction: "single",
  exec: function exec(morph$$1) {
    var selections = morph$$1.selection.selections,
        l = selections.length;
    if (l <= 1) return true;
    var byRow = lively_lang.arr.groupBy(selections, function (sel) {
      return sel.range.start.row;
    }),
        leftOverSels = byRow.keys().map(function (row) {
      var selsOfRow = byRow[row],
          rightMostSel = lively_lang.arr.max(selsOfRow, function (ea) {
        return ea.range.start.column;
      });
      lively_lang.arr.without(selsOfRow, rightMostSel).forEach(function (sel) {
        return sel.range = rightMostSel.range;
      });
      return rightMostSel;
    }),
        maxCol = lively_lang.arr.max(leftOverSels, function (ea) {
      return ea.range.start.column;
    }).range.start.column;
    leftOverSels.forEach(function (sel) {
      var _sel$range$start = sel.range.start,
          row = _sel$range$start.row,
          column = _sel$range$start.column;

      morph$$1.insertText(" ".repeat(maxCol - column), {
        row: row,
        column: column
      });
    });
    return true;
  }
}, {
  name: "[multi select] create rectangular selection",
  multiSelectAction: "single",
  exec: function exec(morph$$1) {
    morph$$1.selection.disableMultiSelect();
    if (morph$$1.selection.isEmpty()) {
      var from = morph$$1.lastSavedMark && morph$$1.lastSavedMark.position || _this$3.lineRange().start,
          to = morph$$1.cursorPosition;
    } else {
      var _morph$selection = morph$$1.selection,
          to = _morph$selection.lead,
          from = _morph$selection.anchor;
    }
    morph$$1.selection.collapse();
    var startCol = from.column,
        endCol = to.column;
    lively_lang.arr.range(from.row, to.row).forEach(function (row) {
      return morph$$1.getLine(row).length > Math.min(endCol, startCol) && morph$$1.selection.addRange({
        end: {
          row: row,
          column: endCol
        },
        start: {
          row: row,
          column: startCol
        }
      }, false);
    });
    morph$$1.selection.mergeSelections();
    return true;
  }
}, {
  name: "[multi select] count",
  multiSelectAction: "single",
  handlesCount: true,
  exec: function exec(morph$$1, _) {
    var count = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

    morph$$1.undoManager.group();
    morph$$1.selection.selections.forEach(function (sel, i) {
      return sel.text = String(i + count);
    });
    morph$$1.undoManager.group();
    return true;
  }
}];

function pToI(ed, pos) {
  return ed.positionToIndex(pos);
}
function iToP(ed, pos) {
  return ed.indexToPosition(pos);
}
function execCodeNavigator(sel) {
  return function (ed, args, count) {
    var nav = ed.pluginInvokeFirst("getNavigator");
    if (!nav) return true;
    ed.saveMark();
    var count = count || 1;
    for (var i = 0; i < count; i++) {
      nav[sel](ed, args);
    }
    return true;
  };
}
var commands$3 = [{
  name: "forwardSexp",
  bindKey: "Ctrl-Alt-f|Ctrl-Alt-Right",
  exec: execCodeNavigator("forwardSexp"),
  multiSelectAction: "forEach",
  readOnly: true
}, {
  name: "backwardSexp",
  bindKey: "Ctrl-Alt-b|Ctrl-Alt-Left",
  exec: execCodeNavigator("backwardSexp"),
  multiSelectAction: "forEach",
  readOnly: true
}, {
  name: "backwardUpSexp",
  bindKey: "Ctrl-Alt-u|Ctrl-Alt-Up",
  exec: execCodeNavigator("backwardUpSexp"),
  multiSelectAction: "forEach",
  readOnly: true
}, {
  name: "forwardDownSexp",
  bindKey: "Ctrl-Alt-d|Ctrl-Alt-Down",
  exec: execCodeNavigator("forwardDownSexp"),
  multiSelectAction: "forEach",
  readOnly: true
}, {
  name: "markDefun",
  bindKey: "Ctrl-Alt-h",
  exec: execCodeNavigator("markDefun"),
  multiSelectAction: "forEach",
  readOnly: true
}, {
  name: "expandRegion",
  bindKey: {
    win: "Shift-Ctrl-E|Ctrl-Shift-Space",
    mac: "Shift-Command-Space|Ctrl-Shift-Space"
  },
  exec: function exec(ed, args) {
    args = args || {};
    var expander = ed.pluginInvokeFirst("getNavigator");
    if (!expander) return true;
    var newState;
    var start = args.start,
        end = args.end;
    if (typeof start === "number" && typeof end === "number") {
      var state = ensureExpandState();
      newState = {
        range: [start, end],
        prev: ensureExpandState()
      };
    } else {
      var ast = expander.ensureAST(ed);
      if (!ast) return;
      var newState = expander.expandRegion(ed, ed.textString, ast, ensureExpandState());
    }
    if (newState && newState.range) {
      ed.selection = {
        start: iToP(ed, newState.range[0]),
        end: iToP(ed, newState.range[1])
      };
      ed.$expandRegionState = newState;
    }
    lively_bindings.once(ed, "selectionChange", function () {
      return ed.$expandRegionState = null;
    }, "call");
    return true;
    function ensureExpandState() {
      var state = ed.$expandRegionState;
      var pos = pToI(ed, ed.cursorPosition);
      if (state && (state.range[0] === pos || state.range[1] === pos)) return state;
      var range = ed.selection.range;
      return ed.$expandRegionState = {
        range: [pToI(ed, range.start), pToI(ed, range.end)]
      };
    }
  },
  multiSelectAction: "forEach",
  readOnly: true
}, {
  name: "contractRegion",
  bindKey: {
    win: "Shift-Ctrl-S|Ctrl-Alt-Space",
    mac: "Ctrl-Command-space|Ctrl-Alt-Space"
  },
  exec: function exec(ed) {
    if (ed.selection.isEmpty()) return true;
    var expander = ed.pluginInvokeFirst("getNavigator");
    if (!expander) return true;
    var ast = expander.ensureAST(ed);
    if (!ast) return true;
    var state = ed.$expandRegionState;
    if (!state) return true;
    var newState = expander.contractRegion(ed, ed.textString, ast, state);
    if (newState && newState.range) {
      ed.selection = {
        start: iToP(ed, newState.range[0]),
        end: iToP(ed, newState.range[1])
      };
      ed.$expandRegionState = newState;
    }
    lively_bindings.once(ed, "selectionChange", function () {
      return ed.$expandRegionState = null;
    }, "call");
    return true;
  },
  multiSelectAction: "forEach",
  readOnly: true
}];
lively.modules.module("lively.morphic/text/commands.js").reload({
  reloadDeps: false,
  resetEnv: false
});

var commands$4 = [{
  name: "toggle comment",
  exec: function exec(morph$$1) {
    var comment = morph$$1.pluginInvokeFirst("getComment");
    if (!comment || !comment.lineCommentStart) return true;
    if (!comment) return true;
    if (!comment.lineCommentStart) {
      if (comment.blockCommentStart) return morph$$1.execCommand("toggle block comment");
      return true;
    }
    var cstart = comment.lineCommentStart,
        commentRe = new RegExp("^(\\s*)(" + cstart + "\\s?)(.*)"),
        doc = morph$$1.document,
        sel = morph$$1.selection;
    if (!sel.isEmpty() && sel.end.column === 0) sel.growRight(-1);
    var startRow = sel.start.row,
        lines = doc.lines.slice(sel.start.row, sel.end.row + 1),
        lines = lines.some(function (l) {
      return !!l.trim();
    }) ? lively_lang.arr.dropWhile(lines, function (l) {
      return !l.trim() ? ++startRow && true : false;
    }) : lines,
        isCommented = lines.every(function (line) {
      return line.trim() && line.match(commentRe);
    });
    morph$$1.undoManager.group();
    if (isCommented) {
      lines.forEach(function (line, i) {
        var match = line.match(commentRe);
        if (match) {
          var _match = slicedToArray(match, 4),
              _ = _match[0],
              before = _match[1],
              comment = _match[2],
              after = _match[3],
              range = {
            start: {
              row: startRow + i,
              column: before.length
            },
            end: {
              row: startRow + i,
              column: before.length + comment.length
            }
          };

          morph$$1.deleteText(range);
        }
      });
    } else {
      var minSpace = lines.reduce(function (minSpace, line, i) {
        return !line.trim() && (!sel.isEmpty() || sel.start.row !== sel.end.row) ? minSpace : Math.min(minSpace, line.match(/^\s*/)[0].length);
      }, Infinity),
          minSpace = minSpace === Infinity ? 0 : minSpace;
      lines.forEach(function (line, i) {
        var _line$match = line.match(/^(\s*)(.*)/),
            _line$match2 = slicedToArray(_line$match, 3),
            _ = _line$match2[0],
            space = _line$match2[1],
            rest = _line$match2[2];

        morph$$1.insertText(cstart + " ", {
          row: startRow + i,
          column: minSpace
        });
      });
    }
    morph$$1.undoManager.group();
    return true;
  }
}, {
  name: "toggle block comment",
  exec: function exec(morph$$1) {
    var comment = morph$$1.pluginInvokeFirst("getComment");
    if (!comment) return true;
    if (!comment.blockCommentStart) {
      if (comment.lineCommentStart) return morph$$1.execCommand("toggle comment");
      return true;
    }
    if (!comment || !comment.blockCommentStart) return true;
    var cstart = comment.blockCommentStart,
        cend = comment.blockCommentEnd,
        startRe = new RegExp("^" + cstart.replace(/\*/g, "\\*")),
        endRe = new RegExp(cend.replace(/\*/g, "\\*") + "$"),
        token = morph$$1.tokenAt(morph$$1.cursorPosition);

    if (token && token.token === "comment") {
      var text = morph$$1.textInRange(token);
      if (text.match(startRe) && text.match(endRe)) {
        morph$$1.undoManager.group();
        morph$$1.replace(token, text.slice(cstart.length, -cend.length));
        morph$$1.undoManager.group();
        return true;
      }
    }
    morph$$1.undoManager.group();
    morph$$1.insertText(cstart, morph$$1.selection.start);
    morph$$1.insertText(cend, morph$$1.selection.end);
    morph$$1.undoManager.group();
    var select = !morph$$1.selection.isEmpty();
    morph$$1.selection.growLeft(2);
    if (!select) morph$$1.selection.collapse();
    return true;
  }
}, {
  name: "comment box",
  exec: function exec(morph$$1, _, count) {
    var undo = morph$$1.undoManager.ensureNewGroup(morph$$1, "comment box");
    if (morph$$1.selection.isEmpty()) {
      morph$$1.insertText("-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-");
      morph$$1.execCommand("toggle comment");
      morph$$1.undoManager.group(undo);
      return true;
    }
    var range = morph$$1.selection.range,
        lines = morph$$1.withSelectedLinesDo(function (line) {
      return line;
    }),
        indent = lively_lang.arr.min([range.start.column].concat(lively_lang.chain(lines).map(function (line) {
      return line.match(/^\s*/);
    }).flatten().compact().pluck("length").value())),
        length = lively_lang.arr.max(lines.map(function (ea) {
      return ea.length;
    })) - indent,
        fence = Array(Math.ceil(length / 2) + 1).join("-=") + "-";
    morph$$1.execCommand("toggle comment");
    morph$$1.collapseSelection();
    morph$$1.cursorPosition = {
      row: range.start.row,
      column: 0
    };
    if (count) morph$$1.insertText(lively_lang.string.indent("-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-" + "\n", " ", indent));else morph$$1.insertText(lively_lang.string.indent(fence + "\n", " ", indent));
    morph$$1.selection.goUp();
    morph$$1.execCommand("toggle comment");
    morph$$1.cursorPosition = {
      row: range.end.row + 2,
      column: 0
    };
    morph$$1.insertText(lively_lang.string.indent(fence + "\n", " ", indent));
    morph$$1.selection.goUp();
    morph$$1.execCommand("toggle comment");
    morph$$1.selection.range = {
      start: {
        row: range.start.row,
        column: 0
      },
      end: morph$$1.cursorPosition
    };
    morph$$1.undoManager.group(undo);
    return true;
  },
  multiSelectAction: "forEach",
  handlesCount: true
}];

var _this$2 = undefined;

var commands$$1 = [{
  name: "clipboard copy",
  doc: "placeholder for native copy",
  scrollCursorIntoView: false,
  exec: function exec(morph$$1) {
    if (morph$$1.selection.isEmpty()) morph$$1.selectLine(morph$$1.cursorPosition.row);
    return true;
  }
}, {
  name: "manual clipboard copy",
  doc: "attempts to copy selection via browser interface",
  scrollCursorIntoView: false,
  multiSelectAction: "single",
  exec: function exec(morph$$1) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      collapseSelection: true,
      delete: false,
      dontTryNativeClipboard: false
    };

    var sel = morph$$1.selection,
        fullText = sel.text,
        collapseSelection = opts.hasOwnProperty("collapseSelection") ? opts.collapseSelection : true;
    morph$$1.saveMark(sel.anchor);
    morph$$1.activeMark = null;
    var sels = sel.isMultiSelection ? sel.selections.slice() : [sel];
    sels.forEach(function (sel) {
      var range = sel.isEmpty() ? morph$$1.lineRange() : sel.range,
          text = morph$$1.textInRange(range);
      morph$$1.env.eventDispatcher.killRing.add(text);
      if (opts["delete"]) morph$$1.deleteText(range);else if (!sel.isEmpty() && collapseSelection) sel.collapse(sel.lead);
    });
    if (!opts.dontTryNativeClipboard) morph$$1.env.eventDispatcher.doCopy(fullText);
    return true;
  }
}, {
  name: "clipboard cut",
  doc: "placeholder for native cut",
  exec: function exec(morph$$1) {
    if (morph$$1.selection.isEmpty()) morph$$1.selectLine(morph$$1.cursorPosition.row, true);
    return true;
  }
}, {
  name: "clipboard paste",
  doc: "placeholder for native paste",
  exec: function exec() {
    return true;
  }
}, {
  name: "manual clipboard paste",
  doc: "attempts to paste from the clipboard to lively \u2013 currently requires browser extension!",
  multiSelectAction: "single",
  exec: function () {
    var _ref = asyncToGenerator(regeneratorRuntime.mark(function _callee(morph$$1) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { killRingCycleBack: false };
      var pasted, kr;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              kr = morph$$1.env.eventDispatcher.killRing;

              if (opts.killRingCycleBack && (lively_lang.arr.last(lively_lang.arr.pluck(morph$$1.commandHandler.history, "name")) || "").includes("clipboard paste")) pasted = kr.back();
              if (!pasted && kr.isCycling()) pasted = kr.yank();
              if (!pasted) pasted = kr.yank();
              if (morph$$1.selection.isMultiSelection) {
                morph$$1.undoManager.group();
                morph$$1.selection.selections.slice(0, -1).reverse().map(function (sel, i) {
                  var idx = kr.pointer - 1 - i;
                  if (idx < 0) idx = kr.buffer.length - 1;
                  return {
                    selection: sel,
                    pasted: kr.buffer[idx] || ""
                  };
                }).concat({
                  selection: morph$$1.selection.defaultSelection,
                  pasted: pasted
                }).forEach(function (_ref2) {
                  var selection = _ref2.selection,
                      pasted = _ref2.pasted;
                  return selection.text = pasted;
                });
                morph$$1.undoManager.group();
              } else {
                if (pasted) {
                  morph$$1.undoManager.group();
                  morph$$1.selection.text = pasted;
                  morph$$1.undoManager.group();
                }
              }
              return _context.abrupt("return", true);

            case 6:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function exec(_x2) {
      return _ref.apply(this, arguments);
    }

    return exec;
  }()
}, {
  name: "browse clipboard",
  exec: function () {
    var _ref3 = asyncToGenerator(regeneratorRuntime.mark(function _callee2(morph$$1) {
      var _morph$env$eventDispa, pointer, buffer, items, _ref4, selected;

      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _morph$env$eventDispa = morph$$1.env.eventDispatcher.killRing;
              pointer = _morph$env$eventDispa.pointer;
              buffer = _morph$env$eventDispa.buffer;
              items = buffer.map(function (value) {
                return {
                  isListItem: true,
                  string: lively_lang.string.truncate(value, 80).replace(/\n/g, ""),
                  value: value
                };
              });
              _context2.next = 6;
              return morph$$1.world().filterableListPrompt("select items to paste", items, {
                preselect: pointer,
                multiSelect: true
              });

            case 6:
              _ref4 = _context2.sent;
              selected = _ref4.selected;

              if (selected.length) {
                morph$$1.undoManager.group();
                morph$$1.insertTextAndSelect(selected.join("\n"));
                morph$$1.undoManager.group();
              }
              return _context2.abrupt("return", true);

            case 10:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, _this$2);
    }));

    return function exec(_x4) {
      return _ref3.apply(this, arguments);
    };
  }()
}, {
  name: "text undo",
  doc: "undo text changes",
  multiSelectAction: "single",
  exec: function exec(morph$$1) {
    morph$$1.textUndo();
    return true;
  }
}, {
  name: "text redo",
  doc: "redo text changes",
  multiSelectAction: "single",
  exec: function exec(morph$$1) {
    morph$$1.textRedo();
    return true;
  }
}, {
  name: "select all",
  doc: "Selects entire text contents.",
  scrollCursorIntoView: false,
  multiSelectAction: "single",
  exec: function exec(morph$$1) {
    morph$$1.saveMark();
    morph$$1.selectAll();
    return true;
  }
}, {
  name: "saveit",
  doc: "...",
  scrollCursorIntoView: false,
  exec: function exec(morph$$1) {
    morph$$1.doSave();
    return true;
  }
}, {
  name: "delete backwards",
  doc: "Delete the character in front of the cursor or the selection.",
  exec: function exec(morph$$1) {
    if (morph$$1.rejectsInput()) return false;
    var sel = morph$$1.selection;
    if (sel.isEmpty()) sel.growLeft(1);
    sel.text = "";
    sel.collapse();
    if (morph$$1.activeMark) morph$$1.activeMark = null;
    return true;
  }
}, {
  name: "delete",
  doc: "Delete the character following the cursor or the selection.",
  exec: function exec(morph$$1) {
    var sel = morph$$1.selection;
    if (morph$$1.rejectsInput()) return false;
    if (sel.isEmpty()) sel.growRight(1);
    sel.text = "";
    sel.collapse();
    if (morph$$1.activeMark) morph$$1.activeMark = null;
    return true;
  }
}, {
  name: "indent",
  scrollCursorIntoView: false,
  exec: function exec(morph$$1) {
    morph$$1.undoManager.group();
    morph$$1.withSelectedLinesDo(function (line, range) {
      return morph$$1.insertText(morph$$1.tab, range.start);
    });
    morph$$1.undoManager.group();
    return true;
  }
}, {
  name: "outdent",
  scrollCursorIntoView: false,
  exec: function exec(morph$$1) {
    morph$$1.undoManager.group();
    morph$$1.withSelectedLinesDo(function (line, range) {
      if (line.startsWith(morph$$1.tab)) morph$$1.deleteText({
        start: range.start,
        end: {
          row: range.start.row,
          column: morph$$1.tab.length
        }
      });
    });
    morph$$1.undoManager.group();
    return true;
  }
}, {
  name: "tab - snippet expand or indent",
  scrollCursorIntoView: true,
  exec: function exec(morph$$1) {
    var snippet = morph$$1.snippets.find(function (snippet) {
      return snippet.canExpand(morph$$1);
    });
    if (snippet) {
      snippet.expandAtCursor(morph$$1);
      return true;
    }
    return morph$$1.execCommand("insertstring", { string: morph$$1.tab });
  }
}, {
  name: "transpose chars",
  exec: function exec(morph$$1) {
    if (morph$$1.selection.isEmpty()) {
      var _morph$cursorPosition = morph$$1.cursorPosition,
          row = _morph$cursorPosition.row,
          column = _morph$cursorPosition.column,
          range = Range.create(row, column - 1, row, column + 1),
          line = morph$$1.getLine(row),
          left = line[column - 1],
          right = line[column];

      if (left && right) morph$$1.replace(range, right + left, true);
    }
    return true;
  }
}, {
  name: "go left",
  doc: "Move the cursor 1 character left. At the beginning of a line move the cursor up. If a selection is active, collapse the selection left.",
  exec: function exec(morph$$1) {
    morph$$1.activeMark ? morph$$1.selection.selectLeft(1) : morph$$1.selection.goLeft(1);
    return true;
  }
}, {
  name: "go right",
  doc: "Move the cursor 1 character right. At the end of a line move the cursor down. If a selection is active, collapse the selection right.",
  exec: function exec(morph$$1) {
    morph$$1.activeMark ? morph$$1.selection.selectRight(1) : morph$$1.selection.goRight(1);
    return true;
  }
}, {
  name: "go up",
  doc: "Move the cursor 1 line. At the end of a line move the cursor down. If a selection is active, collapse the selection right.",
  scrollCursorIntoView: true,
  exec: function exec(morph$$1) {
    morph$$1.activeMark ? morph$$1.selection.selectUp(1) : morph$$1.selection.goUp(1, true);
    return true;
  }
}, {
  name: "go down",
  exec: function exec(morph$$1) {
    morph$$1.activeMark ? morph$$1.selection.selectDown(1) : morph$$1.selection.goDown(1, true);
    return true;
  }
}, {
  name: "select left",
  exec: function exec(morph$$1) {
    morph$$1.selection.selectLeft(1);
    return true;
  }
}, {
  name: "select right",
  exec: function exec(morph$$1) {
    morph$$1.selection.selectRight(1);
    return true;
  }
}, {
  name: "select up",
  exec: function exec(morph$$1) {
    morph$$1.selection.selectUp(1, true);
    return true;
  }
}, {
  name: "select down",
  exec: function exec(morph$$1) {
    morph$$1.selection.selectDown(1, true);
    return true;
  }
}, {
  name: "select line",
  exec: function exec(morph$$1) {
    var sel = morph$$1.selection,
        row = sel.lead.row,
        fullLine = morph$$1.lineRange(row, false);
    sel.range = sel.range.equals(fullLine) ? morph$$1.lineRange(row, true) : fullLine;
    return true;
  }
}, {
  name: "goto line start",
  exec: function exec(morph$$1) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { select: false };

    var select = opts.select || !!morph$$1.activeMark,
        sel = morph$$1.selection,
        cursor = sel.lead,
        line = morph$$1.screenLineRange(cursor, true);
    sel.lead = eqPosition(cursor, line.start) ? {
      column: 0,
      row: cursor.row
    } : line.start;
    !select && (sel.anchor = sel.lead);
    return true;
  }
}, {
  name: "goto line end",
  exec: function exec(morph$$1) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { select: false };

    var select = opts.select || !!morph$$1.activeMark,
        sel = morph$$1.selection,
        cursor = sel.lead,
        line = morph$$1.screenLineRange(cursor, true);
    sel.lead = line.end;
    !select && (sel.anchor = sel.lead);
    return true;
  }
}, {
  name: "goto page up",
  exec: function exec(morph$$1) {
    morph$$1.pageUpOrDown({
      direction: "up",
      select: !!morph$$1.activeMark
    });
    return true;
  }
}, {
  name: "goto page down",
  exec: function exec(morph$$1) {
    morph$$1.pageUpOrDown({
      direction: "down",
      select: !!morph$$1.activeMark
    });
    return true;
  }
}, {
  name: "goto page up and select",
  exec: function exec(morph$$1) {
    morph$$1.pageUpOrDown({
      direction: "up",
      select: true
    });
    return true;
  }
}, {
  name: "goto page down and select",
  exec: function exec(morph$$1) {
    morph$$1.pageUpOrDown({
      direction: "down",
      select: true
    });
    return true;
  }
}, {
  name: "goto start",
  exec: function exec(morph$$1) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { select: !!morph$$1.activeMark };

    morph$$1.gotoDocumentStart(Object.assign({}, opts));
    return true;
  }
}, {
  name: "goto end",
  exec: function exec(morph$$1) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { select: !!morph$$1.activeMark };

    morph$$1.gotoDocumentEnd(Object.assign({}, opts));
    return true;
  }
}, {
  name: "goto paragraph above",
  exec: function exec(morph$$1) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { select: !!morph$$1.activeMark };

    var pRange = morph$$1.paragraphRangeAbove(morph$$1.cursorPosition.row);
    pRange.start.row--;
    morph$$1.selection.lead = pRange.start;
    if (!opts.select) morph$$1.collapseSelection();
    return true;
  }
}, {
  name: "goto paragraph below",
  exec: function exec(morph$$1) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { select: !!morph$$1.activeMark };

    var pRange = morph$$1.paragraphRangeBelow(morph$$1.cursorPosition.row);
    pRange.end.row++;
    morph$$1.selection.lead = pRange.end;
    if (!opts.select) morph$$1.collapseSelection();
    return true;
  }
}, {
  name: "move cursor to screen bottom in 1/3 steps",
  readOnly: true,
  exec: function exec(morph$$1) {
    var select = !!morph$$1.activeMark,
        currentPos = morph$$1.lineWrapping ? morph$$1.cursorScreenPosition : morph$$1.cursorPosition,
        firstRow = morph$$1.textLayout.firstFullVisibleLine(morph$$1),
        lastRow = morph$$1.textLayout.lastFullVisibleLine(morph$$1),
        middleRow = firstRow + Math.floor((lastRow - firstRow) / 2),
        newPos = currentPos;
    if (currentPos.row < firstRow) newPos.row = firstRow;else if (currentPos.row < middleRow) newPos.row = middleRow;else if (currentPos.row < lastRow) newPos.row = lastRow;else return true;
    morph$$1.selection.lead = morph$$1.lineWrapping ? morph$$1.toDocumentPosition(newPos) : newPos;
    if (!select) morph$$1.selection.anchor = morph$$1.selection.lead;
    return true;
  }
}, {
  name: "move cursor to screen top in 1/3 steps",
  readOnly: true,
  exec: function exec(morph$$1) {
    var select = !!morph$$1.activeMark,
        currentPos = morph$$1.lineWrapping ? morph$$1.cursorScreenPosition : morph$$1.cursorPosition,
        firstRow = morph$$1.textLayout.firstFullVisibleLine(morph$$1),
        lastRow = morph$$1.textLayout.lastFullVisibleLine(morph$$1),
        middleRow = firstRow + Math.floor((lastRow - firstRow) / 2),
        newPos = currentPos;
    if (currentPos.row <= firstRow) return true;
    if (currentPos.row <= middleRow) newPos.row = firstRow;else if (currentPos.row <= lastRow) newPos.row = middleRow;else newPos.row = lastRow;
    morph$$1.selection.lead = morph$$1.lineWrapping ? morph$$1.toDocumentPosition(newPos) : newPos;
    if (!select) morph$$1.selection.anchor = morph$$1.selection.lead;
    return true;
  }
}, {
  name: "goto line",
  exec: function () {
    var _ref5 = asyncToGenerator(regeneratorRuntime.mark(function _callee3(morph$$1) {
      var select, row;
      return regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              select = !!morph$$1.activeMark;
              _context3.t0 = Number;
              _context3.next = 4;
              return morph$$1.world().prompt("Enter line number");

            case 4:
              _context3.t1 = _context3.sent;
              row = (0, _context3.t0)(_context3.t1);

              if (!isNaN(row)) {
                if (select) morph$$1.selection.lead = {
                  row: row,
                  column: 0
                };else morph$$1.cursorPosition = {
                  row: row,
                  column: 0
                };
                morph$$1.scrollCursorIntoView();
                morph$$1.focus();
              }
              return _context3.abrupt("return", true);

            case 8:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function exec(_x11) {
      return _ref5.apply(this, arguments);
    }

    return exec;
  }()
}, {
  name: "join line",
  exec: function exec(morph$$1) {
    var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { withLine: "before" };
    var _morph$selection = morph$$1.selection,
        start = _morph$selection.start,
        end = _morph$selection.end,
        lead = _morph$selection.lead;

    if (!morph$$1.selection.isEmpty()) {
      if (start.row === end.row) return true;
      var undo = morph$$1.undoManager.ensureNewGroup(morph$$1, "join line"),
          joinPositions = lively_lang.arr.range(0, end.row - 1 - start.row).map(function (_) {
        return morph$$1.joinLine(start.row);
      });
      morph$$1.undoManager.group(undo);
      if (morph$$1.selection.isMultiSelection) {
        morph$$1.cursorPosition = joinPositions[0];
        joinPositions.slice(1).forEach(function (pos) {
          return morph$$1.selection.addRange({
            start: pos,
            end: pos
          });
        });
      }
      return true;
    }
    var row = lead.row;

    if (args.withLine === "before" && row <= 0) return true;
    if (args.withLine === "after" && row >= morph$$1.document.endPosition.row) return true;
    morph$$1.undoManager.group();
    var firstRow = args.withLine === "before" ? row - 1 : row;
    morph$$1.cursorPosition = morph$$1.joinLine(firstRow);
    morph$$1.undoManager.group();
    return true;
  }
}, {
  name: "split line",
  exec: function exec(morph$$1) {
    var pos = morph$$1.cursorPosition,
        indent = morph$$1.getLine(pos.row).match(/^\s*/)[0].length;
    morph$$1.insertText("\n" + " ".repeat(indent), pos);
    morph$$1.cursorPosition = pos;
    return true;
  }
}, {
  name: "insert line",
  exec: function exec(morph$$1) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { where: "above" };
    var row = morph$$1.cursorPosition.row,
        indent = morph$$1.getLine(row).match(/^\s*/)[0].length;
    if (opts.where === "below") row++;
    morph$$1.insertText(" ".repeat(indent) + "\n", {
      column: 0,
      row: row
    });
    morph$$1.cursorPosition = {
      column: indent,
      row: row
    };
    return true;
  }
}, {
  name: "duplicate line or selection",
  exec: function exec(morph$$1) {
    morph$$1.undoManager.group();
    var pos = morph$$1.selection.end;
    if (morph$$1.selection.isEmpty()) {
      morph$$1.insertText(morph$$1.getLine(pos.row) + "\n", {
        column: 0,
        row: pos.row + 1
      });
    } else {
      var range = morph$$1.selection.range;
      morph$$1.insertText(morph$$1.selection.text, pos);
      morph$$1.selection = range;
    }
    morph$$1.undoManager.group();
    return true;
  }
}, {
  name: "delete emtpy line or until end of line",
  exec: function exec(morph$$1) {
    var pos = morph$$1.cursorPosition,
        line = morph$$1.getLine(pos.row);
    if (eqPosition(morph$$1.document.endPosition, pos)) return true;
    var range = line.trim() ? {
      start: pos,
      end: {
        row: pos.row,
        column: line.length
      }
    } : {
      start: {
        row: pos.row,
        column: 0
      },
      end: {
        row: pos.row + 1,
        column: 0
      }
    };
    morph$$1.env.eventDispatcher.doCopy(morph$$1.textInRange(range));
    morph$$1.undoManager.group();
    morph$$1.deleteText(range);
    morph$$1.undoManager.group();
    return true;
  }
}, {
  name: "delete left until beginning of line",
  exec: function exec(morph$$1) {
    if (morph$$1.activeMark) morph$$1.activeMark = null;
    if (!morph$$1.selection.isEmpty()) {
      morph$$1.selection.text = "";
      return true;
    }
    var lineRange = morph$$1.lineRange(),
        end = morph$$1.cursorPosition;
    if (eqPosition({
      row: end.row,
      column: 0
    }, end)) return true;
    var start = eqPosition(lineRange.start, end) ? {
      row: end.row,
      column: 0
    } : lineRange.start,
        range = {
      start: start,
      end: end
    };
    morph$$1.deleteText(range);
    return true;
  }
}, {
  name: "move lines up",
  multiSelectAction: "single",
  exec: function exec(morph$$1) {
    var sel = morph$$1.selection;
    if (morph$$1.inMultiSelectMode()) {
      var ranges = sel.selections.map(function (ea) {
        return ea.range;
      });
      ranges.slice().sort(Range.compare).forEach(function (range) {
        morph$$1.selection = range;
        morph$$1.execCommand("move lines up");
      });
      ranges.forEach(function (range) {
        range.start.row--;
        range.end.row--;
      });
      morph$$1.selection.ranges = ranges;
      return true;
    }
    if (!sel.isEmpty() && sel.end.column === 0) sel.growRight(-1);
    var start = sel.start,
        end = sel.end;

    var lineBefore = morph$$1.getLine(start.row - 1);
    var undo = morph$$1.undoManager.ensureNewGroup(morph$$1);
    morph$$1.insertText(lineBefore + "\n", {
      row: end.row + 1,
      column: 0
    });
    morph$$1.deleteText({
      start: {
        row: start.row - 1,
        column: 0
      },
      end: {
        row: start.row,
        column: 0
      }
    });
    morph$$1.undoManager.group(undo);
    return true;
  }
}, {
  name: "move lines down",
  multiSelectAction: "single",
  exec: function exec(morph$$1) {
    var sel = morph$$1.selection;
    if (morph$$1.inMultiSelectMode()) {
      var ranges = sel.selections.map(function (ea) {
        return ea.range;
      });
      ranges.slice().sort(Range.compare).reverse().forEach(function (range) {
        morph$$1.selection = range;
        morph$$1.execCommand("move lines down");
      });
      ranges.forEach(function (range) {
        range.start.row++;
        range.end.row++;
      });
      morph$$1.selection.ranges = ranges;
      return true;
    }
    if (!sel.isEmpty() && sel.end.column === 0) sel.growRight(-1);
    var range = sel.range,
        _range = range,
        start = _range.start,
        end = _range.end;
    if (sel.isEmpty()) range = {
      start: {
        row: start.row,
        column: 0
      },
      end: {
        row: start.row + 1,
        column: 0
      }
    };else if (end.column !== 0) range = {
      start: start,
      end: {
        row: end.row + 1,
        column: 0
      }
    };
    var undo = morph$$1.undoManager.ensureNewGroup(morph$$1);
    var linesToMove = morph$$1.deleteText(range);
    morph$$1.insertText(linesToMove, {
      row: start.row + 1,
      column: 0
    });
    morph$$1.undoManager.group(undo);
    morph$$1.selection = {
      start: Object.assign({}, start, { row: start.row + 1 }),
      end: Object.assign({}, end, { row: end.row + 1 })
    };
    return true;
  }
}, {
  name: "select word",
  exec: function exec(morph$$1) {
    var sel = morph$$1.selection;
    sel.range = morph$$1.wordAt(sel.lead).range;
    return true;
  }
}, {
  name: "select word right",
  exec: function exec(morph$$1) {
    var sel = morph$$1.selection;
    sel.anchor = morph$$1.wordRight(sel.end).range.end;
    return true;
  }
}, {
  name: "goto word left",
  exec: function exec(morph$$1) {
    var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { select: false };
    var select = args.select || !!morph$$1.activeMark,
        _morph$wordLeft = morph$$1.wordLeft(),
        range = _morph$wordLeft.range;
    morph$$1.selection.lead = range.start;
    if (!select) morph$$1.selection.anchor = range.start;
    return true;
  }
}, {
  name: "goto word right",
  exec: function exec(morph$$1) {
    var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { select: false };
    var select = args.select || !!morph$$1.activeMark,
        _morph$wordRight = morph$$1.wordRight(),
        range = _morph$wordRight.range;
    morph$$1.selection.lead = range.end;
    if (!select) morph$$1.selection.anchor = range.end;
    return true;
  }
}, {
  name: "delete word right",
  exec: function exec(morph$$1) {
    morph$$1.undoManager.group();

    var _morph$wordRight2 = morph$$1.wordRight(),
        end = _morph$wordRight2.range.end,
        range = {
      start: morph$$1.cursorPosition,
      end: end
    };

    morph$$1.env.eventDispatcher.doCopy(morph$$1.textInRange(range));
    morph$$1.deleteText(range);
    morph$$1.undoManager.group();
    return true;
  }
}, {
  name: "delete word left",
  exec: function exec(morph$$1) {
    morph$$1.undoManager.group();

    var _morph$wordLeft2 = morph$$1.wordLeft(),
        start = _morph$wordLeft2.range.start,
        range = {
      start: start,
      end: morph$$1.cursorPosition
    };

    morph$$1.deleteText(range);
    morph$$1.undoManager.group();
    return true;
  }
}, {
  name: "goto matching right",
  exec: function exec(morph$$1) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { select: !!morph$$1.activeMark };

    var pairs = opts.pairs || {
      "{": "}",
      "[": "]",
      "(": ")",
      "<": ">"
    };
    var found = morph$$1.findMatchingForward(morph$$1.cursorPosition, "right", pairs) || morph$$1.findMatchingForward(morph$$1.cursorPosition, "left", pairs);
    if (found) {
      morph$$1.selection.lead = found;
      if (!opts.select) morph$$1.selection.anchor = morph$$1.selection.lead;
    }
    return true;
  }
}, {
  name: "goto matching left",
  exec: function exec(morph$$1) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { select: !!morph$$1.activeMark };

    var pairs = opts.pairs || {
      "}": "{",
      "]": "[",
      ")": "(",
      ">": "<"
    };
    var found = morph$$1.findMatchingBackward(morph$$1.cursorPosition, "left", pairs) || morph$$1.findMatchingBackward(morph$$1.cursorPosition, "right", pairs);
    if (found) {
      morph$$1.selection.lead = found;
      if (!opts.select) morph$$1.selection.anchor = morph$$1.selection.lead;
    }
    return true;
  }
}, {
  name: "realign top-bottom-center",
  doc: "Cycles through centering the cursor position, aligning it at the top, aligning it at the bottom.",
  scrollCursorIntoView: false,
  multiSelectAction: "single",
  exec: function exec(morph$$1) {
    var charBounds = morph$$1.charBoundsFromTextPosition(morph$$1.cursorPosition),
        pos = charBounds.topLeft(),
        h$$1 = morph$$1.height - charBounds.height,
        _morph$scroll = morph$$1.scroll,
        scrollX = _morph$scroll.x,
        scrollY = _morph$scroll.y;
    if (Math.abs(pos.y - scrollY) < 2) {
      scrollY = pos.y - h$$1;
    } else if (Math.abs(pos.y - scrollY - h$$1 * 0.5) < 2) {
      scrollY = pos.y;
    } else {
      scrollY = pos.y - h$$1 * 0.5;
    }
    morph$$1.scroll = lively_graphics.pt(scrollX, scrollY);
    return true;
  }
}, {
  name: "reverse selection",
  doc: "switches the selection lead and anchor",
  exec: function exec(morph$$1) {
    var sel = morph$$1.selection;
    if (sel.isEmpty()) {
      var m = morph$$1.popSavedMark();
      if (m) {
        morph$$1.saveMark(morph$$1.cursorPosition);
        sel.lead = m.position;
      }
    } else sel.reverse();
    return true;
  }
}, {
  name: "toggle active mark",
  doc: "....",
  handlesCount: true,
  multiSelectAction: "single",
  exec: function exec(morph$$1, args, count) {
    var m = morph$$1.activeMark,
        sel = morph$$1.selection,
        selected = !sel.isEmpty();
    if (count === 4) {
      var lastMark = morph$$1.popSavedMark();
      if (lastMark) {
        sel.lead = lastMark.position;
        if (!selected) sel.anchor = sel.lead;
      }
      return true;
    }
    if (!m && !selected) {
      morph$$1.activeMark = sel.lead;
      return true;
    }
    morph$$1.saveMark(m || sel.anchor);
    morph$$1.activeMark = null;
    if (selected) {
      var sels = morph$$1.inMultiSelectMode() ? sel.selections : [sel];
      sels.forEach(function (sel) {
        return sel.anchor = sel.lead;
      });
    }
    return true;
  }
}, {
  name: "fit text to column",
  handlesCount: true,
  multiSelectAction: "forEach",
  exec: function exec(morph$$1, opts, count) {
    if (count === 4) return morph$$1.execCommand("join line");
    if (morph$$1.selection.isEmpty()) morph$$1.selectLine();
    var sel = morph$$1.selection,
        col = count || 80,
        rows = sel.selectedRows,
        range = sel.range,
        splitRe = /[ ]+/g,
        whitespacePrefixRe = /^[\s\t]+/,
        paragraphs = lively_lang.string.paragraphs(lively_lang.arr.range(rows.first, rows.last).map(function (row) {
      return morph$$1.getLine(row);
    }).join("\n"), { keepEmptyLines: true }),
        newString = lively_lang.chain(paragraphs.map(fitParagraph)).flatten().value().join("\n");
    morph$$1.undoManager.group();
    morph$$1.replace(range, newString);
    morph$$1.undoManager.group();
    return true;
    function splitLineIntoChunks(line, whitespacePrefix, n) {
      if (line.length <= col) return [whitespacePrefix + line.trim()];
      var firstChunk = line.slice(0, col),
          splitMatch = lively_lang.arr.last(lively_lang.string.reMatches(firstChunk, splitRe)),
          lastWordSplit = splitMatch && splitMatch.start > 0 ? splitMatch.start : col,
          first = firstChunk.slice(0, lastWordSplit),
          rest = whitespacePrefix + (firstChunk.slice(lastWordSplit) + line.slice(col)).trimLeft();
      return [first].concat(splitLineIntoChunks(rest, whitespacePrefix, n + 1));
    }
    function fitRow(row) {
      if (row.trim() === "") return [""];
      var whitespacePrefixMatch = row.match(whitespacePrefixRe),
          whitespacePrefix = whitespacePrefixMatch ? whitespacePrefixMatch[0] : "";
      return splitLineIntoChunks(whitespacePrefix + row.trim(), whitespacePrefix);
    }
    function fitParagraph(para) {
      return (/^\s*$/.test(para) ? para : fitRow(para.split("\n").join(" ")).join("\n") + "\n"
      );
    }
  }
}, {
  name: "lowercase",
  exec: function exec(morph$$1) {
    morph$$1.undoManager.group();
    if (morph$$1.selection.isEmpty()) morph$$1.selection = morph$$1.wordAt().range;
    morph$$1.selection.text = morph$$1.selection.text.toLowerCase();
    morph$$1.undoManager.group();
    return true;
  }
}, {
  name: "remove trailing whitespace",
  exec: function exec(morph$$1) {
    morph$$1.undoManager.group();
    var i = 0;
    morph$$1.withLinesDo(0, morph$$1.documentEndPosition.row, function (line, range) {
      return line.match(/\s+$/) && ++i && morph$$1.replace(range, line.trimRight());
    });
    morph$$1.world().setStatusMessage(i + " lines cleaned up");
    morph$$1.undoManager.group();
    return true;
  }
}, {
  name: "uppercase",
  exec: function exec(morph$$1) {
    morph$$1.undoManager.group();
    if (morph$$1.selection.isEmpty()) morph$$1.selection = morph$$1.wordAt().range;
    morph$$1.selection.text = morph$$1.selection.text.toUpperCase();
    morph$$1.undoManager.group();
    return true;
  }
}, {
  name: "newline",
  exec: function exec(morph$$1) {
    var row = morph$$1.cursorPosition.row,
        currentLine = morph$$1.getLine(row),
        indent = currentLine.match(/^\s*/)[0].length;
    morph$$1.undoManager.group();
    if (!currentLine.trim() && indent) var deleted = morph$$1.deleteText({
      start: {
        row: row,
        column: 0
      },
      end: {
        row: row,
        column: indent
      }
    });
    morph$$1.selection.text = morph$$1.document.constructor.newline + " ".repeat(indent);
    morph$$1.selection.collapseToEnd();
    morph$$1.undoManager.group();
    return true;
  }
}, {
  name: "insertstring",
  exec: function exec(morph$$1) {
    var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      string: null,
      undoGroup: false
    };

    morph$$1.saveActiveMarkAndDeactivate();
    var string$$1 = args.string,
        undoGroup = args.undoGroup,
        isValid = typeof string$$1 === "string" && string$$1.length;

    if (!isValid) console.warn("command insertstring called with not string value");
    if (morph$$1.rejectsInput() || !isValid) return false;
    var sel = morph$$1.selection,
        isDelete = !sel.isEmpty();
    if (isDelete) morph$$1.undoManager.group();
    sel.text = string$$1;
    sel.collapseToEnd();
    if (isDelete) morph$$1.undoManager.group();
    if (undoGroup) {
      if (!/^[\s\.,\?\+=]+$/.test(string$$1) && typeof undoGroup === "number") morph$$1.undoManager.groupLater(undoGroup);else morph$$1.undoManager.group();
    }
    return true;
  }
}, {
  name: "toggle line wrapping",
  scrollCursorIntoView: false,
  multiSelectAction: "single",
  exec: function exec(morph$$1) {
    morph$$1.keepPosAtSameScrollOffsetWhile(function () {
      return morph$$1.lineWrapping = !morph$$1.lineWrapping;
    });
    return true;
  }
}, {
  name: "increase font size",
  scrollCursorIntoView: false,
  exec: function exec(morph$$1) {
    morph$$1.keepPosAtSameScrollOffsetWhile(function () {
      return morph$$1.fontSize++;
    });
    return true;
  }
}, {
  name: "decrease font size",
  scrollCursorIntoView: false,
  exec: function exec(morph$$1) {
    morph$$1.keepPosAtSameScrollOffsetWhile(function () {
      return morph$$1.fontSize--;
    });
    return true;
  }
}, {
  name: "cancel input",
  scrollCursorIntoView: false,
  multiSelectAction: "single",
  exec: function exec(morph$$1, args, count, evt) {
    morph$$1.env.eventDispatcher.resetKeyInputState();
    morph$$1.selection.disableMultiSelect && morph$$1.selection.disableMultiSelect();
    if (!morph$$1.selection.isEmpty()) morph$$1.selection.anchor = morph$$1.selection.lead;
    if (morph$$1.activeMark) morph$$1.activeMark = null;
    return true;
  }
}];
var usefulEditorCommands = [{
  name: "insert date",
  handlesCount: true,
  exec: function exec(ed, opts, count) {
    var dateString = lively_lang.date.format(new Date(), count ? "mediumDate" : "isoDate");
    ed.undoManager.group();
    ed.insertText(dateString);
    ed.undoManager.group();
    return true;
  }
}, {
  name: "sort lines",
  exec: function exec(text) {
    var _text$selection = text.selection,
        startRow = _text$selection.start.row,
        endRow = _text$selection.end.row,
        lines = [];

    text.withLinesDo(startRow, endRow, function (line) {
      var idx = lines.findIndex(function (ea) {
        return ea > line;
      });
      idx > -1 ? lines.splice(idx, 0, line) : lines.push(line);
    });
    text.undoManager.group();
    text.replace({
      start: {
        row: startRow,
        column: 0
      },
      end: {
        row: endRow + 1,
        column: 0
      }
    }, lines.join("\n") + "\n");
    text.undoManager.group();
    return true;
  }
}, {
  name: "remove duplicate lines (uniq)",
  exec: function exec(text) {
    var _text$selection2 = text.selection,
        startRow = _text$selection2.start.row,
        endRow = _text$selection2.end.row,
        lines = [];

    text.withLinesDo(startRow, endRow, function (line) {
      return lively_lang.arr.pushIfNotIncluded(lines, line);
    });
    text.undoManager.group();
    text.replace({
      start: {
        row: startRow,
        column: 0
      },
      end: {
        row: endRow + 1,
        column: 0
      }
    }, lines.join("\n") + "\n");
    text.undoManager.group();
    return true;
  }
}, {
  name: "change string inflection",
  handlesCount: true,
  multiSelectAction: "single",
  exec: function () {
    var _ref6 = asyncToGenerator(regeneratorRuntime.mark(function _callee4(textMorph, opts, count) {
      var ranges, string$$1, type, offers, _ref7, _ref7$selected, choice, convertCamelCased, detectCamelCaseType;

      return regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              detectCamelCaseType = function detectCamelCaseType(string$$1) {
                if (string$$1.match(/[A-Z]/)) return "uppercased";
                if (string$$1.match(/-/)) return "dashed";
                if (string$$1.match(/\s/)) return "spaced";
                return "unknown";
              };

              convertCamelCased = function convertCamelCased(string$$1, intoType) {
                var match,
                    replace,
                    fromType = detectCamelCaseType(string$$1).trim();
                if (fromType === "uppercased") match = /\s*[A-Z0-9]+/g;else if (fromType === "dashed") match = /-\w/g;else if (fromType === "spaced") match = /\s+.?/g;
                if (intoType === "uppercased") replace = function replace(m) {
                  return m.trim().replace(/^-/, "").toUpperCase();
                };else if (intoType === "dashed") replace = function replace(m) {
                  return "-" + m.trim().replace(/^-/, "").toLowerCase();
                };else if (intoType === "spaced") replace = function replace(m) {
                  return " " + m.trim().replace(/^-/, "").toLowerCase();
                };
                return string$$1.replace(match, replace);
              };

              if (textMorph.selection.isEmpty()) textMorph.selection = textMorph.wordAt().range;
              ranges = textMorph.selection.ranges, string$$1 = textMorph.textInRange(ranges[0]);

              if (string$$1) {
                _context4.next = 7;
                break;
              }

              textMorph.setStatusMessage("Please select some text");
              return _context4.abrupt("return", true);

            case 7:
              type = detectCamelCaseType(string$$1);
              offers = lively_lang.arr.without(["uppercased", "dashed", "spaced"], type);
              _context4.next = 11;
              return textMorph.world().listPrompt("Convert " + type + " into?", offers, {});

            case 11:
              _ref7 = _context4.sent;
              _ref7$selected = slicedToArray(_ref7.selected, 1);
              choice = _ref7$selected[0];

              if (choice) {
                _context4.next = 16;
                break;
              }

              return _context4.abrupt("return", true);

            case 16:
              textMorph.undoManager.group();
              ranges.forEach(function (range, i) {
                var string$$1 = textMorph.textInRange(range),
                    replacement = convertCamelCased(string$$1, choice);
                textMorph.replace(range, replacement);
              });
              textMorph.undoManager.group();
              textMorph.focus();
              return _context4.abrupt("return", true);

            case 21:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function exec(_x19, _x20, _x21) {
      return _ref6.apply(this, arguments);
    }

    return exec;
  }()
}, {
  name: "spell check word",
  exec: function () {
    var _ref8 = asyncToGenerator(regeneratorRuntime.mark(function _callee5(text, opts) {
      var word, _ref9, spellCheckWord, suggestions, _ref10, _ref10$selected, choice;

      return regeneratorRuntime.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              word = text.wordAt();

              if (word.string) {
                _context5.next = 4;
                break;
              }

              text.setStatusMessage("no word for spellcheck!");
              return _context5.abrupt("return", true);

            case 4:
              _context5.next = 6;
              return System.import("lively.morphic/ide/shell/spell-checker.js");

            case 6:
              _ref9 = _context5.sent;
              spellCheckWord = _ref9.spellCheckWord;
              _context5.next = 10;
              return spellCheckWord(word.string);

            case 10:
              suggestions = _context5.sent;

              if (suggestions.length) {
                _context5.next = 14;
                break;
              }

              text.setStatusMessage("no suggestions for word " + word.string);
              return _context5.abrupt("return", true);

            case 14:
              _context5.next = 16;
              return text.world().filterableListPrompt("Choose replacement for " + word.string, suggestions);

            case 16:
              _ref10 = _context5.sent;
              _ref10$selected = slicedToArray(_ref10.selected, 1);
              choice = _ref10$selected[0];

              if (choice) {
                text.undoManager.group();
                text.replace(word.range, choice);
                text.undoManager.group();
              }
              return _context5.abrupt("return", true);

            case 21:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));

    function exec(_x22, _x23) {
      return _ref8.apply(this, arguments);
    }

    return exec;
  }()
}, {
  name: "[shell] run shell command on region",
  multiSelectAction: "single",
  exec: function () {
    var _ref11 = asyncToGenerator(regeneratorRuntime.mark(function _callee6(ed, opts) {
      var input, options, cmdString, _ref12, runCommand, cmd, result;

      return regeneratorRuntime.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              input = ed.textInRange(ed.selection);
              options = !input || input.length === 0 ? {} : { stdin: input };
              _context6.next = 4;
              return ed.world().prompt("Enter shell command to run on region.", { historyId: "lively.ide.execShellCommand" });

            case 4:
              cmdString = _context6.sent;
              _context6.next = 7;
              return System.import("lively.morphic/ide/shell/shell-interface.js");

            case 7:
              _ref12 = _context6.sent;
              runCommand = _ref12.runCommand;

              if (cmdString) {
                _context6.next = 11;
                break;
              }

              return _context6.abrupt("return", ed.setStatusMessage("No command entered, aborting...!"));

            case 11:
              cmd = runCommand(cmdString, options);
              _context6.prev = 12;
              _context6.next = 15;
              return cmd.whenDone();

            case 15:
              result = cmd.output.trim();

              ed.undoManager.group();
              ed.selection.selections.forEach(function (sel) {
                return sel.text = result;
              });
              ed.undoManager.group();
              _context6.next = 24;
              break;

            case 21:
              _context6.prev = 21;
              _context6.t0 = _context6["catch"](12);

              ed.showError(_context6.t0);

            case 24:
              return _context6.abrupt("return", true);

            case 25:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this, [[12, 21]]);
    }));

    function exec(_x24, _x25) {
      return _ref11.apply(this, arguments);
    }

    return exec;
  }()
}, {
  name: "open file at cursor",
  exec: function () {
    var _ref13 = asyncToGenerator(regeneratorRuntime.mark(function _callee7(ed, opts) {
      var line, startRow, start, end, text, parts, url, _ref14, TextEditor, textEd;

      return regeneratorRuntime.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              line = ed.getLine(), startRow = ed.cursorPosition.row, start = ed.document.scanBackward(ed.cursorPosition, function (c, pos) {
                return (pos.column <= 0 || c.match(/\s/)) && pos;
              }) || {
                row: 0,
                column: 0
              }, end = ed.document.scanForward(ed.cursorPosition, function (c, pos) {
                return (pos.row != startRow || c.match(/\s/)) && pos;
              }) || ed.documentEndPosition, text = ed.textInRange({
                start: start,
                end: end
              }).replace(/\s/g, ""), parts = text.split(":"), url = parts[0].match(/^file|http/) ? parts.shift() + ":" + parts.shift() : parts.shift();

              if (parts[0].match(/^[0-9]+$/)) url += ":" + parts.shift();
              _context7.next = 4;
              return System.import("lively.morphic/ide/text-editor.js");

            case 4:
              _ref14 = _context7.sent;
              TextEditor = _ref14.default;
              textEd = TextEditor.openInWindow();

              textEd.location = url;
              return _context7.abrupt("return", textEd);

            case 9:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, this);
    }));

    function exec(_x26, _x27) {
      return _ref13.apply(this, arguments);
    }

    return exec;
  }()
}];
commands$$1.push.apply(commands$$1, usefulEditorCommands);
commands$$1.push(activate);
commands$$1.push.apply(commands$$1, toConsumableArray(completionCommands));
commands$$1.push.apply(commands$$1, toConsumableArray(searchCommands));
commands$$1.push.apply(commands$$1, toConsumableArray(multiSelectCommands));
commands$$1.push.apply(commands$$1, toConsumableArray(commands$3));
commands$$1.push.apply(commands$$1, toConsumableArray(commands$4));

var defaultRenderer = {
  renderMorph: function renderMorph(renderer, morph$$1) {
    var textLayout = morph$$1.textLayout;
    textLayout.updateFromMorphIfNecessary(morph$$1);
    var cursorWidth = morph$$1.fontSize <= 11 ? 2 : 3,
        selectionLayer = [];
    if (morph$$1.inMultiSelectMode()) {
      var _selectionLayer2;

      var sels = morph$$1.selection.selections,
          i = 0;
      for (; i < sels.length - 1; i++) {
        var _selectionLayer;

        (_selectionLayer = selectionLayer).push.apply(_selectionLayer, toConsumableArray(this.renderSelectionLayer(textLayout, morph$$1, sels[i], true, 2)));
      }(_selectionLayer2 = selectionLayer).push.apply(_selectionLayer2, toConsumableArray(this.renderSelectionLayer(textLayout, morph$$1, sels[i], false, 4)));
    } else selectionLayer = this.renderSelectionLayer(textLayout, morph$$1, morph$$1.selection, false, cursorWidth);
    return vdom.h("div", Object.assign({}, defaultAttributes(morph$$1, renderer), { style: Object.assign({}, defaultStyle(morph$$1), { cursor: morph$$1.nativeCursor === "auto" ? morph$$1.readOnly ? "default" : "text" : morph$$1.nativeCursor }) }), [renderer.renderSubmorphs(morph$$1)].concat(selectionLayer).concat(morph$$1.debug ? this.renderDebugLayer(textLayout, morph$$1) : []).concat(this.renderMarkerLayer(textLayout, morph$$1)).concat(this.renderTextLayer(textLayout, morph$$1)));
  },
  renderSelectionLayer: function renderSelectionLayer(textLayouter, morph$$1, selection) {
    var diminished = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var cursorWidth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 2;

    if (!selection) return [];
    var start = selection.start,
        end = selection.end,
        lead = selection.lead,
        cursorVisible = selection.cursorVisible,
        selectionColor = selection.selectionColor,
        start = textLayouter.docToScreenPos(morph$$1, start),
        end = textLayouter.docToScreenPos(morph$$1, end),
        isReverse = selection.isReverse(),
        document = morph$$1.document,
        lines = textLayouter.wrappedLines(morph$$1),
        startPos = textLayouter.pixelPositionForScreenPos(morph$$1, start),
        endPos = textLayouter.pixelPositionForScreenPos(morph$$1, end),
        cursorPos = isReverse ? startPos : endPos,
        defaultHeight = null,
        endLineHeight = end.row in lines ? lines[end.row].height : defaultHeight = textLayouter.defaultCharSize(morph$$1).height,
        leadLineHeight = lead.row in lines ? lines[lead.row].height : defaultHeight || (defaultHeight = textLayouter.defaultCharSize(morph$$1).height);

    if (selection.isEmpty()) return [this.cursor(cursorPos, leadLineHeight, cursorVisible, diminished, cursorWidth)];
    if (start.row === end.row) return [this.selectionLayerPart(startPos, endPos.addXY(0, endLineHeight), selectionColor), this.cursor(cursorPos, leadLineHeight, cursorVisible, diminished, cursorWidth)];
    var endPosLine1 = lively_graphics.pt(morph$$1.width, startPos.y + lines[start.row].height),
        startPosLine2 = lively_graphics.pt(0, endPosLine1.y);
    if (start.row + 1 === end.row) {
      return [this.selectionLayerPart(startPos, endPosLine1, selectionColor), this.selectionLayerPart(startPosLine2, endPos.addXY(0, endLineHeight), selectionColor), this.cursor(cursorPos, leadLineHeight, cursorVisible, diminished, cursorWidth)];
    }
    var endPosMiddle = lively_graphics.pt(morph$$1.width, endPos.y),
        startPosLast = lively_graphics.pt(0, endPos.y);
    return [this.selectionLayerPart(startPos, endPosLine1, selectionColor), this.selectionLayerPart(startPosLine2, endPosMiddle, selectionColor), this.selectionLayerPart(startPosLast, endPos.addXY(0, endLineHeight), selectionColor), this.cursor(cursorPos, leadLineHeight, cursorVisible, diminished, cursorWidth)];
  },
  renderMarkerLayer: function renderMarkerLayer(textLayouter, morph$$1) {
    var markers = morph$$1.markers,
        parts = [];
    if (!markers) return parts;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = markers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var m = _step.value;
        var style = m.style,
            _m$range = m.range,
            start = _m$range.start,
            end = _m$range.end;

        if (start.row === end.row) {
          parts.push(this.renderMarkerPart(textLayouter, morph$$1, start, end, style));
          continue;
        }
        parts.push(this.renderMarkerPart(textLayouter, morph$$1, start, morph$$1.lineRange(start.row).end, style));
        for (var row = start.row + 1; row <= end.row - 1; row++) {
          var _morph$lineRange = morph$$1.lineRange(row),
              lineStart = _morph$lineRange.start,
              lineEnd = _morph$lineRange.end;

          parts.push(this.renderMarkerPart(textLayouter, morph$$1, lineStart, lineEnd, style));
        }
        parts.push(this.renderMarkerPart(textLayouter, morph$$1, {
          row: end.row,
          column: 0
        }, end, style));
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return parts;
  },
  renderTextLayer: function renderTextLayer(textLayouter, morph$$1) {
    var lines = textLayouter.wrappedLines(morph$$1),
        textWidth = 0,
        textHeight = 0,
        padding = morph$$1.padding,
        scroll = morph$$1.scroll,
        height = morph$$1.height,
        _scroll$subPt = scroll.subPt(padding.topLeft()),
        visibleTop = _scroll$subPt.y,
        visibleBottom = visibleTop + height,
        lastVisibleLineBottom = 0,
        row = 0,
        spacerBefore = void 0,
        renderedLines = [],
        spacerAfter = void 0,
        lineLeft = padding.left(),
        lineTop = padding.top();
    for (; row < lines.length; row++) {
      var _lines$row = lines[row],
          width = _lines$row.width,
          _height = _lines$row.height,
          newTextHeight = textHeight + _height;

      if (newTextHeight >= visibleTop) break;
      textWidth = Math.max(width, textWidth);
      textHeight += _height;
    }
    textLayouter.firstVisibleLine = row;
    spacerBefore = vdom.h("div", {
      style: {
        height: textHeight + "px",
        width: textWidth + "px"
      }
    });
    for (; row < lines.length; row++) {
      var _lines$row2 = lines[row],
          width = _lines$row2.width,
          _height2 = _lines$row2.height,
          newTextHeight = textHeight + _height2;

      renderedLines.push(this.renderLine(lines[row], lineLeft, lineTop));
      textWidth = Math.max(width, textWidth);
      lineTop += _height2;
      textHeight += _height2;
      if (textHeight >= visibleBottom) break;
    }
    textLayouter.lastVisibleLine = row;
    lastVisibleLineBottom = textHeight;
    for (; row < lines.length; row++) {
      var _lines$row3 = lines[row],
          width = _lines$row3.width,
          _height3 = _lines$row3.height;

      textWidth = Math.max(width, textWidth);
      textHeight += _height3;
    }
    spacerAfter = vdom.h("div", {
      style: {
        height: textHeight - lastVisibleLineBottom + "px",
        width: textWidth + "px"
      }
    });
    return vdom.h("div.text-layer", {
      style: {
        whiteSpace: "pre",
        width: "100%",
        zIndex: 3,
        position: "absolute",
        height: textHeight + "px",
        padding: padding.top() + "px " + padding.right() + "px " + padding.bottom() + "px " + padding.left() + "px"
      }
    }, [spacerBefore].concat(renderedLines).concat(spacerAfter));
  },
  renderDebugLayer: function renderDebugLayer(textLayouter, morph$$1) {
    var lines = textLayouter.wrappedLines(morph$$1),
        visibleTop = morph$$1.scroll.y,
        visibleBottom = visibleTop + morph$$1.height,
        padding = morph$$1.padding,
        debugHighlights = [],
        paddingLeft = padding.left(),
        paddingTop = padding.top(),
        textHeight = 0,
        textWidth = 0;
    for (var row = 0; row < lines.length; row++) {
      var _lines$row4 = lines[row],
          width = _lines$row4.width,
          height = _lines$row4.height,
          charBounds = _lines$row4.charBounds;

      for (var col = 0; col < charBounds.length; col++) {
        var _charBounds$col = charBounds[col],
            x = _charBounds$col.x,
            _width = _charBounds$col.width,
            _height4 = _charBounds$col.height,
            y = textHeight + paddingTop;

        x += paddingLeft;
        debugHighlights.push(vdom.h("div", {
          style: {
            position: "absolute",
            left: x + "px",
            top: y + "px",
            width: _width + "px",
            height: _height4 + "px",
            outline: "1px solid orange",
            pointerEvents: "none",
            zIndex: 3
          }
        }));
      }
      textHeight += height;
      textWidth = Math.max(textWidth, width);
      if (textHeight < visibleTop || textHeight > visibleBottom) continue;
    }
    debugHighlights.push(vdom.h("div", {
      style: {
        position: "absolute",
        left: padding.left() + "px",
        top: padding.top() + "px",
        width: textWidth + "px",
        height: textHeight + "px",
        outline: "1px solid red",
        pointerEvents: "none",
        zIndex: 3
      }
    }));
    return debugHighlights;
  },
  selectionLayerPart: function selectionLayerPart(startPos, endPos, selectionColor) {
    return vdom.h("div.selection-layer-part", {
      style: {
        pointerEvents: "none",
        position: "absolute",
        left: startPos.x + "px",
        top: startPos.y + "px",
        width: endPos.x - startPos.x + "px",
        height: endPos.y - startPos.y + "px",
        backgroundColor: selectionColor,
        zIndex: 1
      }
    });
  },
  cursor: function cursor(pos, height, visible, diminished, width) {
    return vdom.h("div.selection-layer-part", {
      style: {
        pointerEvents: "none",
        position: "absolute",
        left: pos.x - Math.ceil(width / 2) + "px",
        top: pos.y + "px",
        width: width + "px",
        height: height + "px",
        backgroundColor: diminished ? "gray" : "black",
        zIndex: 5,
        display: visible ? "" : "none"
      }
    });
  },
  renderMarkerPart: function renderMarkerPart(textLayouter, morph$$1, start, end, style) {
    var _textLayouter$boundsF = textLayouter.boundsFor(morph$$1, start),
        x = _textLayouter$boundsF.x,
        y = _textLayouter$boundsF.y,
        _textLayouter$boundsF2 = textLayouter.boundsFor(morph$$1, end),
        height = _textLayouter$boundsF2.height,
        endX = _textLayouter$boundsF2.x;

    return vdom.h("div.marker-layer-part", {
      style: Object.assign({ zIndex: 3 }, style, {
        position: "absolute",
        left: x + "px",
        top: y + "px",
        height: height + "px",
        width: endX - x + "px"
      })
    });
  },
  renderLine: function renderLine(textLayoutLine, lineLeft, lineTop) {
    var _this = this;

    if (textLayoutLine.rendered) return textLayoutLine.rendered;
    var chunks = textLayoutLine.chunks,
        height = textLayoutLine.height,
        width = textLayoutLine.width;

    height += "px";
    return textLayoutLine.rendered = vdom.h("div", {
      style: {
        height: height,
        lineHeight: height
      }
    }, chunks.map(function (ea) {
      return _this.renderChunk(ea);
    }));
  },
  renderChunk: function renderChunk(textChunk) {
    if (textChunk.rendered) return textChunk.rendered;
    var style = textChunk.style,
        text = textChunk.text,
        width = textChunk.width,
        height = textChunk.height,
        fontSize = style.fontSize,
        fontFamily = style.fontFamily,
        fontColor = style.fontColor,
        backgroundColor = style.backgroundColor,
        fontWeight = style.fontWeight,
        fontStyle = style.fontStyle,
        textDecoration = style.textDecoration,
        fixedCharacterSpacing = style.fixedCharacterSpacing,
        nativeCursor = style.nativeCursor,
        textStyleClasses = style.textStyleClasses,
        link = style.link;

    if (text.length > 1000) text = text.slice(0, 1000);
    text = text.replace(/\t/g, " ");
    var tagname = link ? "a" : "span",
        textNodes = fixedCharacterSpacing ? text.split("").map(function (c) {
      return vdom.h("span", c);
    }) : text,
        attrs = {
      style: {
        fontSize: fontSize + "px",
        fontFamily: fontFamily,
        fontWeight: fontWeight,
        fontStyle: fontStyle,
        textDecoration: textDecoration,
        color: fontColor ? String(fontColor) : "",
        backgroundColor: backgroundColor ? String(backgroundColor) : ""
      }
    };
    if (link) {
      attrs.href = link;
      attrs.target = "_blank";
    }
    if (nativeCursor) {
      attrs.style.cursor = nativeCursor;
    }
    if (textStyleClasses && textStyleClasses.length) attrs.className = textStyleClasses.join(" ");
    return textChunk.rendered = vdom.h(tagname, attrs, textNodes);
  }
};

function addIndexToTextPos(textMorph, textPos, index) {
  return textMorph.indexToPosition(textMorph.positionToIndex(textPos) + index);
}
var Snippet = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("Snippet") && typeof __lively_classholder__.Snippet === "function" ? __lively_classholder__.Snippet : __lively_classholder__.Snippet = function Snippet(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function Snippet_initialize_() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        trigger: null,
        expansion: ""
      };
      var trigger = opts.trigger,
          expansion = opts.expansion;

      this.trigger = trigger;
      this.expansion = expansion;
      this.resetExpansionState();
    }
  }, {
    key: "isTextSnippet",
    get: function get() {
      return true;
    }
  }, {
    key: "attach",
    value: function Snippet_attach_(textMorph) {
      if (!this.isExpanding) return;
      this.textMorph = textMorph;
      lively_bindings.connect(this.textMorph, "selectionChange", this, "onCursorMove");
    }
  }, {
    key: "detach",
    value: function Snippet_detach_(textMorph) {
      if (!this.isExpanding) return;
      lively_bindings.disconnect(textMorph, "selectionChange", this, "onCursorMove");
      this.textMorph = null;
    }
  }, {
    key: "onCursorMove",
    value: function Snippet_onCursorMove_() {
      var _expansionState = this.expansionState,
          startAnchor = _expansionState.startAnchor,
          endAnchor = _expansionState.endAnchor,
          isExpanding = _expansionState.isExpanding;

      if (!isExpanding) {
        this.resetExpansionState();
        return;
      }
      var range = Range.fromPositions(startAnchor.position, endAnchor.position);
      if (!range.containsPosition(this.textMorph.cursorPosition)) this.resetExpansionState();
    }
  }, {
    key: "resetExpansionState",
    value: function Snippet_resetExpansionState_() {
      var m = this.textMorph;
      if (m) {
        var _ref = this.expansionState || {},
            marker = _ref.marker,
            startAnchor = _ref.startAnchor,
            endAnchor = _ref.endAnchor,
            steps = _ref.steps;

        if (startAnchor) m.removeAnchor(startAnchor);
        if (endAnchor) m.removeAnchor(endAnchor);
        if (marker) m.removeMarker(marker);
        steps.forEach(function (_ref2) {
          var anchor = _ref2.anchor;
          return m.removeAnchor(anchor);
        });
      }
      this.expansionState = {
        stepIndex: -1,
        steps: [],
        isExpanding: false,
        startMarker: null,
        endMarker: null
      };
      m && m.removePlugin(this);
    }
  }, {
    key: "isExpanding",
    get: function get() {
      return this.expansionState.isExpanding;
    }
  }, {
    key: "createExpansionSteps",
    value: function Snippet_createExpansionSteps_(expansion) {
      var steps = [],
          matches = lively.lang.string.reMatches(expansion, /\$[0-9]+|\$\{[0-9]+:[^\}]*\}/g),
          offset = 0;
      matches.forEach(function (_ref3) {
        var start = _ref3.start,
            end = _ref3.end,
            match = _ref3.match;

        var n,
            prefill = "";
        if (match.startsWith("${")) {
          var _match$match = match.match(/^\$\{([0-9]+):([^\}]*)\}/),
              _match$match2 = slicedToArray(_match$match, 3),
              _ = _match$match2[0],
              nString = _match$match2[1],
              _prefill = _match$match2[2];

          n = Number(nString);
          prefill = _prefill;
        } else {
          n = Number(match.replace(/^\$/, ""));
        }
        expansion = expansion.slice(0, start - offset) + prefill + expansion.slice(end - offset);
        steps[n] = {
          index: start - offset,
          prefill: prefill,
          anchor: null
        };
        offset += end - start - prefill.length;
      });
      return {
        steps: steps,
        expansion: expansion
      };
    }
  }, {
    key: "expandAtCursor",
    value: function Snippet_expandAtCursor_(textMorph) {
      var m = textMorph,
          sel = m.selection,
          indent = m.cursorPosition.column,
          expansion = this.expansion;
      if (this.trigger) indent -= this.trigger.length;
      indent = Math.max(0, indent);
      if (indent) {
        var lines = lively_lang.string.lines(expansion);
        lines = [lines[0]].concat(toConsumableArray(lines.slice(1).map(function (line) {
          return lively_lang.string.indent(line, " ", indent);
        })));
        expansion = lines.join("\n");
      }

      var _createExpansionSteps = this.createExpansionSteps(expansion),
          expansion = _createExpansionSteps.expansion,
          steps = _createExpansionSteps.steps;

      if (this.trigger) sel.growLeft(this.trigger.length);
      sel.text = expansion;
      var start = sel.start,
          end = sel.end;

      sel.collapseToEnd();
      if (!steps.length) return;
      var id = lively_lang.string.newUUID();
      steps.forEach(function (step, i) {
        return step.anchor = m.addAnchor(Object.assign({ id: "snippet-step-" + i + "-" + id }, addIndexToTextPos(m, start, step.index)));
      });
      var startAnchor = m.addAnchor(Object.assign({ id: "snippet-start-" + id }, start, { insertBehavior: "stay" })),
          endAnchor = m.addAnchor(Object.assign({ id: "snippet-end-" + id }, end)),
          marker = m.addMarker({
        id: "snippet-marker-" + id,
        get range() {
          return {
            start: startAnchor.position,
            end: endAnchor.position
          };
        },
        style: {
          "border-radius": "4px",
          "background-color": "rgba(30, 200, 140, 0.3)",
          "box-shadow": "0 0 4px rgba(30, 200, 140, 0.3)",
          "pointer-events": "none",
          "content": "fooooo"
        }
      });
      this.expansionState = {
        marker: marker,
        startAnchor: startAnchor,
        endAnchor: endAnchor,
        stepIndex: 0,
        steps: steps,
        isExpanding: true
      };
      m.addPlugin(this);
      this.nextStep();
    }
  }, {
    key: "nextStep",
    value: function Snippet_nextStep_() {
      var _expansionState2 = this.expansionState,
          steps = _expansionState2.steps,
          stepIndex = _expansionState2.stepIndex,
          startAnchor = _expansionState2.startAnchor,
          isExpanding = _expansionState2.isExpanding,
          m = this.textMorph;

      if (!isExpanding || !m) return;
      var sel = m.selection;
      var _steps$stepIndex = steps[stepIndex],
          stepPosition = _steps$stepIndex.anchor.position,
          prefill = _steps$stepIndex.prefill;

      sel.lead = sel.anchor = stepPosition;
      sel.growRight(prefill.length);
      this.expansionState.stepIndex++;
      if (this.expansionState.stepIndex >= steps.length) {
        this.resetExpansionState();
        console.log("[snippet] expansion of " + this.expansion + " done");
      }
    }
  }, {
    key: "canExpand",
    value: function Snippet_canExpand_(text) {
      var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : text.cursorPosition;

      var triggerEnd = text.positionToIndex(text.cursorPosition),
          triggerStart = triggerEnd - this.trigger.length;
      return text.textString.slice(triggerStart, triggerEnd) === this.trigger;
    }
  }, {
    key: "tryTrigger",
    value: function Snippet_tryTrigger_(text) {
      var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : text.cursorPosition;

      if (!this.canExpand(text, position = text.cursorPosition)) return false;
      this.expandAtCursor(text);
      return true;
    }
  }, {
    key: "getCommands",
    value: function Snippet_getCommands_(commands) {
      var _this = this;

      return commands.concat([{
        name: "[snippet] next expansion step",
        exec: function exec(textMorph) {
          _this.nextStep();
          return true;
        }
      }, {
        name: "[snippet] cancel expansion",
        exec: function exec(textMorph) {
          _this.resetExpansionState();
          return true;
        }
      }]);
    }
  }, {
    key: "getKeyHandlers",
    value: function Snippet_getKeyHandlers_(handlers) {
      return handlers.concat(KeyHandler.withBindings([{
        keys: "Tab",
        command: "[snippet] next expansion step"
      }, {
        keys: "Escape",
        command: "[snippet] cancel expansion"
      }]));
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 331,
    end: 5939
  });
}(undefined);

var defaultTextStyle = {
  fontFamily: "Sans-Serif",
  fontSize: 12,
  fontColor: lively_graphics.Color.black,
  fontWeight: "normal",
  fontStyle: "normal",
  textDecoration: "none",
  backgroundColor: undefined,
  fixedCharacterSpacing: false,
  textStyleClasses: undefined,
  link: undefined,
  nativeCursor: undefined
};
var Text$1 = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("Text") && typeof __lively_classholder__.Text === "function" ? __lively_classholder__.Text : __lively_classholder__.Text = function Text$1(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function Text_initialize_() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var position = props.position,
          rightCenter = props.rightCenter,
          leftCenter = props.leftCenter,
          topCenter = props.topCenter,
          bottom = props.bottom,
          top = props.top,
          right = props.right,
          left = props.left,
          bottomCenter = props.bottomCenter,
          bottomLeft = props.bottomLeft,
          bottomRight = props.bottomRight,
          topRight = props.topRight,
          topLeft = props.topLeft,
          center = props.center;

      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, props);
      this.undoManager.reset();
      this.fit();
      this._needsFit = false;
      if (position !== undefined) this.position = position;
      if (rightCenter !== undefined) this.rightCenter = rightCenter;
      if (leftCenter !== undefined) this.leftCenter = leftCenter;
      if (topCenter !== undefined) this.topCenter = topCenter;
      if (bottom !== undefined) this.bottom = bottom;
      if (top !== undefined) this.top = top;
      if (right !== undefined) this.right = right;
      if (left !== undefined) this.left = left;
      if (bottomCenter !== undefined) this.bottomCenter = bottomCenter;
      if (bottomLeft !== undefined) this.bottomLeft = bottomLeft;
      if (bottomRight !== undefined) this.bottomRight = bottomRight;
      if (topRight !== undefined) this.topRight = topRight;
      if (topLeft !== undefined) this.topLeft = topLeft;
      if (center !== undefined) this.center = center;
    }
  }, {
    key: "__deserialize__",
    value: function Text___deserialize___(snapshot, objRef) {
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "__deserialize__", this).call(this, snapshot, objRef);
      this.textLayout = new TextLayout(this.env.fontMetric);
      this.textRenderer = defaultRenderer;
      this.changeDocument(TextDocument.fromString(""), true);
      this.ensureUndoManager();
      this.setDefaultTextStyle(defaultTextStyle);
    }
  }, {
    key: "__only_serialize__",
    get: function get() {
      var propNames = lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "__only_serialize__", this);
      return lively_lang.arr.withoutAll(propNames, ["document", "textLayout", "undoManager", "textRenderer", "textAttributes"]);
    }
  }, {
    key: "__additionally_serialize__",
    value: function Text___additionally_serialize___(snapshot, objRef) {
      snapshot.props.textAndAttributes = {
        key: "textAndAttributes",
        verbatim: true,
        value: this.textAndAttributes.map(function (_ref) {
          var _ref2 = slicedToArray(_ref, 2),
              text = _ref2[0],
              attrs = _ref2[1];

          return [text, attrs.map(function (ea) {
            return ea.data;
          })];
        })
      };
    }
  }, {
    key: "isText",
    get: function get() {
      return true;
    }
  }, {
    key: "onChange",
    value: function Text_onChange_(change) {
      var textChange = change.selector === "insertText" || change.selector === "deleteText";
      if (textChange || change.prop === "extent" && this.lineWrapping && this.isClip() || change.prop === "lineWrapping" && this.isClip() || change.prop === "fixedWidth" || change.prop === "fixedHeight" || change.prop === "fontFamily" || change.prop === "fontSize" || change.prop === "backgroundColor" || change.prop === "fontColor" || change.prop === "fontWeight" || change.prop === "fontStyle" || change.prop === "textDecoration" || change.prop === "fixedCharacterSpacing" || change.prop === "textStyleClasses") this.textLayout && (this.textLayout.layoutComputed = false);
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "onChange", this).call(this, change);
      textChange && lively_bindings.signal(this, "textChange", change);
    }
  }, {
    key: "rejectsInput",
    value: function Text_rejectsInput_() {
      return this.readOnly;
    }
  }, {
    key: "addAnchor",
    value: function Text_addAnchor_(anchor) {
      if (!anchor) return;
      if (typeof anchor === "string") {
        anchor = {
          id: anchor,
          row: 0,
          column: 0
        };
      }
      if (!anchor.isAnchor) {
        var _anchor = anchor,
            id = _anchor.id,
            column = _anchor.column,
            row = _anchor.row;

        anchor = new Anchor(id, row || column ? {
          row: row,
          column: column
        } : undefined, anchor.insertBehavior || "move");
      }
      var existing = anchor.id && this.anchors.find(function (ea) {
        return ea.id === anchor.id;
      });
      if (existing) return Object.assign(existing, anchor);
      this.anchors.push(anchor);
      return anchor;
    }
  }, {
    key: "removeAnchor",
    value: function Text_removeAnchor_(anchor) {
      this.anchors = this.anchors.filter(typeof anchor === "string" ? function (ea) {
        return ea.id !== anchor;
      } : function (ea) {
        return ea !== anchor;
      });
    }
  }, {
    key: "addMarker",
    value: function Text_addMarker_(marker) {
      this.removeMarker(marker.id);
      this.markers.push(marker);
      this.makeDirty();
      return marker;
    }
  }, {
    key: "removeMarker",
    value: function Text_removeMarker_(marker) {
      var id = typeof marker === "string" ? marker : marker.id;
      this.markers = this.markers.filter(function (ea) {
        return ea.id !== id;
      });
      this.makeDirty();
    }
  }, {
    key: "saveMark",
    value: function Text_saveMark_() {
      var p = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cursorPosition;
      var activate = arguments[1];

      var prevMark = this.activeMark;
      if (prevMark && prevMark !== p && !prevMark.equalsPosition(p)) this.savedMarks = this.savedMarks.concat(prevMark);
      if (activate) this.activeMark = p;else this.savedMarks = this.savedMarks.concat(p);
    }
  }, {
    key: "saveActiveMarkAndDeactivate",
    value: function Text_saveActiveMarkAndDeactivate_() {
      var m = this.activeMark;
      if (m) {
        this.saveMark(m);
        this.activeMark = null;
      }
    }
  }, {
    key: "popSavedMark",
    value: function Text_popSavedMark_() {
      var mark = this.activeMark;
      if (mark) {
        this.activeMark = null;
        return mark;
      }
      var last = lively_lang.arr.last(this.savedMarks);
      this.savedMarks = this.savedMarks.slice(0, -1);
      return last;
    }
  }, {
    key: "lastSavedMark",
    get: function get() {
      return this.activeMark || lively_lang.arr.last(this.savedMarks);
    }
  }, {
    key: "savedMarkForSelection",
    value: function Text_savedMarkForSelection_(replacement) {
      var sel = this.selection,
          savedMarks = this.savedMarks,
          multiRangeLength = this.multiSelect ? this.multiSelect.getAllRanges().length : 1,
          selIndex = sel.index || 0,
          markIndex = savedMarks.length - (multiRangeLength - selIndex),
          lastMark = savedMarks[markIndex] || sel.anchor;

      if (replacement && "row" in replacement && "column" in replacement) {
        this.savedMarks = savedMarks.slice(0, markIndex).concat(replacement).concat(savedMarks.slice(markIndex + 1));
      }
      return lastMark;
    }
  }, {
    key: "addPlugin",
    value: function Text_addPlugin_(plugin) {
      if (!this.plugins.includes(plugin)) {
        this.plugins.push(plugin);
        typeof plugin.attach === "function" && plugin.attach(this);
      }
      return plugin;
    }
  }, {
    key: "removePlugin",
    value: function Text_removePlugin_(plugin) {
      if (!this.plugins.includes(plugin)) return false;
      lively_lang.arr.remove(this.plugins, plugin);
      typeof plugin.detach === "function" && plugin.detach(this);
      return true;
    }
  }, {
    key: "pluginCollect",
    value: function Text_pluginCollect_(method) {
      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      this.plugins.forEach(function (p) {
        return typeof p[method] === "function" && (result = p[method](result));
      });
      return result;
    }
  }, {
    key: "pluginInvokeFirst",
    value: function Text_pluginInvokeFirst_(method) {
      var plugin = this.pluginFind(function (p) {
        return typeof p[method] === "function";
      });

      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return plugin ? plugin[method].apply(plugin, args) : undefined;
    }
  }, {
    key: "pluginFind",
    value: function Text_pluginFind_(iterator) {
      return this.plugins.slice().reverse().find(iterator);
    }
  }, {
    key: "textBounds",
    value: function Text_textBounds_() {
      return this.textLayout ? this.textLayout.textBounds(this) : this.padding.topLeft().extent(lively_graphics.pt(0, 0));
    }
  }, {
    key: "scrollExtent",
    get: function get() {
      return this.textBounds().extent().addPt(this.padding.topLeft()).addPt(this.padding.bottomRight()).maxPt(lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "scrollExtent", this));
    }
  }, {
    key: "commands",
    get: function get() {
      return this.pluginCollect("getCommands", (this._commands || []).concat(commands$$1));
    }
  }, {
    key: "execCommand",
    value: function Text_execCommand_(commandOrName, args, count, evt) {
      var _this = this;

      var _ref3 = this.lookupCommand(commandOrName) || {},
          name = _ref3.name,
          command = _ref3.command;

      if (!command) return undefined;
      var multiSelect = this.inMultiSelectMode(),
          multiSelectAction = command.hasOwnProperty("multiSelectAction") ? command.multiSelectAction : "forEach";
      if (multiSelect && multiSelectAction === "forEach") {
        var origSelection = this.selection,
            selections = this.selection.selections.slice().reverse();
        this.selection = selections[0];
        this._multiSelection = origSelection;
        try {
          var result = this.execCommand(commandOrName, args, count, evt);
        } catch (err) {
          this.selection = origSelection;
          this._multiSelection = null;
          this.selection.mergeSelections();
          throw err;
        }
        if (!result) return result;
        var results = [result];
        if (typeof result.then === "function" && typeof result.catch === "function") {
          return lively_lang.promise.finally(lively_lang.promise.chain([function () {
            return result;
          }].concat(selections.slice(1).map(function (sel) {
            return function () {
              _this.selection = sel;
              return Promise.resolve(_this.execCommand(commandOrName, args, count, evt)).then(function (result) {
                return results.push(result);
              });
            };
          }))).then(function () {
            return results;
          }), function () {
            _this.selection = origSelection;
            _this._multiSelection = null;
            _this.selection.mergeSelections();
          });
        } else {
          try {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = selections.slice(1)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var sel = _step.value;

                this.selection = sel;
                results.push(this.execCommand(commandOrName, args, count, evt));
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          } finally {
            this.selection = origSelection;
            this._multiSelection = null;
            this.selection.mergeSelections();
          }
          return results;
        }
      }
      var result = this.commandHandler.exec(commandOrName, this, args, count, evt);
      if (result) {
        if (typeof result.then === "function" && typeof result.catch === "function") result.then(function () {
          return cleanupScroll(_this);
        });else cleanupScroll(this);
      }
      return result;
      function cleanupScroll(morph$$1) {
        var scrollCursorIntoView = command.hasOwnProperty("scrollCursorIntoView") ? command.scrollCursorIntoView : true;
        if (scrollCursorIntoView) lively_lang.fun.throttleNamed("execCommand-scrollCursorIntoView-" + morph$$1.id, 100, function () {
          return morph$$1.scrollCursorIntoView();
        })();
      }
    }
  }, {
    key: "changeDocument",
    value: function Text_changeDocument_(doc) {
      var resetStyle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (this.document) var defaultTextStyle = this.defaultTextStyle;else resetStyle = false;
      this.document = doc;
      this.textLayout.reset();
      if (resetStyle) this.setDefaultTextStyle(defaultTextStyle);
      this.makeDirty();
    }
  }, {
    key: "textInRange",
    value: function Text_textInRange_(range) {
      return this.document.textInRange(range);
    }
  }, {
    key: "charRight",
    value: function Text_charRight_() {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cursorPosition,
          row = _ref4.row,
          column = _ref4.column;

      return this.getLine(row).slice(column, column + 1);
    }
  }, {
    key: "charLeft",
    value: function Text_charLeft_() {
      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cursorPosition,
          row = _ref5.row,
          column = _ref5.column;

      return this.getLine(row).slice(column - 1, column);
    }
  }, {
    key: "indexToPosition",
    value: function Text_indexToPosition_(index) {
      return this.document.indexToPosition(index);
    }
  }, {
    key: "positionToIndex",
    value: function Text_positionToIndex_(position) {
      return this.document.positionToIndex(position);
    }
  }, {
    key: "getVisibleLine",
    value: function Text_getVisibleLine_() {
      var row = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cursorScreenPosition.row;

      return this.textLayout.wrappedLines(this)[row].text;
    }
  }, {
    key: "isLineVisible",
    value: function Text_isLineVisible_() {
      var row = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cursorScreenPosition.row;

      return this.textLayout.isLineVisible(this, row);
    }
  }, {
    key: "isLineFullyVisible",
    value: function Text_isLineFullyVisible_() {
      var row = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cursorScreenPosition.row;

      return this.textLayout.isLineFullyVisible(this, row);
    }
  }, {
    key: "getLine",
    value: function Text_getLine_() {
      var row = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cursorPosition.row;

      var doc = this.document;
      return doc.getLine(row);
    }
  }, {
    key: "isLineEmpty",
    value: function Text_isLineEmpty_(row) {
      return !this.getLine(row).trim();
    }
  }, {
    key: "isAtLineEnd",
    value: function Text_isAtLineEnd_() {
      var pos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cursorPosition;

      var line = this.getLine(pos.row);
      return pos.column === line.length;
    }
  }, {
    key: "wordsOfLine",
    value: function Text_wordsOfLine_() {
      var row = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cursorPosition.row;

      return this.document.wordsOfLine(row);
    }
  }, {
    key: "wordAt",
    value: function Text_wordAt_() {
      var pos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cursorPosition;

      return this.document.wordAt(pos);
    }
  }, {
    key: "wordLeft",
    value: function Text_wordLeft_() {
      var pos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cursorPosition;

      return this.document.wordLeft(pos);
    }
  }, {
    key: "wordRight",
    value: function Text_wordRight_() {
      var pos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cursorPosition;

      return this.document.wordRight(pos);
    }
  }, {
    key: "lineRange",
    value: function Text_lineRange_() {
      var row = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cursorPosition.row;
      var ignoreLeadingWhitespace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (typeof row !== "number") this.cursorPosition.row;
      var line = this.getLine(row),
          range = {
        start: {
          column: 0,
          row: row
        },
        end: {
          column: line.length,
          row: row
        }
      },
          leadingSpace = line.match(/^\s*/);
      if (leadingSpace[0].length && ignoreLeadingWhitespace) range.start.column += leadingSpace[0].length;
      return new Range(range);
    }
  }, {
    key: "rangesOfWrappedLine",
    value: function Text_rangesOfWrappedLine_() {
      var row = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cursorPosition.row;

      return this.textLayout.rangesOfWrappedLine(this, row);
    }
  }, {
    key: "screenLineRange",
    value: function Text_screenLineRange_() {
      var pos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cursorPosition;
      var ignoreLeadingWhitespace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      var ranges = this.textLayout.rangesOfWrappedLine(this, pos.row),
          range = ranges.slice().reverse().find(function (_ref6) {
        var start = _ref6.start,
            end = _ref6.end;
        return start.column <= pos.column;
      }),
          content = this.textInRange(range),
          leadingSpace = content.match(/^\s*/);
      if (leadingSpace[0].length && ignoreLeadingWhitespace) range.start.column += leadingSpace[0].length;
      if (range !== lively_lang.arr.last(ranges)) range.end.column--;
      return new Range(range);
    }
  }, {
    key: "setTextWithTextAttributes",
    value: function Text_setTextWithTextAttributes_(text, attributes) {
      this.deleteText({
        start: {
          row: 0,
          column: 0
        },
        end: this.documentEndPosition
      });
      return this.insertTextWithTextAttributes(text, attributes, {
        row: 0,
        column: 0
      });
    }
  }, {
    key: "insertTextWithTextAttributes",
    value: function Text_insertTextWithTextAttributes_(text) {
      var _this2 = this;

      var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var pos = arguments[2];

      if (!Array.isArray(attributes)) attributes = [attributes];
      var range = this.insertText(text, pos);
      attributes.forEach(function (attr) {
        return _this2.addTextAttribute(attr, range);
      });
      return range;
    }
  }, {
    key: "insertTextAndSelect",
    value: function Text_insertTextAndSelect_(text) {
      var pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      text = String(text);
      if (pos) this.selection.range = this.insertText(text, pos);else this.selection.text = text;
    }
  }, {
    key: "append",
    value: function Text_append_(text) {
      var _this3 = this;

      return this.saveExcursion(function () {
        return _this3.insertText(text, _this3.documentEndPosition);
      });
    }
  }, {
    key: "insertText",
    value: function Text_insertText_(text) {
      var _this4 = this;

      var pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.cursorPosition;

      text = String(text);
      if (!text.length) return Range.fromPositions(pos, pos);
      var defaultStyleAttr = this.defaultTextStyleAttribute;
      if (lessPosition(defaultStyleAttr.end, pos)) {
        var prevEnd = defaultStyleAttr.end;
        lively_lang.arr.range(prevEnd.row + 1, pos.row).map(function (row) {
          var attrsOfLine = _this4.document._textAttributesByLine[row] || (_this4.document._textAttributesByLine[row] = []);
          if (!attrsOfLine.includes(defaultStyleAttr)) attrsOfLine.unshift(defaultStyleAttr);
        });
        this.defaultTextStyleAttribute.end = pos;
      }
      var range = this.document.insert(text, pos);
      this.textLayout.shiftLinesIfNeeded(this, range, "insertText");
      this.undoManager.undoStart(this, "insertText");
      this.addMethodCallChangeDoing({
        target: this,
        selector: "insertText",
        args: [text, pos],
        undo: {
          target: this,
          selector: "deleteText",
          args: [range]
        }
      }, function () {
        _this4._needsFit = true;
        _this4.anchors.forEach(function (ea) {
          return ea.onInsert(range);
        });
        if (_this4._multiSelection) _this4._multiSelection.updateFromAnchors();else _this4.selection.updateFromAnchors();
      });
      this.undoManager.undoStop();
      return new Range(range);
    }
  }, {
    key: "deleteText",
    value: function Text_deleteText_(range) {
      var _this5 = this;

      range = range.isRange ? range : new Range(range);
      if (range.isEmpty()) return;
      this.undoManager.undoStart(this, "deleteText");
      var doc = this.document,
          textLayout = this.textLayout,
          text = doc.textInRange(range);

      doc.remove(range);
      textLayout.shiftLinesIfNeeded(this, range, "deleteText");
      this._needsFit = true;
      this.addMethodCallChangeDoing({
        target: this,
        selector: "deleteText",
        args: [range],
        undo: {
          target: this,
          selector: "insertText",
          args: [text, range.start]
        }
      }, function () {
        _this5.anchors.forEach(function (ea) {
          return ea.onDelete(range);
        });
        if (_this5._multiSelection) _this5._multiSelection.updateFromAnchors();else _this5.selection.updateFromAnchors();
      });
      this.undoManager.undoStop();
      return text;
    }
  }, {
    key: "replace",
    value: function Text_replace_(range, text) {
      var undoGroup = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      if (undoGroup) this.undoManager.group();
      this.deleteText(range);
      var range = this.insertText(text, range.start);
      if (undoGroup) this.undoManager.group();
      return range;
    }
  }, {
    key: "modifyLines",
    value: function Text_modifyLines_(startRow, endRow, modifyFn) {
      var _this6 = this;

      var lines = lively_lang.arr.range(startRow, endRow).map(function (row) {
        return _this6.getLine(row);
      }),
          modifiedText = lines.map(modifyFn).join("\n") + "\n";
      this.deleteText({
        start: {
          row: startRow,
          column: 0
        },
        end: {
          row: endRow + 1,
          column: 0
        }
      });
      this.insertText(modifiedText, {
        row: startRow,
        column: 0
      });
    }
  }, {
    key: "modifySelectedLines",
    value: function Text_modifySelectedLines_(modifyFn) {
      var range = this.selection.isEmpty() ? this.lineRange(undefined, false) : this.selection.range;
      return this.modifyLines(range.start.row, range.end.row, modifyFn);
    }
  }, {
    key: "withLinesDo",
    value: function Text_withLinesDo_(startRow, endRow, doFunc) {
      var _this7 = this;

      return lively_lang.arr.range(startRow, endRow).map(function (row) {
        var line = _this7.getLine(row),
            range = Range.create(row, 0, row, line.length);
        return doFunc(line, range);
      });
    }
  }, {
    key: "withSelectedLinesDo",
    value: function Text_withSelectedLinesDo_(doFunc) {
      var range = this.selection.isEmpty() ? this.lineRange(undefined, false) : this.selection.range;
      var startRow = range.start.row,
          _range$end = range.end,
          endRow = _range$end.row,
          endColumn = _range$end.column;

      return this.withLinesDo(startRow, endColumn === 0 && endRow > startRow ? endRow - 1 : endRow, doFunc);
    }
  }, {
    key: "joinLine",
    value: function Text_joinLine_() {
      var row = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cursorPosition.row;

      var firstLine = this.getLine(row),
          otherLine = this.getLine(row + 1),
          joined = firstLine + otherLine.replace(/^\s+/, "") + this.document.constructor.newline;
      this.replace({
        start: {
          column: 0,
          row: row
        },
        end: {
          column: 0,
          row: row + 2
        }
      }, joined, true);
      return {
        row: row,
        column: firstLine.length
      };
    }
  }, {
    key: "whatsVisible",
    get: function get() {
      var startRow = this.textLayout.firstVisibleLine || 0,
          endRow = this.textLayout.lastVisibleLine,
          lines = this.lineWrapping ? this.textLayout.wrappedLines(this).slice(startRow, endRow).map(function (ea) {
        return ea.text;
      }) : this.document.lines.slice(startRow, endRow);
      return {
        lines: lines,
        startRow: startRow,
        endRow: endRow
      };
    }
  }, {
    key: "flash",
    value: function Text_flash_() {
      var _this8 = this;

      var range = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.selection.range;
      var options = arguments[1];

      options = Object.assign({
        time: 1000,
        fill: lively_graphics.Color.orange
      }, options);
      var id = options.id || "flash" + lively_lang.string.newUUID();
      this.addMarker({
        id: id,
        range: range,
        style: {
          "background-color": options.fill.toCSSString(),
          "pointer-events": "none"
        }
      });
      lively_lang.fun.debounceNamed("flash-" + id, options.time, function () {
        return _this8.removeMarker(id);
      })();
    }
  }, {
    key: "setSortedTextAttributes",
    value: function Text_setSortedTextAttributes_(attrs) {
      this.document.setSortedTextAttributes(attrs);
      this.onAttributesChanged();
    }
  }, {
    key: "addTextAttribute",
    value: function Text_addTextAttribute_(attr, range) {
      if (!attr.isTextAttribute) attr = TextStyleAttribute.isStyleData(attr) ? new TextStyleAttribute(attr) : new TextAttribute(attr);
      if (range) attr.range = range;
      var attr = this.document.addTextAttribute(attr);
      this.onAttributesChanged();
      return attr;
    }
  }, {
    key: "removeTextAttribute",
    value: function Text_removeTextAttribute_(attr) {
      this.document.removeTextAttribute(attr);
      this.onAttributesChanged();
    }
  }, {
    key: "textAttributesAt",
    value: function Text_textAttributesAt_(point) {
      var chunk = this.textLayout.chunkAtPoint(this, point);
      return chunk ? chunk.textAttributes : [];
    }
  }, {
    key: "textAttributesAtScreenPos",
    value: function Text_textAttributesAtScreenPos_(pos) {
      var chunk = this.textLayout.chunkAtScreenPos(this, pos);
      return chunk ? chunk.textAttributes : [];
    }
  }, {
    key: "resetTextAttributes",
    value: function Text_resetTextAttributes_() {
      this.document.resetTextAttributes();
      this.setDefaultTextStyle();
    }
  }, {
    key: "onAttributesChanged",
    value: function Text_onAttributesChanged_() {
      this._needsFit = true;
      this.textLayout && (this.textLayout.layoutComputed = false);
      this.makeDirty();
    }
  }, {
    key: "styleAt",
    value: function Text_styleAt_(point) {
      var chunk = this.textLayout.chunkAtPoint(this, point);
      return chunk ? chunk.style : Object.assign({}, this.defaultTextStyle);
    }
  }, {
    key: "styleAtScreenPos",
    value: function Text_styleAtScreenPos_(pos) {
      var chunk = this.textLayout.chunkAtScreenPos(this, pos);
      return chunk ? chunk.style : Object.assign({}, this.defaultTextStyle);
    }
  }, {
    key: "setDefaultTextStyle",
    value: function Text_setDefaultTextStyle_() {
      var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : lively_lang.obj.select(this, TextStyleAttribute.styleProps);

      var attr = this.defaultTextStyleAttribute;
      Object.assign(attr.data, style);
      this.onAttributesChanged();
      return attr;
    }
  }, {
    key: "getStyleInRange",
    value: function Text_getStyleInRange_() {
      var range = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.selection;

      var _document$stylesChunk = this.document.stylesChunked(range),
          _document$stylesChunk2 = slicedToArray(_document$stylesChunk, 1),
          _document$stylesChunk3 = slicedToArray(_document$stylesChunk2[0], 3),
          from = _document$stylesChunk3[0],
          to = _document$stylesChunk3[1],
          firstStyle = _document$stylesChunk3[2];

      return firstStyle;
    }
  }, {
    key: "setStyleInRange",
    value: function Text_setStyleInRange_(style) {
      var range = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selection;

      this.document.setStyleInRange(style, range, this.document._textAttributes[0]);
      this.onAttributesChanged();
    }
  }, {
    key: "resetStyleInRange",
    value: function Text_resetStyleInRange_() {
      var range = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.selection;

      this.setStyleInRange(this.defaultTextStyle, range);
    }
  }, {
    key: "inMultiSelectMode",
    value: function Text_inMultiSelectMode_() {
      return this.selection.selections && this.selection.selections.length > 1;
    }
  }, {
    key: "selectionBounds",
    value: function Text_selectionBounds_() {
      var _this9 = this;

      return this.selections.map(function (sel) {
        var start = _this9.charBoundsFromTextPosition(sel.start),
            end = _this9.charBoundsFromTextPosition(sel.end);
        return sel.start.row === sel.end.row ? start.union(end) : lively_graphics.rect(lively_graphics.pt(_this9.padding.left(), start.top()), lively_graphics.pt(_this9.width - _this9.padding.left(), end.bottom()));
      }).reduce(function (all, ea) {
        return ea.union(all);
      });
    }
  }, {
    key: "documentEndPosition",
    get: function get() {
      return this.document ? this.document.endPosition : {
        row: 0,
        column: 0
      };
    }
  }, {
    key: "isAtDocumentEnd",
    value: function Text_isAtDocumentEnd_() {
      return eqPosition(this.cursorPosition, this.documentEndPosition);
    }
  }, {
    key: "cursorUp",
    value: function Text_cursorUp_() {
      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

      return this.selection.goUp(n);
    }
  }, {
    key: "cursorDown",
    value: function Text_cursorDown_() {
      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

      return this.selection.goDown(n);
    }
  }, {
    key: "cursorLeft",
    value: function Text_cursorLeft_() {
      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

      return this.selection.goLeft(n);
    }
  }, {
    key: "cursorRight",
    value: function Text_cursorRight_() {
      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

      return this.selection.goRight(n);
    }
  }, {
    key: "getPositionAboveOrBelow",
    value: function Text_getPositionAboveOrBelow_() {
      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.cursorPosition;
      var useScreenPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var goalColumn = arguments[3];

      if (n === 0) return pos;
      if (!useScreenPosition) {
        if (goalColumn === undefined) goalColumn = pos.column;
        return {
          row: pos.row - n,
          column: Math.min(this.getLine(pos.row - n).length, goalColumn)
        };
      }
      var ranges = this.rangesOfWrappedLine(pos.row);
      if (!ranges.length) return pos;
      var currentRangeIndex = ranges.length - 1 - ranges.slice().reverse().findIndex(function (_ref7) {
        var start = _ref7.start,
            end = _ref7.end;
        return start.column <= pos.column;
      }),
          nextRange,
          nextRangeIsAtLineEnd = false;
      if (n >= 1) {
        var isFirst = 0 === currentRangeIndex;
        nextRange = isFirst ? lively_lang.arr.last(this.rangesOfWrappedLine(pos.row - 1)) : ranges[currentRangeIndex - 1];
        if (!nextRange) return pos;
        nextRangeIsAtLineEnd = isFirst;
      } else if (n <= -1) {
        var isLast = ranges.length - 1 === currentRangeIndex,
            nextRanges = isLast ? this.rangesOfWrappedLine(pos.row + 1) : ranges.slice(currentRangeIndex + 1);
        nextRange = nextRanges[0];
        if (!nextRange) return pos;
        nextRangeIsAtLineEnd = nextRanges.length === 1;
      }
      if (goalColumn === undefined) goalColumn = pos.column - ranges[currentRangeIndex].start.column;
      var columnOffset = Math.min(nextRange.end.column - nextRange.start.column, goalColumn),
          column = nextRange.start.column + columnOffset;
      if (!nextRangeIsAtLineEnd && column >= nextRange.end.column) column--;
      var newPos = {
        row: nextRange.end.row,
        column: column
      };
      return Math.abs(n) > 1 ? this.getPositionAboveOrBelow(n + (n > 1 ? -1 : 1), newPos, useScreenPosition, goalColumn) : newPos;
    }
  }, {
    key: "collapseSelection",
    value: function Text_collapseSelection_() {
      this.selection.collapse(this.selection.lead);
      return this.selection;
    }
  }, {
    key: "selectAll",
    value: function Text_selectAll_() {
      this.selection.selectAll();
      return this.selection;
    }
  }, {
    key: "selectLine",
    value: function Text_selectLine_() {
      var row = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cursorPosition.row;
      var includingLineEnd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      this.selection.selectLine(row, includingLineEnd);
      return this.selection;
    }
  }, {
    key: "selectionOrLineString",
    value: function Text_selectionOrLineString_() {
      var _selection = this.selection,
          text = _selection.text,
          start = _selection.start;

      return text ? text : this.getLine(start.row);
    }
  }, {
    key: "scrollCursorIntoView",
    value: function Text_scrollCursorIntoView_() {
      this.scrollPositionIntoView(this.cursorPosition);
    }
  }, {
    key: "centerRange",
    value: function Text_centerRange_() {
      var range = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.selection.range;
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : lively_graphics.pt(0, 0);
      var alignAtTopIfLarger = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      var t = this.charBoundsFromTextPosition(range.start).top(),
          b = this.charBoundsFromTextPosition(range.end).bottom(),
          height = b - t;
      if (height < this.height || alignAtTopIfLarger === false) {
        var centerY = t + height / 2;
        this.scroll = this.scroll.withY(centerY - this.height / 2).addPt(offset);
      } else {
        this.scroll = this.scroll.withY(t).addPt(offset);
      }
    }
  }, {
    key: "centerRow",
    value: function Text_centerRow_() {
      var row = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cursorPosition.row;
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : lively_graphics.pt(0, 0);

      return this.alignRowAtTop(row, offset.addXY(0, -this.height / 2));
    }
  }, {
    key: "alignRowAtTop",
    value: function Text_alignRowAtTop_() {
      var row = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cursorPosition.row;
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : lively_graphics.pt(0, 0);

      var charBounds = this.charBoundsFromTextPosition({
        row: row,
        column: 0
      }),
          pos = charBounds.topLeft().addXY(-this.padding.left(), 0);
      this.scroll = pos.addPt(offset);
    }
  }, {
    key: "scrollPositionIntoView",
    value: function Text_scrollPositionIntoView_(pos) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : lively_graphics.pt(0, 0);

      if (!this.isClip()) return;
      var scroll = this.scroll,
          padding = this.padding,
          paddedBounds = this.innerBounds().translatedBy(scroll),
          charBounds = this.charBoundsFromTextPosition(pos),
          charBounds = this.lineWrapping ? charBounds : charBounds.insetByPt(lively_graphics.pt(-20, 0)),
          delta = charBounds.topLeft().subPt(paddedBounds.translateForInclusion(charBounds).topLeft());

      this.scroll = this.scroll.addPt(delta).addPt(offset);
      if (this.isFocused()) this.ensureKeyInputHelperAtCursor();
    }
  }, {
    key: "keepPosAtSameScrollOffsetWhile",
    value: function Text_keepPosAtSameScrollOffsetWhile_(doFn) {
      var _this10 = this;

      var pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.cursorPosition;

      var scroll = this.scroll,
          pos = this.selection.lead,
          offset = this.charBoundsFromTextPosition(pos).y - scroll.y,
          isPromise = false,
          cleanup = function cleanup() {
        return _this10.scroll = _this10.scroll.withY(_this10.charBoundsFromTextPosition(pos).y - offset);
      };

      try {
        var result = doFn();
        isPromise = result && result instanceof Promise;
      } finally {
        !isPromise && cleanup();
      }
      if (isPromise) lively_lang.promise.finally(result, cleanup);
      return result;
    }
  }, {
    key: "saveExcursion",
    value: function Text_saveExcursion_(doFn, opts) {
      var _this11 = this;

      opts = Object.assign({ useAnchors: false }, opts);
      var sels = this.selection.isMultiSelection ? this.selection.selections.map(function (ea) {
        return ea.directedRange;
      }) : [this.selection],
          anchors = opts.useAnchors ? sels.map(function (_ref8) {
        var start = _ref8.start,
            end = _ref8.end;
        return [_this11.addAnchor(Object.assign({}, start, { id: "save-excursion-" + lively_lang.string.newUUID() })), _this11.addAnchor(Object.assign({}, end, { id: "save-excursion-" + lively_lang.string.newUUID() }))];
      }) : null,
          isPromise = false,
          cleanup = opts.useAnchors ? function () {
        var sels = anchors.map(function (_ref9) {
          var _ref10 = slicedToArray(_ref9, 2),
              start = _ref10[0].position,
              end = _ref10[1].position;

          return {
            start: start,
            end: end
          };
        });
        _this11.selections = sels;
        anchors.forEach(function (_ref11) {
          var _ref12 = slicedToArray(_ref11, 2),
              a = _ref12[0],
              b = _ref12[1];

          _this11.removeAnchor(a);
          _this11.removeAnchor(b);
        });
      } : function () {
        return _this11.selections = sels;
      };
      try {
        var result = this.keepPosAtSameScrollOffsetWhile(doFn);
        isPromise = result && result instanceof Promise;
      } finally {
        !isPromise && cleanup();
      }
      
      if (isPromise) lively_lang.promise.finally(result, cleanup);
      return result;
    }
  }, {
    key: "alignRow",
    value: function Text_alignRow_(row) {
      var how = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "center";

      if (!this.isClip()) return;
      var scroll = this.scroll,
          padding = this.padding,
          paddedBounds = this.innerBounds().insetByRect(padding).translatedBy(scroll),
          charBounds = this.charBoundsFromTextPosition({
        row: row,
        column: 0
      }),
          deltaY = how === "top" || how === "bottom" ? paddedBounds[how]() - charBounds[how]() : how === "center" ? paddedBounds[how]().y - charBounds[how]().y : 0;

      if (deltaY) this.scroll = this.scroll.addXY(0, -deltaY);
    }
  }, {
    key: "fit",
    value: function Text_fit_() {
      var fixedWidth = this.fixedWidth,
          fixedHeight = this.fixedHeight;

      if (fixedHeight && fixedWidth || !this.textLayout) return;
      var textBounds = this.textBounds().outsetByRect(this.padding);
      if (!fixedHeight) this.height = textBounds.height;
      if (!fixedWidth) this.width = textBounds.width;
      return this;
    }
  }, {
    key: "fitIfNeeded",
    value: function Text_fitIfNeeded_() {
      if (this._needsFit) {
        this.fit();
        this._needsFit = false;
      }
    }
  }, {
    key: "defaultLineHeight",
    get: function get() {
      var p = this.padding;
      return p.top() + p.bottom() + this.textLayout.fontMetric.defaultLineHeight({
        fontSize: this.fontSize,
        fontFamily: this.fontFamily
      });
    }
  }, {
    key: "textPositionFromPoint",
    value: function Text_textPositionFromPoint_(point) {
      return this.textLayout.screenToDocPos(this, this.screenPositionFromPoint(point));
    }
  }, {
    key: "screenPositionFromPoint",
    value: function Text_screenPositionFromPoint_(point) {
      return this.textLayout.screenPositionFor(this, point);
    }
  }, {
    key: "toScreenPosition",
    value: function Text_toScreenPosition_(documentPosition) {
      return this.textLayout.docToScreenPos(this, documentPosition);
    }
  }, {
    key: "toDocumentPosition",
    value: function Text_toDocumentPosition_(screenPosition) {
      return this.textLayout.screenToDocPos(this, screenPosition);
    }
  }, {
    key: "charBoundsFromTextPosition",
    value: function Text_charBoundsFromTextPosition_(pos) {
      return this.textLayout.boundsFor(this, pos);
    }
  }, {
    key: "forceRerender",
    value: function Text_forceRerender_() {
      this.textLayout.reset();
      this.makeDirty();
    }
  }, {
    key: "aboutToRender",
    value: function Text_aboutToRender_(renderer) {
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "aboutToRender", this).call(this, renderer);
      this.fitIfNeeded();
    }
  }, {
    key: "render",
    value: function Text_render_(renderer) {
      return this.textRenderer.renderMorph(renderer, this);
    }
  }, {
    key: "onMouseDown",
    value: function Text_onMouseDown_(evt) {
      if (evt.rightMouseButtonPressed()) return;
      this.activeMark && (this.activeMark = null);
      var position = evt.position,
          _evt$state = evt.state,
          clickedOnMorph = _evt$state.clickedOnMorph,
          clickedOnPosition = _evt$state.clickedOnPosition,
          clickCount = _evt$state.clickCount;

      if (clickedOnMorph !== this) return;
      var maxClicks = 3,
          normedClickCount = (clickCount - 1) % maxClicks + 1,
          clickPos = this.localize(position),
          clickTextPos = this.textPositionFromPoint(clickPos);
      if (evt.leftMouseButtonPressed() && !evt.isShiftDown() && !evt.isAltDown() && this.callTextAttributeDoitFromMouseEvent(evt, clickPos)) {}
      if (!this.selectable) return;
      if (evt.isShiftDown()) {
        this.selection.lead = clickTextPos;
      } else if (evt.isAltDown()) {
        this.selection.addRange(Range.at(clickTextPos));
      } else {
        this.selection.disableMultiSelect();
        if (normedClickCount === 1) {
          if (!evt.isShiftDown()) this.selection = {
            start: clickTextPos,
            end: clickTextPos
          };else this.selection.lead = clickTextPos;
        } else if (normedClickCount === 2) this.execCommand("select word", null, 1, evt);else if (normedClickCount === 3) this.execCommand("select line", null, 1, evt);
      }
      if (this.isFocused()) this.ensureKeyInputHelperAtCursor();
    }
  }, {
    key: "callTextAttributeDoitFromMouseEvent",
    value: function Text_callTextAttributeDoitFromMouseEvent_(evt, clickPos) {
      var _this12 = this;

      var attributes = this.textAttributesAt(clickPos) || [],
          doit;
      for (var i = attributes.length; i--;) {
        var ea = attributes[i];
        if (ea.data && ea.data.doit) {
          doit = ea.data.doit;
          break;
        }
      }
      if (!doit || !doit.code) return false;
      var moduleId = "lively://text-doit/" + this.id,
          mod = lively.modules.module(moduleId);
      mod.recorder.evt = evt;
      lively.vm.runEval(doit.code, {
        context: doit.context || this,
        format: "esm",
        targetModule: moduleId
      }).catch(function (err) {
        return _this12.world().logError(new Error("Error in text doit: " + err.stack));
      });
      return true;
    }
  }, {
    key: "onMouseMove",
    value: function Text_onMouseMove_(evt) {
      if (!evt.leftMouseButtonPressed() || !this.selectable || evt.state.clickedOnMorph !== this) return;
      this.selection.lead = this.textPositionFromPoint(this.localize(evt.position));
    }
  }, {
    key: "onContextMenu",
    value: function Text_onContextMenu_(evt) {
      var posClicked = this.textPositionFromPoint(this.localize(evt.position));
      var sels = this.selection.selections || [this.selection];
      if (this.selection.isEmpty() || sels.every(function (sel) {
        return !sel.range.containsPosition(posClicked);
      })) this.cursorPosition = posClicked;
      return lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "onContextMenu", this).call(this, evt);
    }
  }, {
    key: "menuItems",
    value: function Text_menuItems_() {
      var _this13 = this;

      var items = [["run command", function () {
        _this13.focus();
        _this13.world().execCommand("run command");
      }], {
        command: "text undo",
        alias: "undo",
        target: this,
        showKeyShortcuts: true
      }, {
        command: "text redo",
        alias: "redo",
        target: this,
        showKeyShortcuts: true
      }, {
        command: "manual clipboard copy",
        alias: "copy",
        target: this,
        showKeyShortcuts: this.keysForCommand("clipboard copy"),
        args: {
          collapseSelection: false,
          delete: false
        }
      }, {
        command: "manual clipboard paste",
        alias: "paste",
        target: this,
        showKeyShortcuts: this.keysForCommand("clipboard paste")
      }];
      return this.pluginCollect("getMenuItems", items);
    }
  }, {
    key: "keybindings",
    get: function get() {
      return this.pluginCollect("getKeyBindings", lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "keybindings", this).concat(config.text.defaultKeyBindings));
    }
  }, {
    key: "keybindings",
    set: function set(x) {
      lively.classes.runtime.initializeClass._set(Object.getPrototypeOf(__lively_class__.prototype), "keybindings", x, this);
    }
  }, {
    key: "keyhandlers",
    get: function get() {
      return this.pluginCollect("getKeyHandlers", lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "keyhandlers", this).concat(this._keyhandlers || []));
    }
  }, {
    key: "snippets",
    get: function get() {
      return this.pluginCollect("getSnippets", []).map(function (snippet) {
        if (snippet.isTextSnippet) return snippet;

        var _snippet = slicedToArray(snippet, 2),
            trigger = _snippet[0],
            expansion = _snippet[1];

        return new Snippet({
          trigger: trigger,
          expansion: expansion
        });
      });
    }
  }, {
    key: "onKeyDown",
    value: function Text_onKeyDown_(evt) {
      this.selection.cursorBlinkStart();
      KeyHandler.invokeKeyHandlers(this, evt, true);
    }
  }, {
    key: "onTextInput",
    value: function Text_onTextInput_(evt) {
      KeyHandler.invokeKeyHandlers(this, evt, false);
    }
  }, {
    key: "doSave",
    value: function Text_doSave_() {}
  }, {
    key: "onCut",
    value: function Text_onCut_(evt) {
      if (this.rejectsInput() || !this.isFocused()) return;
      if (config.emacs) return;
      this.onCopy(evt, !this.rejectsInput());
    }
  }, {
    key: "onCopy",
    value: function Text_onCopy_(evt) {
      var deleteCopiedText = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (!this.isFocused()) return;
      evt.stop();
      var sel = this.selection;
      evt.domEvt.clipboardData.setData("text", sel.text);
      this.execCommand("manual clipboard copy", {
        delete: deleteCopiedText,
        dontTryNativeClipboard: true
      });
    }
  }, {
    key: "onPaste",
    value: function Text_onPaste_(evt) {
      var _this14 = this;

      if (this.rejectsInput()) return;
      evt.stop();
      var data = evt.domEvt.clipboardData.getData("text");
      this.undoManager.group();
      var sel = this.selection,
          sels = sel.isMultiSelection ? sel.selections : [sel];
      sels.forEach(function (sel) {
        sel.text = data;
        _this14.saveMark(sel.start);
        sel.collapseToEnd();
      });
      this.undoManager.group();
    }
  }, {
    key: "onFocus",
    value: function Text_onFocus_(evt) {
      this.makeDirty();
      this.selection.cursorBlinkStart();
    }
  }, {
    key: "onScroll",
    value: function Text_onScroll_(evt) {
      if (this.isFocused()) this.ensureKeyInputHelperAtCursor();
    }
  }, {
    key: "ensureKeyInputHelperAtCursor",
    value: function Text_ensureKeyInputHelperAtCursor_() {
      if (this.env.eventDispatcher.keyInputHelper) this.env.eventDispatcher.keyInputHelper.ensureBeingAtCursorOfText(this);
    }
  }, {
    key: "onBlur",
    value: function Text_onBlur_(evt) {
      this.makeDirty();
      this.selection.cursorBlinkStop();
    }
  }, {
    key: "pageUpOrDown",
    value: function Text_pageUpOrDown_() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        direction: "up",
        select: false
      };
      var direction = opts.direction,
          select = opts.select;

      this[direction === "down" ? "scrollPageDown" : "scrollPageUp"]();
      var offset = lively_graphics.pt(0, (direction === "down" ? 1 : -1) * this.height),
          pos = this.textLayout.pixelPositionFor(this, this.cursorPosition).addPt(offset),
          textPos = this.textPositionFromPoint(pos);
      if (!opts || !opts.select) this.cursorPosition = textPos;else this.selection.lead = textPos;
    }
  }, {
    key: "gotoDocumentStart",
    value: function Text_gotoDocumentStart_() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { select: false };

      this.selection.lead = {
        row: 0,
        column: 0
      };
      if (!opts || !opts.select) this.selection.anchor = this.selection.lead;
    }
  }, {
    key: "gotoDocumentEnd",
    value: function Text_gotoDocumentEnd_() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { select: false };

      this.selection.lead = this.documentEndPosition;
      if (!opts || !opts.select) this.selection.anchor = this.selection.lead;
    }
  }, {
    key: "paragraphRangeAbove",
    value: function Text_paragraphRangeAbove_(row) {
      var startLineIsEmpty = this.isLineEmpty(row),
          rowInParagraph;
      if (startLineIsEmpty) {
        for (var i = row - 1; i >= 0; i--) {
          if (!this.isLineEmpty(i)) {
            rowInParagraph = i;
            break;
          }
        }if (rowInParagraph === undefined) return {
          start: {
            row: row,
            column: 0
          },
          end: {
            row: row,
            column: 0
          }
        };
      } else rowInParagraph = row;
      return this.paragraphRange(rowInParagraph);
    }
  }, {
    key: "paragraphRangeBelow",
    value: function Text_paragraphRangeBelow_(row) {
      var startLineIsEmpty = this.isLineEmpty(row),
          rowInParagraph,
          endPos = this.documentEndPosition;
      if (startLineIsEmpty) {
        for (var i = row + 1; i <= endPos.row; i++) {
          if (!this.isLineEmpty(i)) {
            rowInParagraph = i;
            break;
          }
        }if (rowInParagraph === undefined) return {
          start: {
            row: row,
            column: 0
          },
          end: {
            row: row,
            column: 0
          }
        };
      } else rowInParagraph = row;
      return this.paragraphRange(rowInParagraph);
    }
  }, {
    key: "paragraphRange",
    value: function Text_paragraphRange_(row) {
      if (this.isLineEmpty(row)) return {
        start: {
          row: row,
          column: 0
        },
        end: {
          row: row,
          column: 0
        }
      };
      var endPos = this.documentEndPosition,
          pragraphEnd;
      for (var i = row + 1; i <= endPos.row; i++) {
        if (this.isLineEmpty(i)) {
          pragraphEnd = {
            row: i - 1,
            column: this.getLine(i - 1).length
          };
          break;
        }
      }if (!pragraphEnd) pragraphEnd = endPos;
      var start;
      for (var i = pragraphEnd.row - 1; i >= 0; i--) {
        if (this.isLineEmpty(i)) {
          start = {
            row: i + 1,
            column: 0
          };
          break;
        }
      }if (!start) start = {
        row: 0,
        column: 0
      };
      return {
        start: start,
        end: pragraphEnd
      };
    }
  }, {
    key: "astNodeRange",
    value: function Text_astNodeRange_(node) {
      return {
        start: this.document.indexToPosition(node.start),
        end: this.document.indexToPosition(node.end)
      };
    }
  }, {
    key: "computeTextRangeForChanges",
    value: function Text_computeTextRangeForChanges_(changes) {
      if (!changes.length) return Range.at(this.cursorPosition);
      var change = changes[0],
          range = change.selector === "insertText" ? insertRange(change.args[0], change.args[1]) : change.selector === "deleteText" ? Range.at(change.args[0].start) : Range.at(this.cursorPosition);
      for (var i = 1; i < changes.length; i++) {
        var change = changes[i];
        range = change.selector === "deleteText" ? range.without(change.args[0]) : change.selector === "insertText" ? range.merge(insertRange(change.args[0], change.args[1])) : range;
      }
      return range;
      function insertRange(text, pos) {
        var lines = TextDocument.parseIntoLines(text),
            range;
        if (lines.length === 1) return Range.fromPositions(pos, {
          row: pos.row,
          column: pos.column + lines[0].length
        });
        if (lines.length > 1) return Range.fromPositions(pos, {
          row: pos.row + lines.length - 1,
          column: lively_lang.arr.last(lines).length
        });
        return Range.at(pos);
      }
    }
  }, {
    key: "ensureUndoManager",
    value: function Text_ensureUndoManager_() {
      if (this.undoManager) return this.undoManager;
      var filterFn = function filterFn(change) {
        return change.selector === "insertText" || change.selector === "deleteText";
      };
      return this.undoManager = new UndoManager(filterFn);
    }
  }, {
    key: "textUndo",
    value: function Text_textUndo_() {
      var undo = this.undoManager.undo();
      if (!undo) return;
      var changes = undo.changes.slice().reverse().map(function (ea) {
        return ea.undo;
      });
      this.selection = this.computeTextRangeForChanges(changes);
    }
  }, {
    key: "textRedo",
    value: function Text_textRedo_() {
      var redo = this.undoManager.redo();
      if (!redo) return;
      var changes = redo.changes.slice();
      this.selection = this.computeTextRangeForChanges(changes);
    }
  }, {
    key: "findMatchingForward",
    value: function Text_findMatchingForward_(pos) {
      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "right";
      var pairs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var openChar = this[side === "right" ? "charRight" : "charLeft"](pos),
          closeChar = pairs[openChar];
      if (!closeChar) return null;
      var counter = side === "right" ? -1 : 0;
      return this.document.scanForward(pos, function (char, pos) {
        if (char === closeChar) {
          if (counter === 0) return side === "right" ? {
            row: pos.row,
            column: pos.column + 1
          } : pos;else counter--;
        } else if (char === openChar) counter++;
        return null;
      });
    }
  }, {
    key: "findMatchingBackward",
    value: function Text_findMatchingBackward_(pos) {
      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "right";
      var pairs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var openChar = this[side === "right" ? "charRight" : "charLeft"](pos),
          closeChar = pairs[openChar];
      if (!closeChar) return null;
      var counter = side === "left" ? -1 : 0;
      return this.document.scanBackward(pos, function (char, pos) {
        if (char === closeChar) {
          if (counter === 0) return side === "right" ? {
            row: pos.row,
            column: pos.column + 1
          } : pos;else counter--;
        } else if (char === openChar) counter++;
        return null;
      });
    }
  }, {
    key: "search",
    value: function Text_search_(needle) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        start: this.cursorPosition,
        backwards: false,
        caseSensitive: false
      };

      return new TextSearcher(this).search(Object.assign({ needle: needle }, options));
    }
  }, {
    key: "searchForAll",
    value: function Text_searchForAll_(needle) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { caseSensitive: false };

      return new TextSearcher(this).searchForAll(Object.assign({ needle: needle }, options));
    }
  }, {
    key: "tokenAt",
    value: function Text_tokenAt_(pos) {
      return this.pluginInvokeFirst("tokenAt", pos);
    }
  }, {
    key: "astAt",
    value: function Text_astAt_(pos) {
      return this.pluginInvokeFirst("astAt", pos);
    }
  }, {
    key: "evalEnvironment",
    get: function get() {
      var p = this.pluginFind(function (p) {
        return p.isEditorPlugin;
      });
      return p && p.evalEnvironment;
    }
  }, {
    key: "evalEnvironment",
    set: function set(env) {
      var p = this.pluginFind(function (p) {
        return p.isEditorPlugin;
      });
      p && (p.evalEnvironment = env);
    }
  }, {
    key: "doitContext",
    get: function get() {
      var _ref13 = this.evalEnvironment || {},
          context = _ref13.context;

      return context;
    }
  }, {
    key: "doitContext",
    set: function set(c) {
      (this.evalEnvironment || {}).context = c;
    }
  }, {
    key: "exportToJSON",
    value: function Text_exportToJSON_(options) {
      return Object.assign(lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "exportToJSON", this).call(this, options), { textString: this.textString });
    }
  }, {
    key: "inspect",
    value: function Text_inspect_() {
      return "Text(\"" + this.name + "\" <" + this.selection + ">)";
    }
  }], [{
    key: "makeLabel",
    value: function Text_makeLabel_(value, props) {
      return morph$1(Object.assign({
        type: "label",
        value: value,
        fontFamily: "Helvetica Neue, Arial, sans-serif",
        fontColor: lively_graphics.Color.almostBlack,
        fontSize: 11
      }, props));
    }
  }, {
    key: "makeInputLine",
    value: function Text_makeInputLine_(props) {
      return new InputLine(props);
    }
  }, {
    key: "properties",
    get: function get() {
      return {
        fontMetric: {},
        textLayout: {
          after: ["fontMetric", "padding"],
          initialize: function initialize() {
            this.textLayout = new TextLayout(this.fontMetric || this.env.fontMetric);
          }
        },
        textRenderer: { defaultValue: defaultRenderer },
        document: {
          after: ["textLayout"],
          initialize: function initialize() {
            this.changeDocument(TextDocument.fromString(""), true);
          }
        },
        undoManager: {
          before: ["document"],
          initialize: function initialize() {
            this.ensureUndoManager();
          }
        },
        draggable: { defaultValue: false },
        useSoftTabs: { defaultValue: config.text.useSoftTabs !== undefined ? config.text.useSoftTabs : true },
        tabWidth: { defaultValue: config.text.tabWidth || 2 },
        tab: {
          after: ["useSoftTabs", "tabWidth"],
          readOnly: true,
          get: function get() {
            return this.useSoftTabs ? " ".repeat(this.tabWidth) : "\t";
          }
        },
        clipMode: {
          defaultValue: "visible",
          set: function set(value) {
            this.setProperty("clipMode", value);
            this.fixedWidth = this.fixedHeight = this.isClip();
          }
        },
        fixedWidth: {
          after: ["clipMode"],
          defaultValue: false,
          get: function get() {
            return this.getProperty("fixedWidth");
          },
          set: function set(value) {
            this.setProperty("fixedWidth", value);
            this._needsFit = true;
          }
        },
        fixedHeight: {
          after: ["clipMode"],
          defaultValue: false,
          get: function get() {
            return this.getProperty("fixedHeight");
          },
          set: function set(value) {
            this.setProperty("fixedHeight", value);
            this._needsFit = true;
          }
        },
        readOnly: {
          defaultValue: false,
          set: function set(value) {
            this.nativeCursor = value ? "default" : "auto";
            this.setProperty("readOnly", value);
          }
        },
        selectable: {
          after: ["selection"],
          defaultValue: true,
          set: function set(value) {
            this.setProperty("selectable", value);
            if (!value) this.selection.collapse();
          }
        },
        padding: {
          defaultValue: lively_graphics.Rectangle.inset(0),
          set: function set(value) {
            this.setProperty("padding", typeof value === "number" ? lively_graphics.Rectangle.inset(value) : value);
            this._needsFit = true;
          }
        },
        cursorScreenPosition: {
          derived: true,
          after: ["cursorPosition"],
          get: function get() {
            return this.toScreenPosition(this.cursorPosition);
          },
          set: function set(p) {
            return this.cursorPosition = this.toDocumentPosition(p);
          }
        },
        cursorPosition: {
          derived: true,
          after: ["selection"],
          get: function get() {
            return this.selection.lead;
          },
          set: function set(p) {
            this.selection.range = {
              start: p,
              end: p
            };
          }
        },
        selection: {
          after: ["textLayout", "document", "textString"],
          get: function get() {
            var sel = this.getProperty("selection");
            if (sel) return sel;
            sel = new (config.text.useMultiSelect ? MultiSelection : Selection)(this);
            this.setProperty("selection", sel);
            return sel;
          },
          set: function set(selOrRange) {
            if (!selOrRange) {
              if (this.selection.isMultiSelection) {
                this.selection.disableMultiSelect();
              }
              this.selection.collapse();
            } else if (selOrRange.isSelection) this.setProperty("selection", selOrRange);else this.selection.range = selOrRange;
          }
        },
        selections: {
          derived: true,
          after: ["selection"],
          get: function get() {
            return this.selection.isMultiSelection ? this.selection.selections : [this.selection];
          },
          set: function set(sels) {
            var _this15 = this;

            this.selection = sels[0];
            if (!this.selection.isMultiSelection) return;
            sels.slice(1).forEach(function (ea) {
              return _this15.selection.addRange(ea);
            });
          }
        },
        textString: {
          after: ["document"],
          derived: true,
          get: function get() {
            return this.document ? this.document.textString : "";
          },
          set: function set(value) {
            value = value ? String(value) : "";
            this.deleteText({
              start: {
                column: 0,
                row: 0
              },
              end: this.document.endPosition
            });
            this.insertText(value, {
              column: 0,
              row: 0
            });
          }
        },
        value: {
          after: ["textAttributes"],
          derived: true,
          get: function get() {
            var textAndAttributes = this.textAndAttributes;

            if (textAndAttributes.length === 1) {
              var _textAndAttributes$ = slicedToArray(textAndAttributes[0], 2),
                  text = _textAndAttributes$[0],
                  style = _textAndAttributes$[1];

              if (!Object.keys(style || {}).length) return text;
            }
            return textAndAttributes;
          },
          set: function set(value) {
            typeof value === "string" ? this.textString = value : this.textAndAttributes = value;
          }
        },
        textAttributes: {
          derived: true,
          after: ["document", "textString"],
          get: function get() {
            return this.document.textAttributes;
          },
          set: function set(attrs) {
            this.document.textAttributes = attrs;
            this.onAttributesChanged();
          }
        },
        textAndAttributes: {
          derived: true,
          after: ["document"],
          get: function get() {
            return this.document.textAndAttributes;
          },
          set: function set(textAndAttributes) {
            var _this16 = this;

            this.deleteText({
              start: {
                row: 0,
                column: 0
              },
              end: this.documentEndPosition
            });
            var rangesAndAttrs = textAndAttributes.map(function (_ref14) {
              var _ref15 = slicedToArray(_ref14, 2),
                  text = _ref15[0],
                  attrs = _ref15[1];

              return [_this16.insertText(text, _this16.documentEndPosition), attrs];
            });
            rangesAndAttrs.forEach(function (_ref16) {
              var _ref17 = slicedToArray(_ref16, 2),
                  range = _ref17[0],
                  attrs = _ref17[1];

              return (Array.isArray(attrs) ? attrs : [attrs]).forEach(function (attr) {
                return _this16.addTextAttribute(attr, range);
              });
            });
            return {
              start: {
                row: 0,
                column: 0
              },
              end: this.documentEndPosition
            };
          }
        },
        defaultTextStyleAttribute: {
          derived: true,
          after: ["textAttributes"],
          get: function get() {
            var attr = this.textAttributes.find(function (ea) {
              return ea.isStyleAttribute && (ea.start.row < 0 || ea.start.row === 0 && ea.start.column < 0);
            });
            if (!attr) attr = this.addTextAttribute(new TextStyleAttribute(Object.assign({}, defaultTextStyle), {
              start: {
                row: 0,
                column: -1
              },
              end: this.documentEndPosition
            }));
            return attr;
          }
        },
        defaultTextStyle: {
          after: ["defaultTextStyleAttribute"],
          initialize: function initialize() {
            this.defaultTextStyle = defaultTextStyle;
          },
          get: function get() {
            return this.defaultTextStyleAttribute.data;
          },
          set: function set(style) {
            this.setDefaultTextStyle(style);
          }
        },
        fontFamily: {
          derived: true,
          after: ["defaultTextStyle"],
          get: function get() {
            return this.defaultTextStyle.fontFamily;
          },
          set: function set(fontFamily) {
            this.setProperty("fontFamily", fontFamily);
            this.setDefaultTextStyle({ fontFamily: fontFamily });
          }
        },
        fontSize: {
          derived: true,
          after: ["defaultTextStyle"],
          get: function get() {
            return this.defaultTextStyle.fontSize;
          },
          set: function set(fontSize) {
            this.setProperty("fontSize", fontSize);
            this.setDefaultTextStyle({ fontSize: fontSize });
          }
        },
        selectionColor: {
          derived: true,
          after: ["defaultTextStyle"],
          get: function get() {
            return this.defaultTextStyle.selectionColor;
          },
          set: function set(selectionColor) {
            this.setProperty("selectionColor", selectionColor);
            this.setDefaultTextStyle({ selectionColor: selectionColor });
          }
        },
        fontColor: {
          derived: true,
          after: ["defaultTextStyle"],
          get: function get() {
            return this.defaultTextStyle.fontColor;
          },
          set: function set(fontColor) {
            this.setProperty("fontColor", fontColor);
            this.setDefaultTextStyle({ fontColor: fontColor });
          }
        },
        fontWeight: {
          derived: true,
          after: ["defaultTextStyle"],
          get: function get() {
            return this.defaultTextStyle.fontWeight;
          },
          set: function set(fontWeight) {
            this.setProperty("fontWeight", fontWeight);
            this.setDefaultTextStyle({ fontWeight: fontWeight });
          }
        },
        fontStyle: {
          derived: true,
          after: ["defaultTextStyle"],
          get: function get() {
            return this.defaultTextStyle.fontStyle;
          },
          set: function set(fontStyle) {
            this.setProperty("fontStyle", fontStyle);
            this.setDefaultTextStyle({ fontStyle: fontStyle });
          }
        },
        textDecoration: {
          derived: true,
          after: ["defaultTextStyle"],
          get: function get() {
            return this.defaultTextStyle.textDecoration;
          },
          set: function set(textDecoration) {
            this.setProperty("textDecoration", textDecoration);
            this.setDefaultTextStyle({ textDecoration: textDecoration });
          }
        },
        fixedCharacterSpacing: {
          derived: true,
          after: ["defaultTextStyle"],
          get: function get() {
            return this.defaultTextStyle.fixedCharacterSpacing;
          },
          set: function set(fixedCharacterSpacing) {
            this.setProperty("fixedCharacterSpacing", fixedCharacterSpacing);
            this.setDefaultTextStyle({ fixedCharacterSpacing: fixedCharacterSpacing });
          }
        },
        textStyleClasses: {
          derived: true,
          after: ["defaultTextStyle"],
          get: function get() {
            return this.defaultTextStyle.textStyleClasses;
          },
          set: function set(textStyleClasses) {
            this.setProperty("textStyleClasses", textStyleClasses);
            this.setDefaultTextStyle({ textStyleClasses: textStyleClasses });
          }
        },
        backgroundColor: {
          derived: true,
          after: ["defaultTextStyle"],
          get: function get() {
            return this.defaultTextStyle.backgroundColor;
          },
          set: function set(backgroundColor) {
            this.setProperty("backgroundColor", backgroundColor);
            this.setDefaultTextStyle({ backgroundColor: backgroundColor });
          }
        },
        lineWrapping: {
          after: ["textLayout", "document"],
          set: function set(lineWrapping) {
            this.setProperty("lineWrapping", lineWrapping);
            this.textLayout.updateFromMorphIfNecessary(this);
          }
        },
        anchors: { defaultValue: [] },
        markers: { defaultValue: [] },
        savedMarks: {
          defaultValue: [],
          after: ["anchors"],
          set: function set(val) {
            var _this17 = this;

            var savedMarks = this.savedMarks;
            val = val.map(function (ea) {
              return ea.isAnchor ? ea : _this17.addAnchor(Object.assign({}, ea, { id: "saved-mark-" + lively_lang.string.newUUID() }));
            });
            var toRemove = this.savedMarks.filter(function (ea) {
              return !val.includes(ea);
            });
            if (val > config.text.markStackSize) toRemove.push.apply(toRemove, toConsumableArray(val.splice(0, val.length - config.text.markStackSize)));
            toRemove.map(function (ea) {
              return _this17.removeAnchor(ea);
            });
            return this.setProperty("savedMarks", val);
          }
        },
        activeMarkPosition: {
          after: ["activeMark"],
          derived: true,
          get: function get() {
            var m = this.activeMark;
            return m ? m.position : null;
          }
        },
        activeMark: {
          after: ["anchors"],
          set: function set(val) {
            if (val) val = this.addAnchor(val.isAnchor ? val : Object.assign({}, val, { id: "saved-mark-" + lively_lang.string.newUUID() }));else {
              var m = this.activeMark;
              if (!this.savedMarks.includes(m)) this.removeAnchor(m);
            }
            this.setProperty("activeMark", val);
          }
        },
        plugins: {
          defaultValue: [],
          after: ["textAttributes", "value"],
          set: function set(plugins) {
            var _this18 = this;

            var prevPlugins = this.getProperty("plugins"),
                removed = lively_lang.arr.withoutAll(prevPlugins, plugins);
            removed.forEach(function (p) {
              return _this18.removePlugin(p);
            });
            plugins.forEach(function (p) {
              return _this18.addPlugin(p);
            });
          }
        }
      };
    }
  }], __lively_classholder__, undefined, {
    start: 1256,
    end: 58457
  });
}(Morph$1);

var diff$1 = vdom__default.diff;
var patch$1 = vdom__default.patch;
var h$1 = vdom__default.h;
var createElement = vdom__default.create;

var CustomVNode = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("CustomVNode") && typeof __lively_classholder__.CustomVNode === "function" ? __lively_classholder__.CustomVNode : __lively_classholder__.CustomVNode = function CustomVNode(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function CustomVNode_initialize_(morph$$1, renderer) {
      this.morph = morph$$1;
      this.renderer = renderer;
      this.morphVtree = null;
    }
  }, {
    key: "type",
    get: function get() {
      return "Widget";
    }
  }, {
    key: "renderMorph",
    value: function CustomVNode_renderMorph_() {
      var vtree = this.morphVtree = this.renderer.renderMorph(this.morph);
      var key = "customNode-key-" + this.morph.id;
      if (!vtree.children[0] || vtree.children[0].key !== key) vtree.children.unshift(h$1("div", { key: key }, []));
      return vtree;
    }
  }, {
    key: "init",
    value: function CustomVNode_init_() {
      var domNode = createElement(this.renderMorph(), this.renderer.domEnvironment);
      domNode.replaceChild(this.morph.domNode, domNode.childNodes[0]);
      return domNode;
    }
  }, {
    key: "update",
    value: function CustomVNode_update_(previous, domNode) {
      var oldTree = previous.morphVtree || this.renderMorph(),
          newTree = this.renderMorph(),
          patches = diff$1(oldTree, newTree);
      patch$1(domNode, patches);
      return null;
    }
  }, {
    key: "destroy",
    value: function CustomVNode_destroy_(domNode) {
      console.log("[HTMLMorph] node of " + this + " gets removed from DOM");
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 270,
    end: 1627
  });
}(undefined);
var HTMLMorph$$1 = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("HTMLMorph") && typeof __lively_classholder__.HTMLMorph === "function" ? __lively_classholder__.HTMLMorph : __lively_classholder__.HTMLMorph = function HTMLMorph$$1(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: "defaultHTML",
    get: function get() {
      return "\n<div style=\"display: flex;\n            align-items: center;\n            justify-content: center;\n            height: 100%;\n            background: -webkit-gradient(linear, 0% 0%, 0% 100%, color-stop(0%, rgba(242,243,244,1)),color-stop(100%, rgba(229,231,233,1)))\">\n  <p style=\"font: bold 40pt Inconsolata, monospace; color: lightgray;\">&lt;HTML&#x2F;&gt;</p>\n</div>";
    }
  }, {
    key: "render",
    value: function HTMLMorph_render_(renderer) {
      return new CustomVNode(this, renderer);
    }
  }], [{
    key: "properties",
    get: function get() {
      return {
        extent: { defaultValue: lively_graphics.pt(420, 330) },
        html: {
          initialize: function initialize() {
            this.html = this.defaultHTML;
          },
          get: function get() {
            return this.domNode.innerHTML;
          },
          set: function set(value) {
            this.domNode.innerHTML = value;
          }
        },
        domNode: {
          derived: true,
          get: function get() {
            if (!this._domNode) {
              this._domNode = this.document.createElement("div");
              this._domNode.setAttribute("style", "position: absolute; width: 100%; height: 100%;");
            }
            return this._domNode;
          },
          set: function set(node) {
            if (this.domNode.parentNode) {
              this.domNode.parentNode.replaceChild(node, this.domNode);
            }
            return this._domNode = node;
          }
        },
        document: {
          readOnly: true,
          get: function get() {
            return this.env.renderer.domEnvironment.document;
          }
        },
        scrollExtent: {
          readOnly: true,
          get: function get() {
            return lively_graphics.pt(this.domNode.scrollWidth, this.domNode.scrollHeight);
          }
        }
      };
    }
  }], __lively_classholder__, undefined, {
    start: 1952,
    end: 3543
  });
}(Morph$1);

var InputLine = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("InputLine") && typeof __lively_classholder__.InputLine === "function" ? __lively_classholder__.InputLine : __lively_classholder__.InputLine = function InputLine(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function InputLine_initialize_() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, props);
      lively_bindings.connect(this, "textChange", this, "onInputChanged");
      lively_bindings.connect(this, "selectionChange", this, "fixCursor");
    }
  }, {
    key: "isInputLine",
    get: function get() {
      return true;
    }
  }, {
    key: "allowDuplicatesInHistory",
    get: function get() {
      return false;
    }
  }, {
    key: "resetHistory",
    value: function InputLine_resetHistory_() {
      this.inputHistory = {
        items: [],
        max: 50,
        index: 0
      };
    }
  }, {
    key: "inputHistory",
    get: function get() {
      if (this._inputHistory) return this._inputHistory;
      return this._inputHistory = this.historyId ? this.constructor.getHistory(this.historyId) : {
        items: [],
        max: 30,
        index: 0
      };
    }
  }, {
    key: "inputHistory",
    set: function set(hist) {
      this._inputHistory = hist;
      this.historyId && this.constructor.setHistory(this.historyId, this._inputHistory);
    }
  }, {
    key: "clear",
    value: function InputLine_clear_() {
      this.input = "";
    }
  }, {
    key: "focus",
    value: function InputLine_focus_() {
      this.fixCursor();
      return lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "focus", this).call(this);
    }
  }, {
    key: "fixCursor",
    value: function InputLine_fixCursor_() {
      if (!this.label) return;
      var leadIndex = this.positionToIndex(this.selection.lead);
      if (leadIndex < this.label.length) this.selection.lead = this.indexToPosition(this.label.length);
      var anchorIndex = this.positionToIndex(this.selection.anchor);
      if (anchorIndex < this.label.length) this.selection.anchor = this.indexToPosition(this.label.length);
    }
  }, {
    key: "acceptInput",
    value: function InputLine_acceptInput_() {
      var i = this.input;
      this.onInput(i);
      return i;
    }
  }, {
    key: "onInput",
    value: function InputLine_onInput_(input) {
      if (this.input.length > 0) this.addInputToHistory(this.input);
      this.clearOnInput && this.clear();
      lively_bindings.signal(this, "inputAccepted", input);
    }
  }, {
    key: "onInputChanged",
    value: function InputLine_onInputChanged_(change) {
      lively_bindings.signal(this, "inputChanged", change);
    }
  }, {
    key: "addInputToHistory",
    value: function InputLine_addInputToHistory_(input) {
      var hist = this.inputHistory,
          items = hist.items;
      if (lively_lang.arr.last(items) === input) return;
      items.push(input);
      if (items.length > hist.max) {
        hist.items = items = items.slice(-hist.max);
      }
      hist.index = items.length - 1;
      if (!this.allowDuplicatesInHistory) {
        for (var i = hist.items.length - 1; i--;) {
          if (hist.items[i] === input) {
            hist.items.splice(i, 1);
            hist.index--;
          }
        }
      }
      this.historyId && this.constructor.addHistoryToLocalStorage(this.historyId, hist);
    }
  }, {
    key: "browseHistory",
    value: function () {
      var _ref = asyncToGenerator(regeneratorRuntime.mark(function _callee() {
        var items, _ref2, _ref2$selected, item;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                items = this.inputHistory.items.map(function (item, i) {
                  return {
                    isListItem: true,
                    string: item,
                    value: i
                  };
                }).reverse();
                _context.next = 3;
                return this.world().filterableListPrompt("Choose item:", items, { commands: [this.histEditCommandForHistBrowse()] });

              case 3:
                _ref2 = _context.sent;
                _ref2$selected = slicedToArray(_ref2.selected, 1);
                item = _ref2$selected[0];

                typeof item === "number" && this.setAndShowHistItem(item);
                this.focus();

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function InputLine_browseHistory_() {
        return _ref.apply(this, arguments);
      }

      return InputLine_browseHistory_;
    }()
  }, {
    key: "histEditCommandForHistBrowse",
    value: function InputLine_histEditCommandForHistBrowse_() {
      var _this = this;

      return {
        name: "edit history " + this.historyId,
        exec: function () {
          var _ref3 = asyncToGenerator(regeneratorRuntime.mark(function _callee2(prompt) {
            var items, _ref4, status, values;

            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    items = _this.inputHistory.items.slice().reverse();
                    _context2.next = 3;
                    return prompt.world().editListPrompt("edit history " + _this.historyId, items);

                  case 3:
                    _ref4 = _context2.sent;
                    status = _ref4.status;
                    values = _ref4.list;

                    if (!("canceled" === status)) {
                      _context2.next = 8;
                      break;
                    }

                    return _context2.abrupt("return", true);

                  case 8:
                    items = items.filter(function (ea) {
                      return ea.isListItem ? values.includes(ea.value) : values.includes(ea);
                    });
                    _this.inputHistory = Object.assign({}, _this.inputHistory, { items: items });
                    prompt.get("list").items = items.map(function (item, i) {
                      return {
                        isListItem: true,
                        string: item,
                        value: i
                      };
                    }).reverse();
                    return _context2.abrupt("return", true);

                  case 12:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, _this);
          }));

          return function exec(_x2) {
            return _ref3.apply(this, arguments);
          };
        }()
      };
    }
  }, {
    key: "setAndShowHistItem",
    value: function InputLine_setAndShowHistItem_(idx) {
      var hist = this.inputHistory,
          items = hist.items,
          len = items.length - 1,
          i = idx;
      if (!lively_lang.num.between(i, 0, len + 1)) hist.index = i = len;else hist.index = i;
      if (this.input !== items[i] && typeof items[i] !== "undefined") this.input = items[i];
    }
  }, {
    key: "showHistItem",
    value: function InputLine_showHistItem_(dir) {
      dir = dir || "next";
      var hist = this.inputHistory,
          items = hist.items,
          len = items.length - 1,
          i = hist.index;
      if (!lively_lang.num.between(i, 0, len + 1)) hist.index = i = len;
      if (this.input !== items[i] && typeof items[i] !== "undefined") {
        this.input = items[i];
        return;
      }
      if (dir === "next") {
        if (i > len) return;
        i = ++hist.index;
      } else {
        if (i <= 0) return;
        i = --hist.index;
      }
      this.input = items[i] || "";
    }
  }, {
    key: "commands",
    get: function get() {
      var _this2 = this;

      return [{
        name: "accept input",
        exec: function exec() {
          _this2.acceptInput();
          return true;
        }
      }, {
        name: "show previous input from history",
        exec: function exec() {
          _this2.showHistItem("prev");
          return true;
        }
      }, {
        name: "show next input from history",
        exec: function exec() {
          _this2.showHistItem("next");
          return true;
        }
      }, {
        name: "browse history",
        exec: function exec() {
          _this2.browseHistory();
          return true;
        }
      }, {
        name: "remove items from history",
        exec: function () {
          var _ref5 = asyncToGenerator(regeneratorRuntime.mark(function _callee3(inputLine) {
            var hist, items, _ref6, selected;

            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    hist = inputLine.inputHistory;
                    items = hist.items.map(function (item, i) {
                      return {
                        isListItem: true,
                        string: item,
                        value: i
                      };
                    }).reverse();
                    _context3.next = 4;
                    return inputLine.world().filterableListPrompt("Choose items to delete:", items, { multiSelect: true });

                  case 4:
                    _ref6 = _context3.sent;
                    selected = _ref6.selected;

                    lively_lang.arr.sort(selected).reverse().forEach(function (index) {
                      if (index < hist.index) hist.index--;
                      hist.items.splice(index, 1);
                    });
                    inputLine.inputHistory = hist;
                    return _context3.abrupt("return", true);

                  case 9:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, _this2);
          }));

          return function exec(_x3) {
            return _ref5.apply(this, arguments);
          };
        }()
      }].concat(lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "commands", this));
    }
  }, {
    key: "keybindings",
    get: function get() {
      return lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "keybindings", this).concat([{
        keys: "Enter",
        command: "accept input"
      }, {
        keys: {
          mac: "Meta-S",
          win: "Ctrl-S"
        },
        command: "accept input"
      }, {
        keys: "Up|Ctrl-Up|Alt-P",
        command: "show previous input from history"
      }, {
        keys: "Down|Ctrl-Down|Alt-N",
        command: "show next input from history"
      }, {
        keys: "Alt-H",
        command: "browse history"
      }, {
        keys: "Alt-Shift-H",
        command: "remove items from history"
      }]);
    }
  }], [{
    key: "getHistoryFromLocalSorage",
    value: function InputLine_getHistoryFromLocalSorage_(id) {
      if (typeof localStorage === "undefined") return null;
      try {
        var hist = localStorage.getItem("lively.morphic-inputline-" + id);
        return hist ? JSON.parse(hist) : null;
      } catch (e) {
        return null;
      }
    }
  }, {
    key: "addHistoryToLocalStorage",
    value: function InputLine_addHistoryToLocalStorage_(id, hist) {
      if (typeof localStorage === "undefined") return;
      try {
        localStorage.setItem("lively.morphic-inputline-" + id, JSON.stringify(hist));
      } catch (e) {
        console.error(e);
      }
    }
  }, {
    key: "histories",
    get: function get() {
      if (!this._histories) this._histories = new Map();
      return this._histories;
    }
  }, {
    key: "getHistory",
    value: function InputLine_getHistory_(id) {
      var hist = this.histories.get(id);
      if (hist) return hist;
      hist = this.getHistoryFromLocalSorage(id) || {
        items: [],
        max: 50,
        index: 0
      };
      this.histories.set(id, hist);
      return hist;
    }
  }, {
    key: "setHistory",
    value: function InputLine_setHistory_(id) {
      var hist = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        items: [],
        max: 50,
        index: 0
      };

      this.histories.set(id, hist);
      this.addHistoryToLocalStorage(id, hist);
      return hist;
    }
  }, {
    key: "properties",
    get: function get() {
      return {
        fixedWidth: { defaultValue: true },
        fixedHeight: { defaultValue: true },
        extent: { defaultValue: lively_graphics.pt(100, 20) },
        padding: { defaultValue: lively_graphics.Rectangle.inset(2, 4) },
        clipMode: { defaultValue: "hidden" },
        lineWrapping: { defaultValue: false },
        historyId: { defaultValue: null },
        clearOnInput: { defaultValue: false },
        height: {
          after: ["padding", "textAttributes"],
          initialize: function initialize() {
            this.height = this.defaultLineHeight + this.padding.top() + this.padding.bottom();
          }
        },
        label: {
          derived: true,
          after: ["textString"],
          defaultValue: "",
          set: function set(value) {
            lively_bindings.disconnect(this, "textChange", this, "onInputChanged");
            this.textString = value + this.input;
            lively_bindings.connect(this, "textChange", this, "onInputChanged");
            this.setProperty("label", value);
          }
        },
        input: {
          after: ["label"],
          derived: true,
          get: function get() {
            var input = this.textString;
            if (this.label && input.startsWith(this.label)) input = input.slice(this.label.length);
            return input;
          },
          set: function set(val) {
            this.textString = this.label + (val ? String(val) : "");
          }
        },
        placeholder: {
          after: ["submorphs", "textAttributes", "textString", "extent"],
          dervied: true,
          get: function get() {
            var placeholder = this.getSubmorphNamed("placeholder");
            return placeholder ? placeholder.value : null;
          },
          set: function set(val) {
            var _this3 = this;

            var placeholder = this.getSubmorphNamed("placeholder");
            if (!val) {
              if (placeholder) {
                placeholder.remove();
                placeholder = null;
              }
            } else {
              if (!placeholder) {
                placeholder = this.addMorph(Text$1.makeLabel(val, Object.assign({}, this.defaultTextStyle, {
                  name: "placeholder",
                  reactsToPointer: false,
                  fontColor: lively_graphics.Color.gray
                })));
                placeholder.onInputChange = function () {
                  placeholder.visible = !_this3.input.length;
                };
                placeholder.onLabelChange = function () {
                  var fm = _this3.env.fontMetric,
                      style = _this3.defaultTextStyle,
                      w = fm.sizeFor(style, _this3.label || "").width;
                  placeholder.leftCenter = _this3.leftCenter.addXY(w + _this3.padding.left(), 0);
                  if (_this3.wdith < placeholder.right) _this3.wdith = placeholder.right;
                };
                lively_bindings.connect(this, "inputChanged", placeholder, "onInputChange");
                lively_bindings.connect(this, "label", placeholder, "onLabelChange");
                placeholder.onInputChange();
                placeholder.onLabelChange();
              }
            }
          }
        }
      };
    }
  }], __lively_classholder__, undefined, {
    start: 292,
    end: 11273
  });
}(Text$1);
var PasswordInputLine = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("PasswordInputLine") && typeof __lively_classholder__.PasswordInputLine === "function" ? __lively_classholder__.PasswordInputLine : __lively_classholder__.PasswordInputLine = function PasswordInputLine(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function PasswordInputLine_initialize_() {
      var _this4 = this;

      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, opts);
      this.html = "<input style=\"height: calc(100% - 6px); width: calc(100% - 6px);\" type=\"password\" value=\"\">";
      this.ensureInputNode().then(function (node) {
        return node.onkeydown = function (evt) {
          return _this4.env.eventDispatcher.dispatchDOMEvent(evt, _this4, "onKeyDown");
        };
      });
    }
  }, {
    key: "inputNode",
    get: function get() {
      return this.domNode.childNodes[0];
    }
  }, {
    key: "ensureInputNode",
    value: function PasswordInputLine_ensureInputNode_() {
      var _this5 = this;

      return this.whenRendered().then(function () {
        return _this5.inputNode;
      });
    }
  }, {
    key: "input",
    get: function get() {
      return this.inputNode.value || "";
    }
  }, {
    key: "input",
    set: function set(val) {
      this.ensureInputNode().then(function (n) {
        return n.value = val;
      });
    }
  }, {
    key: "placeholder",
    get: function get() {
      return this.inputNode.placeholder;
    }
  }, {
    key: "placeholder",
    set: function set(val) {
      this.ensureInputNode().then(function (n) {
        return n.placeholder = val;
      });
    }
  }, {
    key: "focus",
    value: function PasswordInputLine_focus_() {
      this.ensureInputNode().then(function (n) {
        return n.focus();
      });
    }
  }, {
    key: "acceptInput",
    value: function PasswordInputLine_acceptInput_() {
      var i = this.input;
      lively_bindings.signal(this, "inputAccepted", i);
      
      return i;
    }
  }, {
    key: "onInputChanged",
    value: function PasswordInputLine_onInputChanged_(change) {
      lively_bindings.signal(this, "inputChanged", change);
    }
  }, {
    key: "commands",
    get: function get() {
      var _this6 = this;

      return [{
        name: "accept input",
        exec: function exec() {
          _this6.acceptInput();
          return true;
        }
      }].concat(lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "commands", this));
    }
  }, {
    key: "keybindings",
    get: function get() {
      return lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "keybindings", this).concat([{
        keys: "Enter",
        command: "accept input"
      }, {
        keys: {
          mac: "Meta-S",
          win: "Ctrl-S"
        },
        command: "accept input"
      }]);
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 11330,
    end: 12680
  });
}(HTMLMorph$$1);

var AbstractPrompt = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("AbstractPrompt") && typeof __lively_classholder__.AbstractPrompt === "function" ? __lively_classholder__.AbstractPrompt : __lively_classholder__.AbstractPrompt = function AbstractPrompt(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function AbstractPrompt_initialize_() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, Object.assign({
        fill: lively_graphics.Color.black.withA(0.6),
        extent: lively_graphics.pt(300, 80),
        borderRadius: 5,
        dropShadow: true
      }, lively_lang.obj.dissoc(props, ["label", "autoRemove", "commands", "keybindings"])));
      this.build(props);
      this.state = {
        answer: null,
        isActive: false,
        autoRemove: props.hasOwnProperty("autoRemove") ? props.autoRemove : true
      };
      if (props.commands) this.addCommands(props.commands);
      if (props.keybindings) this.addKeyBindings(props.keybindings);
    }
  }, {
    key: "isEpiMorph",
    get: function get() {
      return true;
    }
  }, {
    key: "isPrompt",
    get: function get() {
      return true;
    }
  }, {
    key: "label",
    get: function get() {
      return this.get("label").textString;
    }
  }, {
    key: "label",
    set: function set(label) {
      this.get("label").textString = label;
    }
  }, {
    key: "resolve",
    value: function AbstractPrompt_resolve_(arg) {
      this.state.answer.resolve(arg);
    }
  }, {
    key: "reject",
    value: function AbstractPrompt_reject_(reason) {
      this.state.answer.resolve(undefined);
    }
  }, {
    key: "activate",
    value: function () {
      var _ref = asyncToGenerator(regeneratorRuntime.mark(function _callee() {
        var _this = this;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.focus();
                this.state.answer = lively_lang.promise.deferred();
                this.state.isActive = true;
                lively_lang.promise.finally(this.state.answer.promise, function () {
                  return _this.state.isActive = false;
                });
                if (this.state.autoRemove) lively_lang.promise.finally(this.state.answer.promise, function () {
                  return _this.fadeOut(500);
                });
                return _context.abrupt("return", this.state.answer.promise);

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function AbstractPrompt_activate_() {
        return _ref.apply(this, arguments);
      }

      return AbstractPrompt_activate_;
    }()
  }, {
    key: "isActive",
    value: function AbstractPrompt_isActive_() {
      return !!this.world() && this.state.isActive;
    }
  }, {
    key: "build",
    value: function AbstractPrompt_build_() {
      throw new Error("Not yet implemented");
    }
  }, {
    key: "applyLayout",
    value: function AbstractPrompt_applyLayout_() {
      throw new Error("Not yet implemented");
    }
  }, {
    key: "onKeyDown",
    value: function AbstractPrompt_onKeyDown_(evt) {
      switch (evt.keyCombo) {
        case "Enter":
          this.resolve();
          evt.stop();
          break;
        case "Escape":
          this.reject();
          evt.stop();
          break;
        default:
          return lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "onKeyDown", this).call(this, evt);
      }
    }
  }, {
    key: "buttonStyle",
    get: function get() {
      return {
        type: "button",
        activeStyle: {
          borderWidth: 2,
          fill: lively_graphics.Color.transparent,
          fontColor: lively_graphics.Color.white,
          borderColor: lively_graphics.Color.white,
          fontStyle: "bold",
          nativeCursor: "pointer"
        }
      };
    }
  }, {
    key: "okButtonStyle",
    get: function get() {
      return {
        activeStyle: {
          borderWidth: 2,
          fill: lively_graphics.Color.transparent,
          borderColor: lively_graphics.Color.green.lighter(),
          fontColor: lively_graphics.Color.green.lighter(),
          fontStyle: "bold",
          nativeCursor: "pointer"
        }
      };
    }
  }, {
    key: "cancelButtonStyle",
    get: function get() {
      return {
        activeStyle: {
          borderWidth: 2,
          fill: lively_graphics.Color.transparent,
          borderColor: lively_graphics.Color.red.lighter(),
          fontColor: lively_graphics.Color.red.lighter(),
          fontStyle: "bold",
          nativeCursor: "pointer"
        }
      };
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 381,
    end: 2820
  });
}(lively_morphic.Morph);
var InformPrompt = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("InformPrompt") && typeof __lively_classholder__.InformPrompt === "function" ? __lively_classholder__.InformPrompt : __lively_classholder__.InformPrompt = function InformPrompt(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: "build",
    value: function InformPrompt_build_() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var label = props.label;

      this.addMorph({
        name: "label",
        type: "label",
        value: props.label,
        fill: null,
        padding: lively_graphics.Rectangle.inset(3),
        fontSize: 14,
        fontColor: lively_graphics.Color.gray
      });
      this.addMorph(Object.assign({
        name: "ok button",
        type: "button",
        label: "OK"
      }, this.okButtonStyle));
      lively_bindings.connect(this.get("ok button"), "fire", this, "resolve");
      this.initLayout();
    }
  }, {
    key: "initLayout",
    value: function InformPrompt_initLayout_() {
      var label = this.get("label");
      label.fit();
      this.width = label.width + 10;
      this.height = label.height + 30;
      var l = this.layout = new lively_morphic.GridLayout({
        grid: [["label", "label", "label"], [null, "ok button", null]]
      });
      l.col(2).paddingRight = 5;
      l.col(1).fixed = 100;
      l.col(0).paddingLeft = 5;
      l.row(1).paddingBottom = 5;
      l.row(1).fixed = 30;
    }
  }, {
    key: "onKeyDown",
    value: function InformPrompt_onKeyDown_(evt) {
      switch (evt.keyCombo) {
        case "Escape":
        case "Enter":
          this.resolve();
          evt.stop();
          break;
        default:
          return lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "onKeyDown", this).call(this, evt);
      }
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 2886,
    end: 3959
  });
}(AbstractPrompt);
var ConfirmPrompt = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("ConfirmPrompt") && typeof __lively_classholder__.ConfirmPrompt === "function" ? __lively_classholder__.ConfirmPrompt : __lively_classholder__.ConfirmPrompt = function ConfirmPrompt(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: "build",
    value: function ConfirmPrompt_build_(props) {
      this.addMorph({
        name: "label",
        type: "label",
        value: props.label,
        fill: null,
        padding: lively_graphics.Rectangle.inset(3),
        fontSize: 14,
        fontColor: lively_graphics.Color.gray
      });
      this.addMorph(Object.assign({
        name: "ok button",
        type: "button",
        label: "OK"
      }, this.okButtonStyle));
      this.addMorph(Object.assign({
        name: "cancel button",
        type: "button",
        label: "Cancel"
      }, this.cancelButtonStyle));
      lively_bindings.connect(this.get("ok button"), "fire", this, "resolve");
      lively_bindings.connect(this.get("cancel button"), "fire", this, "reject");
      this.initLayout();
    }
  }, {
    key: "resolve",
    value: function ConfirmPrompt_resolve_() {
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "resolve", this).call(this, true);
    }
  }, {
    key: "reject",
    value: function ConfirmPrompt_reject_() {
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "resolve", this).call(this, false);
    }
  }, {
    key: "initLayout",
    value: function ConfirmPrompt_initLayout_() {
      var label = this.get("label");
      label.fit();
      this.width = label.width + 10;
      this.height = label.height + 30;
      var l = this.layout = new lively_morphic.GridLayout({
        grid: [["label", "label", "label", "label"], [null, "ok button", "cancel button", null]]
      });
      l.col(0).paddingLeft = 5;
      l.col(1).paddingRight = 2.5;
      l.col(1).fixed = 60;
      l.col(2).fixed = 60;
      l.col(2).paddingLeft = 2.5;
      l.col(3).paddingRight = 5;
      l.row(1).paddingBottom = 5;
      l.row(1).fixed = 30;
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 3969,
    end: 5331
  });
}(AbstractPrompt);
var MultipleChoicePrompt = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("MultipleChoicePrompt") && typeof __lively_classholder__.MultipleChoicePrompt === "function" ? __lively_classholder__.MultipleChoicePrompt : __lively_classholder__.MultipleChoicePrompt = function MultipleChoicePrompt(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: "build",
    value: function MultipleChoicePrompt_build_() {
      var _this2 = this;

      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { choices: ["No choice"] };
      var label = props.label,
          choices = props.choices;

      if (label) this.addMorph({
        name: "label",
        type: "label",
        value: label,
        fill: null,
        padding: lively_graphics.Rectangle.inset(3),
        fontSize: 14,
        fontColor: lively_graphics.Color.gray
      });
      choices.forEach(function (choice, i) {
        var btn = _this2.addMorph(Object.assign({
          name: "button " + i,
          type: "button",
          padding: lively_graphics.Rectangle.inset(10, 8),
          label: choice
        }, _this2.okButtonStyle));
        btn.choice = choice;
        lively_bindings.connect(btn, "fire", _this2, "resolve", {
          converter: function converter() {
            return this.sourceObj.choice;
          }
        });
      });
      this.initLayout();
    }
  }, {
    key: "initLayout",
    value: function MultipleChoicePrompt_initLayout_() {
      var _this3 = this;

      var label = this.get("label");
      label && label.fit();
      var buttons = this.submorphs.filter(function (_ref2) {
        var isButton = _ref2.isButton;
        return isButton;
      });
      buttons.forEach(function (ea) {
        return ea.fit();
      });
      this.width = Math.max(label ? label.width + 10 : 0, buttons.reduce(function (width, ea) {
        return width + ea.width + 10;
      }, 0) + 20);
      var l = this.layout = new lively_morphic.GridLayout({
        fitToCell: false,
        grid: label ? [lively_lang.arr.withN(buttons.length, "label"), buttons.map(function (_ref3) {
          var name = _ref3.name;
          return name;
        })] : [buttons.map(function (_ref4) {
          var name = _ref4.name;
          return name;
        })]
      });
      buttons.forEach(function (b, i) {
        l.col(i).paddingLeft = 5;
        l.col(i).proportion = (b.width + 10) / (_this3.width - 20);
        l.col(i).paddingRight = 5;
      });
      l.row(1).paddingBottom = 5;
    }
  }, {
    key: "onKeyDown",
    value: function MultipleChoicePrompt_onKeyDown_(evt) {
      if (/^[0-9]$/.test(evt.keyCombo)) {
        var n = Number(evt.keyCombo) - 1;
        var btn = this.get("button " + n);
        if (btn) {
          btn.trigger();
          return evt.stop();
        }
      }
      return lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "onKeyDown", this).call(this, evt);
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 5341,
    end: 7172
  });
}(AbstractPrompt);
var TextPrompt = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("TextPrompt") && typeof __lively_classholder__.TextPrompt === "function" ? __lively_classholder__.TextPrompt : __lively_classholder__.TextPrompt = function TextPrompt(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: "maxWidth",
    get: function get() {
      return this.env.world.visibleBounds().width - 20;
    }
  }, {
    key: "build",
    value: function TextPrompt_build_(_ref5) {
      var label = _ref5.label,
          input = _ref5.input,
          historyId = _ref5.historyId,
          useLastInput = _ref5.useLastInput;

      this.addMorph({
        fill: null,
        padding: lively_graphics.Rectangle.inset(3),
        fontSize: 14,
        fontColor: lively_graphics.Color.gray,
        name: "label",
        type: "label",
        value: label
      });
      var inputLine = this.addMorph(lively_morphic.Text.makeInputLine({
        historyId: historyId,
        name: "input",
        textString: input || "",
        borderWidth: 0,
        borderRadius: 20,
        fill: lively_graphics.Color.rgbHex("#DDD"),
        fontSize: 14,
        fontColor: lively_graphics.Color.rgbHex("#666"),
        padding: lively_graphics.Rectangle.inset(10, 5)
      }));
      if (historyId && useLastInput) {
        var lastInput = lively_lang.arr.last(inputLine.inputHistory.items);
        if (lastInput) inputLine.textString = lastInput;
      }
      inputLine.gotoDocumentEnd();
      inputLine.scrollCursorIntoView();
      var inputWidth = inputLine.textBounds().width;
      if (inputWidth > this.width - 25) this.width = Math.min(this.maxWidth, inputWidth + 25);
      this.addMorph(Object.assign({
        name: "ok button",
        type: "button",
        label: "OK"
      }, this.okButtonStyle));
      this.addMorph(Object.assign({
        name: "cancel button",
        type: "button",
        label: "Cancel"
      }, this.cancelButtonStyle));
      lively_bindings.connect(this.get("ok button"), "fire", this, "resolve");
      lively_bindings.connect(this.get("cancel button"), "fire", this, "reject");
      this.initLayout();
    }
  }, {
    key: "resolve",
    value: function TextPrompt_resolve_() {
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "resolve", this).call(this, this.get("input").acceptInput());
    }
  }, {
    key: "initLayout",
    value: function TextPrompt_initLayout_() {
      var label = this.get("label"),
          input = this.get("input");
      label.fit();
      var goalWidth = Math.max(input.textBounds().width + 20, label.width);
      this.width = Math.min(this.maxWidth, goalWidth + 10);
      var l = this.layout = new lively_morphic.GridLayout({
        grid: [["label", "label", "label"], ["input", "input", "input"], [null, "ok button", "cancel button"]]
      });
      l.col(0).paddingLeft = 2.5;
      l.col(2).paddingRight = 2.5;
      l.col(2).fixed = 100;
      l.col(1).fixed = 100;
      l.row(2).paddingTop = 2.5;
      l.row(2).paddingBottom = 2.5;
    }
  }, {
    key: "focus",
    value: function TextPrompt_focus_() {
      this.get("input").focus();
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 7181,
    end: 9310
  });
}(AbstractPrompt);
var PasswordPrompt = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("PasswordPrompt") && typeof __lively_classholder__.PasswordPrompt === "function" ? __lively_classholder__.PasswordPrompt : __lively_classholder__.PasswordPrompt = function PasswordPrompt(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: "maxWidth",
    get: function get() {
      return 800;
    }
  }, {
    key: "build",
    value: function PasswordPrompt_build_(_ref6) {
      var label = _ref6.label,
          placeholder = _ref6.placeholder;

      this.addMorph({
        fill: null,
        padding: lively_graphics.Rectangle.inset(3),
        fontSize: 14,
        fontColor: lively_graphics.Color.gray,
        name: "label",
        type: "label",
        value: label
      });
      var passwordInput = this.addMorph(new PasswordInputLine({
        name: "input",
        placeholder: placeholder || "",
        borderWidth: 0
      }));
      this.addMorph(Object.assign({
        name: "ok button",
        type: "button",
        label: "OK"
      }, this.okButtonStyle));
      this.addMorph(Object.assign({
        name: "cancel button",
        type: "button",
        label: "Cancel"
      }, this.cancelButtonStyle));
      lively_bindings.connect(this.get("ok button"), "fire", this, "resolve");
      lively_bindings.connect(this.get("cancel button"), "fire", this, "reject");
      this.initLayout();
    }
  }, {
    key: "resolve",
    value: function PasswordPrompt_resolve_() {
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "resolve", this).call(this, this.get("input").acceptInput());
    }
  }, {
    key: "initLayout",
    value: function PasswordPrompt_initLayout_() {
      var l = this.layout = new lively_morphic.GridLayout({
        grid: [["label", "label", "label"], ["input", "input", "input"], [null, "ok button", "cancel button"]]
      });
      l.col(2).fixed = 100;
      l.col(1).fixed = 100;
      l.col(2).paddingRight = 5;
      l.col(2).paddingLeft = 2.5;
      l.col(0).paddingLeft = 5;
      l.col(0).paddingRight = 2.5;
      l.row(1).paddingBottom = 5;
      l.row(2).paddingBottom = 5;
    }
  }, {
    key: "focus",
    value: function PasswordPrompt_focus_() {
      this.get("input").focus();
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 9319,
    end: 10663
  });
}(AbstractPrompt);
var ListPrompt = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("ListPrompt") && typeof __lively_classholder__.ListPrompt === "function" ? __lively_classholder__.ListPrompt : __lively_classholder__.ListPrompt = function ListPrompt(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function ListPrompt_initialize_() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, lively_lang.obj.dissoc(props, ["preselect", "items", "onSelection"]));
      this.get("list").items = props.items || [];
      if (typeof props.preselect === "number") {
        this.get("list").selectedIndex = props.preselect;
        this.get("list").scrollSelectionIntoView();
      }
      if (typeof props.onSelection === "function") lively_bindings.connect(this.get("list"), "selection", props, "onSelection");
    }
  }, {
    key: "build",
    value: function ListPrompt_build_(_ref7) {
      var label = _ref7.label,
          listFontSize = _ref7.listFontSize,
          listFontFamily = _ref7.listFontFamily,
          labelFontSize = _ref7.labelFontSize,
          labelFontFamily = _ref7.labelFontFamily,
          filterable = _ref7.filterable,
          padding = _ref7.padding,
          itemPadding = _ref7.itemPadding,
          extent = _ref7.extent,
          multiSelect = _ref7.multiSelect,
          historyId = _ref7.historyId,
          useLastInput = _ref7.useLastInput,
          fuzzy = _ref7.fuzzy,
          filterFunction = _ref7.filterFunction,
          sortFunction = _ref7.sortFunction;

      this.extent = extent || lively_graphics.pt(500, 400);
      labelFontFamily = labelFontFamily || "Helvetica Neue, Arial, sans-serif";
      labelFontSize = labelFontSize || 15;
      listFontFamily = listFontFamily || "Inconsolata, monospace";
      listFontSize = listFontSize || labelFontSize;
      var labelProps = {
        name: "label",
        type: "label",
        value: label,
        fill: null,
        padding: lively_graphics.Rectangle.inset(3),
        fontSize: labelFontSize,
        fontFamily: labelFontFamily,
        fontColor: lively_graphics.Color.gray
      };
      this.addMorph(labelProps);
      var listProps = {
        name: "list",
        type: filterable ? FilterableList$$1 : List$$1,
        multiSelect: multiSelect,
        historyId: historyId,
        useLastInput: useLastInput,
        borderWidth: 0,
        borderColor: lively_graphics.Color.gray,
        fontSize: listFontSize,
        fontFamily: listFontFamily,
        padding: padding,
        itemPadding: itemPadding,
        theme: "dark"
      };
      if (filterable && fuzzy) listProps.fuzzy = fuzzy;
      if (filterable && typeof filterFunction === "function") listProps.filterFunction = filterFunction;
      if (filterable && typeof sortFunction === "function") listProps.sortFunction = sortFunction;
      this.addMorph(lively_morphic.morph(listProps));
      this.addMorph(Object.assign({
        name: "ok button",
        type: "button",
        label: "Select"
      }, this.okButtonStyle));
      this.addMorph(Object.assign({
        name: "cancel button",
        type: "button",
        label: "Cancel"
      }, this.cancelButtonStyle));
      lively_bindings.connect(this.get("ok button"), "fire", this, "resolve");
      lively_bindings.connect(this.get("cancel button"), "fire", this, "reject");
      this.initLayout();
    }
  }, {
    key: "initLayout",
    value: function ListPrompt_initLayout_() {
      var l = this.layout = new lively_morphic.GridLayout({
        grid: [["label", "label", "label"], ["list", "list", "list"], [null, "ok button", "cancel button"]]
      });
      l.row(0).fixed = 30;
      l.row(2).fixed = 30;
      l.row(2).paddingBottom = 5;
      l.col(0).paddingLeft = 5;
      l.col(1).fixed = 100;
      l.col(1).paddingRight = 5;
      l.row(1).paddingBottom = 10;
      l.col(2).fixed = 100;
      l.col(2).paddingRight = 5;
    }
  }, {
    key: "resolve",
    value: function ListPrompt_resolve_() {
      var answer = this.get("list") instanceof FilterableList$$1 ? this.get("list").acceptInput() : {
        selected: this.get("list").selections,
        status: "accepted"
      };
      return this.state.answer.resolve(answer);
    }
  }, {
    key: "reject",
    value: function ListPrompt_reject_() {
      return this.state.answer.resolve({
        prompt: this,
        selected: [],
        filtered: [],
        status: "canceled"
      });
    }
  }, {
    key: "focus",
    value: function ListPrompt_focus_() {
      this.get("list").focus();
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 10673,
    end: 13845
  });
}(AbstractPrompt);
var EditListPrompt = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("EditListPrompt") && typeof __lively_classholder__.EditListPrompt === "function" ? __lively_classholder__.EditListPrompt : __lively_classholder__.EditListPrompt = function EditListPrompt(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: "build",
    value: function EditListPrompt_build_(props) {
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "build", this).call(this, props);
      var addBtn = this.addMorph(Object.assign({ name: "add item button" }, this.buttonStyle, { label: Icon$$1.makeLabel("plus", { fontSize: 12 }) })),
          rmBtn = this.addMorph(Object.assign({ name: "remove item button" }, this.buttonStyle, { label: Icon$$1.makeLabel("minus", { fontSize: 12 }) }));
      lively_bindings.connect(addBtn, "fire", this, "addItemToList");
      lively_bindings.connect(rmBtn, "fire", this, "removeSelectedItemsFromList");
    }
  }, {
    key: "initLayout",
    value: function EditListPrompt_initLayout_() {
      var l = this.layout = new lively_morphic.GridLayout({
        autoAssign: false,
        grid: [["label", "label", "label", "label", "label"], ["list", "list", "list", "list", "list"], ["add item button", "remove item button", null, "ok button", "cancel button"]]
      });
      l.row(0).fixed = 30;
      l.row(1).fixed = undefined;
      l.row(2).fixed = 30;
      l.row(0).paddingTop = 5;
      l.row(0).paddingBottom = 5;
      l.row(1).paddingBottom = 2;
      l.row(2).paddingBottom = 5;
      l.col(0).paddingLeft = 5;
      l.col(0).paddingRight = 5;
      l.col(3).paddingRight = 5;
      l.col(4).paddingRight = 5;
    }
  }, {
    key: "removeSelectedItemsFromList",
    value: function () {
      var _ref8 = asyncToGenerator(regeneratorRuntime.mark(function _callee2() {
        var list, selectAfterwards;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                list = this.get("list"), selectAfterwards = list.selectedItems.length != 1 ? -1 : list.selectedIndex === 0 ? 0 : list.selectedIndex - 1;

                list.items = lively_lang.arr.withoutAll(list.items, list.selectedItems);
                if (selectAfterwards < 0) list.selection = null;else list.selectedIndex = selectAfterwards;
                list.focus();

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function EditListPrompt_removeSelectedItemsFromList_() {
        return _ref8.apply(this, arguments);
      }

      return EditListPrompt_removeSelectedItemsFromList_;
    }()
  }, {
    key: "addItemToList",
    value: function () {
      var _ref9 = asyncToGenerator(regeneratorRuntime.mark(function _callee3() {
        var list, input, toAdd, insertAt;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                list = this.get("list");
                input = list.selection ? list.items[list.selectedIndex].string : "";
                _context3.next = 4;
                return this.world().prompt("Input to add to the list", {
                  historyId: this.historyId || "EditListPrompt-input-history",
                  input: input
                });

              case 4:
                toAdd = _context3.sent;

                if (toAdd) {
                  _context3.next = 7;
                  break;
                }

                return _context3.abrupt("return");

              case 7:
                list = this.get("list"), insertAt = list.selection ? list.selectedIndex + 1 : list.items.length;

                list.addItemAt(toAdd, insertAt);
                list.focus();
                list.selectedIndex = insertAt;

              case 11:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function EditListPrompt_addItemToList_() {
        return _ref9.apply(this, arguments);
      }

      return EditListPrompt_addItemToList_;
    }()
  }, {
    key: "onKeyDown",
    value: function EditListPrompt_onKeyDown_(evt) {
      switch (evt.keyCombo) {
        case "Ctrl-G":
          this.get("list").selection = null;
          evt.stop();
          break;
        case "Shift-=":
        case "+":
          this.addItemToList();
          evt.stop();
          break;
        case "-":
        case "Delete":
        case "Backspace":
          this.removeSelectedItemsFromList();
          evt.stop();
          break;
      }
      return lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "onKeyDown", this).call(this, evt);
    }
  }, {
    key: "resolve",
    value: function EditListPrompt_resolve_() {
      var _get = this.get("list"),
          list = _get.values,
          selections = _get.selections;

      return this.state.answer.resolve({
        list: list,
        selections: selections
      });
    }
  }, {
    key: "reject",
    value: function EditListPrompt_reject_() {
      return this.state.answer.resolve({
        list: [],
        selections: [],
        status: "canceled"
      });
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 13855,
    end: 16548
  });
}(ListPrompt);

var _this = undefined;

var worldCommands = [{
  name: "undo",
  exec: function exec(world) {
    if (world.focusedMorph && world.focusedMorph !== world && world.focusedMorph.undoManager) return false;
    world.env.undoManager.undo();
    return true;
  }
}, {
  name: "redo",
  exec: function exec(world) {
    if (world.focusedMorph && world.focusedMorph !== world && world.focusedMorph.undoManager) return false;
    world.env.undoManager.redo();
    return true;
  }
}, {
  name: "run command",
  handlesCount: true,
  exec: function () {
    var _ref = asyncToGenerator(regeneratorRuntime.mark(function _callee(world, args, count) {
      var items, _ref2, prompt, _ref2$selected, cmd;

      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              items = KeyHandler.generateCommandToKeybindingMap(world.focusedMorph || world, true).map(function (ea) {
                var prettyKeys = ea.prettyKeys,
                    target = ea.target,
                    name = ea.command.name,
                    targetName = target.constructor.name,
                    keysPrinted = prettyKeys ? prettyKeys.join(", ") : "";

                return {
                  isListItem: true,
                  label: [["" + targetName, {
                    fontSize: "70%",
                    textStyleClasses: ["v-center-text"],
                    top: "-8%",
                    paddingRight: "10px"
                  }], ["" + name, {}]],
                  annotation: [keysPrinted, {
                    fontSize: "70%",
                    textStyleClasses: ["truncated-text"],
                    maxWidth: 140
                  }],
                  value: ea
                };
              });
              _context.next = 3;
              return world.filterableListPrompt("Run command", items, {
                historyId: "lively.morphic-run command",
                extent: lively_graphics.pt(700, 900),
                prompt: world._cachedRunCommandPrompt
              });

            case 3:
              _ref2 = _context.sent;
              prompt = _ref2.prompt;
              _ref2$selected = slicedToArray(_ref2.selected, 1);
              cmd = _ref2$selected[0];

              world._cachedRunCommandPrompt = prompt;
              return _context.abrupt("return", cmd ? cmd.target.execCommand(cmd.command, args, count) : true);

            case 9:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, _this);
    }));

    return function exec(_x, _x2, _x3) {
      return _ref.apply(this, arguments);
    };
  }()
}, {
  name: "show halo for focused morph",
  exec: function exec(world) {
    var morph$$1 = world.focusedMorph;
    world.showHaloFor(morph$$1.getWindow() || morph$$1, world.firstHand.pointerId);
    return true;
  }
}, {
  name: "select morph",
  exec: function () {
    var _ref3 = asyncToGenerator(regeneratorRuntime.mark(function _callee2(world) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        root: world,
        justReturn: false,
        filterFn: null,
        prependItems: [],
        prompt: null
      };

      var filterFn, i, items, _ref4, morphs;

      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              filterFn = opts.filterFn || function () {
                return true;
              };

              i = 0;
              items = lively_lang.arr.compact(lively_lang.tree.map(opts.root || world, function (m, depth) {
                return filterFn(m) ? {
                  isListItem: true,
                  string: ++i + " " + "  ".repeat(depth) + m,
                  value: m
                } : null;
              }, function (m) {
                return filterFn(m) ? m.submorphs : [];
              }));
              _context2.next = 5;
              return world.filterableListPrompt(opts.prompt || "Choose morph", (opts.prependItems || []).concat(items), {
                historyId: "lively.morphic-select morph",
                onSelection: function onSelection(sel) {
                  return sel && sel.show && sel.show();
                }
              });

            case 5:
              _ref4 = _context2.sent;
              morphs = _ref4.selected;

              if (!opts.justReturn) morphs[0] && world.showHaloFor(morphs[0]);
              return _context2.abrupt("return", morphs);

            case 9:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, _this);
    }));

    return function exec(_x4) {
      return _ref3.apply(this, arguments);
    };
  }()
}, {
  name: "escape",
  exec: function exec(world) {
    var eventState = world.env.eventDispatcher.eventState;
    if (eventState.menu) eventState.menu.remove();
    var halos = world.halos();
    halos.forEach(function (h$$1) {
      return h$$1.remove();
    });
    var focusTarget = lively_lang.arr.last(halos) && lively_lang.arr.last(halos).target || world.focusedMorph || world;
    focusTarget.focus();
    return false;
  }
}, {
  name: "move or resize halo target",
  exec: function exec(world) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      direction: "left",
      offset: 1,
      what: "move"
    };

    var halo = world.halos()[0];
    if (!halo) return false;
    var direction = opts.direction,
        offset = opts.offset,
        what = opts.what,
        t = halo.target;

    offset = offset || 1;
    switch (direction) {
      case "left":
        t[what === "move" ? "left" : "width"] -= offset;
        break;
      case "right":
        t[what === "move" ? "left" : "width"] += offset;
        break;
      case "up":
        t[what === "move" ? "top" : "height"] -= offset;
        break;
      case "down":
        t[what === "move" ? "top" : "height"] += offset;
        break;
    }
    halo.alignWithTarget();
    return true;
  }
}, {
  name: "resize to fit window",
  exec: function exec(world) {
    delete world._cachedWindowBounds;
    world.extent = world.windowBounds().extent();
    return true;
  }
}, {
  name: "window switcher",
  exec: function () {
    var _ref5 = asyncToGenerator(regeneratorRuntime.mark(function _callee3(world) {
      var p, wins, answer, _answer$selected, win;

      return regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              p = world.activePrompt();

              if (!(p && p.historyId === "lively.morphic-window switcher")) {
                _context3.next = 4;
                break;
              }

              p.focus();
              return _context3.abrupt("return", p.get("list").execCommand("select down"));

            case 4:
              wins = world.submorphs.filter(function (_ref6) {
                var isWindow = _ref6.isWindow;
                return isWindow;
              }).reverse().map(function (win) {
                return {
                  isListItem: true,
                  string: win.title || String(win),
                  value: win
                };
              });
              _context3.next = 7;
              return world.filterableListPrompt("Choose window", wins, {
                preselect: 1,
                historyId: "lively.morphic-window switcher",
                onSelection: function onSelection(sel) {
                  return sel && sel.show();
                },
                width: world.visibleBounds().extent().x * 1 / 3,
                labelFontSize: 16,
                listFontSize: 16,
                itemPadding: lively_graphics.Rectangle.inset(4)
              });

            case 7:
              answer = _context3.sent;
              _answer$selected = slicedToArray(answer.selected, 1);
              win = _answer$selected[0];

              win && win.activate();
              return _context3.abrupt("return", true);

            case 12:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, _this);
    }));

    return function exec(_x7) {
      return _ref5.apply(this, arguments);
    };
  }()
}, {
  name: "close active window or morph",
  exec: function exec(world) {
    var focused = world.focusedMorph;
    if (!focused) return true;
    var win = focused.getWindow();
    world.undoStart("window close");
    if (win) win.close();else {
      lively_lang.arr.last(lively_lang.arr.without(focused.ownerChain(), world)).remove();
      var win = world.activeWindow();
      win && win.activate();
    }
    world.undoStop("window close");
    return true;
  }
}, {
  name: "toggle minimize active window",
  exec: function exec(world) {
    var win = world.activeWindow();
    win && win.toggleMinimize();
    return true;
  }
}, {
  name: "open status message of focused morph",
  exec: function exec(world) {
    var focused = world.focusedMorph;

    var _ref7 = focused ? world.visibleStatusMessagesFor(focused) : [],
        _ref8 = slicedToArray(_ref7, 1),
        msg = _ref8[0];

    if (msg) {
      msg.expand();
      msg.focus();
    }
    return msg || true;
  }
}, {
  name: "resize active window",
  exec: function () {
    var _ref9 = asyncToGenerator(regeneratorRuntime.mark(function _callee5(world) {
      var askForHow = function () {
        var _ref10 = asyncToGenerator(regeneratorRuntime.mark(function _callee4() {
          var _ref11, _ref11$selected, how;

          return regeneratorRuntime.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  _context4.next = 2;
                  return world.filterableListPrompt("How to resize the window?", ["full", "fullscreen", "center", "right", "left", "bottom", "top", "shrinkWidth", "growWidth", "shrinkHeight", "growHeight", "col1", "col2", "col3", "col4", "col5", "reset"]);

                case 2:
                  _ref11 = _context4.sent;
                  _ref11$selected = slicedToArray(_ref11.selected, 1);
                  how = _ref11$selected[0];
                  return _context4.abrupt("return", how);

                case 6:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4, this);
        }));

        return function askForHow() {
          return _ref10.apply(this, arguments);
        };
      }();

      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        how: null,
        window: null
      };
      var window, how, win, worldB, winB, thirdWMin, thirdW, thirdColBounds, resizeBounds;
      return regeneratorRuntime.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              resizeBounds = function resizeBounds(how, bounds) {
                switch (how) {
                  case "full":
                  case "fullscreen":
                    return worldB;
                  case "col1":
                  case "left":
                    return thirdColBounds.withTopLeft(worldB.topLeft());
                  case "col2":
                    return thirdColBounds.withTopLeft(worldB.topCenter().scaleByPt(lively_graphics.pt(0.333, 1))).withWidth(thirdW);
                  case "col3":
                  case "center":
                    return thirdColBounds.withCenter(worldB.center());
                  case "col4":
                    return thirdColBounds.translatedBy(worldB.topCenter().withY(0));
                  case "col5":
                  case "right":
                    return thirdColBounds.translatedBy(lively_graphics.pt(worldB.width - thirdW, 0));
                  case "top":
                    return worldB.divide([lively_graphics.rect(0, 0, 1, 0.5)])[0];
                  case "bottom":
                    return worldB.divide([lively_graphics.rect(0, 0.5, 1, 0.5)])[0];
                  case "halftop":
                    return bounds.withY(worldB.top()).withHeight(bounds.height / 2);
                  case "halfbottom":
                    return bounds.withHeight(worldB.height / 2).withY(worldB.top() + worldB.height / 2);
                  case "reset":
                    return win.normalBounds || lively_graphics.pt(500, 400).extentAsRectangle().withCenter(bounds.center());
                  case "quadrant1":
                    return resizeBounds("halftop", resizeBounds("col1", bounds));
                  case "quadrant2":
                    return resizeBounds("halftop", resizeBounds("col2", bounds));
                  case "quadrant3":
                    return resizeBounds("halftop", resizeBounds("col3", bounds));
                  case "quadrant4":
                    return resizeBounds("halftop", resizeBounds("col4", bounds));
                  case "quadrant5":
                    return resizeBounds("halftop", resizeBounds("col5", bounds));
                  case "quadrant6":
                    return resizeBounds("halfbottom", resizeBounds("col1", bounds));
                  case "quadrant7":
                    return resizeBounds("halfbottom", resizeBounds("col2", bounds));
                  case "quadrant8":
                    return resizeBounds("halfbottom", resizeBounds("col3", bounds));
                  case "quadrant9":
                    return resizeBounds("halfbottom", resizeBounds("col4", bounds));
                  case "quadrant0":
                    return resizeBounds("halfbottom", resizeBounds("col5", bounds));
                  default:
                    return bounds;
                }
              };

              window = opts.window, how = opts.how, win = window || world.activeWindow();

              if (win) {
                _context5.next = 4;
                break;
              }

              return _context5.abrupt("return");

            case 4:
              worldB = world.visibleBounds().insetBy(20), winB = win.bounds();

              if (!win._normalBounds) win._normalBounds = winB;
              thirdWMin = 700, thirdW = Math.min(thirdWMin, Math.max(1000, worldB.width / 3)), thirdColBounds = worldB.withWidth(thirdW);

              if (how) {
                _context5.next = 11;
                break;
              }

              _context5.next = 10;
              return askForHow();

            case 10:
              how = _context5.sent;

            case 11:
              if (how) {
                _context5.next = 13;
                break;
              }

              return _context5.abrupt("return");

            case 13:
              if (how === "reset") delete win.normalBounds;
              win.setBounds(resizeBounds(how, how.startsWith("half") ? winB : worldB));
              return _context5.abrupt("return", true);

            case 16:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));

    function exec(_x8) {
      return _ref9.apply(this, arguments);
    }

    return exec;
  }()
}, {
  name: "open workspace",
  exec: function () {
    var _ref12 = asyncToGenerator(regeneratorRuntime.mark(function _callee6(world, opts) {
      var workspaceModules, _ref13, Workspace;

      return regeneratorRuntime.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              opts = Object.assign({
                content: "",
                language: "javascript"
              }, opts);
              workspaceModules = {
                "javascript": "lively.morphic/ide/js/workspace.js",

                get "js"() {
                  return this["javascript"];
                },
                "shell": "lively.morphic/ide/shell/workspace.js"
              };
              _context6.next = 4;
              return System.import(workspaceModules[opts.language]);

            case 4:
              _ref13 = _context6.sent;
              Workspace = _ref13.default;
              return _context6.abrupt("return", new Workspace({
                center: world.center,
                content: opts.content
              }).activate());

            case 7:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, _this);
    }));

    return function exec(_x10, _x11) {
      return _ref12.apply(this, arguments);
    };
  }()
}, {
  name: "open shell workspace",
  exec: function exec(world, opts) {
    return world.execCommand("open workspace", Object.assign({}, opts, { language: "shell" }));
  }
}, {
  name: "open shell terminal",
  exec: function () {
    var _ref14 = asyncToGenerator(regeneratorRuntime.mark(function _callee7(world, opts) {
      var _ref15, Terminal;

      return regeneratorRuntime.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              _context7.next = 2;
              return System.import("lively.morphic/ide/shell/terminal.js");

            case 2:
              _ref15 = _context7.sent;
              Terminal = _ref15.default;
              return _context7.abrupt("return", Terminal.open(opts).openInWorldNearHand());

            case 5:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, _this);
    }));

    return function exec(_x12, _x13) {
      return _ref14.apply(this, arguments);
    };
  }()
}, {
  name: "open text window",
  exec: function exec(world) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var title = opts.title,
        extent = opts.extent,
        content = opts.content,
        mode = opts.mode,
        name = opts.name;

    title = title || "text window";
    content = content || "";
    extent = extent || lively_graphics.pt(500, 400);
    name = name || "text workspace";
    return world.openInWindow(new Text$1(Object.assign({ padding: lively_graphics.Rectangle.inset(3) }, lively_lang.obj.dissoc(opts, ["title", "content"]), {
      textString: content,
      clipMode: "auto",
      name: name,
      extent: extent
    })), { title: title }).activate();
  }
}, {
  name: "diff and open in window",
  exec: function () {
    var _ref16 = asyncToGenerator(regeneratorRuntime.mark(function _callee9(world) {
      var diffInWindow = function () {
        var _ref17 = asyncToGenerator(regeneratorRuntime.mark(function _callee8(a, b, opts) {
          var format, plugin, content, headerA, headerB, filenameA, filenameB, context, _ref18, DiffEditorPlugin, win, textMorph;

          return regeneratorRuntime.wrap(function _callee8$(_context8) {
            while (1) {
              switch (_context8.prev = _context8.next) {
                case 0:
                  format = opts.format;
                  plugin = null;

                  if (!(format === "patch")) {
                    _context8.next = 12;
                    break;
                  }

                  headerA = opts.headerA, headerB = opts.headerB, filenameA = opts.filenameA, filenameB = opts.filenameB, context = opts.context;
                  content = [[diff$$1.createTwoFilesPatch(filenameA || "a", filenameB || "b", a, b, headerA, headerB, typeof context === "number" ? { context: context } : undefined), {}]];
                  _context8.next = 7;
                  return System.import("lively.morphic/ide/diff/editor-plugin.js");

                case 7:
                  _ref18 = _context8.sent;
                  DiffEditorPlugin = _ref18.DiffEditorPlugin;

                  plugin = new DiffEditorPlugin();
                  _context8.next = 14;
                  break;

                case 12:
                  diffed = diff$$1[format](a, b, opts);
                  content = diffed.map(function (_ref19) {
                    var count = _ref19.count,
                        value = _ref19.value,
                        added = _ref19.added,
                        removed = _ref19.removed;

                    var attribute = removed ? {
                      fontWeight: "normal",
                      textDecoration: "line-through",
                      fontColor: lively_graphics.Color.red
                    } : added ? {
                      fontWeight: "bold",
                      textDecoration: "",
                      fontColor: lively_graphics.Color.green
                    } : {
                      fontWeight: "normal",
                      textDecoration: "",
                      fontColor: lively_graphics.Color.darkGray
                    };
                    return [value, attribute];
                  });

                case 14:
                  win = world.execCommand("open text window", opts), textMorph = win.targetMorph;

                  win.extent = lively_graphics.pt(300, 200).maxPt(textMorph.textBounds().extent());
                  textMorph.textAndAttributes = content;
                  if (plugin) textMorph.addPlugin(plugin);
                  return _context8.abrupt("return", textMorph);

                case 19:
                case "end":
                  return _context8.stop();
              }
            }
          }, _callee8, this);
        }));

        return function diffInWindow(_x17, _x18, _x19) {
          return _ref17.apply(this, arguments);
        };
      }();

      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        a: "",
        b: "",
        format: null,
        extent: lively_graphics.pt(500, 600)
      };

      var a, b, format, _findFormat, diff$$1, diffed, findFormat;

      return regeneratorRuntime.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              findFormat = function findFormat(a, b) {
                if (lively_lang.obj.isPrimitive(a) || a instanceof RegExp || lively_lang.obj.isPrimitive(b) || b instanceof RegExp) {
                  a = String(a);
                  b = String(b);
                }
                if (typeof a !== "string" || typeof b !== "string") try {
                  JSON.stringify(a);
                  JSON.stringify(b);
                  return {
                    format: "diffJson",
                    a: a,
                    b: b
                  };
                } catch (e) {
                  a = String(a);
                  b = String(b);
                }
                return {
                  format: "diffLines",
                  a: a,
                  b: b
                };
              };

              a = opts.a, b = opts.b, format = opts.format;

              if (!format) _findFormat = findFormat(a, b), a = _findFormat.a, b = _findFormat.b, format = _findFormat.format;else {
                a = String(a);
                b = String(b);
              }
              _context9.next = 5;
              return System.import("https://cdnjs.cloudflare.com/ajax/libs/jsdiff/3.0.0/diff.js");

            case 5:
              diff$$1 = _context9.sent;
              _context9.next = 8;
              return diffInWindow(a, b, Object.assign({ fontFamily: "monospace" }, opts, { format: format }));

            case 8:
              diffed = _context9.sent;
              return _context9.abrupt("return", diffed);

            case 10:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9, _this);
    }));

    return function exec(_x15) {
      return _ref16.apply(this, arguments);
    };
  }()
}, {
  name: "diff workspaces",
  exec: function () {
    var _ref20 = asyncToGenerator(regeneratorRuntime.mark(function _callee11(world) {
      var selectMorph = function () {
        var _ref21 = asyncToGenerator(regeneratorRuntime.mark(function _callee10(morphs, thenDo) {
          var candidates, _ref22, _ref22$selected, choice;

          return regeneratorRuntime.wrap(function _callee10$(_context10) {
            while (1) {
              switch (_context10.prev = _context10.next) {
                case 0:
                  candidates = morphs.map(function (ea) {
                    return {
                      isListItem: true,
                      value: ea,
                      string: ea.name || String(ea)
                    };
                  });
                  _context10.next = 3;
                  return world.filterableListPrompt("choose text: ", candidates, { onSelection: function onSelection(m) {
                      return m && m.show();
                    } });

                case 3:
                  _ref22 = _context10.sent;
                  _ref22$selected = slicedToArray(_ref22.selected, 1);
                  choice = _ref22$selected[0];
                  return _context10.abrupt("return", choice);

                case 7:
                case "end":
                  return _context10.stop();
              }
            }
          }, _callee10, this);
        }));

        return function selectMorph(_x22, _x23) {
          return _ref21.apply(this, arguments);
        };
      }();

      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var editor1, editor2, editors, doDiff;
      return regeneratorRuntime.wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              doDiff = function doDiff(ed1, ed2) {
                var p1 = ed1.pluginFind(function (ea) {
                  return ea.evalEnvironment;
                });
                var fn1 = p1 && p1.evalEnvironment.targetModule || "no file";
                var p2 = ed2.pluginFind(function (ea) {
                  return ea.evalEnvironment;
                });
                var fn2 = p2 && p2.evalEnvironment.targetModule || "no file";
                return world.execCommand("diff and open in window", {
                  a: ed1.textString,
                  b: ed2.textString,
                  filenameA: fn1,
                  filenameB: fn2
                });
              };

              editor1 = opts.editor1, editor2 = opts.editor2;

              if (!editor1 || !editor2) editors = world.withAllSubmorphsSelect(function (ea) {
                  return ea.isText && !ea.isInputLine && !ea.isUsedAsEpiMorph();
                }).reverse();

              if (editor1) {
                _context11.next = 7;
                break;
              }

              _context11.next = 6;
              return selectMorph(editors);

            case 6:
              editor1 = _context11.sent;

            case 7:
              if (editor1) {
                _context11.next = 9;
                break;
              }

              return _context11.abrupt("return", world.setStatusMessage("Canceled"));

            case 9:
              if (editor2) {
                _context11.next = 13;
                break;
              }

              _context11.next = 12;
              return selectMorph(lively_lang.arr.without(editors, editor1));

            case 12:
              editor2 = _context11.sent;

            case 13:
              if (editor2) {
                _context11.next = 15;
                break;
              }

              return _context11.abrupt("return", world.setStatusMessage("Canceled"));

            case 15:
              return _context11.abrupt("return", doDiff(editor1, editor2));

            case 16:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11, this);
    }));

    function exec(_x20) {
      return _ref20.apply(this, arguments);
    }

    return exec;
  }()
}, {
  name: "open PartsBin",
  exec: function () {
    var _ref23 = asyncToGenerator(regeneratorRuntime.mark(function _callee12(world) {
      var _ref24, loadObjectFromPartsbinFolder, pb;

      return regeneratorRuntime.wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              _context12.next = 2;
              return System.import("lively.morphic/partsbin.js");

            case 2:
              _ref24 = _context12.sent;
              loadObjectFromPartsbinFolder = _ref24.loadObjectFromPartsbinFolder;
              _context12.next = 6;
              return loadObjectFromPartsbinFolder("PartsBin");

            case 6:
              pb = _context12.sent;
              return _context12.abrupt("return", pb.openInWorldNearHand());

            case 8:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12, _this);
    }));

    return function exec(_x24) {
      return _ref23.apply(this, arguments);
    };
  }()
}, {
  name: "open object drawer",
  exec: function () {
    var _ref25 = asyncToGenerator(regeneratorRuntime.mark(function _callee13(world) {
      var _ref26, ObjectDrawer;

      return regeneratorRuntime.wrap(function _callee13$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              _context13.next = 2;
              return System.import("lively.morphic/components/object-drawer.js");

            case 2:
              _ref26 = _context13.sent;
              ObjectDrawer = _ref26.default;
              return _context13.abrupt("return", new ObjectDrawer().openInWorldNearHand());

            case 5:
            case "end":
              return _context13.stop();
          }
        }
      }, _callee13, _this);
    }));

    return function exec(_x25) {
      return _ref25.apply(this, arguments);
    };
  }()
}, {
  name: "open object editor",
  exec: function () {
    var _ref27 = asyncToGenerator(regeneratorRuntime.mark(function _callee14(world) {
      var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { target: null };

      var _ref28, ObjectEditor, editor;

      return regeneratorRuntime.wrap(function _callee14$(_context14) {
        while (1) {
          switch (_context14.prev = _context14.next) {
            case 0:
              if (args.target) {
                _context14.next = 3;
                break;
              }

              world.setStatusMessage("no target for ObjectEditor");
              return _context14.abrupt("return", null);

            case 3:
              _context14.next = 5;
              return System.import("lively.morphic/ide/js/objecteditor/index.js");

            case 5:
              _ref28 = _context14.sent;
              ObjectEditor = _ref28.ObjectEditor;
              _context14.next = 9;
              return ObjectEditor.open({ target: args.target });

            case 9:
              editor = _context14.sent;
              return _context14.abrupt("return", editor);

            case 11:
            case "end":
              return _context14.stop();
          }
        }
      }, _callee14, _this);
    }));

    return function exec(_x26) {
      return _ref27.apply(this, arguments);
    };
  }()
}, {
  name: "open object inspector",
  exec: function () {
    var _ref29 = asyncToGenerator(regeneratorRuntime.mark(function _callee15(world) {
      var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { target: null };
      return regeneratorRuntime.wrap(function _callee15$(_context15) {
        while (1) {
          switch (_context15.prev = _context15.next) {
            case 0:
              if (args.target) {
                _context15.next = 3;
                break;
              }

              world.setStatusMessage("no target for Inspector");
              return _context15.abrupt("return", null);

            case 3:
              return _context15.abrupt("return", exports.inspect({ target: args.target }));

            case 4:
            case "end":
              return _context15.stop();
          }
        }
      }, _callee15, _this);
    }));

    return function exec(_x28) {
      return _ref29.apply(this, arguments);
    };
  }()
}, {
  name: "open browser",
  progressIndicator: "opening browser...",
  exec: function () {
    var _ref30 = asyncToGenerator(regeneratorRuntime.mark(function _callee16(world) {
      var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        packageName: "lively.morphic",
        moduleName: "morph.js"
      };

      var _ref31, Browser, loc, browser;

      return regeneratorRuntime.wrap(function _callee16$(_context16) {
        while (1) {
          switch (_context16.prev = _context16.next) {
            case 0:
              _context16.next = 2;
              return System.import("lively.morphic/ide/js/browser/index.js");

            case 2:
              _ref31 = _context16.sent;
              Browser = _ref31.default;
              loc = lively_lang.obj.select(args, ["packageName", "moduleName", "textPosition", "codeEntity"]);
              _context16.next = 7;
              return Browser.browse(loc, { extent: lively_graphics.pt(700, 600) });

            case 7:
              browser = _context16.sent;

              browser.getWindow().activate();
              return _context16.abrupt("return", browser);

            case 10:
            case "end":
              return _context16.stop();
          }
        }
      }, _callee16, _this);
    }));

    return function exec(_x30) {
      return _ref30.apply(this, arguments);
    };
  }()
}, {
  name: "choose and browse package resources",
  progressIndicator: "browsing resources...",
  exec: function () {
    var _ref32 = asyncToGenerator(regeneratorRuntime.mark(function _callee17(world) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        browser: null,
        backend: null
      };

      var browser, backend, systemInterface, livelySystem, pkgs, items, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _loop, _iterator, _step, _ref33, selected, _arr$partition, _arr$partition2, jsModules, nonJsModules, _ref34, Browser;

      return regeneratorRuntime.wrap(function _callee17$(_context18) {
        while (1) {
          switch (_context18.prev = _context18.next) {
            case 0:
              browser = opts.browser || world.focusedMorph && world.focusedMorph.ownerChain().find(function (ea) {
                return ea.isBrowser;
              });

              if (browser && browser.isBrowser) browser = browser.getWindow();else browser = null;
              backend = opts.backend || browser && browser.backend;
              _context18.next = 5;
              return System.import("lively-system-interface");

            case 5:
              systemInterface = _context18.sent;
              livelySystem = backend && backend !== "local" ? systemInterface.serverInterfaceFor(backend) : systemInterface.localInterface;
              _context18.next = 9;
              return livelySystem.getPackages({ excluded: config.ide.js.ignoredPackages });

            case 9:
              pkgs = _context18.sent;
              items = [];
              _iteratorNormalCompletion = true;
              _didIteratorError = false;
              _iteratorError = undefined;
              _context18.prev = 14;
              _loop = regeneratorRuntime.mark(function _loop() {
                var p;
                return regeneratorRuntime.wrap(function _loop$(_context17) {
                  while (1) {
                    switch (_context17.prev = _context17.next) {
                      case 0:
                        p = _step.value;
                        _context17.t0 = items.push;
                        _context17.t1 = items;
                        _context17.t2 = babelHelpers$1;
                        _context17.next = 6;
                        return livelySystem.resourcesOfPackage(p);

                      case 6:
                        _context17.t3 = function (_ref36) {
                          var url = _ref36.url;
                          return !url.endsWith("/");
                        };

                        _context17.t4 = function (a, b) {
                          if (a.isLoaded && !b.isLoaded) return -1;
                          if (!a.isLoaded && b.isLoaded) return 1;
                          if (a.nameInPackage.toLowerCase() < b.nameInPackage.toLowerCase()) return -1;
                          if (a.nameInPackage.toLowerCase() == b.nameInPackage.toLowerCase()) return 0;
                          return 1;
                        };

                        _context17.t5 = function (resource$$1) {
                          var string$$1 = "[" + p.name + "] " + resource$$1.nameInPackage + (resource$$1.isLoaded ? "" : " [not loaded]");
                          return {
                            isListItem: true,
                            string: string$$1,
                            value: resource$$1
                          };
                        };

                        _context17.t6 = _context17.sent.filter(_context17.t3).sort(_context17.t4).map(_context17.t5);
                        _context17.t7 = _context17.t2.toConsumableArray.call(_context17.t2, _context17.t6);

                        _context17.t0.apply.call(_context17.t0, _context17.t1, _context17.t7);

                      case 12:
                      case "end":
                        return _context17.stop();
                    }
                  }
                }, _loop, _this);
              });
              _iterator = pkgs[Symbol.iterator]();

            case 17:
              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                _context18.next = 22;
                break;
              }

              return _context18.delegateYield(_loop(), "t0", 19);

            case 19:
              _iteratorNormalCompletion = true;
              _context18.next = 17;
              break;

            case 22:
              _context18.next = 28;
              break;

            case 24:
              _context18.prev = 24;
              _context18.t1 = _context18["catch"](14);
              _didIteratorError = true;
              _iteratorError = _context18.t1;

            case 28:
              _context18.prev = 28;
              _context18.prev = 29;

              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }

            case 31:
              _context18.prev = 31;

              if (!_didIteratorError) {
                _context18.next = 34;
                break;
              }

              throw _iteratorError;

            case 34:
              return _context18.finish(31);

            case 35:
              return _context18.finish(28);

            case 36:
              _context18.next = 38;
              return world.filterableListPrompt("Choose module to open", items, {
                historyId: "lively.morphic-choose and browse package resources",
                requester: browser,
                width: 700,
                multiSelect: true,
                fuzzy: "value.shortName"
              });

            case 38:
              _ref33 = _context18.sent;
              selected = _ref33.selected;
              _arr$partition = lively_lang.arr.partition(selected, function (ea) {
                return ea.url.match(/\.js(on)?/);
              });
              _arr$partition2 = slicedToArray(_arr$partition, 2);
              jsModules = _arr$partition2[0];
              nonJsModules = _arr$partition2[1];
              _context18.next = 46;
              return System.import("lively.morphic/ide/js/browser/index.js");

            case 46:
              _ref34 = _context18.sent;
              Browser = _ref34.default;
              _context18.next = 50;
              return Promise.all(jsModules.map(function (ea) {
                var loc = {
                  packageName: ea.package,
                  moduleName: ea.url
                };
                return Browser.browse(loc, browser, backend).then(function (browser) {
                  return browser.activate();
                });
              }));

            case 50:
              if (!nonJsModules.length) {
                _context18.next = 53;
                break;
              }

              _context18.next = 53;
              return Promise.all(nonJsModules.map(function (_ref35) {
                var url = _ref35.url;
                return world.execCommand("open file", { url: url });
              }));

            case 53:
              return _context18.abrupt("return", true);

            case 54:
            case "end":
              return _context18.stop();
          }
        }
      }, _callee17, _this, [[14, 24, 28, 36], [29,, 31, 35]]);
    }));

    return function exec(_x32) {
      return _ref32.apply(this, arguments);
    };
  }()
}, {
  name: "choose and browse module",
  progressIndicator: "browsing module...",
  handlesCount: true,
  exec: function () {
    var _ref37 = asyncToGenerator(regeneratorRuntime.mark(function _callee19(world) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        browser: undefined,
        backend: undefined
      };
      var count = arguments[2];

      var focused, win, browser, _ref38, Browser, backend, remote, systemInterface, livelySystem, pkgs, items, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _p, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, m, shortName;

      return regeneratorRuntime.wrap(function _callee19$(_context20) {
        while (1) {
          switch (_context20.prev = _context20.next) {
            case 0:
              if (opts.browser) {
                _context20.next = 4;
                break;
              }

              focused = world.focusedMorph, win = focused && focused.getWindow();

              if (!(win && win.targetMorph && win.targetMorph.isFileBrowser)) {
                _context20.next = 4;
                break;
              }

              return _context20.abrupt("return", win.targetMorph.execCommand("find file and select", opts, count));

            case 4:
              browser = opts.browser || focused && focused.ownerChain().find(function (ea) {
                return ea.isBrowser;
              });
              _context20.next = 7;
              return System.import("lively.morphic/ide/js/browser/index.js");

            case 7:
              _ref38 = _context20.sent;
              Browser = _ref38.default;
              backend = opts.backend || browser && browser.backend;
              remote = backend && backend !== "local" ? backend : null;
              _context20.next = 13;
              return System.import("lively-system-interface");

            case 13:
              systemInterface = _context20.sent;
              livelySystem = remote ? systemInterface.serverInterfaceFor(remote) : systemInterface.localInterface;
              _context20.next = 17;
              return livelySystem.getPackages();

            case 17:
              pkgs = _context20.sent;
              items = [];
              _iteratorNormalCompletion2 = true;
              _didIteratorError2 = false;
              _iteratorError2 = undefined;
              _context20.prev = 22;
              _iterator2 = pkgs[Symbol.iterator]();

            case 24:
              if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                _context20.next = 48;
                break;
              }

              _p = _step2.value;
              _iteratorNormalCompletion3 = true;
              _didIteratorError3 = false;
              _iteratorError3 = undefined;
              _context20.prev = 29;

              for (_iterator3 = _p.modules[Symbol.iterator](); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                m = _step3.value;
                shortName = livelySystem.shortModuleName(m.name, _p);

                items.push({
                  isListItem: true,
                  string: "[" + _p.name + "] " + shortName,
                  value: {
                    package: _p,
                    module: m,
                    shortName: shortName
                  }
                });
              }
              _context20.next = 37;
              break;

            case 33:
              _context20.prev = 33;
              _context20.t0 = _context20["catch"](29);
              _didIteratorError3 = true;
              _iteratorError3 = _context20.t0;

            case 37:
              _context20.prev = 37;
              _context20.prev = 38;

              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }

            case 40:
              _context20.prev = 40;

              if (!_didIteratorError3) {
                _context20.next = 43;
                break;
              }

              throw _iteratorError3;

            case 43:
              return _context20.finish(40);

            case 44:
              return _context20.finish(37);

            case 45:
              _iteratorNormalCompletion2 = true;
              _context20.next = 24;
              break;

            case 48:
              _context20.next = 54;
              break;

            case 50:
              _context20.prev = 50;
              _context20.t1 = _context20["catch"](22);
              _didIteratorError2 = true;
              _iteratorError2 = _context20.t1;

            case 54:
              _context20.prev = 54;
              _context20.prev = 55;

              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }

            case 57:
              _context20.prev = 57;

              if (!_didIteratorError2) {
                _context20.next = 60;
                break;
              }

              throw _iteratorError2;

            case 60:
              return _context20.finish(57);

            case 61:
              return _context20.finish(54);

            case 62:
              items = lively_lang.arr.sortBy(items, function (ea) {
                return ea.string;
              });
              asyncToGenerator(regeneratorRuntime.mark(function _callee18() {
                var _ref40, selected, i, _selected$i, p, shortName, loc, b;

                return regeneratorRuntime.wrap(function _callee18$(_context19) {
                  while (1) {
                    switch (_context19.prev = _context19.next) {
                      case 0:
                        _context19.next = 2;
                        return world.filterableListPrompt("Choose module to open", items, {
                          historyId: "lively.morphic-choose and browse module",
                          requester: browser || focused,
                          width: 700,
                          multiSelect: true,
                          listFontColor: "white",
                          fuzzy: "value.shortName"
                        });

                      case 2:
                        _ref40 = _context19.sent;
                        selected = _ref40.selected;
                        i = 0;

                      case 5:
                        if (!(i < selected.length)) {
                          _context19.next = 18;
                          break;
                        }

                        _selected$i = selected[i];
                        p = _selected$i.package;
                        shortName = _selected$i.shortName;
                        loc = {
                          packageName: p.name,
                          moduleName: shortName
                        };
                        _context19.next = 12;
                        return Browser.browse(loc, i === 0 ? browser : undefined, backend);

                      case 12:
                        b = _context19.sent;

                        b.moveBy(lively_graphics.pt(i * 20, i * 20));
                        b.activate();

                      case 15:
                        i++;
                        _context19.next = 5;
                        break;

                      case 18:
                      case "end":
                        return _context19.stop();
                    }
                  }
                }, _callee18, _this);
              }))();
              return _context20.abrupt("return", true);

            case 65:
            case "end":
              return _context20.stop();
          }
        }
      }, _callee19, _this, [[22, 50, 54, 62], [29, 33, 37, 45], [38,, 40, 44], [55,, 57, 61]]);
    }));

    return function exec(_x34) {
      return _ref37.apply(this, arguments);
    };
  }()
}, {
  name: "open code search",
  progressIndicator: "opening code search...",
  exec: function () {
    var _ref41 = asyncToGenerator(regeneratorRuntime.mark(function _callee20(world) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        browser: null,
        backend: null,
        input: null
      };

      var browser, _ref42, CodeSearcher, backend, searcher;

      return regeneratorRuntime.wrap(function _callee20$(_context21) {
        while (1) {
          switch (_context21.prev = _context21.next) {
            case 0:
              browser = opts.browser || world.focusedMorph && world.focusedMorph.ownerChain().find(function (ea) {
                return ea.isBrowser;
              });
              _context21.next = 3;
              return System.import("lively.morphic/ide/code-search.js");

            case 3:
              _ref42 = _context21.sent;
              CodeSearcher = _ref42.CodeSearcher;

              if (!(browser && browser.isBrowser)) {
                _context21.next = 10;
                break;
              }

              if (!browser.state.associatedSearchPanel) {
                _context21.next = 8;
                break;
              }

              return _context21.abrupt("return", browser.state.associatedSearchPanel.getWindow().activate());

            case 8:
              _context21.next = 11;
              break;

            case 10:
              browser = null;

            case 11:
              backend = opts.backend || browser && browser.backend, searcher = CodeSearcher.inWindow({
                title: "code search",
                extent: lively_graphics.pt(800, 500),
                targetBrowser: browser,
                input: opts.input,
                backend: backend
              }).activate();

              if (browser) browser.state.associatedSearchPanel = searcher;
              return _context21.abrupt("return", searcher);

            case 14:
            case "end":
              return _context21.stop();
          }
        }
      }, _callee20, _this);
    }));

    return function exec(_x36) {
      return _ref41.apply(this, arguments);
    };
  }()
}, {
  name: "open test runner",
  progressIndicator: "opening test runner...",
  exec: function () {
    var _ref43 = asyncToGenerator(regeneratorRuntime.mark(function _callee21(world) {
      var _ref44, TestRunner;

      return regeneratorRuntime.wrap(function _callee21$(_context22) {
        while (1) {
          switch (_context22.prev = _context22.next) {
            case 0:
              _context22.next = 2;
              return System.import("lively.morphic/ide/test-runner.js");

            case 2:
              _ref44 = _context22.sent;
              TestRunner = _ref44.default;
              _context22.next = 6;
              return TestRunner.open();

            case 6:
              return _context22.abrupt("return", _context22.sent);

            case 7:
            case "end":
              return _context22.stop();
          }
        }
      }, _callee21, _this);
    }));

    return function exec(_x38) {
      return _ref43.apply(this, arguments);
    };
  }()
}, {
  name: "open file browser",
  progressIndicator: "opening file browser...",
  exec: function () {
    var _ref45 = asyncToGenerator(regeneratorRuntime.mark(function _callee22(world) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var _ref46, HTTPFileBrowser, location, file, browser;

      return regeneratorRuntime.wrap(function _callee22$(_context23) {
        while (1) {
          switch (_context23.prev = _context23.next) {
            case 0:
              _context23.next = 2;
              return System.import("lively.morphic/ide/http-file-browser.js");

            case 2:
              _ref46 = _context23.sent;
              HTTPFileBrowser = _ref46.default;
              location = opts.location;
              file = opts.file;
              browser = file ? HTTPFileBrowser.forFile(file, location) : HTTPFileBrowser.forLocation(location || document.location.origin);
              return _context23.abrupt("return", world.openInWindow(browser).activate());

            case 8:
            case "end":
              return _context23.stop();
          }
        }
      }, _callee22, _this);
    }));

    return function exec(_x39) {
      return _ref45.apply(this, arguments);
    };
  }()
}, {
  name: "open file",
  progressIndicator: "opening file...",
  exec: function () {
    var _ref47 = asyncToGenerator(regeneratorRuntime.mark(function _callee23(world) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        url: null,
        lineNumber: null
      };

      var _ref48, TextEditor, url, lineNumber;

      return regeneratorRuntime.wrap(function _callee23$(_context24) {
        while (1) {
          switch (_context24.prev = _context24.next) {
            case 0:
              _context24.next = 2;
              return System.import("lively.morphic/ide/text-editor.js");

            case 2:
              _ref48 = _context24.sent;
              TextEditor = _ref48.default;
              url = opts.url;
              lineNumber = opts.lineNumber;

              if (url) {
                _context24.next = 10;
                break;
              }

              _context24.next = 9;
              return world.prompt("Enter file location", {
                historyId: "lively.morphic-text editor url",
                useLastInput: true
              });

            case 9:
              url = _context24.sent;

            case 10:
              if (lineNumber) url += ":" + lineNumber;
              return _context24.abrupt("return", url ? TextEditor.openURL(url, lively_lang.obj.dissoc(opts, ["url"])) : null);

            case 12:
            case "end":
              return _context24.stop();
          }
        }
      }, _callee23, _this);
    }));

    return function exec(_x41) {
      return _ref47.apply(this, arguments);
    };
  }()
}, {
  name: "open file for EDITOR",
  exec: function () {
    var _ref49 = asyncToGenerator(regeneratorRuntime.mark(function _callee24(world) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        url: null,
        lineNumber: null
      };

      var _ref50, TextEditor, url, lineNumber;

      return regeneratorRuntime.wrap(function _callee24$(_context25) {
        while (1) {
          switch (_context25.prev = _context25.next) {
            case 0:
              _context25.next = 2;
              return System.import("lively.morphic/ide/text-editor.js");

            case 2:
              _ref50 = _context25.sent;
              TextEditor = _ref50.default;
              url = opts.url;
              lineNumber = opts.lineNumber;
              _context25.next = 8;
              return TextEditor.openAsEDITOR(url, {});

            case 8:
              return _context25.abrupt("return", _context25.sent);

            case 9:
            case "end":
              return _context25.stop();
          }
        }
      }, _callee24, _this);
    }));

    return function exec(_x43) {
      return _ref49.apply(this, arguments);
    };
  }()
}, {
  name: "[lively.installer] publish new version of a package",
  exec: function () {
    var _ref51 = asyncToGenerator(regeneratorRuntime.mark(function _callee25(world) {
      var _ref52, publishPackage;

      return regeneratorRuntime.wrap(function _callee25$(_context26) {
        while (1) {
          switch (_context26.prev = _context26.next) {
            case 0:
              _context26.next = 2;
              return lively.modules.registerPackage(document.location.origin + "/lively.installer");

            case 2:
              _context26.next = 4;
              return System.import("lively.installer/packages/publish-new-package-version.js");

            case 4:
              _ref52 = _context26.sent;
              publishPackage = _ref52.default;
              _context26.next = 8;
              return publishPackage();

            case 8:
              return _context26.abrupt("return", true);

            case 9:
            case "end":
              return _context26.stop();
          }
        }
      }, _callee25, _this);
    }));

    return function exec(_x45) {
      return _ref51.apply(this, arguments);
    };
  }()
}, {
  name: "report a bug",
  exec: function () {
    var _ref53 = asyncToGenerator(regeneratorRuntime.mark(function _callee26(world) {
      return regeneratorRuntime.wrap(function _callee26$(_context27) {
        while (1) {
          switch (_context27.prev = _context27.next) {
            case 0:
              window.open("https://github.com/LivelyKernel/lively.morphic/issues/new", "_blank");
              return _context27.abrupt("return", true);

            case 2:
            case "end":
              return _context27.stop();
          }
        }
      }, _callee26, _this);
    }));

    return function exec(_x46) {
      return _ref53.apply(this, arguments);
    };
  }()
}];
var World$$1 = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("World") && typeof __lively_classholder__.World === "function" ? __lively_classholder__.World : __lively_classholder__.World = function World$$1(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function World_initialize_(props) {
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, props);
      this._renderer = null;
      this._tooltipViewer = new TooltipViewer$$1(this);
    }
  }, {
    key: "__deserialize__",
    value: function World___deserialize___(snapshot, objRef) {
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "__deserialize__", this).call(this, snapshot, objRef);
      this._tooltipViewer = new TooltipViewer$$1(this);
    }
  }, {
    key: "isWorld",
    get: function get() {
      return true;
    }
  }, {
    key: "draggable",
    get: function get() {
      return true;
    }
  }, {
    key: "draggable",
    set: function set(_) {}
  }, {
    key: "grabbable",
    get: function get() {
      return false;
    }
  }, {
    key: "grabbable",
    set: function set(_) {}
  }, {
    key: "handForPointerId",
    value: function World_handForPointerId_(pointerId) {
      return this.submorphs.find(function (m) {
        return m instanceof Hand$$1 && m.pointerId === pointerId;
      }) || this.addMorph(new Hand$$1(pointerId), this.submorphs[0]);
    }
  }, {
    key: "world",
    value: function World_world_() {
      return this;
    }
  }, {
    key: "hands",
    get: function get() {
      return lively_lang.arr.sortBy(this.submorphs.filter(function (ea) {
        return ea.isHand;
      }), function (ea) {
        return ea.pointerId;
      });
    }
  }, {
    key: "firstHand",
    get: function get() {
      return this.hands[0];
    }
  }, {
    key: "activeWindow",
    value: function World_activeWindow_() {
      return this.getWindows().reverse().find(function (ea) {
        return ea.isActive();
      });
    }
  }, {
    key: "getWindows",
    value: function World_getWindows_() {
      return this.submorphs.filter(function (ea) {
        return ea.isWindow;
      });
    }
  }, {
    key: "activePrompt",
    value: function World_activePrompt_() {
      return this.getPrompts().reverse().find(function (ea) {
        return ea.isActive();
      });
    }
  }, {
    key: "getPrompts",
    value: function World_getPrompts_() {
      return this.submorphs.filter(function (ea) {
        return ea.isPrompt;
      });
    }
  }, {
    key: "openInWindow",
    value: function World_openInWindow_(morph$$1) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        title: morph$$1.name,
        name: "window for " + morph$$1.name
      };

      return new Window$$1(Object.assign({}, opts, {
        extent: morph$$1.extent.addXY(0, 25),
        targetMorph: morph$$1
      })).openInWorld();
    }
  }, {
    key: "focusedMorph",
    get: function get() {
      var focused = this.env.eventDispatcher.eventState.focusedMorph;
      return focused && focused.world() === this ? focused : this;
    }
  }, {
    key: "onMouseMove",
    value: function World_onMouseMove_(evt) {
      evt.hand && evt.hand.update(evt);
      this._tooltipViewer.mouseMove(evt);
    }
  }, {
    key: "onMouseDown",
    value: function World_onMouseDown_(evt) {
      var target = evt.state.clickedOnMorph,
          isCommandKey = evt.isCommandKey(),
          isShiftKey = evt.isShiftDown();
      var haloTarget;
      if (isCommandKey) {
        var morphsBelow = evt.world.morphsContainingPoint(evt.position),
            morphsBelowTarget = morphsBelow.slice(morphsBelow.indexOf(target));
        morphsBelow = morphsBelow.filter(function (ea) {
          return ea.halosEnabled;
        });
        morphsBelowTarget = morphsBelowTarget.filter(function (ea) {
          return ea.halosEnabled;
        });
        haloTarget = morphsBelowTarget[0] || morphsBelow[0];
      }
      if (isShiftKey && !target.isHaloItem && haloTarget && evt.halo && evt.halo.borderBox != haloTarget) {
        evt.halo.addMorphToSelection(haloTarget);
        return;
      }
      var removeHalo = evt.halo && !evt.targetMorphs.find(function (morph$$1) {
        return morph$$1.isHaloItem;
      }),
          removeLayoutHalo = evt.layoutHalo && !evt.targetMorphs.find(function (morph$$1) {
        return morph$$1.isHaloItem;
      }),
          addHalo = (!evt.halo || removeHalo) && haloTarget;
      if (removeLayoutHalo) evt.layoutHalo.remove();
      if (removeHalo) evt.halo.remove();
      if (addHalo) {
        this.showHaloFor(haloTarget, evt.domEvt.pointerId);
        return;
      }
      if (evt.state.menu) evt.state.menu.remove();
      this._tooltipViewer.mouseDown(evt);
    }
  }, {
    key: "onMouseUp",
    value: function World_onMouseUp_(evt) {
      if (evt.isAltDown() && config.altClickDefinesThat) {
        var target = this.morphsContainingPoint(evt.position)[0];
        setTimeout(function () {
          return System.global.that = target;
        }, 100);
        target.show();
        evt.stop();
        console.log("Set global \"that\" to " + target);
        return;
      }
    }
  }, {
    key: "onMouseWheel",
    value: function World_onMouseWheel_(evt) {
      if (evt.isShiftDown()) {
        window.scrollBy(-evt.domEvt.wheelDeltaX, -evt.domEvt.wheelDeltaY);
        evt.stop();
      }
    }
  }, {
    key: "onDragStart",
    value: function World_onDragStart_(evt) {
      this.selectionStartPos = evt.positionIn(this);
      this.morphSelection = this.addMorph({
        isSelectionElement: true,
        position: this.selectionStartPos,
        extent: evt.state.dragDelta,
        fill: lively_graphics.Color.gray.withA(0.2),
        borderWidth: 2,
        borderColor: lively_graphics.Color.gray
      });
      this.selectedMorphs = {};
    }
  }, {
    key: "onDrag",
    value: function World_onDrag_(evt) {
      var _this2 = this;

      var selectionBounds = lively_graphics.Rectangle.fromAny(evt.position, this.selectionStartPos);
      this.morphSelection.setBounds(selectionBounds);
      this.submorphs.forEach(function (c) {
        if (c.isSelectionElement || c.isHand) return;
        var candidateBounds = c.bounds(),
            included = selectionBounds.containsRect(candidateBounds);
        if (!_this2.selectedMorphs[c.id] && included) {
          _this2.selectedMorphs[c.id] = _this2.addMorph({
            isSelectionElement: true,
            bounds: candidateBounds,
            borderColor: lively_graphics.Color.red,
            borderWidth: 1,
            fill: lively_graphics.Color.transparent
          }, _this2.morphSelection);
        }
        if (_this2.selectedMorphs[c.id] && !included) {
          _this2.selectedMorphs[c.id].remove();
          delete _this2.selectedMorphs[c.id];
        }
      });
    }
  }, {
    key: "onDragEnd",
    value: function World_onDragEnd_(evt) {
      var _this3 = this;

      this.morphSelection.fadeOut(200);
      lively_lang.obj.values(this.selectedMorphs).map(function (m) {
        return m.remove();
      });
      this.showHaloForSelection(Object.keys(this.selectedMorphs).map(function (id) {
        return _this3.getMorphWithId(id);
      }));
      this.selectedMorphs = {};
    }
  }, {
    key: "menuItems",
    value: function World_menuItems_() {
      var _this4 = this;

      return [{ title: "World menu" }, {
        command: "undo",
        target: this
      }, {
        command: "redo",
        target: this
      }, { isDivider: true }, {
        command: "run command",
        target: this
      }, {
        command: "select morph",
        target: this
      }, {
        command: "resize to fit window",
        target: this
      }, {
        command: "window switcher",
        target: this
      }, { isDivider: true }, ["Debugging", [["delete change history", function () {
        var status = _this4.env.printStatus();
        _this4.env.deleteHistory();
        _this4.setStatusMessage(status);
      }], ["fix font metric", function () {
        _this4.env.fontMetric.reset();
        _this4.withAllSubmorphsDo(function (ea) {
          return ea.isText && ea.textLayout && ea.textLayout.reset();
        });
      }]]], ["Tools", [{
        command: "open PartsBin",
        target: this
      }, {
        command: "open object drawer",
        target: this
      }, {
        command: "open workspace",
        target: this
      }, {
        command: "open browser",
        target: this
      }, {
        command: "choose and browse module",
        target: this
      }, {
        command: "open code search",
        target: this
      }, {
        command: "open file browser",
        target: this
      }, {
        command: "open shell workspace",
        target: this
      }]], {
        command: "report a bug",
        target: this
      }];
    }
  }, {
    key: "openWorldMenu",
    value: function World_openWorldMenu_(evt, items) {
      var eventState = this.env.eventDispatcher.eventState;
      if (eventState.menu) eventState.menu.remove();
      return eventState.menu = items && items.length ? Menu$$1.openAtHand(items, { hand: evt && evt.hand || this.firstHand }) : null;
    }
  }, {
    key: "onWindowScroll",
    value: function World_onWindowScroll_(evt) {
      this._cachedWindowBounds = null;
    }
  }, {
    key: "onWindowResize",
    value: function World_onWindowResize_(evt) {
      this._cachedWindowBounds = null;
      this.execCommand("resize to fit window");
    }
  }, {
    key: "commands",
    get: function get() {
      return worldCommands.concat(lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "commands", this));
    }
  }, {
    key: "keybindings",
    get: function get() {
      return lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "keybindings", this).concat(config.globalKeyBindings);
    }
  }, {
    key: "keybindings",
    set: function set(x) {
      lively.classes.runtime.initializeClass._set(Object.getPrototypeOf(__lively_class__.prototype), "keybindings", x, this);
    }
  }, {
    key: "halos",
    value: function World_halos_() {
      return this.submorphs.filter(function (m) {
        return m.isHalo;
      });
    }
  }, {
    key: "haloForPointerId",
    value: function World_haloForPointerId_(pointerId) {
      return this.submorphs.find(function (m) {
        return m.isHalo && m.state.pointerId === pointerId;
      });
    }
  }, {
    key: "showHaloFor",
    value: function () {
      var _ref54 = asyncToGenerator(regeneratorRuntime.mark(function _callee27(target) {
        var pointerId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.firstHand && this.firstHand.pointerId;

        var _ref55, Halo;

        return regeneratorRuntime.wrap(function _callee27$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                _context28.next = 2;
                return System.import("lively.morphic/halo/morph.js");

              case 2:
                _ref55 = _context28.sent;
                Halo = _ref55.default;
                return _context28.abrupt("return", this.addMorph(new Halo({
                  pointerId: pointerId,
                  target: target
                })));

              case 5:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee27, this);
      }));

      function World_showHaloFor_(_x48) {
        return _ref54.apply(this, arguments);
      }

      return World_showHaloFor_;
    }()
  }, {
    key: "showHaloForSelection",
    value: function () {
      var _ref56 = asyncToGenerator(regeneratorRuntime.mark(function _callee28(selection, pointerId) {
        return regeneratorRuntime.wrap(function _callee28$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                _context29.t0 = selection.length > 0;

                if (!_context29.t0) {
                  _context29.next = 5;
                  break;
                }

                _context29.next = 4;
                return this.showHaloFor(selection, pointerId);

              case 4:
                _context29.t0 = _context29.sent;

              case 5:
                return _context29.abrupt("return", _context29.t0);

              case 6:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee28, this);
      }));

      function World_showHaloForSelection_(_x50, _x51) {
        return _ref56.apply(this, arguments);
      }

      return World_showHaloForSelection_;
    }()
  }, {
    key: "layoutHaloForPointerId",
    value: function World_layoutHaloForPointerId_() {
      var pointerId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.firstHand && this.firstHand.pointerId;

      return this.submorphs.find(function (m) {
        return m.isLayoutHalo && m.state.pointerId === pointerId;
      });
    }
  }, {
    key: "showLayoutHaloFor",
    value: function World_showLayoutHaloFor_(morph$$1) {
      var pointerId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.firstHand && this.firstHand.pointerId;

      return this.addMorph(morph$$1.layout.inspect(pointerId));
    }
  }, {
    key: "visibleBounds",
    value: function World_visibleBounds_() {
      if (!this.env.renderer) return this.innerBounds();
      return this.windowBounds().intersection(this.innerBounds());
    }
  }, {
    key: "windowBounds",
    value: function World_windowBounds_(optWorldDOMNode) {
      if (this._cachedWindowBounds) return this._cachedWindowBounds;
      var window = this.env.domEnv.window,
          scale = 1 / this.scale,
          x = window.scrollX * scale,
          y = window.scrollY * scale,
          width = (window.innerWidth || this.width) * scale,
          height = (window.innerHeight || this.height) * scale;
      return this._cachedWindowBounds = new lively_graphics.Rectangle(x, y, width, height);
    }
  }, {
    key: "visibleStatusMessages",
    value: function World_visibleStatusMessages_() {
      return this.submorphs.filter(function (ea) {
        return ea.isStatusMessage;
      });
    }
  }, {
    key: "visibleStatusMessagesFor",
    value: function World_visibleStatusMessagesFor_(morph$$1) {
      return this.submorphs.filter(function (ea) {
        return ea.isStatusMessage && ea.targetMorph === morph$$1;
      });
    }
  }, {
    key: "logErrorPreperation",
    value: function World_logErrorPreperation_(err) {
      var stringified = String(err),
          stack = err.stack || "";
      if (stack && err.message !== err.stack) {
        stack = String(stack);
        var errInStackIdx = stack.indexOf(stringified);
        if (errInStackIdx === 0) stack = stack.slice(stringified.length);
        stringified += "\n" + stack;
      }
      return stringified;
    }
  }, {
    key: "logError",
    value: function World_logError_(err) {
      this.setStatusMessage(this.logErrorPreperation(err), lively_graphics.Color.red);
    }
  }, {
    key: "showError",
    value: function World_showError_(err) {
      return this.logError(err);
    }
  }, {
    key: "showErrorFor",
    value: function World_showErrorFor_(morph$$1, err) {
      return this.setStatusMessageFor(morph$$1, this.logErrorPreperation(err), lively_graphics.Color.red);
    }
  }, {
    key: "setStatusMessageFor",
    value: function World_setStatusMessageFor_(morph$$1, message, color) {
      var delay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 5000;
      var props = arguments[4];

      this.visibleStatusMessagesFor(morph$$1).forEach(function (ea) {
        return ea.remove();
      });
      var msgMorph = new StatusMessageForMorph(Object.assign({
        message: message,
        color: color
      }, props));
      this.openStatusMessage(msgMorph, delay);
      msgMorph.targetMorph = morph$$1;
      msgMorph.fadeIn(300);
      if (msgMorph.removeOnTargetMorphChange && morph$$1.isText) {
        lively_bindings.once(morph$$1, "selectionChange", msgMorph, "fadeOut", { converter: function converter() {
            return 200;
          } });
      }
      return msgMorph;
    }
  }, {
    key: "setStatusMessage",
    value: function World_setStatusMessage_(message, color) {
      var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5000;
      var optStyle = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      console[color == lively_graphics.Color.red ? "error" : "log"](message);
      return config.verboseLogging ? this.openStatusMessage(new StatusMessage(Object.assign({
        message: message,
        color: color
      }, optStyle)), delay) : null;
    }
  }, {
    key: "openStatusMessage",
    value: function World_openStatusMessage_(statusMessage, delay) {
      var _this5 = this;

      this.addMorph(statusMessage);
      if (statusMessage.slidable) {
        var messages = this.visibleStatusMessages();
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = messages[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var m = _step4.value;

            if (messages.length <= (config.maxStatusMessages || 0)) break;
            if (m.stayOpen || !m.slidable) continue;
            m.remove();
            lively_lang.arr.remove(messages, m);
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        messages.forEach(function () {
          var _ref57 = asyncToGenerator(regeneratorRuntime.mark(function _callee29(msg) {
            return regeneratorRuntime.wrap(function _callee29$(_context30) {
              while (1) {
                switch (_context30.prev = _context30.next) {
                  case 0:
                    if (!msg.isMaximized && msg.slidable) {
                      msg.slideTo(msg.position.addPt(lively_graphics.pt(0, -statusMessage.extent.y - 10)));
                    }

                  case 1:
                  case "end":
                    return _context30.stop();
                }
              }
            }, _callee29, _this5);
          }));

          return function (_x57) {
            return _ref57.apply(this, arguments);
          };
        }());
        var msgPos = this.visibleBounds().bottomRight().addXY(-20, -20);
        statusMessage.align(statusMessage.bounds().bottomRight(), msgPos);
        statusMessage.topRight = msgPos.addPt(lively_graphics.pt(0, 40));
        statusMessage.animate({
          bottomRight: msgPos,
          duration: 500
        });
      }
      if (typeof delay === "number") setTimeout(function () {
        return statusMessage.stayOpen || statusMessage.fadeOut();
      }, delay);
      return statusMessage;
    }
  }, {
    key: "openPrompt",
    value: function () {
      var _ref58 = asyncToGenerator(regeneratorRuntime.mark(function _callee30(promptMorph) {
        var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
          requester: null,
          animated: false
        };
        var focused, visBounds, animator;
        return regeneratorRuntime.wrap(function _callee30$(_context31) {
          while (1) {
            switch (_context31.prev = _context31.next) {
              case 0:
                focused = this.focusedMorph, visBounds = this.visibleBounds();

                promptMorph.openInWorldNear(opts.requester ? opts.requester.globalBounds().center() : visBounds.center(), this);
                if (promptMorph.height > visBounds.height) promptMorph.height = visBounds.height - 5;
                if (typeof opts.customize === "function") opts.customize(promptMorph);

                if (!opts.animated) {
                  _context31.next = 13;
                  break;
                }

                animator = new Morph$1({
                  fill: lively_graphics.Color.transparent,
                  extent: lively_graphics.pt(1, 1),
                  opacity: 0,
                  center: this.center
                });

                animator.openInWorld();
                animator.addMorph(promptMorph);
                animator.scale = 2;
                _context31.next = 11;
                return animator.animate({
                  scale: 1,
                  opacity: 1,
                  duration: 500
                });

              case 11:
                animator.remove();
                promptMorph.openInWorld();

              case 13:
                return _context31.abrupt("return", lively_lang.promise.finally(promptMorph.activate(), function () {
                  return focused && focused.focus();
                }));

              case 14:
              case "end":
                return _context31.stop();
            }
          }
        }, _callee30, this);
      }));

      function World_openPrompt_(_x58) {
        return _ref58.apply(this, arguments);
      }

      return World_openPrompt_;
    }()
  }, {
    key: "inform",
    value: function World_inform_() {
      var label = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "no message";
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        fontSize: 16,
        requester: null,
        animated: true
      };

      return this.openPrompt(new InformPrompt(Object.assign({ label: label }, opts)), opts);
    }
  }, {
    key: "prompt",
    value: function World_prompt_(label) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        requester: null,
        input: "",
        historyId: null,
        useLastInput: false
      };

      return this.openPrompt(new TextPrompt(Object.assign({ label: label }, opts)), opts);
    }
  }, {
    key: "passwordPrompt",
    value: function World_passwordPrompt_(label) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        requester: null,
        input: ""
      };

      return this.openPrompt(new PasswordPrompt(Object.assign({ label: label }, opts)), opts);
    }
  }, {
    key: "confirm",
    value: function World_confirm_(label) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        requester: null,
        animated: true
      };

      return this.openPrompt(new ConfirmPrompt(Object.assign({ label: label }, opts)), opts);
    }
  }, {
    key: "multipleChoicePrompt",
    value: function World_multipleChoicePrompt_(label) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        requester: null,
        animated: true,
        choices: []
      };

      return this.openPrompt(new MultipleChoicePrompt(Object.assign({ label: label }, opts)), opts);
    }
  }, {
    key: "listPrompt",
    value: function World_listPrompt_() {
      var label = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      var items = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
        requester: null,
        onSelection: null,
        preselect: 0
      };

      return this.openPrompt(new ListPrompt(Object.assign({
        filterable: false,
        padding: lively_graphics.Rectangle.inset(3),
        label: label,
        items: items
      }, opts)), opts);
    }
  }, {
    key: "filterableListPrompt",
    value: function World_filterableListPrompt_() {
      var label = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      var items = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
        requester: null,
        onSelection: null,
        preselect: 0,
        multiSelect: false,
        historyId: null,
        fuzzy: false
      };

      if (opts.prompt) {
        var list = opts.prompt.get("list");
        list.items = items;
        list.selectedIndex = opts.preselect || 0;
        return this.openPrompt(opts.prompt, opts);
      }
      return this.openPrompt(new ListPrompt(Object.assign({
        filterable: true,
        padding: lively_graphics.Rectangle.inset(3),
        label: label,
        items: items
      }, opts)), opts);
    }
  }, {
    key: "editListPrompt",
    value: function World_editListPrompt_() {
      var label = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      var items = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
        requester: null,
        multiSelect: true,
        historyId: null
      };

      return this.openPrompt(new EditListPrompt(Object.assign({
        label: label,
        multiSelect: true,
        items: items,
        padding: lively_graphics.Rectangle.inset(3)
      }, opts)), opts);
    }
  }], [{
    key: "defaultWorld",
    value: function World_defaultWorld_() {
      return MorphicEnv.default().world;
    }
  }], __lively_classholder__, undefined, {
    start: 25223,
    end: 40928
  });
}(Morph$1);
var Hand$$1 = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("Hand") && typeof __lively_classholder__.Hand === "function" ? __lively_classholder__.Hand : __lively_classholder__.Hand = function Hand$$1(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function Hand_initialize_(pointerId) {
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, {
        fill: lively_graphics.Color.orange,
        extent: lively_graphics.pt(4, 4),
        reactsToPointer: false,
        pointerId: pointerId
      });
      this.reset();
    }
  }, {
    key: "__deserialize__",
    value: function Hand___deserialize___(snapshot, objRef) {
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "__deserialize__", this).call(this, snapshot, objRef);
      this.reset();
    }
  }, {
    key: "reset",
    value: function Hand_reset_() {
      this.prevMorphProps = new WeakMap();
    }
  }, {
    key: "isHand",
    get: function get() {
      return true;
    }
  }, {
    key: "pointerId",
    get: function get() {
      return this.getProperty("pointerId");
    }
  }, {
    key: "pointerId",
    set: function set(id) {
      this.setProperty("pointerId", id);
    }
  }, {
    key: "draggable",
    get: function get() {
      return false;
    }
  }, {
    key: "draggable",
    set: function set(_) {}
  }, {
    key: "grabbable",
    get: function get() {
      return false;
    }
  }, {
    key: "grabbable",
    set: function set(_) {}
  }, {
    key: "grabbedMorphs",
    get: function get() {
      return this.submorphs;
    }
  }, {
    key: "carriesMorphs",
    value: function Hand_carriesMorphs_() {
      return !!this.grabbedMorphs.length;
    }
  }, {
    key: "morphsContainingPoint",
    value: function Hand_morphsContainingPoint_(point, list) {
      return list;
    }
  }, {
    key: "update",
    value: function Hand_update_(evt) {
      this.position = evt.position;
      this.carriesMorphs() && evt.halo && evt.halo.grabHalo().update();
    }
  }, {
    key: "grab",
    value: function Hand_grab_(morph$$1) {
      var _this6 = this;

      if (lively_lang.obj.isArray(morph$$1)) return morph$$1.forEach(function (m) {
        return _this6.grab(m);
      });
      morph$$1.withAllSubmorphsDo(function (ea) {
        _this6.prevMorphProps.set(ea, lively_lang.obj.select(ea, ["dropShadow", "reactsToPointer"]));
        ea.reactsToPointer = false;
        ea.dropShadow = true;
      });
      this.addMorph(morph$$1);
    }
  }, {
    key: "dropMorphsOn",
    value: function Hand_dropMorphsOn_(dropTarget) {
      var _this7 = this;

      this.grabbedMorphs.forEach(function (morph$$1) {
        dropTarget.addMorph(morph$$1);
        morph$$1.withAllSubmorphsDo(function (ea) {
          Object.assign(ea, _this7.prevMorphProps.get(ea));
        });
      });
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 40937,
    end: 42495
  });
}(Morph$1);

var Leash = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("Leash") && typeof __lively_classholder__.Leash === "function" ? __lively_classholder__.Leash : __lively_classholder__.Leash = function Leash(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function Leash_initialize_(props) {
      var start = props.start,
          end = props.end;

      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, Object.assign({
        borderWidth: 2,
        borderColor: lively_graphics.Color.black,
        fill: lively_graphics.Color.transparent
      }, props, {
        endpointStyle: Object.assign({
          fill: lively_graphics.Color.black,
          origin: lively_graphics.pt(3.5, 3.5),
          extent: lively_graphics.pt(10, 10),
          nativeCursor: "-webkit-grab"
        }, props.endpointStyle),
        vertices: [start, end]
      }));
      this.build();
      lively_bindings.connect(this, "extent", this, "relayout");
      lively_bindings.connect(this, "position", this, "relayout");
    }
  }, {
    key: "endpointStyle",
    get: function get() {
      return this._endpointStyle;
    }
  }, {
    key: "endpointStyle",
    set: function set(style) {
      this._endpointStyle = style;
      this.startPoint && Object.assign(this.startPoint, this.getEndpointStyle(0));
      this.endPoint && Object.assign(this.endPoint, this.getEndpointStyle(1));
    }
  }, {
    key: "remove",
    value: function Leash_remove_() {
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "remove", this).call(this);
      this.startPoint.clearConnection();
      this.endPoint.clearConnection();
    }
  }, {
    key: "onEndpointDrag",
    value: function Leash_onEndpointDrag_(endpoint, evt) {
      var v = endpoint.getVertex(),
          x = v.x,
          y = v.y;
      endpoint.setVertex(Object.assign({}, v, {}, lively_graphics.pt(x, y).addPt(evt.state.dragDelta)));
      this.relayout();
    }
  }, {
    key: "getEndpointStyle",
    value: function Leash_getEndpointStyle_(idx) {
      return Object.assign({}, this.endpointStyle, {}, idx == 0 ? this.endpointStyle.start : this.endpointStyle.end);
    }
  }, {
    key: "endpoint",
    value: function Leash_endpoint_(idx) {
      var leash = this,
          _leash$vertices$idx = leash.vertices[idx],
          x = _leash$vertices$idx.x,
          y = _leash$vertices$idx.y;
      return new Ellipse$$1(Object.assign({
        position: lively_graphics.pt(x, y),
        index: idx
      }, this.getEndpointStyle(idx), {
        onDrag: function onDrag(evt) {
          leash.onEndpointDrag(this, evt);
        },
        getConnectionPoint: function getConnectionPoint() {
          var _this = this;

          var _connectedMorph = this.connectedMorph,
              isPath = _connectedMorph.isPath,
              isPolygon = _connectedMorph.isPolygon,
              vertices = _connectedMorph.vertices,
              origin = _connectedMorph.origin,
              gb = this.connectedMorph.globalBounds();

          if ((isPath || isPolygon) && this.attachedSide != "center") {
            var _ret = function () {
              var vs = vertices.map(function (_ref) {
                var x = _ref.x,
                    y = _ref.y;
                return lively_graphics.pt(x, y).addPt(origin);
              }),
                  ib = lively_graphics.Rectangle.unionPts(vs),
                  side = ib[_this.attachedSide](),
                  center = ib.center().addPt(ib.center().subPt(side)),
                  line = svgIntersections.shape("line", {
                x1: side.x,
                y1: side.y,
                x2: center.x,
                y2: center.y
              }),
                  path = svgIntersections.shape("polyline", { points: vs.map(function (_ref2) {
                  var x = _ref2.x,
                      y = _ref2.y;
                  return x + "," + y;
                }).join(" ") }),
                  _arr$min = lively_lang.arr.min(svgIntersections.intersect(path, line).points, function (_ref3) {
                var x = _ref3.x,
                    y = _ref3.y;
                return lively_graphics.pt(x, y).dist(side);
              }),
                  x = _arr$min.x,
                  y = _arr$min.y;
              return {
                v: lively_graphics.pt(x, y).addPt(gb.topLeft())
              };
            }();

            if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
          } else {
            return gb[this.attachedSide]();
          }
        },
        update: function update(change) {
          var globalPos = this.getConnectionPoint(),
              pos = leash.localize(globalPos);
          this.setVertex(Object.assign({}, this.vertex, {}, pos));
        },
        clearConnection: function clearConnection() {
          if (this.connectedMorph) {
            lively_bindings.disconnect(this.connectedMorph, "extent", this, "update");
            lively_bindings.disconnect(this.connectedMorph, "position", this, "update");
          }
        },
        relayout: function relayout() {
          var _getVertex = this.getVertex(),
              x = _getVertex.x,
              y = _getVertex.y,
              bw = leash.borderWidth;

          this.center = lively_graphics.pt(x + bw, y + bw);
        },
        getVertex: function getVertex() {
          return leash.vertices[idx];
        },
        setVertex: function setVertex(v) {
          leash.vertices[idx] = v;
          leash.vertices = leash.vertices;
        },
        attachTo: function attachTo(morph$$1, side) {
          this.clearConnection();
          this.connectedMorph = morph$$1;
          this.attachedSide = side;
          this.vertex = Object.assign({}, leash.vertices[idx], { controlPoints: leash.controlPointsFor(side) });
          lively_bindings.connect(this.connectedMorph, "position", this, "update");
          lively_bindings.connect(this.connectedMorph, "extent", this, "update");
          this.update();
        }
      }));
    }
  }, {
    key: "controlPointsFor",
    value: function Leash_controlPointsFor_(side) {
      var next = {
        topCenter: lively_graphics.pt(0, -1),
        topLeft: lively_graphics.pt(1, -1),
        rightCenter: lively_graphics.pt(1, 0),
        bottomRight: lively_graphics.pt(1, 1),
        bottomCenter: lively_graphics.pt(0, 1),
        bottomLeft: lively_graphics.pt(-1, 1),
        leftCenter: lively_graphics.pt(-1, 0),
        topRight: lively_graphics.pt(-1, -1),
        center: lively_graphics.pt(0, 0)
      }[side];
      return {
        previous: next.negated().scaleBy(100),
        next: next.scaleBy(100)
      };
    }
  }, {
    key: "build",
    value: function Leash_build_() {
      this.submorphs = [this.startPoint = this.endpoint(0), this.endPoint = this.endpoint(1)];
    }
  }, {
    key: "relayout",
    value: function Leash_relayout_() {
      this.startPoint.relayout();
      this.endPoint.relayout();
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 397,
    end: 5098
  });
}(Path$1);
var Slider = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("Slider") && typeof __lively_classholder__.Slider === "function" ? __lively_classholder__.Slider : __lively_classholder__.Slider = function Slider(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function Slider_initialize_(props) {
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, Object.assign({
        height: 20,
        fill: lively_graphics.Color.transparent
      }, props));
      var slider = this;
      this.submorphs = [new Path$1({
        borderColor: lively_graphics.Color.gray.darker(),
        borderWidth: 2,
        vertices: [this.leftCenter.addXY(5, 0), this.rightCenter.addXY(-5, 0)]
      }), {
        type: "ellipse",
        fill: lively_graphics.Color.gray,
        name: "slideHandle",
        borderColor: lively_graphics.Color.gray.darker(),
        borderWidth: 1,
        dropShadow: { blur: 5 },
        extent: lively_graphics.pt(15, 15),
        nativeCursor: "grab",
        onDrag: function onDrag(evt) {
          slider.onSlide(this, evt.state.dragDelta);
        }
      }];
      lively_bindings.connect(this, "extent", this, "update");
      this.update();
    }
  }, {
    key: "normalize",
    value: function Slider_normalize_(v) {
      return Math.abs(v / (this.max - this.min));
    }
  }, {
    key: "update",
    value: function Slider_update_() {
      var x = (this.width - 15) * this.normalize(this.target[this.property]);
      this.get("slideHandle").center = lively_graphics.pt(x + 7.5, 12);
    }
  }, {
    key: "onSlide",
    value: function Slider_onSlide_(slideHandle, delta) {
      var oldValue = this.target[this.property],
          newValue = oldValue + delta.x / this.width;
      this.target[this.property] = Math.max(this.min, Math.min(this.max, newValue));
      this.update();
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 5107,
    end: 6474
  });
}(Morph$1);
var PropertyInspector = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("PropertyInspector") && typeof __lively_classholder__.PropertyInspector === "function" ? __lively_classholder__.PropertyInspector : __lively_classholder__.PropertyInspector = function PropertyInspector(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function PropertyInspector_initialize_(props) {
      var target = props.target,
          property = props.property;

      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, Object.assign({}, props, {
        morphClasses: ["root"],
        submorphs: [new ValueScrubber(Object.assign({
          name: "value",
          value: target[property]
        }, lively_lang.obj.dissoc(props, ["name"]))), {
          type: "button",
          name: "down",
          label: Icon$$1.makeLabel("sort-desc", {
            padding: lively_graphics.rect(2, 2, 0, 0),
            fontSize: 12
          })
        }, {
          type: "button",
          name: "up",
          label: Icon$$1.makeLabel("sort-asc", {
            padding: lively_graphics.rect(2, 2, 0, 0),
            fontSize: 12
          })
        }]
      }));
      this.build();
    }
  }, {
    key: "build",
    value: function PropertyInspector_build_() {
      this.styleRules = this.styler;
      this.initLayout();
      lively_bindings.connect(this.get("value"), "scrub", this.target, this.property);
      lively_bindings.connect(this.get("up"), "fire", this, "increment");
      lively_bindings.connect(this.get("down"), "fire", this, "decrement");
    }
  }, {
    key: "styler",
    get: function get() {
      var buttonStyle = {
        type: "button",
        clipMode: "hidden",
        activeStyle: {
          fill: lively_graphics.Color.transparent,
          borderWidth: 0,
          fontColor: lively_graphics.Color.white.darker()
        },
        triggerStyle: {
          fill: lively_graphics.Color.transparent,
          fontColor: lively_graphics.Color.black
        }
      };
      return new StyleRules({
        root: {
          extent: lively_graphics.pt(55, 25),
          borderRadius: 5,
          borderWidth: 1,
          borderColor: lively_graphics.Color.gray,
          clipMode: "hidden"
        },
        down: Object.assign({ padding: lively_graphics.rect(0, -5, 0, 10) }, buttonStyle),
        up: Object.assign({ padding: lively_graphics.rect(0, 0, 0, -5) }, buttonStyle),
        value: {
          fill: lively_graphics.Color.white,
          padding: lively_graphics.Rectangle.inset(4),
          fontSize: 15
        }
      });
    }
  }, {
    key: "update",
    value: function PropertyInspector_update_() {
      this.get("value").value = this.target[this.property];
    }
  }, {
    key: "increment",
    value: function PropertyInspector_increment_() {
      if (this.max != undefined && this.target[this.property] >= this.max) return;
      this.target[this.property] += 1;
      this.update();
    }
  }, {
    key: "decrement",
    value: function PropertyInspector_decrement_() {
      if (this.min != undefined && this.target[this.property] <= this.min) return;
      this.target[this.property] -= 1;
      this.update();
    }
  }, {
    key: "initLayout",
    value: function PropertyInspector_initLayout_() {
      var l = this.layout = new GridLayout$1({
        grid: [["value", "up"], ["value", "down"]]
      });
      l.col(1).paddingLeft = 5;
      l.col(1).paddingRight = 5;
      l.col(1).fixed = 25;
      return l;
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 6483,
    end: 8949
  });
}(Morph$1);
var ValueScrubber = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("ValueScrubber") && typeof __lively_classholder__.ValueScrubber === "function" ? __lively_classholder__.ValueScrubber : __lively_classholder__.ValueScrubber = function ValueScrubber(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function ValueScrubber_initialize_(props) {
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, Object.assign({
        fill: lively_graphics.Color.transparent,
        draggable: true,
        min: -Infinity,
        max: Infinity
      }, lively_lang.obj.dissoc(props, ["value"])));
      this.value = props.value || 0;
    }
  }, {
    key: "onKeyDown",
    value: function ValueScrubber_onKeyDown_(evt) {
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "onKeyDown", this).call(this, evt);
      if ("Enter" == evt.keyCombo) {
        var _textString$split = this.textString.split(" "),
            _textString$split2 = slicedToArray(_textString$split, 2),
            v = _textString$split2[0],
            unit = _textString$split2[1];

        if (v) {
          this.value = parseFloat(v);
          lively_bindings.signal(this, "scrub", this.scrubbedValue);
        }
        evt.stop();
      }
    }
  }, {
    key: "onDragStart",
    value: function ValueScrubber_onDragStart_(evt) {
      this.execCommand("toggle active mark");
      this.initPos = evt.position;
      this.factorLabel = new Tooltip$$1({ description: "1x" }).openInWorld(evt.hand.position.addXY(10, 10));
    }
  }, {
    key: "getScaleAndOffset",
    value: function ValueScrubber_getScaleAndOffset_(evt) {
      var _evt$position$subPt = evt.position.subPt(this.initPos),
          x = _evt$position$subPt.x,
          y = _evt$position$subPt.y,
          scale = lively_lang.num.roundTo(Math.exp(-y / this.world().height * 4), 0.01);

      return {
        offset: x,
        scale: scale
      };
    }
  }, {
    key: "onDrag",
    value: function ValueScrubber_onDrag_(evt) {
      var _getScaleAndOffset = this.getScaleAndOffset(evt),
          scale = _getScaleAndOffset.scale,
          offset = _getScaleAndOffset.offset,
          v = this.getCurrentValue(offset, scale);

      lively_bindings.signal(this, "scrub", v);
      this.textString = lively_lang.obj.safeToString(v);
      if (this.unit) this.textString += " " + this.unit;
      this.factorLabel.description = scale + "x";
      this.factorLabel.position = evt.hand.position.addXY(10, 10);
    }
  }, {
    key: "getCurrentValue",
    value: function ValueScrubber_getCurrentValue_(delta, s) {
      var v = this.scrubbedValue + Math.round(delta * s);
      return Math.max(this.min, Math.min(this.max, v));
    }
  }, {
    key: "onDragEnd",
    value: function ValueScrubber_onDragEnd_(evt) {
      var _getScaleAndOffset2 = this.getScaleAndOffset(evt),
          offset = _getScaleAndOffset2.offset,
          scale = _getScaleAndOffset2.scale;

      this.value = this.getCurrentValue(offset, scale);
      this.factorLabel.softRemove();
    }
  }, {
    key: "value",
    set: function set(v) {
      v = Math.max(this.min, Math.min(this.max, v));
      this.scrubbedValue = v;
      this.textString = lively_lang.obj.safeToString(v) || "";
      if (this.unit) this.textString += " " + this.unit;
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 8958,
    end: 10897
  });
}(Text$1);
var CheckBox = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("CheckBox") && typeof __lively_classholder__.CheckBox === "function" ? __lively_classholder__.CheckBox : __lively_classholder__.CheckBox = function CheckBox(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: "trigger",
    value: function CheckBox_trigger_() {
      try {
        this.checked = !this.checked;
        lively_bindings.signal(this, "toggle", this.checked);
      } catch (err) {
        var w = this.world();
        if (w) w.logError(err);else console.error(err);
      }
    }
  }, {
    key: "onMouseDown",
    value: function CheckBox_onMouseDown_(evt) {
      if (this.active) this.trigger();
    }
  }, {
    key: "render",
    value: function CheckBox_render_(renderer) {
      return renderer.renderCheckBox(this);
    }
  }], [{
    key: "properties",
    get: function get() {
      return {
        draggable: { defaultValue: false },
        extent: { defaultValue: lively_graphics.pt(15, 15) },
        borderWidth: { defaultValue: 0 },
        active: { defaultValue: true },
        checked: { defaultValue: false },
        fill: { defaultValue: lively_graphics.Color.transparent },
        nativeCursor: { defaultValue: "pointer" }
      };
    }
  }], __lively_classholder__, undefined, {
    start: 10906,
    end: 11633
  });
}(Morph$1);
var LabeledCheckBox = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("LabeledCheckBox") && typeof __lively_classholder__.LabeledCheckBox === "function" ? __lively_classholder__.LabeledCheckBox : __lively_classholder__.LabeledCheckBox = function LabeledCheckBox(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function LabeledCheckBox_initialize_(props) {
      var _this2 = this;

      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, props);
      lively_bindings.connect(this, "alignCheckBox", this, "relayout");
      lively_bindings.connect(this.labelMorph, "value", this, "relayout");
      lively_bindings.connect(this.checkboxMorph, "checked", this, "checked");
      this.relayout();
      setTimeout(function () {
        return _this2.relayout();
      }, 0);
    }
  }, {
    key: "relayout",
    value: function LabeledCheckBox_relayout_() {
      var l = this.labelMorph,
          cb = this.checkboxMorph;
      if (this.alignCheckBox === "left") {
        cb.leftCenter = lively_graphics.pt(0, l.height / 2);
        l.leftCenter = cb.rightCenter;
      } else {
        l.position = lively_graphics.pt(0, 0);
        cb.leftCenter = lively_graphics.pt(l.width, l.height / 2);
      }
      this.extent = this.submorphBounds().extent();
    }
  }, {
    key: "trigger",
    value: function LabeledCheckBox_trigger_() {
      this.checkboxMorph.trigger();
    }
  }, {
    key: "onMouseDown",
    value: function LabeledCheckBox_onMouseDown_(evt) {
      if (this.active) this.trigger();
      evt.stop();
    }
  }], [{
    key: "example",
    value: function LabeledCheckBox_example_() {
      var cb = new LabeledCheckBox({ label: "foo" }).openInWorld();
    }
  }, {
    key: "properties",
    get: function get() {
      return {
        name: { defaultValue: "LabeledCheckBox" },
        alignCheckBox: { defaultValue: "left" },
        label: {
          defaultValue: "label",
          after: ["submorphs"],
          derived: true,
          get: function get() {
            return this.labelMorph.value;
          },
          set: function set(value) {
            this.labelMorph.value = value;
          }
        },
        checked: {
          after: ["submorphs"],
          derived: true,
          get: function get() {
            return this.checkboxMorph.checked;
          },
          set: function set(value) {
            this.checkboxMorph.checked = value;
            lively_bindings.signal(this, "checked", value);
          }
        },
        active: {
          after: ["submorphs"],
          derived: true,
          get: function get() {
            return this.checkboxMorph.active;
          },
          set: function set(value) {
            this.checkboxMorph.active;
          }
        },
        labelMorph: {
          derived: true,
          readOnly: true,
          get: function get() {
            return this.getSubmorphNamed("label");
          }
        },
        checkboxMorph: {
          derived: true,
          readOnly: true,
          get: function get() {
            return this.getSubmorphNamed("checkbox");
          }
        },
        submorphs: {
          initialize: function initialize() {
            this.submorphs = [new CheckBox({ name: "checkbox" }), new Label$$1({
              nativeCursor: "pointer",
              name: "label",
              padding: lively_graphics.Rectangle.inset(3, 0)
            })];
          }
        }
      };
    }
  }], __lively_classholder__, undefined, {
    start: 11642,
    end: 13821
  });
}(Morph$1);
var ModeSelector = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("ModeSelector") && typeof __lively_classholder__.ModeSelector === "function" ? __lively_classholder__.ModeSelector : __lively_classholder__.ModeSelector = function ModeSelector(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function ModeSelector_initialize_(props) {
      var _this3 = this;

      var items = props.items,
          init = props.init,
          _props$tooltips = props.tooltips,
          tooltips = _props$tooltips === undefined ? {} : _props$tooltips,
          keys,
          values;

      if (lively_lang.obj.isArray(items)) {
        keys = values = items;
      } else {
        keys = lively_lang.obj.keys(items);
        values = lively_lang.obj.values(items);
      }
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, Object.assign({
        keys: keys,
        values: values,
        tooltips: tooltips,
        morphClasses: ["root"],
        layout: new GridLayout$1({
          grid: [[].concat(toConsumableArray(lively_lang.arr.interpose(keys.map(function (k) {
            return k + "Label";
          }), null)))],
          autoAssign: false,
          fitToCell: true
        })
      }, props));
      this.build();
      this.update(init ? init : keys[0], values[keys.includes(init) ? keys.indexOf(init) : 0], true);
      lively_bindings.connect(this, "extent", this, "relayout");
      this.whenRendered().then(function () {
        _this3.withAllSubmorphsDo(function (ea) {
          if (ea.isLabel) {
            ea._cachedTextBounds = null;
            ea.fit();
          }
        });
      });
    }
  }, {
    key: "build",
    value: function ModeSelector_build_() {
      this.submorphs = [{ name: "typeMarker" }].concat(toConsumableArray(this.createLabels(this.keys, this.values, this.tooltips)));
      this.layout.col(0).row(0).group.align = "topCenter";
      this.layout.col(2).row(0).group.align = "topCenter";
      this.applyStyler();
    }
  }, {
    key: "applyStyler",
    value: function ModeSelector_applyStyler_() {
      var _this4 = this;

      this.withAllSubmorphsDo(function (m) {
        var styleProps;
        if (styleProps = _this4.styler[m.name]) {
          Object.assign(m, styleProps);
        } else if (m.morphClasses) {
          styleProps = lively_lang.obj.merge(lively_lang.arr.compact(m.morphClasses.map(function (c) {
            return _this4.styler[c];
          })));
          Object.assign(m, styleProps);
        }
      });
    }
  }, {
    key: "styler",
    get: function get() {
      return {
        root: {
          fill: lively_graphics.Color.transparent,
          height: 30,
          origin: lively_graphics.pt(0, 5)
        },
        typeMarker: {
          fill: lively_graphics.Color.gray.darker(),
          borderRadius: 3
        },
        label: {
          fontWeight: "bold",
          nativeCursor: "pointer",
          padding: lively_graphics.Rectangle.inset(4)
        }
      };
    }
  }, {
    key: "createLabels",
    value: function ModeSelector_createLabels_(keys, values) {
      var _this5 = this;

      var tooltips = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      return lively_lang.arr.zip(keys, values).map(function (_ref4) {
        var _ref5 = slicedToArray(_ref4, 2),
            name = _ref5[0],
            value = _ref5[1];

        var tooltip = tooltips[name];
        return Object.assign({
          name: name + "Label",
          morphClasses: ["label"],
          type: "label",
          value: name
        }, _this5.labelStyle, {}, tooltip && { tooltip: tooltip }, {
          onMouseDown: function onMouseDown(evt) {
            _this5.update(name, value);
          }
        });
      });
    }
  }, {
    key: "relayout",
    value: function () {
      var _ref6 = asyncToGenerator(regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", this.currentLabel && this.get("typeMarker").animate({
                  bounds: this.currentLabel.bounds(),
                  duration: 200
                }));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function ModeSelector_relayout_() {
        return _ref6.apply(this, arguments);
      }

      return ModeSelector_relayout_;
    }()
  }, {
    key: "update",
    value: function () {
      var _ref7 = asyncToGenerator(regeneratorRuntime.mark(function _callee2(label, value) {
        var silent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var newLabel, duration;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                newLabel = this.get(label + "Label"), duration = 200;

                if (!(newLabel == this.currentLabel)) {
                  _context2.next = 3;
                  break;
                }

                return _context2.abrupt("return");

              case 3:
                if (this.currentLabel) this.currentLabel.fontColor = lively_graphics.Color.black;
                this.currentLabel = newLabel;
                newLabel.fontColor = lively_graphics.Color.white;
                _context2.next = 8;
                return this.relayout(duration);

              case 8:
                !silent && lively_bindings.signal(this, label, value);
                !silent && lively_bindings.signal(this, "switchLabel", value);

              case 10:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function ModeSelector_update_(_x2, _x3) {
        return _ref7.apply(this, arguments);
      }

      return ModeSelector_update_;
    }()
  }], [{
    key: "example",
    value: function ModeSelector_example_() {
      var cb = new ModeSelector({ items: { foo: {} } }).openInWorld();
    }
  }], __lively_classholder__, undefined, {
    start: 13830,
    end: 16804
  });
}(Morph$1);
var DropDownSelector = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("DropDownSelector") && typeof __lively_classholder__.DropDownSelector === "function" ? __lively_classholder__.DropDownSelector : __lively_classholder__.DropDownSelector = function DropDownSelector(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function DropDownSelector_initialize_(props) {
      var target = props.target,
          property = props.property,
          values = props.values;

      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, Object.assign({
        border: {
          radius: 3,
          color: lively_graphics.Color.gray.darker(),
          style: "solid"
        },
        layout: new HorizontalLayout({ spacing: 4 })
      }, props));
      this.build();
    }
  }, {
    key: "build",
    value: function DropDownSelector_build_() {
      this.dropDownLabel = Icon$$1.makeLabel("chevron-circle-down", {
        opacity: 0,
        fontSize: 16,
        fontColor: lively_graphics.Color.gray.darker()
      });
      this.submorphs = [{
        type: "text",
        name: "currentValue",
        textString: this.getNameFor(this.target[this.property]),
        padding: lively_graphics.Rectangle.inset(0),
        readOnly: true
      }, this.dropDownLabel];
    }
  }, {
    key: "getMenuEntries",
    value: function DropDownSelector_getMenuEntries_() {
      var _this6 = this;

      var currentValue = this.getNameFor(this.target[this.property]);
      return [{
        command: currentValue,
        target: this
      }].concat(toConsumableArray(lively_lang.arr.compact(this.commands.map(function (c) {
        return c.name != currentValue && {
          command: c.name,
          target: _this6
        };
      }))));
    }
  }, {
    key: "commands",
    get: function get() {
      var _this7 = this;

      if (lively_lang.obj.isArray(this.values)) {
        return this.values.map(function (v) {
          return {
            name: v,
            exec: function exec() {
              _this7.value = v;
            }
          };
        });
      } else {
        return lively_lang.properties.forEachOwn(this.values, function (name, v) {
          return {
            name: name,
            exec: function exec() {
              _this7.value = v;
            }
          };
        });
      }
    }
  }, {
    key: "getNameFor",
    value: function DropDownSelector_getNameFor_(value) {
      if (this.getCurrentValue) return this.getCurrentValue();
      if (lively_lang.obj.isArray(this.values)) {
        return lively_lang.obj.safeToString(value);
      } else {
        return lively_lang.obj.safeToString(lively_lang.properties.nameFor(this.values, value));
      }
    }
  }, {
    key: "value",
    set: function set(v) {
      if (lively_lang.obj.isFunction(v)) {
        v();
      } else {
        this.target[this.property] = v;
      }
      this.get("currentValue").textString = this.getNameFor(v);
    }
  }, {
    key: "onHoverIn",
    value: function DropDownSelector_onHoverIn_() {
      this.dropDownLabel.animate({
        opacity: 1,
        duration: 300
      });
    }
  }, {
    key: "onHoverOut",
    value: function DropDownSelector_onHoverOut_() {
      this.dropDownLabel.animate({
        opacity: 0,
        duration: 200
      });
    }
  }, {
    key: "onMouseDown",
    value: function DropDownSelector_onMouseDown_(evt) {
      this.menu = this.world().openWorldMenu(evt, this.getMenuEntries());
      this.menu.globalPosition = this.globalPosition;
      this.menu.isHaloItem = this.isHaloItem;
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 16813,
    end: 19042
  });
}(Morph$1);

var AxisHalo = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("AxisHalo") && typeof __lively_classholder__.AxisHalo === "function" ? __lively_classholder__.AxisHalo : __lively_classholder__.AxisHalo = function AxisHalo(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function AxisHalo_initialize_(_ref) {
      var halo = _ref.halo,
          targetAxis = _ref.targetAxis;

      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, {
        fill: lively_graphics.Color.transparent,
        halo: halo,
        targetAxis: targetAxis,
        container: halo.container
      });
      this.initialize();
    }
  }, {
    key: "initialize",
    value: function AxisHalo_initialize_() {
      this.setBounds(this.fetchBounds());
      this.minSlider = this.minSlider(), this.axisMenu = this.axisMenu(), this.proportionSlider = this.proportionSlider();
      this.proportionSlider.addMorph(this.minSlider);
      this.submorphs = [this.proportionSlider, this.axisMenu];
      this.halo.addGuide(this);
    }
  }, {
    key: "forceMenuHidden",
    set: function set(hidden) {
      this._forceMenuHidden = hidden;
      this.axisMenu.visible = !hidden;
    }
  }, {
    key: "forceMenuHidden",
    get: function get() {
      return this._forceMenuHidden;
    }
  }, {
    key: "lastAxis",
    get: function get() {
      return !this.targetAxis.after;
    }
  }, {
    key: "fetchBounds",
    value: function AxisHalo_fetchBounds_() {
      return this.fetchPosition().extent(this.fetchExtent());
    }
  }, {
    key: "alignWithTarget",
    value: function AxisHalo_alignWithTarget_() {
      this.extent = this.fetchExtent();
      this.position = this.fetchPosition();
      this.proportionSlider.alignWithTarget();
      this.axisMenu.alignWithTarget();
    }
  }, {
    key: "onHoverIn",
    value: function AxisHalo_onHoverIn_() {
      this.minSlider.requestToShow();
      this.axisMenu.visible = !this.forceMenuHidden && true;
    }
  }, {
    key: "onHoverOut",
    value: function AxisHalo_onHoverOut_(evt) {
      this.minSlider.requestToHide();
      this.axisMenu.visible = this.forceMenuVisible || false;
    }
  }, {
    key: "proportionSlider",
    value: function AxisHalo_proportionSlider_() {
      var _this = this;

      var self = this,
          proportionViewer = this.proportionViewer();
      return this.halo.addGuide(new Morph$1({
        nativeCursor: this.getResizeCursor(),
        fill: lively_graphics.Color.transparent,
        submorphs: [this.devider(), proportionViewer],
        alignWithTarget: function alignWithTarget() {
          this.setBounds(self.getProportionSliderBounds(this));
        },
        onDragStart: function onDragStart() {
          proportionViewer.visible = true;
        },

        onDrag: function onDrag(evt) {
          _this.targetAxis.adjustStretch(_this.getDelta(evt));
          self.halo.alignWithTarget();
        },
        onDragEnd: function onDragEnd() {
          proportionViewer.visible = false;
        }
      }));
    }
  }, {
    key: "devider",
    value: function AxisHalo_devider_() {
      return new Morph$1({
        visible: !this.lastAxis,
        fill: lively_graphics.Color.black.withA(0.5),
        bounds: this.getDeviderBounds(),
        draggable: false,
        reactsToPointer: false
      });
    }
  }, {
    key: "minSlider",
    value: function AxisHalo_minSlider_() {
      var _this2 = this;

      var self = this,
          minSpaceVisualizer = this.minSpaceVisualizer(),
          minViewer = this.minViewer();
      return this.halo.addGuide(new Ellipse$$1({
        nativeCursor: this.getResizeCursor(),
        fill: lively_graphics.Color.green,
        extent: lively_graphics.pt(10, 10),
        visible: false,
        submorphs: [minSpaceVisualizer, minViewer],
        becomesActiveOnHover: true,
        alignWithTarget: function alignWithTarget() {
          this.position = self.getMinSliderPosition();
        },
        requestToShow: function requestToShow() {
          this.visible = !self.targetAxis.fixed;
        },
        requestToHide: function requestToHide() {
          if (this.active) {
            this.shouldHide = true;
          } else {
            this.visible = false;
          }
        },
        onDragStart: function onDragStart() {
          self.forceMenuHidden = true;
          minViewer.visible = true;
          minSpaceVisualizer.visible = true;
          this.active = true;
        },

        onDrag: function onDrag(evt) {
          _this2.targetAxis.adjustMin(-_this2.getDelta(evt));
          _this2.halo.alignWithTarget();
        },
        onDragEnd: function onDragEnd() {
          self.forceMenuHidden = false;
          minViewer.visible = false;
          minSpaceVisualizer.visible = false;
          this.active = false;
          if (this.shouldHide) {
            this.visible = false;
            this.shouldHide = false;
          }
        }
      }));
    }
  }, {
    key: "minViewer",
    value: function AxisHalo_minViewer_() {
      var gridLayout = this.target,
          self = this;
      return this.viewer({
        position: this.getMinViewerPosition(),
        alignWithTarget: function alignWithTarget() {
          var min = self.targetAxis.min;

          this.textString = "min: " + min.toFixed() + "px !";
        }
      });
    }
  }, {
    key: "minSpaceBorder",
    value: function AxisHalo_minSpaceBorder_() {
      return new Path$1(Object.assign({
        position: lively_graphics.pt(-1, -1),
        borderStyle: "dashed",
        borderColor: lively_graphics.Color.green,
        borderWidth: 2
      }, this.getMinSpaceBorder()));
    }
  }, {
    key: "minSpaceVisualizer",
    value: function AxisHalo_minSpaceVisualizer_() {
      var self = this,
          minSpaceBorder = this.minSpaceBorder();
      return this.halo.addGuide(new Morph$1({
        fill: lively_graphics.Color.green.withA(0.1),
        visible: false,
        isHaloItem: true,
        submorphs: [minSpaceBorder],
        alignWithTarget: function alignWithTarget() {
          this.extent = self.getMinSpaceExtent();
          this.topLeft = lively_graphics.pt(5, 5);
        }
      }));
    }
  }, {
    key: "axisMenu",
    value: function AxisHalo_axisMenu_() {
      var lockButton = this.lockButton(),
          menuButton = this.menuButton(),
          self = this;
      return new Morph$1({
        layout: this.getMenuLayout(),
        submorphs: [lockButton, menuButton],
        fill: lively_graphics.Color.transparent,
        visible: false,
        becomesActiveOnHover: true,
        alignWithTarget: function alignWithTarget() {
          this.bottomRight = this.owner.extent.subPt(self.getMenuOffset(this));
        }
      });
    }
  }, {
    key: "lockButton",
    value: function AxisHalo_lockButton_() {
      var self = this;
      return this.halo.addGuide(new Morph$1({
        fill: lively_graphics.Color.transparent,
        extent: lively_graphics.pt(25, 25),
        submorphs: [{
          center: lively_graphics.pt(12.5, 12.5),
          fill: lively_graphics.Color.transparent,
          styleClasses: ["fa", "fa-unlock"]
        }],
        alignWithTarget: function alignWithTarget() {
          if (self.targetAxis.fixed) {
            this.fontColor = lively_graphics.Color.red;
            this.submorphs[0].styleClasses = ["fa", "fa-lock"];
          } else {
            this.fontColor = lively_graphics.Color.green;
            this.submorphs[0].styleClasses = ["fa", "fa-unlock"];
          }
        },
        onMouseDown: function onMouseDown() {
          this.toggleLock();
        },
        toggleLock: function toggleLock() {
          self.targetAxis.fixed = !self.targetAxis.fixed;
          self.halo.alignWithTarget();
        }
      }));
    }
  }, {
    key: "menuButton",
    value: function AxisHalo_menuButton_() {
      var _this3 = this;

      var self = this,
          remove = function remove() {
        _this3.targetAxis.remove();
        _this3.halo.initGuides();
        _this3.halo.alignWithTarget();
      },
          addBefore = function addBefore() {
        _this3.targetAxis.addBefore();
        _this3.halo.initGuides();
        _this3.halo.alignWithTarget();
      },
          addAfter = function addAfter() {
        _this3.targetAxis.addAfter();
        _this3.halo.initGuides();
        _this3.halo.alignWithTarget();
      };
      return new Morph$1({
        fill: lively_graphics.Color.transparent,
        extent: lively_graphics.pt(25, 25),
        submorphs: [{
          fill: lively_graphics.Color.transparent,
          styleClasses: ["fa", "fa-cog"],
          center: lively_graphics.pt(12.5, 12.5)
        }],
        onMouseDown: function onMouseDown(evt) {
          self.forceMenuVisible = true;
          this.addMorph(evt.state.menu = new Menu$$1({
            position: lively_graphics.pt(15, 15),
            items: [["Remove " + self.subject, function () {
              return remove();
            }], ["Insert " + self.subject + " before", function () {
              return addBefore();
            }], ["Insert " + self.subject + " after", function () {
              return addAfter();
            }]]
          }));
        }
      });
    }
  }, {
    key: "viewer",
    value: function AxisHalo_viewer_(_ref2) {
      var position = _ref2.position,
          alignWithTarget = _ref2.alignWithTarget;

      return this.halo.addGuide(new Text$1({
        styleClasses: ["Halo"],
        padding: lively_graphics.Rectangle.inset(6),
        visible: false,
        borderRadius: 10,
        fontColor: lively_graphics.Color.white,
        fill: lively_graphics.Color.black.withA(0.5),
        position: position,
        alignWithTarget: alignWithTarget,
        readOnly: true
      }));
    }
  }, {
    key: "proportionViewer",
    value: function AxisHalo_proportionViewer_() {
      var self = this;
      return this.viewer({
        position: this.getProportionViewerPosition(),
        alignWithTarget: function alignWithTarget() {
          var length = self.targetAxis.length;

          this.textString = length.toFixed(1) + "px";
        }
      });
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 393,
    end: 8477
  });
}(Morph$1);
var RowHalo = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("RowHalo") && typeof __lively_classholder__.RowHalo === "function" ? __lively_classholder__.RowHalo : __lively_classholder__.RowHalo = function RowHalo(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function RowHalo_initialize_(_ref3) {
      var row = _ref3.row,
          halo = _ref3.halo;

      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, {
        targetAxis: halo.target.row(row),
        halo: halo
      });
    }
  }, {
    key: "subject",
    get: function get() {
      return "row";
    }
  }, {
    key: "getDelta",
    value: function RowHalo_getDelta_(evt) {
      return evt.state.dragDelta.y;
    }
  }, {
    key: "axisOffset",
    value: function RowHalo_axisOffset_() {
      return this.targetAxis.origin.position.y;
    }
  }, {
    key: "fetchPosition",
    value: function RowHalo_fetchPosition_() {
      return lively_graphics.pt(-45, this.axisOffset() + 10);
    }
  }, {
    key: "fetchExtent",
    value: function RowHalo_fetchExtent_() {
      return lively_graphics.pt(40, this.targetAxis.length - 10);
    }
  }, {
    key: "getMenuOffset",
    value: function RowHalo_getMenuOffset_(menu) {
      return this.targetAxis.length > menu.height ? lively_graphics.pt(2, 5) : lively_graphics.pt(26, 10);
    }
  }, {
    key: "getMenuLayout",
    value: function RowHalo_getMenuLayout_() {
      return new VerticalLayout();
    }
  }, {
    key: "getResizeCursor",
    value: function RowHalo_getResizeCursor_() {
      return "row-resize";
    }
  }, {
    key: "getMinViewerPosition",
    value: function RowHalo_getMinViewerPosition_() {
      return lively_graphics.pt(50, 20);
    }
  }, {
    key: "getMinSliderPosition",
    value: function RowHalo_getMinSliderPosition_() {
      return lively_graphics.pt(0, -this.targetAxis.min);
    }
  }, {
    key: "getMinSpaceExtent",
    value: function RowHalo_getMinSpaceExtent_() {
      return lively_graphics.pt(this.container.width + 45, this.targetAxis.min);
    }
  }, {
    key: "getMinSpaceBorder",
    value: function RowHalo_getMinSpaceBorder_() {
      return {
        extent: lively_graphics.pt(this.container.width + 50, 2),
        vertices: [lively_graphics.pt(0, 1), lively_graphics.pt(this.container.width + 50, 1)]
      };
    }
  }, {
    key: "getProportionViewerPosition",
    value: function RowHalo_getProportionViewerPosition_() {
      return lively_graphics.pt(40, 20);
    }
  }, {
    key: "getProportionSliderBounds",
    value: function RowHalo_getProportionSliderBounds_(slider) {
      return lively_graphics.pt(0, slider.owner.height - 5).extent(lively_graphics.pt(40, 10));
    }
  }, {
    key: "getDeviderBounds",
    value: function RowHalo_getDeviderBounds_() {
      return lively_graphics.pt(15, 4).extent(lively_graphics.pt(25, 2));
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 8479,
    end: 9627
  });
}(AxisHalo);
var ColumnHalo = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("ColumnHalo") && typeof __lively_classholder__.ColumnHalo === "function" ? __lively_classholder__.ColumnHalo : __lively_classholder__.ColumnHalo = function ColumnHalo(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function ColumnHalo_initialize_(_ref4) {
      var col = _ref4.col,
          halo = _ref4.halo;

      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, {
        targetAxis: halo.target.col(col),
        halo: halo
      });
    }
  }, {
    key: "subject",
    get: function get() {
      return "column";
    }
  }, {
    key: "getDelta",
    value: function ColumnHalo_getDelta_(evt) {
      return evt.state.dragDelta.x;
    }
  }, {
    key: "axisOffset",
    value: function ColumnHalo_axisOffset_() {
      return this.targetAxis.origin.position.x;
    }
  }, {
    key: "fetchPosition",
    value: function ColumnHalo_fetchPosition_() {
      return lively_graphics.pt(this.axisOffset() + 10, -45);
    }
  }, {
    key: "fetchExtent",
    value: function ColumnHalo_fetchExtent_() {
      return lively_graphics.pt(this.targetAxis.length - 10, 40);
    }
  }, {
    key: "getMenuOffset",
    value: function ColumnHalo_getMenuOffset_(menu) {
      return this.targetAxis.length > menu.width ? lively_graphics.pt(5, 3) : lively_graphics.pt(8, 26);
    }
  }, {
    key: "getMenuLayout",
    value: function ColumnHalo_getMenuLayout_() {
      return new HorizontalLayout();
    }
  }, {
    key: "getResizeCursor",
    value: function ColumnHalo_getResizeCursor_() {
      return "col-resize";
    }
  }, {
    key: "getMinViewerPosition",
    value: function ColumnHalo_getMinViewerPosition_() {
      return lively_graphics.pt(20, 50);
    }
  }, {
    key: "getMinSliderPosition",
    value: function ColumnHalo_getMinSliderPosition_() {
      return lively_graphics.pt(-this.targetAxis.min, 0);
    }
  }, {
    key: "getMinSpaceExtent",
    value: function ColumnHalo_getMinSpaceExtent_() {
      return lively_graphics.pt(this.targetAxis.min, this.container.height + 45);
    }
  }, {
    key: "getMinSpaceBorder",
    value: function ColumnHalo_getMinSpaceBorder_() {
      return {
        extent: lively_graphics.pt(2, this.container.height + 50),
        vertices: [lively_graphics.pt(1, 0), lively_graphics.pt(1, this.container.height + 50)]
      };
    }
  }, {
    key: "getProportionViewerPosition",
    value: function ColumnHalo_getProportionViewerPosition_() {
      return lively_graphics.pt(20, 40);
    }
  }, {
    key: "getProportionSliderBounds",
    value: function ColumnHalo_getProportionSliderBounds_(slider) {
      return lively_graphics.pt(slider.owner.width - 5, 0).extent(lively_graphics.pt(10, 40));
    }
  }, {
    key: "getDeviderBounds",
    value: function ColumnHalo_getDeviderBounds_() {
      return lively_graphics.pt(4, 15).extent(lively_graphics.pt(2, 25));
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 9629,
    end: 10785
  });
}(AxisHalo);
var GridLayoutHalo = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("GridLayoutHalo") && typeof __lively_classholder__.GridLayoutHalo === "function" ? __lively_classholder__.GridLayoutHalo : __lively_classholder__.GridLayoutHalo = function GridLayoutHalo(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function GridLayoutHalo_initialize_(container, pointerId) {
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, {
        styleClasses: ["Halo"],
        borderColor: lively_graphics.Color.orange,
        borderWidth: 2,
        borderRadius: container.borderRadius,
        extent: container.extent,
        fill: lively_graphics.Color.transparent,
        state: {
          container: container,
          pointerId: pointerId,
          target: container.layout
        }
      });
      this.initialize();
    }
  }, {
    key: "initialize",
    value: function GridLayoutHalo_initialize_() {
      this.initGuides();
      this.alignWithTarget();
      this.focus();
    }
  }, {
    key: "optionControls",
    value: function GridLayoutHalo_optionControls_() {
      var layout = this.target,
          compensateOrigin = new CheckBox({
        name: "compensateOrigin",
        checked: layout.compensateOrigin
      }),
          fitToCell = new CheckBox({
        name: "fitToCell",
        checked: layout.fitToCell
      });
      lively_bindings.connect(compensateOrigin, "toggle", layout, "compensateOrigin");
      lively_bindings.connect(fitToCell, "toggle", layout, "fitToCell");
      lively_bindings.connect(compensateOrigin, "toggle", this, "alignWithTarget");
      return [[{
        type: "text",
        textString: "Compensate Origin",
        padding: lively_graphics.rect(5, 0, 10, 10),
        fill: lively_graphics.Color.transparent,
        fontColor: lively_graphics.Color.gray.darker(),
        readOnly: true
      }, compensateOrigin], [{
        type: "text",
        textString: "Fit morphs to cell",
        padding: lively_graphics.rect(5, 0, 10, 10),
        fill: lively_graphics.Color.transparent,
        fontColor: lively_graphics.Color.gray.darker(),
        readOnly: true
      }, fitToCell]].map(function (x) {
        return {
          submorphs: x,
          fill: lively_graphics.Color.transparent,
          layout: new HorizontalLayout({ spacing: 3 })
        };
      });
    }
  }, {
    key: "isLayoutHalo",
    get: function get() {
      return false;
    }
  }, {
    key: "container",
    get: function get() {
      return this.state.container;
    }
  }, {
    key: "target",
    get: function get() {
      return this.state.target;
    }
  }, {
    key: "alignWithTarget",
    value: function GridLayoutHalo_alignWithTarget_() {
      this.target.apply();
      this.position = this.container.globalPosition;
      if (this.target.compensateOrigin) this.moveBy(this.container.origin.negated());
      this.extent = this.container.extent;
      this.addMissingGuides();
      lively_lang.arr.reverse(this.guides).forEach(function (guide) {
        return guide.alignWithTarget();
      });
    }
  }, {
    key: "addMissingGuides",
    value: function GridLayoutHalo_addMissingGuides_() {
      var _this4 = this;

      lively_lang.arr.withoutAll(this.target.cellGroups, this.guides.map(function (g) {
        return g.cellGroup;
      })).forEach(function (group) {
        return _this4.addMorph(_this4.cellGuide(group));
      });
    }
  }, {
    key: "initGuides",
    value: function GridLayoutHalo_initGuides_() {
      this.submorphs = [];
      this.guides = [];
      this.initCellGuides();
      this.initColumnGuides();
      this.initRowGuides();
    }
  }, {
    key: "cells",
    get: function get() {
      return lively_lang.arr.flatten(this.target.col(0).items.map(function (c) {
        return c.row(0).items;
      }));
    }
  }, {
    key: "initCellGuides",
    value: function GridLayoutHalo_initCellGuides_() {
      var _this5 = this;

      var cellContainer = this.addMorph({
        fill: lively_graphics.Color.transparent,
        borderRadius: this.borderRadius,
        extent: this.extent,
        clipMode: "hidden"
      });
      this.target.cellGroups.forEach(function (group) {
        cellContainer.addMorph(_this5.cellGuide(group));
      });
      this.addMorph(this.resizer());
    }
  }, {
    key: "addGuide",
    value: function GridLayoutHalo_addGuide_(guide) {
      guide.isHaloItem = true;
      this.guides.push(guide);
      return guide;
    }
  }, {
    key: "initRowGuides",
    value: function GridLayoutHalo_initRowGuides_() {
      var _this6 = this;

      var self = this;
      this.addGuide(this.addMorph(new Morph$1({
        width: 25,
        fill: lively_graphics.Color.gray.withA(0.7),
        borderRadius: 15,
        height: this.container.height,
        topRight: lively_graphics.pt(-5, 0),
        alignWithTarget: function alignWithTarget() {
          this.height = self.container.height;
        }
      })));
      lively_lang.arr.range(0, this.target.rowCount - 1).forEach(function (row) {
        _this6.addMorph(new RowHalo({
          row: row,
          halo: _this6
        }));
      });
    }
  }, {
    key: "initColumnGuides",
    value: function GridLayoutHalo_initColumnGuides_() {
      var _this7 = this;

      var self = this;
      this.addGuide(this.addMorph(new Morph$1({
        height: 25,
        fill: lively_graphics.Color.gray.withA(0.7),
        borderRadius: 15,
        width: this.container.width,
        bottomLeft: lively_graphics.pt(0, -5),
        alignWithTarget: function alignWithTarget() {
          this.width = self.container.width;
        }
      })));
      lively_lang.arr.range(0, this.target.columnCount - 1).forEach(function (col) {
        _this7.addMorph(new ColumnHalo({
          col: col,
          halo: _this7
        }));
      });
    }
  }, {
    key: "resizer",
    value: function GridLayoutHalo_resizer_() {
      var self = this;
      return this.addGuide(new Morph$1({
        fill: lively_graphics.Color.transparent,
        extent: lively_graphics.pt(25, 25),
        nativeCursor: "nwse-resize",
        onDrag: function onDrag(evt) {
          self.container.resizeBy(evt.state.dragDelta);
          self.alignWithTarget();
        },
        alignWithTarget: function alignWithTarget() {
          this.bottomRight = self.extent;
        }
      }));
    }
  }, {
    key: "cellResizer",
    value: function GridLayoutHalo_cellResizer_(cellGroup, corner) {
      var self = this,
          adjacentCorner = corner == "topLeft" ? "bottomRight" : "topLeft",
          getCorner = function getCorner(c) {
        return cellGroup.bounds().partNamed(c);
      };
      return new Ellipse$$1({
        borderWidth: 1,
        visible: false,
        borderColor: lively_graphics.Color.black,
        nativeCursor: "nwse-resize",
        removeCell: function removeCell(cell) {
          cellGroup.disconnect(cell);
          self.alignWithTarget();
        },
        addCell: function addCell(cell) {
          cellGroup.connect(cell);
          self.alignWithTarget();
        },
        start: function start() {
          this.fixpointCell = cellGroup[adjacentCorner];
          this.draggedDelta = getCorner(corner);
          this.debugMorph = self.addMorph(new Morph$1({ fill: lively_graphics.Color.orange.withA(0.5) }));
        },
        update: function update(delta) {
          var _this8 = this;

          this.draggedDelta = this.draggedDelta.addPt(delta);
          var coveringRect = lively_graphics.Rectangle.unionPts([this.draggedDelta]).union(this.fixpointCell.bounds());
          this.debugMorph.setBounds(coveringRect);
          self.cells.forEach(function (cell) {
            var coverage = coveringRect.intersection(cell.bounds()).area() / cell.bounds().area();
            if (cellGroup.includes(cell) && coverage < 0.1) _this8.removeCell(cell);
            if (!cellGroup.includes(cell) && coverage > 1 / 3) _this8.addCell(cell);
          });
        },
        onDragEnd: function onDragEnd(evt) {
          this.debugMorph.remove();
        },
        onDragStart: function onDragStart(evt) {
          this.start(evt.position);
        },
        onDrag: function onDrag(evt) {
          this.update(evt.state.dragDelta);
        }
      });
    }
  }, {
    key: "cellGuide",
    value: function GridLayoutHalo_cellGuide_(cellGroup) {
      var self = this,
          topLeft = this.cellResizer(cellGroup, "topLeft"),
          bottomRight = this.cellResizer(cellGroup, "bottomRight");
      return this.addGuide(new Morph$1({
        cellGroup: cellGroup,
        bounds: cellGroup.bounds(),
        fill: lively_graphics.Color.transparent,
        borderColor: lively_graphics.Color.orange,
        borderWidth: 1,
        isHaloItem: true,
        isCell: true,
        draggable: false,
        submorphs: [topLeft, bottomRight],
        onMouseDown: function onMouseDown(evt) {
          this.becomeActive();
        },
        deactivate: function deactivate() {
          this.borderColor = lively_graphics.Color.orange;
          this.fill = lively_graphics.Color.transparent;
          this.submorphs.forEach(function (b) {
            b.visible = false;
          });
        },
        becomeActive: function becomeActive() {
          self.guides.forEach(function (guide) {
            if (guide.isCell) guide.deactivate();
          });
          this.borderColor = lively_graphics.Color.rgbHex("#1565C0"), this.fill = lively_graphics.Color.rgbHex("#1565C0").withA(0.3), self.addMorph(this.remove());
          this.submorphs.forEach(function (b) {
            b.visible = true;
          });
        },
        onHoverIn: function onHoverIn(evt) {
          if (evt.hand.grabbedMorphs.length > 0) this.fill = lively_graphics.Color.orange.withA(0.7);
        },
        onHoverOut: function onHoverOut(evt) {
          this.fill = lively_graphics.Color.transparent;
        },
        onDrop: function onDrop(evt) {
          var _evt$hand$grabbedMorp = slicedToArray(evt.hand.grabbedMorphs, 1),
              m = _evt$hand$grabbedMorp[0];

          evt.hand.dropMorphsOn(self.container);
          cellGroup.morph = m;
        },
        alignWithTarget: function alignWithTarget() {
          var bounds = cellGroup.bounds();
          if (bounds.isNonEmpty()) {
            this.setBounds(cellGroup.bounds());
            topLeft.center = this.innerBounds().topLeft();
            bottomRight.center = this.innerBounds().bottomRight();
          } else {
            lively_lang.arr.remove(self.guides, this);
            this.remove();
          }
        }
      }));
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 10794,
    end: 18351
  });
}(Morph$1);
var TilingLayoutHalo = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("TilingLayoutHalo") && typeof __lively_classholder__.TilingLayoutHalo === "function" ? __lively_classholder__.TilingLayoutHalo : __lively_classholder__.TilingLayoutHalo = function TilingLayoutHalo(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function TilingLayoutHalo_initialize_(container, pointerId) {
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, {
        isHaloItem: true,
        styleClasses: ["Halo"],
        extent: container.extent,
        fill: lively_graphics.Color.transparent
      });
      this.state = {
        container: container,
        pointerId: pointerId,
        target: container.layout
      };
      this.alignWithTarget();
    }
  }, {
    key: "container",
    get: function get() {
      return this.state.container;
    }
  }, {
    key: "target",
    get: function get() {
      return this.state.target;
    }
  }, {
    key: "alignWithTarget",
    value: function TilingLayoutHalo_alignWithTarget_() {
      this.setBounds(this.container.globalBounds());
    }
  }, {
    key: "optionControls",
    value: function TilingLayoutHalo_optionControls_() {
      var layout = this.target,
          spacing = new PropertyInspector({
        min: 0,
        target: layout,
        unit: "px",
        property: "spacing"
      });
      return [[{
        type: "text",
        textString: "Submorph Spacing",
        padding: lively_graphics.Rectangle.inset(5),
        fill: lively_graphics.Color.transparent,
        fontColor: lively_graphics.Color.gray.darker(),
        readOnly: true
      }, spacing]].map(function (x) {
        return {
          submorphs: x,
          fill: lively_graphics.Color.transparent,
          layout: new HorizontalLayout({ spacing: 3 })
        };
      });
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 18360,
    end: 19448
  });
}(Morph$1);
var FlexLayoutHalo = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("FlexLayoutHalo") && typeof __lively_classholder__.FlexLayoutHalo === "function" ? __lively_classholder__.FlexLayoutHalo : __lively_classholder__.FlexLayoutHalo = function FlexLayoutHalo(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function FlexLayoutHalo_initialize_(container, pointerId) {
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, {
        isHaloItem: true,
        styleClasses: ["Halo"],
        extent: container.extent,
        fill: lively_graphics.Color.transparent,
        previews: []
      });
      this.state = {
        container: container,
        pointerId: pointerId,
        target: container.layout
      };
      this.alignWithTarget();
    }
  }, {
    key: "onHoverIn",
    value: function FlexLayoutHalo_onHoverIn_(evt) {
      if (evt.hand.grabbedMorphs.length > 0) this.previewDrop(evt.hand.grabbedMorphs);
    }
  }, {
    key: "onHoverOut",
    value: function FlexLayoutHalo_onHoverOut_(evt) {
      this.removePreviews();
    }
  }, {
    key: "previewDrop",
    value: function FlexLayoutHalo_previewDrop_(morphs) {
      var _this9 = this;

      var pulseDuration = 2000;
      if (this.previews.length > 0) return;
      this.previews = morphs.map(function (morph$$1) {
        return _this9.container.addMorph({
          isHaloItem: true,
          bounds: morph$$1.bounds(),
          fill: lively_graphics.Color.orange.withA(0.3),
          borderColor: lively_graphics.Color.orange,
          borderWidth: 2,
          opacity: 1,
          borderStyle: "dashed",
          step: function step() {
            var _this10 = this;

            return asyncToGenerator(regeneratorRuntime.mark(function _callee() {
              var easing;
              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      easing = Sine.easeInOut;
                      _context.next = 3;
                      return _this10.animate({
                        opacity: 0.5,
                        duration: pulseDuration / 2,
                        easing: easing
                      });

                    case 3:
                      _context.next = 5;
                      return _this10.animate({
                        opacity: 1,
                        duration: pulseDuration / 2,
                        easing: easing
                      });

                    case 5:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, _this10);
            }))();
          }
        });
      });
      this.previews.forEach(function (p) {
        p.step();
        p.startStepping(pulseDuration, "step");
      });
    }
  }, {
    key: "remove",
    value: function FlexLayoutHalo_remove_() {
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "remove", this).call(this);
      this.removePreviews();
    }
  }, {
    key: "removePreviews",
    value: function FlexLayoutHalo_removePreviews_() {
      this.previews.forEach(function (p) {
        return p.remove();
      });
    }
  }, {
    key: "onDrop",
    value: function FlexLayoutHalo_onDrop_(evt) {
      this.removePreviews();
      evt.hand.dropMorphsOn(this.container);
    }
  }, {
    key: "alignWithTarget",
    value: function FlexLayoutHalo_alignWithTarget_() {
      this.setBounds(this.container.globalBounds());
    }
  }, {
    key: "target",
    get: function get() {
      return this.state.target;
    }
  }, {
    key: "container",
    get: function get() {
      return this.state.container;
    }
  }, {
    key: "updateResizePolicy",
    value: function FlexLayoutHalo_updateResizePolicy_(auto) {
      if (auto) this.originalExtent = this.container.extent;
      this.target.autoResize = auto;
      if (!auto) this.container.extent = this.originalExtent;
      this.alignWithTarget();
    }
  }, {
    key: "optionControls",
    value: function FlexLayoutHalo_optionControls_() {
      var layout = this.target,
          spacing = new PropertyInspector({
        min: 0,
        target: layout,
        unit: "px",
        property: "spacing"
      }),
          autoResize = new CheckBox({
        name: "autoResize",
        checked: layout.autoResize
      });
      lively_bindings.connect(autoResize, "toggle", this, "updateResizePolicy");
      return [[{
        type: "text",
        textString: "Resize Container",
        padding: lively_graphics.rect(5, 0, 10, 10),
        fill: lively_graphics.Color.transparent,
        fontColor: lively_graphics.Color.gray.darker(),
        readOnly: true
      }, autoResize], [{
        type: "text",
        textString: "Submorph Spacing",
        padding: lively_graphics.Rectangle.inset(5),
        fill: lively_graphics.Color.transparent,
        fontColor: lively_graphics.Color.gray.darker(),
        readOnly: true
      }, spacing]].map(function (x) {
        return {
          submorphs: x,
          fill: lively_graphics.Color.transparent,
          layout: new HorizontalLayout({ spacing: 3 })
        };
      });
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 19457,
    end: 22285
  });
}(Morph$1);

var Layout = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("Layout") && typeof __lively_classholder__.Layout === "function" ? __lively_classholder__.Layout : __lively_classholder__.Layout = function Layout(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function Layout_initialize_() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          spacing = _ref.spacing,
          border = _ref.border,
          container = _ref.container,
          autoResize = _ref.autoResize,
          ignore = _ref.ignore;

      this.border = Object.assign({
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      }, border);
      this.spacing = spacing || 0;
      this.ignore = ignore || [];
      this.lastBounds = this.container && this.container.bounds();
      this.active = false;
      this.container = container;
      this.autoResize = autoResize != undefined ? autoResize : true;
    }
  }, {
    key: "description",
    value: function Layout_description_() {
      return "Describe the layout behavior here.";
    }
  }, {
    key: "name",
    value: function Layout_name_() {
      return "Name presented to the user.";
    }
  }, {
    key: "disable",
    value: function Layout_disable_() {
      this.active = true;
    }
  }, {
    key: "enable",
    value: function Layout_enable_(animation) {
      this.active = false;
      this.apply(animation);
    }
  }, {
    key: "boundsChanged",
    get: function get() {
      return !this.container.bounds().equals(this.lastBounds);
    }
  }, {
    key: "layoutableSubmorphs",
    get: function get() {
      var _this = this;

      return this.container.submorphs.filter(function (m) {
        return m.isLayoutable && !_this.ignore.includes(m.name);
      });
    }
  }, {
    key: "onSubmorphResized",
    value: function Layout_onSubmorphResized_(submorph, change) {
      if (this.container.submorphs.includes(submorph) || this.boundsChanged) this.apply(change.meta.animation);
    }
  }, {
    key: "onSubmorphAdded",
    value: function Layout_onSubmorphAdded_(submorph, anim) {
      this.apply(anim);
    }
  }, {
    key: "onSubmorphRemoved",
    value: function Layout_onSubmorphRemoved_(submorph, anim) {
      this.apply(anim);
    }
  }, {
    key: "onChange",
    value: function Layout_onChange_(_ref2) {
      var selector = _ref2.selector,
          args = _ref2.args,
          prop = _ref2.prop,
          value = _ref2.value,
          prevValue = _ref2.prevValue,
          meta = _ref2.meta;

      var anim = meta && meta.animation;
      switch (selector) {
        case "removeMorph":
          this.onSubmorphRemoved(args[0], anim);
          break;
        case "addMorphAt":
          this.onSubmorphAdded(args[0], anim);
          break;
      }
      if (prop == "extent" && !(value && value.equals(prevValue))) this.apply(anim);
    }
  }, {
    key: "affectsLayout",
    value: function Layout_affectsLayout_(submorph, _ref3) {
      var prop = _ref3.prop,
          value = _ref3.value,
          prevValue = _ref3.prevValue;

      return ["position", "scale", "rotation"].includes(prop) && !lively_lang.obj.equals(value, prevValue) && this.container.submorphs.includes(submorph);
    }
  }, {
    key: "onSubmorphChange",
    value: function Layout_onSubmorphChange_(submorph, change) {
      if ("extent" == change.prop && !change.value.equals(change.prevValue)) this.onSubmorphResized(submorph, change);
      if (this.affectsLayout(submorph, change)) this.apply(change.meta.animation);
    }
  }, {
    key: "changePropertyAnimated",
    value: function Layout_changePropertyAnimated_(target, propName, value, animate) {
      if (animate) {
        var _target$animate;

        var duration = animate.duration,
            easing = animate.easing;

        target.animate((_target$animate = {}, defineProperty(_target$animate, propName, value), defineProperty(_target$animate, "duration", duration), defineProperty(_target$animate, "easing", easing), _target$animate));
      } else {
        target[propName] = value;
      }
    }
  }, {
    key: "attachAnimated",
    value: function Layout_attachAnimated_() {
      var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var container = arguments[1];
      var easing = arguments[2];

      if (this.active) return;
      this.container = container;
      this.apply({
        duration: duration,
        easing: easing
      });
      this.active = true;
      container.layout = this;
      this.active = false;
    }
  }, {
    key: "apply",
    value: function Layout_apply_(animated) {
      this.lastBounds = this.container && this.container.bounds();
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 183,
    end: 2728
  });
}(undefined);
var FillLayout = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("FillLayout") && typeof __lively_classholder__.FillLayout === "function" ? __lively_classholder__.FillLayout : __lively_classholder__.FillLayout = function FillLayout(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function FillLayout_initialize_() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, config);
      this.morphs = config.morphs || [];
      this.fixedHeight = config.fixedHeight;
      this.fixedWidth = config.fixedWidth;
    }
  }, {
    key: "name",
    value: function FillLayout_name_() {
      return "Fill";
    }
  }, {
    key: "description",
    value: function FillLayout_description_() {
      return "Forces all submorphs to match the extent of their owner.";
    }
  }, {
    key: "spacing",
    set: function set() {
      var spacing = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      if (lively_lang.obj.isNumber(spacing)) {
        var top = left = right = bottom = spacing;
      } else {
        var top = spacing.top,
            left = spacing.left,
            right = spacing.right,
            bottom = spacing.bottom;

        top = top || 0;
        left = left || 0;
        right = right || 0;
        bottom = bottom || 0;
      }
      this._spacing = {
        top: top,
        left: left,
        right: right,
        bottom: bottom
      };
      this.apply();
    }
  }, {
    key: "spacing",
    get: function get() {
      return this._spacing;
    }
  }, {
    key: "apply",
    value: function FillLayout_apply_() {
      var _this2 = this;

      var animate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.active || !this.container) return;
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "apply", this).call(this, animate);
      var fixedWidth = this.fixedWidth,
          fixedHeight = this.fixedHeight,
          _spacing = this.spacing,
          top = _spacing.top,
          bottom = _spacing.bottom,
          left = _spacing.left,
          right = _spacing.right,
          height = !fixedHeight && this.container.height - top - bottom,
          width = !fixedWidth && this.container.width - left - right;

      this.active = true;
      this.morphs.forEach(function (m) {
        if (!m.isLayoutable) return;
        var m = _this2.container.getSubmorphNamed(m),
            newBounds = lively_graphics.pt(left, top).extent(lively_graphics.pt(width || m.width, height || m.height));
        if (animate) {
          var duration = animate.duration,
              easing = animate.easing;

          m.animate({
            bounds: newBounds,
            duration: duration,
            easing: easing
          });
        } else {
          m.setBounds(newBounds);
        }
      });
      this.active = false;
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 2937,
    end: 4518
  });
}(Layout);
var VerticalLayout = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("VerticalLayout") && typeof __lively_classholder__.VerticalLayout === "function" ? __lively_classholder__.VerticalLayout : __lively_classholder__.VerticalLayout = function VerticalLayout(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: "name",
    value: function VerticalLayout_name_() {
      return "Vertical";
    }
  }, {
    key: "description",
    value: function VerticalLayout_description_() {
      return "Assemble the submorphs in a vertically growing list.";
    }
  }, {
    key: "inspect",
    value: function VerticalLayout_inspect_(pointerId) {
      return new FlexLayoutHalo(this.container, pointerId);
    }
  }, {
    key: "autoResize",
    get: function get() {
      return this._autoResize;
    }
  }, {
    key: "autoResize",
    set: function set(active) {
      this._autoResize = active;
      this.apply();
    }
  }, {
    key: "spacing",
    get: function get() {
      return this._spacing;
    }
  }, {
    key: "spacing",
    set: function set(offset) {
      this._spacing = offset;
      this.apply();
    }
  }, {
    key: "apply",
    value: function VerticalLayout_apply_() {
      var _this3 = this;

      var animate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.active || !this.container) return;
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "apply", this).call(this, animate);
      var pos = lively_graphics.pt(this.spacing, this.spacing),
          submorphs = this.layoutableSubmorphs,
          maxWidth = 0;
      this.active = true;
      submorphs.forEach(function (m) {
        if (animate) {
          var duration = animate.duration,
              easing = animate.easing;

          m.animate({
            topLeft: pos,
            duration: duration,
            easing: easing
          });
        } else {
          m.topLeft = pos;
        }
        pos = m.bottomLeft.addPt(lively_graphics.pt(0, _this3.spacing));
        maxWidth = Math.max(m.bounds().width, maxWidth);
      });
      if (this.autoResize && submorphs.length > 0) {
        var newExtent = lively_graphics.pt(maxWidth + 2 * this.spacing, pos.y);
        if (animate) {
          var duration = animate.duration,
              easing = animate.easing;

          this.container.animate({
            extent: newExtent,
            duration: duration,
            easing: easing
          });
        } else {
          this.container.extent = newExtent;
        }
      }
      this.active = false;
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 4527,
    end: 5896
  });
}(Layout);
var HorizontalLayout = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("HorizontalLayout") && typeof __lively_classholder__.HorizontalLayout === "function" ? __lively_classholder__.HorizontalLayout : __lively_classholder__.HorizontalLayout = function HorizontalLayout(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function HorizontalLayout_initialize_() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, props);
      this._direction = props.direction || "leftToRight";
    }
  }, {
    key: "name",
    value: function HorizontalLayout_name_() {
      return "Horizontal";
    }
  }, {
    key: "description",
    value: function HorizontalLayout_description_() {
      return "Assemble the submorphs in a horizontally growing list.";
    }
  }, {
    key: "inspect",
    value: function HorizontalLayout_inspect_(pointerId) {
      return new FlexLayoutHalo(this.container, pointerId);
    }
  }, {
    key: "direction",
    get: function get() {
      return this._direction;
    }
  }, {
    key: "direction",
    set: function set(d) {
      this._direction = d;
      this.apply();
    }
  }, {
    key: "autoResize",
    get: function get() {
      return this._autoResize;
    }
  }, {
    key: "autoResize",
    set: function set(active) {
      this._autoResize = active;
      this.apply();
    }
  }, {
    key: "spacing",
    get: function get() {
      return this._spacing;
    }
  }, {
    key: "spacing",
    set: function set(offset) {
      this._spacing = offset;
      this.apply();
    }
  }, {
    key: "apply",
    value: function HorizontalLayout_apply_() {
      var _this4 = this;

      var animate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.active || !this.container || !this.container.submorphs.length) return;
      var direction = this.direction,
          spacing = this.spacing,
          container = this.container,
          autoResize = this.autoResize,
          layoutableSubmorphs = this.layoutableSubmorphs;

      if (!layoutableSubmorphs.length) return;
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "apply", this).call(this, animate);
      this.active = true;
      this.maxHeight = 0;
      var minExtent = direction === "leftToRight" && !autoResize ? container.extent : this.computeMinContainerExtent(spacing, container, layoutableSubmorphs);
      var startX = 0;
      if (direction === "rightToLeft") {
        startX = Math.max(0, container.width - minExtent.x);
      } else if (direction === "centered") {
        startX = (container.width - minExtent.x) / 2;
      }
      layoutableSubmorphs.reduce(function (pos, m) {
        _this4.changePropertyAnimated(m, "topLeft", pos, animate);
        return m.topRight.addPt(lively_graphics.pt(spacing, 0));
      }, lively_graphics.pt(Math.max(0, startX) + spacing, spacing));
      if (autoResize) {
        var w = 0;
        if (direction === "centered") {
          var leftOffset = layoutableSubmorphs[0].left;
          w = lively_lang.arr.last(layoutableSubmorphs).right + leftOffset;
        } else {
          w = lively_lang.arr.last(layoutableSubmorphs).right + spacing;
        }
        var newExtent = lively_graphics.pt(Math.max(minExtent.x, w), minExtent.y + 2 * spacing);
        this.changePropertyAnimated(container, "extent", newExtent, animate);
      }
      this.active = false;
    }
  }, {
    key: "computeMinContainerExtent",
    value: function HorizontalLayout_computeMinContainerExtent_(spacing, container, layoutableSubmorphs) {
      var spacingWidth = (layoutableSubmorphs.length + 1) * spacing;
      var maxW = 0,
          maxH = 0;
      for (var i = 0; i < layoutableSubmorphs.length; i++) {
        var m = layoutableSubmorphs[i],
            _m$extent = m.extent,
            w = _m$extent.x,
            h$$1 = _m$extent.y;
        maxW += w;
        maxH = Math.max(h$$1, maxH);
      }
      return lively_graphics.pt(maxW + spacingWidth, maxH);
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 5905,
    end: 8433
  });
}(Layout);
var TilingLayout = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("TilingLayout") && typeof __lively_classholder__.TilingLayout === "function" ? __lively_classholder__.TilingLayout : __lively_classholder__.TilingLayout = function TilingLayout(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: "name",
    value: function TilingLayout_name_() {
      return "Tiling";
    }
  }, {
    key: "description",
    value: function TilingLayout_description_() {
      return "Make the submorphs fill their owner, inserting breaks to defer intersecting the bounds as much as possible.";
    }
  }, {
    key: "inspect",
    value: function TilingLayout_inspect_(pointerId) {
      return new TilingLayoutHalo(this.container, pointerId);
    }
  }, {
    key: "apply",
    value: function TilingLayout_apply_() {
      var animate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.active) return;
      this.active = true;
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "apply", this).call(this, animate);
      var width = this.getOptimalWidth(),
          currentRowHeight = 0,
          currentRowWidth = this.border.left,
          spacing = this.spacing,
          layoutableSubmorphs = this.layoutableSubmorphs,
          previousRowHeight = spacing + this.border.top,
          i = 0,
          rowSwitch = true;
      while (i < layoutableSubmorphs.length) {
        var submorphExtent = layoutableSubmorphs[i].extent,
            newPos;
        if (rowSwitch || currentRowWidth + submorphExtent.x + 2 * spacing <= width) {
          newPos = lively_graphics.pt(currentRowWidth + spacing, previousRowHeight);
          rowSwitch = false;
          if (animate) {
            var duration = animate.duration,
                easing = animate.easing;

            layoutableSubmorphs[i].animate({
              position: newPos,
              duration: duration,
              easing: easing
            });
          } else {
            layoutableSubmorphs[i].position = newPos;
          }
          currentRowHeight = Math.max(currentRowHeight, submorphExtent.y);
          currentRowWidth += spacing + submorphExtent.x;
          i++;
        } else {
          previousRowHeight += spacing + currentRowHeight;
          currentRowWidth = this.border.left;
          currentRowHeight = 0;
          rowSwitch = true;
        }
      }
      this.active = false;
    }
  }, {
    key: "getMinWidth",
    value: function TilingLayout_getMinWidth_() {
      return this.layoutableSubmorphs.reduce(function (s, e) {
        return e.extent.x > s ? e.extent.x : s;
      }, 0) + this.border.left + this.border.right;
    }
  }, {
    key: "getMinHeight",
    value: function TilingLayout_getMinHeight_() {
      return this.layoutableSubmorphs.reduce(function (s, e) {
        return e.extent.y > s ? e.extent.y : s;
      }, 0) + this.border.top + this.border.bottom;
    }
  }, {
    key: "getOptimalWidth",
    value: function TilingLayout_getOptimalWidth_() {
      var width = this.container.width - this.border.left - this.border.right,
          maxSubmorphWidth = this.getMinWidth();
      return Math.max(width, maxSubmorphWidth);
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 8442,
    end: 10489
  });
}(Layout);
var CellGroup = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("CellGroup") && typeof __lively_classholder__.CellGroup === "function" ? __lively_classholder__.CellGroup : __lively_classholder__.CellGroup = function CellGroup(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function CellGroup_initialize_(_ref4) {
      var cell = _ref4.cell,
          morph$$1 = _ref4.morph,
          layout = _ref4.layout,
          align = _ref4.align;

      this.state = {
        cells: [cell],
        layout: layout,
        align: align,
        resize: true
      };
      layout && layout.addGroup(this);
      this.morph = morph$$1;
    }
  }, {
    key: "morph",
    get: function get() {
      var _state = this.state,
          morph$$1 = _state.morph,
          layout = _state.layout;

      if (morph$$1) {
        if (morph$$1.isMorph) return morph$$1;
        return layout.layoutableSubmorphs.find(function (m) {
          return m.name == morph$$1;
        });
      }
      return null;
    }
  }, {
    key: "compensateOrigin",
    get: function get() {
      return this.layout.compensateOrigin;
    }
  }, {
    key: "resize",
    get: function get() {
      return this.state.resize;
    }
  }, {
    key: "resize",
    set: function set(forceBounds) {
      this.state.resize = forceBounds;
      this.layout.apply();
    }
  }, {
    key: "align",
    get: function get() {
      return this.state.align || "topLeft";
    }
  }, {
    key: "align",
    set: function set(orientation) {
      this.state.align = orientation;
      this.resize = false;
      this.layout.apply();
    }
  }, {
    key: "morph",
    set: function set(value) {
      var conflictingGroup = value && this.layout.getCellGroupFor(value);
      if (conflictingGroup) conflictingGroup.morph = null;
      if (value) {
        this.layout.morphToGroup[value.id || value] = this;
      } else {
        if (this.morph && this.layout.morphToGroup[this.morph.id] == this) delete this.layout.morphToGroup[this.morph.id];
      }
      this.state.morph = value;
      this.layout.apply();
    }
  }, {
    key: "manages",
    value: function CellGroup_manages_(morph$$1) {
      return this.morph && (this.morph == morph$$1 || this.morph.name == morph$$1);
    }
  }, {
    key: "apply",
    value: function CellGroup_apply_() {
      var animate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      var target = this.morph;
      if (target) {
        var bounds = this.layout.fitToCell ? this.bounds() : this.bounds().topLeft().extent(target.extent),
            offset = this.compensateOrigin ? this.layout.container.origin.negated() : lively_graphics.pt(0, 0);
        if (animate) {
          var _target$animate2;

          var extent = this.resize ? bounds.extent() : target.extent,
              duration = animate.duration,
              easing = animate.easing;
          target.animate((_target$animate2 = {}, defineProperty(_target$animate2, this.align, bounds[this.align]().addPt(offset)), defineProperty(_target$animate2, "extent", extent), defineProperty(_target$animate2, "duration", duration), defineProperty(_target$animate2, "easing", easing), _target$animate2));
        } else {
          if (this.resize) target.extent = bounds.extent();
          target[this.align] = bounds[this.align]().addPt(offset);
        }
      }
    }
  }, {
    key: "cells",
    get: function get() {
      return this.state.cells;
    }
  }, {
    key: "layout",
    get: function get() {
      return this.state.layout;
    }
  }, {
    key: "bounds",
    value: function CellGroup_bounds_() {
      if (this.cells.length > 0) {
        return this.cells.map(function (cell) {
          return cell.bounds();
        }).reduce(function (a, b) {
          return a.union(b);
        });
      } else {
        return lively_graphics.rect(0, 0, 0, 0);
      }
    }
  }, {
    key: "includes",
    value: function CellGroup_includes_(cell) {
      return this.cells.find(function (c) {
        return c == cell;
      });
    }
  }, {
    key: "connect",
    value: function CellGroup_connect_(cell) {
      if (this.morph == undefined) {
        this.morph = cell.group.morph;
      }
      if (cell.group) {
        cell.group.disconnect(cell, this);
      } else {
        cell.group = this;
      }
      this.cells.push(cell);
    }
  }, {
    key: "disconnect",
    value: function CellGroup_disconnect_(cell) {
      var newGroup = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      cell.group = newGroup || new CellGroup({
        morph: null,
        layout: this.layout,
        cell: cell
      });
      lively_lang.arr.remove(this.cells, cell);
      if (this.cells.length < 1 && this.layout) this.layout.removeGroup(this);
    }
  }, {
    key: "merge",
    value: function CellGroup_merge_(otherGroup) {
      var _this5 = this;

      otherGroup.cells.forEach(function (c) {
        _this5.connect(c);
      });
    }
  }, {
    key: "topLeft",
    get: function get() {
      var _this6 = this;

      return this.cells.find(function (cell) {
        return (cell.left == null || cell.left.group != _this6) && (cell.top == null || cell.top.group != _this6);
      });
    }
  }, {
    key: "bottomRight",
    get: function get() {
      var _this7 = this;

      return this.cells.find(function (cell) {
        return (cell.right == null || cell.right.group != _this7) && (cell.bottom == null || cell.bottom.group != _this7);
      });
    }
  }, {
    key: "position",
    get: function get() {
      return this.topLeft.position;
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 10498,
    end: 13852
  });
}(undefined);
var LayoutAxis = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("LayoutAxis") && typeof __lively_classholder__.LayoutAxis === "function" ? __lively_classholder__.LayoutAxis : __lively_classholder__.LayoutAxis = function LayoutAxis(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function LayoutAxis_initialize_(cell) {
      this.origin = cell;
    }
  }, {
    key: "otherAxis",
    get: function get() {
      return [].concat(toConsumableArray(this.axisBefore), toConsumableArray(this.axisAfter));
    }
  }, {
    key: "axisBefore",
    get: function get() {
      var curr = this,
          res = [];
      while (curr = curr.before) {
        res = [curr].concat(toConsumableArray(res));
      }return res;
    }
  }, {
    key: "axisAfter",
    get: function get() {
      var curr = this,
          res = [];
      while (curr = curr.after) {
        res = [].concat(toConsumableArray(res), [curr]);
      }return res;
    }
  }, {
    key: "before",
    get: function get() {
      throw Error("before() not implemented!");
    }
  }, {
    key: "after",
    get: function get() {
      throw Error("after() not implemented!");
    }
  }, {
    key: "getRoot",
    value: function LayoutAxis_getRoot_() {
      return (this.axisBefore[0] || this).items[0];
    }
  }, {
    key: "adjustProportion",
    value: function LayoutAxis_adjustProportion_(delta) {
      var dynamicProportion = this.dynamicLength / this.containerLength,
          nextDynamic;
      if (nextDynamic = this.axisAfter.find(function (axis) {
        return !axis.isStatic;
      })) {
        delta = Math.min(delta, nextDynamic.proportion);
        this.proportion += delta;
        nextDynamic.proportion -= delta;
      } else {
        if (this.length + delta * this.containerLength < 0) delta = -this.length / this.containerLength;
        this.axisBefore.forEach(function (a) {
          a.proportion /= 1 + delta;
        });
        this.proportion = 1 - lively_lang.arr.sum(this.axisBefore.map(function (a) {
          return a.proportion;
        }));
        this.containerLength += delta * this.containerLength;
      }
    }
  }, {
    key: "adjustStretch",
    value: function LayoutAxis_adjustStretch_(delta) {
      if (this.fixed) {
        this.fixed += delta;
        this.containerLength += delta;
      } else {
        this.adjustProportion(delta / this.containerLength);
      }
    }
  }, {
    key: "equalizeDynamicAxis",
    value: function LayoutAxis_equalizeDynamicAxis_() {
      var dynamicAxis = this.otherAxis.length + 1;
      this.otherAxis.forEach(function (a) {
        a.proportion = 1 / dynamicAxis;
      });
      this.proportion = 1 / dynamicAxis;
    }
  }, {
    key: "addBefore",
    value: function LayoutAxis_addBefore_() {
      var newAxis = this.emptyAxis();
      this.before && this.before.attachTo(newAxis);
      newAxis.attachTo(this);
      this.equalizeDynamicAxis();
      this.layout.grid = this.getRoot();
    }
  }, {
    key: "addAfter",
    value: function LayoutAxis_addAfter_() {
      var newAxis = this.emptyAxis();
      this.after && newAxis.attachTo(this.after);
      this.attachTo(newAxis);
      this.equalizeDynamicAxis();
      this.layout.grid = this.getRoot();
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 13854,
    end: 15992
  });
}(undefined);
var LayoutColumn = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("LayoutColumn") && typeof __lively_classholder__.LayoutColumn === "function" ? __lively_classholder__.LayoutColumn : __lively_classholder__.LayoutColumn = function LayoutColumn(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function LayoutColumn_initialize_(cell) {
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, cell);
      this.items = [].concat(toConsumableArray(cell.above), [cell], toConsumableArray(cell.below));
    }
  }, {
    key: "emptyAxis",
    value: function LayoutColumn_emptyAxis_() {
      var col = new LayoutColumn(new LayoutCell({
        column: lively_lang.arr.withN(this.items.length, null),
        layout: this.layout
      }));
      lively_lang.arr.zip(col.items, this.items).forEach(function (_ref5) {
        var _ref6 = slicedToArray(_ref5, 2),
            n = _ref6[0],
            o = _ref6[1];

        n.proportion.height = o.proportion.height;
        n.fixed.height = o.fixed.height;
        n.min.height = o.min.height;
      });
      return col;
    }
  }, {
    key: "paddingLeft",
    set: function set(left) {
      this.items.forEach(function (c) {
        c.padding.x = left;
      });
      this.layout.apply();
    }
  }, {
    key: "paddingRight",
    set: function set(right) {
      this.items.forEach(function (c) {
        c.padding.width = right;
      });
      this.layout.apply();
    }
  }, {
    key: "before",
    get: function get() {
      return this.origin.left && new LayoutColumn(this.origin.left);
    }
  }, {
    key: "after",
    get: function get() {
      return this.origin.right && new LayoutColumn(this.origin.right);
    }
  }, {
    key: "containerLength",
    get: function get() {
      return this.container.width;
    }
  }, {
    key: "containerLength",
    set: function set(width) {
      this.container.width = width;
    }
  }, {
    key: "length",
    get: function get() {
      return this.origin.width;
    }
  }, {
    key: "dynamicLength",
    get: function get() {
      return this.origin.dynamicWidth;
    }
  }, {
    key: "container",
    get: function get() {
      return this.origin.container;
    }
  }, {
    key: "layout",
    get: function get() {
      return this.origin.layout;
    }
  }, {
    key: "isStatic",
    get: function get() {
      return this.origin.staticWidth;
    }
  }, {
    key: "attachTo",
    value: function LayoutColumn_attachTo_(col) {
      lively_lang.arr.zip(this.items, col.items).forEach(function (_ref7) {
        var _ref8 = slicedToArray(_ref7, 2),
            a = _ref8[0],
            b = _ref8[1];

        a.right = b;
        b.left = a;
      });
      this.equalizeDynamicAxis();
      return col;
    }
  }, {
    key: "row",
    value: function LayoutColumn_row_(idx) {
      return this.items[idx];
    }
  }, {
    key: "min",
    get: function get() {
      return this.origin.min.width || 0;
    }
  }, {
    key: "min",
    set: function set(x) {
      this.adjustMin(x - this.min);
    }
  }, {
    key: "adjustMin",
    value: function LayoutColumn_adjustMin_(delta) {
      this.items.forEach(function (c) {
        if (c.min.width + delta < 0) {
          c.min.width = 0;
        } else if (c.min.width + delta > c.width) {
          c.min.width += delta;
        } else {
          c.min.width += delta;
        }
      });
      this.layout.apply();
    }
  }, {
    key: "fixed",
    get: function get() {
      return this.origin.fixed.width;
    }
  }, {
    key: "fixed",
    set: function set(active) {
      var fixedWidth = typeof active == "number" ? active : active && this.origin.width;
      this.items.forEach(function (c) {
        c.fixed.width = fixedWidth;
      });
      this.layout.apply();
    }
  }, {
    key: "proportion",
    set: function set(prop) {
      this.items.forEach(function (c) {
        c.proportion.width = prop;
      });
      this.layout.apply();
    }
  }, {
    key: "proportion",
    get: function get() {
      return this.origin.proportion.width;
    }
  }, {
    key: "adjustedProportion",
    get: function get() {
      return this.origin.adjustedProportion.width;
    }
  }, {
    key: "remove",
    value: function LayoutColumn_remove_() {
      var _this8 = this;

      var a = this.before || this.after;
      this.items.forEach(function (c) {
        if (c.left) c.left.right = c.right;
        if (c.right) c.right.left = c.left;
        c.group.disconnect(c);
        _this8.layout.removeGroup(c.group);
      });
      a.equalizeDynamicAxis();
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 16001,
    end: 18726
  });
}(LayoutAxis);
var LayoutRow = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("LayoutRow") && typeof __lively_classholder__.LayoutRow === "function" ? __lively_classholder__.LayoutRow : __lively_classholder__.LayoutRow = function LayoutRow(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function LayoutRow_initialize_(cell) {
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, cell);
      this.items = [].concat(toConsumableArray(cell.before), [cell], toConsumableArray(cell.after));
    }
  }, {
    key: "emptyAxis",
    value: function LayoutRow_emptyAxis_() {
      var row = new LayoutRow(new LayoutCell({
        row: lively_lang.arr.withN(this.items.length, null),
        layout: this.layout
      }));
      lively_lang.arr.zip(row.items, this.items).forEach(function (_ref9) {
        var _ref10 = slicedToArray(_ref9, 2),
            n = _ref10[0],
            o = _ref10[1];

        n.proportion.width = o.proportion.width;
        n.fixed.width = o.fixed.width;
        n.min.width = o.min.width;
      });
      return row;
    }
  }, {
    key: "paddingTop",
    set: function set(top) {
      this.items.forEach(function (c) {
        c.padding.y = top;
      });
      this.layout.apply();
    }
  }, {
    key: "paddingBottom",
    set: function set(bottom) {
      this.items.forEach(function (c) {
        c.padding.height = bottom;
      });
      this.layout.apply();
    }
  }, {
    key: "before",
    get: function get() {
      return this.origin.top && new LayoutRow(this.origin.top);
    }
  }, {
    key: "after",
    get: function get() {
      return this.origin.bottom && new LayoutRow(this.origin.bottom);
    }
  }, {
    key: "container",
    get: function get() {
      return this.origin.container;
    }
  }, {
    key: "layout",
    get: function get() {
      return this.origin.layout;
    }
  }, {
    key: "isStatic",
    get: function get() {
      return this.origin.staticHeight;
    }
  }, {
    key: "attachTo",
    value: function LayoutRow_attachTo_(row) {
      lively_lang.arr.zip(this.items, row.items).forEach(function (_ref11) {
        var _ref12 = slicedToArray(_ref11, 2),
            a = _ref12[0],
            b = _ref12[1];

        a.bottom = b;
        b.top = a;
      });
      this.equalizeDynamicAxis();
      return row;
    }
  }, {
    key: "col",
    value: function LayoutRow_col_(idx) {
      return this.items[idx];
    }
  }, {
    key: "min",
    get: function get() {
      return this.origin.min.height || 0;
    }
  }, {
    key: "min",
    set: function set(x) {
      this.adjustMin(x - this.min);
    }
  }, {
    key: "adjustMin",
    value: function LayoutRow_adjustMin_(delta) {
      this.items.forEach(function (c) {
        if (c.min.height + delta < 0) {
          c.min.height = 0;
        } else if (c.min.height + delta > c.height) {
          c.min.height += delta;
        } else {
          c.min.height += delta;
        }
      });
      this.layout.apply();
    }
  }, {
    key: "containerLength",
    get: function get() {
      return this.container.height;
    }
  }, {
    key: "containerLength",
    set: function set(height) {
      this.container.height = height;
    }
  }, {
    key: "dynamicLength",
    get: function get() {
      return this.origin.dynamicHeight;
    }
  }, {
    key: "length",
    get: function get() {
      return this.origin.height;
    }
  }, {
    key: "fixed",
    get: function get() {
      return this.origin.fixed.height;
    }
  }, {
    key: "fixed",
    set: function set(active) {
      var fixedHeight = typeof active == "number" ? active : active && this.origin.height;
      this.items.forEach(function (c) {
        c.fixed.height = fixedHeight;
      });
      this.layout.apply();
    }
  }, {
    key: "proportion",
    set: function set(prop) {
      this.items.forEach(function (c) {
        c.proportion.height = prop;
      });
      this.layout.apply();
    }
  }, {
    key: "proportion",
    get: function get() {
      return this.origin.proportion.height;
    }
  }, {
    key: "adjustedProportion",
    get: function get() {
      return this.origin.adjustedProportion.height;
    }
  }, {
    key: "remove",
    value: function LayoutRow_remove_() {
      var _this9 = this;

      var a = this.before || this.after;
      this.items.forEach(function (c) {
        if (c.top) c.top.bottom = c.bottom;
        if (c.bottom) c.bottom.top = c.top;
        c.group.disconnect(c);
        _this9.layout.removeGroup(c.group);
      });
      a.equalizeDynamicAxis();
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 18735,
    end: 21446
  });
}(LayoutAxis);
var LayoutCell = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("LayoutCell") && typeof __lively_classholder__.LayoutCell === "function" ? __lively_classholder__.LayoutCell : __lively_classholder__.LayoutCell = function LayoutCell(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function LayoutCell_initialize_(_ref13) {
      var row = _ref13.row,
          column = _ref13.column,
          top = _ref13.top,
          left = _ref13.left,
          right = _ref13.right,
          bottom = _ref13.bottom,
          layout = _ref13.layout;
      var group,
          _ref14 = row || [],
          _ref15 = toArray(_ref14),
          rv = _ref15[0],
          row = _ref15.slice(1),
          _ref16 = column || [],
          _ref17 = toArray(_ref16),
          cv = _ref17[0],
          column = _ref17.slice(1);
      this.layout = layout;
      this.fixed = {};
      this.min = {
        width: 0,
        height: 0
      };
      this.top = top;
      this.left = left;
      this.bottom = bottom;
      this.right = right;
      this.padding = lively_graphics.rect(0, 0, 0, 0);
      if (row.length > 0) {
        this.right = new LayoutCell({
          row: row,
          left: this,
          layout: layout
        });
      } else if (column.length > 0) {
        this.bottom = new LayoutCell({
          column: column,
          top: this,
          layout: layout
        });
      }
      this.proportion = {
        height: 1 / this.col(0).items.length,
        width: 1 / this.row(0).items.length
      };
      if (group = layout && layout.getCellGroupFor(rv || cv)) {
        group.connect(this);
      } else {
        this.group = new CellGroup({
          cell: this,
          morph: rv || cv,
          layout: layout
        });
      }
    }
  }, {
    key: "container",
    get: function get() {
      return this.layout.container;
    }
  }, {
    key: "above",
    get: function get() {
      return this.collect({
        neighbor: "top",
        prepend: true
      });
    }
  }, {
    key: "below",
    get: function get() {
      return this.collect({
        neighbor: "bottom",
        append: true
      });
    }
  }, {
    key: "before",
    get: function get() {
      return this.collect({
        neighbor: "left",
        prepend: true
      });
    }
  }, {
    key: "after",
    get: function get() {
      return this.collect({
        neighbor: "right",
        append: true
      });
    }
  }, {
    key: "collect",
    value: function LayoutCell_collect_(_ref18) {
      var neighbor = _ref18.neighbor,
          prepend = _ref18.prepend,
          append = _ref18.append;

      var items = [],
          curr = this;
      while (curr = curr[neighbor]) {
        if (prepend) items = [curr].concat(toConsumableArray(items));
        if (append) items = [].concat(toConsumableArray(items), [curr]);
      }
      return items;
    }
  }, {
    key: "col",
    value: function LayoutCell_col_(idx) {
      var cell = this,
          i = idx;
      while (i > 0 && cell) {
        cell = cell.right;
        i--;
      }
      if (!cell) throw Error(idx + " out of bounds! Last column was " + (idx - i - 1));
      return new LayoutColumn(cell);
    }
  }, {
    key: "row",
    value: function LayoutCell_row_(idx) {
      var cell = this,
          i = idx;
      while (i > 0 && cell) {
        cell = cell.bottom;
        i--;
      }
      if (!cell) throw Error(idx + " out of bounds! Last row was " + (idx - i - 1));
      return new LayoutRow(cell);
    }
  }, {
    key: "extent",
    get: function get() {
      return lively_graphics.pt(this.width, this.height);
    }
  }, {
    key: "staticWidth",
    get: function get() {
      return this.fixed.width || this.min.width > this.proportion.width * this.container.width;
    }
  }, {
    key: "totalStaticWidth",
    get: function get() {
      return lively_lang.arr.sum([this].concat(toConsumableArray(this.before), toConsumableArray(this.after)).map(function (c) {
        if (c.staticWidth) {
          return c.fixed.width || c.min.width;
        } else {
          return 0;
        }
      }));
    }
  }, {
    key: "staticHeight",
    get: function get() {
      return this.fixed.height || this.min.height > this.proportion.height * this.container.height;
    }
  }, {
    key: "totalStaticHeight",
    get: function get() {
      return lively_lang.arr.sum([this].concat(toConsumableArray(this.above), toConsumableArray(this.below)).map(function (c) {
        if (c.staticHeight) {
          return c.fixed.height || c.min.height;
        } else {
          return 0;
        }
      }));
    }
  }, {
    key: "dynamicWidth",
    get: function get() {
      return Math.max(this.container.width - this.totalStaticWidth, 0);
    }
  }, {
    key: "dynamicHeight",
    get: function get() {
      return Math.max(this.container.height - this.totalStaticHeight, 0);
    }
  }, {
    key: "inactiveProportion",
    get: function get() {
      return {
        width: lively_lang.arr.sum([this].concat(toConsumableArray(this.before), toConsumableArray(this.after)).map(function (c) {
          return c.staticWidth && c.proportion.width || 0;
        })),
        height: lively_lang.arr.sum([this].concat(toConsumableArray(this.above), toConsumableArray(this.below)).map(function (c) {
          return c.staticHeight && c.proportion.height || 0;
        }))
      };
    }
  }, {
    key: "adjustedProportion",
    get: function get() {
      return {
        width: this.inactiveProportion.width > 0 ? this.proportion.width / (1 - this.inactiveProportion.width) : this.proportion.width,
        height: this.inactiveProportion.height > 0 ? this.proportion.height / (1 - this.inactiveProportion.height) : this.proportion.height
      };
    }
  }, {
    key: "width",
    get: function get() {
      var width = this.fixed.width,
          width = width || this.adjustedProportion.width * this.dynamicWidth;
      return width < this.min.width ? this.min.width : width;
    }
  }, {
    key: "height",
    get: function get() {
      var height = this.fixed.height,
          height = height || this.adjustedProportion.height * this.dynamicHeight;
      return height < this.min.height ? this.min.height : height;
    }
  }, {
    key: "position",
    get: function get() {
      return lively_graphics.pt(lively_lang.arr.sum(this.before.map(function (c) {
        return c.width;
      })), lively_lang.arr.sum(this.above.map(function (c) {
        return c.height;
      })));
    }
  }, {
    key: "bounds",
    value: function LayoutCell_bounds_() {
      return this.position.addPt(this.padding.topLeft()).extent(this.extent.subPt(this.padding.extent()).subPt(this.padding.topLeft()));
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 21455,
    end: 25812
  });
}(undefined);
var GridLayout$1 = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("GridLayout") && typeof __lively_classholder__.GridLayout === "function" ? __lively_classholder__.GridLayout : __lively_classholder__.GridLayout = function GridLayout$1(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function GridLayout_initialize_(config) {
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, config);
      config = Object.assign({
        autoAssign: true,
        fitToCell: true
      }, config);
      this.cellGroups = [];
      this.morphToGroup = {};
      this.config = config;
    }
  }, {
    key: "name",
    value: function GridLayout_name_() {
      return "Grid";
    }
  }, {
    key: "description",
    value: function GridLayout_description_() {
      return "Aligns the submorphs alongside a configurable grid. Columns and rows and be configured to have different proportional, minimal or fixed sizes. Cells can further be grouped such that submorphs fill up multiple slots of the grid.";
    }
  }, {
    key: "initGrid",
    value: function GridLayout_initGrid_() {
      var _this10 = this;

      var grid = this.ensureGrid(this.config),
          rows = grid.map(function (row) {
        return new LayoutRow(new LayoutCell({
          row: row,
          layout: _this10
        }));
      });
      rows.reduce(function (a, b) {
        return a.attachTo(b);
      });
      this.config.autoAssign && this.autoAssign(this.notInLayout);
      this.grid = rows[0].col(0);
    }
  }, {
    key: "compensateOrigin",
    get: function get() {
      return this.config.compensateOrigin;
    }
  }, {
    key: "compensateOrigin",
    set: function set(compensate) {
      this.config.compensateOrigin = compensate;
      this.apply();
    }
  }, {
    key: "fitToCell",
    get: function get() {
      return this.config.fitToCell;
    }
  }, {
    key: "fitToCell",
    set: function set(fit) {
      this.config.fitToCell = fit;
      this.apply();
    }
  }, {
    key: "notInLayout",
    get: function get() {
      return lively_lang.arr.withoutAll(this.layoutableSubmorphs, this.cellGroups.map(function (g) {
        return g.morph;
      }));
    }
  }, {
    key: "col",
    value: function GridLayout_col_(idx) {
      return this.grid.col(idx);
    }
  }, {
    key: "row",
    value: function GridLayout_row_(idx) {
      return this.grid.row(idx);
    }
  }, {
    key: "rowCount",
    get: function get() {
      return this.grid.col(0).items.length;
    }
  }, {
    key: "columnCount",
    get: function get() {
      return this.grid.row(0).items.length;
    }
  }, {
    key: "addGroup",
    value: function GridLayout_addGroup_(group) {
      this.cellGroups.push(group);
    }
  }, {
    key: "removeGroup",
    value: function GridLayout_removeGroup_(group) {
      lively_lang.arr.remove(this.cellGroups, group);
    }
  }, {
    key: "apply",
    value: function GridLayout_apply_() {
      var _this11 = this;

      var animate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.active) return;
      this.active = true;
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "apply", this).call(this, animate);
      if (!this.grid) this.initGrid();
      this.layoutableSubmorphs.forEach(function (m) {
        var g = _this11.getCellGroupFor(m);
        g && g.apply(animate);
      });
      this.container.extent = lively_graphics.pt(Math.max(this.grid.totalStaticWidth, this.container.width), Math.max(this.grid.totalStaticHeight, this.container.height));
      this.active = false;
    }
  }, {
    key: "getCellGroupFor",
    value: function GridLayout_getCellGroupFor_(morph$$1) {
      return morph$$1 && (this.morphToGroup[morph$$1.id] || this.morphToGroup[morph$$1.name]);
    }
  }, {
    key: "onSubmorphRemoved",
    value: function GridLayout_onSubmorphRemoved_(removedMorph) {
      var cellGroup = this.getCellGroupFor(removedMorph);
      if (cellGroup) cellGroup.morph = null;
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "onSubmorphRemoved", this).call(this, removedMorph);
    }
  }, {
    key: "inspect",
    value: function GridLayout_inspect_(pointerId) {
      return new GridLayoutHalo(this.container, pointerId);
    }
  }, {
    key: "ensureGrid",
    value: function GridLayout_ensureGrid_(_ref19) {
      var _this12 = this;

      var grid = _ref19.grid,
          rowCount = _ref19.rowCount,
          columnCount = _ref19.columnCount;

      grid = grid || [[]];
      rowCount = rowCount || grid.length;
      columnCount = columnCount || lively_lang.arr.max(grid.map(function (row) {
        return row.length;
      }));
      if (grid.length < rowCount) {
        grid = grid.concat(lively_lang.arr.withN(rowCount - grid.length, []));
      }
      grid = grid.map(function (row) {
        if (row.length < columnCount) row = row.concat(lively_lang.arr.withN(columnCount - row.length, null));
        return row.map(function (v) {
          if (v && v.isMorph) {
            return v;
          } else if (v) {
            return _this12.container.getSubmorphNamed(v) || v;
          } else {
            return v;
          }
        });
      });
      return grid;
    }
  }, {
    key: "autoAssign",
    value: function GridLayout_autoAssign_(morphs) {
      var _this13 = this;

      morphs.forEach(function (m) {
        var cellGroup,
            closestDist = Infinity;
        _this13.cellGroups.forEach(function (g) {
          if (!g.morph) {
            g.cells.forEach(function (c) {
              var distToCell = c.position.dist(m.position);
              if (distToCell < closestDist) {
                cellGroup = g;
                closestDist = distToCell;
              }
            });
          }
        });
        if (cellGroup) cellGroup.morph = m;
      });
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 25821,
    end: 29368
  });
}(Layout);

var StyleRules = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("StyleRules") && typeof __lively_classholder__.StyleRules === "function" ? __lively_classholder__.StyleRules : __lively_classholder__.StyleRules = function StyleRules(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function StyleRules_initialize_(rules) {
      this.rules = rules;
    }
  }, {
    key: "applyToAll",
    value: function StyleRules_applyToAll_(root, morph$$1) {
      var _this = this;

      var removedLayouts = {};
      root.withAllSubmorphsDo(function (m) {
        removedLayouts[m.id] = m.layout;
        m.layout = null;
      });
      (morph$$1 || root).withAllSubmorphsDo(function (m) {
        return _this.enforceRulesOn(m);
      });
      root.withAllSubmorphsDo(function (m) {
        (m.layout = removedLayouts[m.id]) || _this.applyLayout(m);
      });
    }
  }, {
    key: "onMorphChange",
    value: function StyleRules_onMorphChange_(morph$$1, change) {
      var selector = change.selector,
          args = change.args,
          prop = change.prop,
          prevValue = change.prevValue,
          value = change.value;

      if (selector == "addMorphAt") {
        this.applyToAll(morph$$1, args[0]);
      } else if (prop == "name" || prop == "morphClasses") {
        if (prevValue == value) return;
        this.enforceRulesOn(morph$$1);
        this.applyLayout(morph$$1);
      }
    }
  }, {
    key: "getShadowedProps",
    value: function StyleRules_getShadowedProps_(morph$$1) {
      var props = {},
          curr = morph$$1;
      while (curr && curr.styleRules != this) {
        if (curr.styleRules) props = Object.assign({}, props, {}, curr.styleRules.getStyleProps(morph$$1));
        curr = curr.owner;
      }
      return ["layout"].concat(toConsumableArray(Object.keys(props)));
    }
  }, {
    key: "getStyleProps",
    value: function StyleRules_getStyleProps_(morph$$1) {
      var _this2 = this;

      if (this.rules[morph$$1.name]) {
        return this.rules[morph$$1.name];
      } else if (morph$$1.morphClasses) {
        return lively_lang.obj.merge(lively_lang.arr.compact(morph$$1.morphClasses.map(function (c) {
          return _this2.rules[c];
        })));
      }
      return {};
    }
  }, {
    key: "enforceRulesOn",
    value: function StyleRules_enforceRulesOn_(morph$$1) {
      var styleProps = this.getStyleProps(morph$$1),
          shadowedProps = this.getShadowedProps(morph$$1);
      styleProps && this.applyToMorph(morph$$1, lively_lang.obj.dissoc(styleProps, shadowedProps));
    }
  }, {
    key: "applyLayout",
    value: function StyleRules_applyLayout_(morph$$1) {
      var layout = this.getStyleProps(morph$$1).layout;
      if (layout) morph$$1.layout = layout;
    }
  }, {
    key: "applyToMorph",
    value: function StyleRules_applyToMorph_(morph$$1, styleProps) {
      return Object.assign(morph$$1, styleProps);
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 572,
    end: 2327
  });
}(undefined);

var MenuDivider = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("MenuDivider") && typeof __lively_classholder__.MenuDivider === "function" ? __lively_classholder__.MenuDivider : __lively_classholder__.MenuDivider = function MenuDivider(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function MenuDivider_initialize_() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, Object.assign({
        fill: lively_graphics.Color.gray.lighter(),
        extent: lively_graphics.pt(100, 5),
        reactsToPointer: false
      }, props));
    }
  }, {
    key: "isMenuDivider",
    get: function get() {
      return true;
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 185,
    end: 418
  });
}(Morph$1);
var MenuItem = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("MenuItem") && typeof __lively_classholder__.MenuItem === "function" ? __lively_classholder__.MenuItem : __lively_classholder__.MenuItem = function MenuItem(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function MenuItem_initialize_() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, Object.assign({
        fixedWidth: false,
        fixedHeight: false,
        fill: null,
        fontSize: 14,
        draggable: false,
        readOnly: true,
        nativeCursor: "pointer"
      }, lively_lang.obj.dissoc(props, ["selected"])));
      this.selected = props.hasOwnProperty("selected") ? props.selected : false;
    }
  }, {
    key: "isMenuItem",
    get: function get() {
      return true;
    }
  }, {
    key: "selected",
    get: function get() {
      return this.getProperty("selected");
    }
  }, {
    key: "selected",
    set: function set(value) {
      if (this.selected === value) return;
      this.addValueChange("selected", value);
      if (value) {
        this.fontColor = lively_graphics.Color.white;
        this.fill = lively_graphics.Color.blue;
      } else {
        this.fill = lively_graphics.Color.null;
        this.fontColor = lively_graphics.Color.black;
      }
    }
  }, {
    key: "label",
    get: function get() {
      var value = this.valueAndAnnotation.value,
          label = value.map(function (_ref) {
        var _ref2 = slicedToArray(_ref, 1),
            string$$1 = _ref2[0];

        return string$$1;
      }).join("\n");
      return label;
    }
  }, {
    key: "label",
    set: function set(value) {
      this.valueAndAnnotation = {
        value: value,
        annotation: this.annotation
      };
    }
  }, {
    key: "annotation",
    get: function get() {
      return this.valueAndAnnotation.annotation;
    }
  }, {
    key: "annotation",
    set: function set(annotation) {
      this.valueAndAnnotation = {
        value: this.value,
        annotation: annotation
      };
    }
  }, {
    key: "action",
    get: function get() {
      return this.getProperty("action");
    }
  }, {
    key: "action",
    set: function set(value) {
      this.addValueChange("action", value);
    }
  }, {
    key: "submenu",
    get: function get() {
      return this.getProperty("submenu");
    }
  }, {
    key: "submenu",
    set: function set(value) {
      this.addValueChange("submenu", value);
    }
  }, {
    key: "onHoverIn",
    value: function MenuItem_onHoverIn_(evt) {
      var _this = this;

      this.owner.itemMorphs.forEach(function (ea) {
        return ea !== _this && (ea.selected = false);
      });
      this.selected = true;
      if (this.submenu) this.owner.openSubMenuDelayed(evt, this, this.submenu);
    }
  }, {
    key: "onHoverOut",
    value: function MenuItem_onHoverOut_(evt) {
      var _this2 = this;

      var hand = evt.hand;

      setTimeout(function () {
        var submenus = _this2.owner ? _this2.owner.submenus : [];
        if (!submenus.some(function (ea) {
          return ea.fullContainsWorldPoint(hand.position);
        })) _this2.selected = false;
      }, 20);
      this.owner.maybeRemoveSubmenu();
    }
  }, {
    key: "onMouseDown",
    value: function MenuItem_onMouseDown_(evt) {
      if (this.submenu) return;
      try {
        if (typeof this.action !== "function") throw new Error("Menu item " + this.textString + " has no executable action!");
        this.action();
      } catch (err) {
        var w = this.world();
        if (w) w.logError(err);else console.error(err);
      }
    }
  }], undefined, __lively_classholder__, undefined, {
    start: 427,
    end: 2673
  });
}(Label$$1);
var invalidItem = {
  string: "invalid item",
  action: function action() {
    return show$$1("invalid item");
  }
};
var Menu$$1 = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("Menu") && typeof __lively_classholder__.Menu === "function" ? __lively_classholder__.Menu : __lively_classholder__.Menu = function Menu$$1(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function Menu_initialize_(props) {
      var ownerMenu = props.ownerMenu,
          ownerItemMorph = props.ownerItemMorph,
          subMenu = props.subMenu,
          removeOnMouseOut = props.removeOnMouseOut,
          items = props.items;

      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, Object.assign({
        dropShadow: true,
        title: null,
        padding: lively_graphics.Rectangle.inset(0, 2),
        itemPadding: lively_graphics.Rectangle.inset(8, 4),
        borderWidth: 1,
        fill: lively_graphics.Color.white,
        borderColor: lively_graphics.Color.gray.lighter(),
        borderRadius: 4,
        opacity: 0.95,
        fontSize: 16,
        fontFamily: "Helvetica Neue, Arial, sans-serif"
      }, lively_lang.obj.dissoc(props, ["ownerMenu", "ownerItemMorph", "subMenu", "items", "removeOnMouseOut"])));
      this.state = {
        ownerMenu: null,
        ownerItemMorph: null,
        removeOnMouseOut: false,
        subMenu: null,
        items: null,
        openingSubMenuProcess: null
      };
      Object.assign(this, {
        ownerMenu: ownerMenu,
        ownerItemMorph: ownerItemMorph,
        subMenu: subMenu,
        removeOnMouseOut: removeOnMouseOut,
        items: items
      });
      this.updateMorphs();
    }
  }, {
    key: "remove",
    value: function () {
      var _ref3 = asyncToGenerator(regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.animate({
                  opacity: 0,
                  duration: 300
                });

              case 2:
                lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "remove", this).call(this);

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function Menu_remove_() {
        return _ref3.apply(this, arguments);
      }

      return Menu_remove_;
    }()
  }, {
    key: "title",
    get: function get() {
      return this.getProperty("title");
    }
  }, {
    key: "title",
    set: function set(value) {
      this.addValueChange("title", value);
    }
  }, {
    key: "ownerMenu",
    get: function get() {
      return this.state.ownerMenu;
    }
  }, {
    key: "ownerMenu",
    set: function set(value) {
      this.state.ownerMenu = value;
    }
  }, {
    key: "submenu",
    get: function get() {
      return this.state.submenu;
    }
  }, {
    key: "submenu",
    set: function set(value) {
      this.state.submenu = value;
    }
  }, {
    key: "submenus",
    get: function get() {
      return this.submenu ? [this.submenu].concat(this.submenu.submenus) : [];
    }
  }, {
    key: "ownerItemMorph",
    get: function get() {
      return this.state.ownerItemMorph;
    }
  }, {
    key: "ownerItemMorph",
    set: function set(value) {
      this.state.ownerItemMorph = value;
    }
  }, {
    key: "removeOnMouseOut",
    get: function get() {
      return this.state.removeOnMouseOut;
    }
  }, {
    key: "removeOnMouseOut",
    set: function set(value) {
      this.state.removeOnMouseOut = value;
    }
  }, {
    key: "items",
    get: function get() {
      return this.state.items;
    }
  }, {
    key: "items",
    set: function set(items) {
      items = items.map(this.ensureItem.bind(this)).filter(Boolean);
      this.state.items = items;
    }
  }, {
    key: "padding",
    get: function get() {
      return this.getProperty("padding");
    }
  }, {
    key: "padding",
    set: function set(value) {
      this.addValueChange("padding", value);
    }
  }, {
    key: "fontSize",
    get: function get() {
      return this.getProperty("fontSize");
    }
  }, {
    key: "fontSize",
    set: function set(value) {
      this.addValueChange("fontSize", value);
    }
  }, {
    key: "fontFamily",
    get: function get() {
      return this.getProperty("fontFamily");
    }
  }, {
    key: "fontFamily",
    set: function set(value) {
      this.addValueChange("fontFamily", value);
    }
  }, {
    key: "selectedItemMorph",
    get: function get() {
      return this.itemMorphs.find(function (ea) {
        return ea.selected;
      });
    }
  }, {
    key: "titleMorph",
    get: function get() {
      return this.getSubmorphNamed("title");
    }
  }, {
    key: "itemMorphs",
    get: function get() {
      return this.submorphs.filter(function (ea) {
        return ea.isMenuItem;
      });
    }
  }, {
    key: "ensureItem",
    value: function Menu_ensureItem_(item) {
      if (!item) return invalidItem;
      if (item.title) {
        this.title = item.title;
        return null;
      }
      if (item.isDivider) return item;
      if (Array.isArray(item)) {
        var _item = slicedToArray(item, 2),
            name = _item[0],
            actionOrList = _item[1];

        if (typeof name !== "string" && !Array.isArray(name)) return invalidItem;
        if (!actionOrList || typeof actionOrList === "function") return {
          label: name,
          action: actionOrList || show$$1.bind(null, name)
        };
        if (Array.isArray(actionOrList)) return {
          label: name,
          submenu: actionOrList,
          annotation: [" ", {
            textStyleClasses: ["fa", "fa-caret-right"]
          }]
        };
        return invalidItem;
      }
      if (item.command) {
        var command = item.command,
            showKeyShortcuts = item.showKeyShortcuts,
            target = item.target,
            alias = item.alias,
            args = item.args;

        if (!command || !target) return invalidItem;
        if (showKeyShortcuts === undefined) showKeyShortcuts = true;
        var keys = !showKeyShortcuts ? null : typeof showKeyShortcuts === "string" ? showKeyShortcuts : target.keysForCommand(command),
            label = alias || command,
            annotation = keys ? ["\t" + keys, { fontSize: "70%" }] : ["", {}];
        return {
          string: label,
          annotation: annotation,
          action: function action() {
            return target.execCommand(command, args);
          }
        };
      }
      return invalidItem;
    }
  }, {
    key: "updateMorphs",
    value: function Menu_updateMorphs_() {
      var _this3 = this;

      this.submorphs = [];
      var pLeft = this.padding.left(),
          pRight = this.padding.right(),
          pTop = this.padding.top(),
          pBottom = this.padding.bottom(),
          maxWidth = 0,
          pos = lively_graphics.pt(pLeft, pTop);
      var defaultStyle = {};
      if (this.fontFamily) defaultStyle.fontFamily = this.fontFamily;
      if (this.fontSize) defaultStyle.fontSize = this.fontSize;
      if (this.itemPadding) defaultStyle.padding = this.itemPadding;
      if (this.title) {
        var title = this.addMorph(Object.assign({
          type: "label",
          value: this.title,
          name: "title",
          position: pos,
          fontWeight: "bold"
        }, defaultStyle));
        pos = title.bottomLeft;
        maxWidth = Math.max(title.width, maxWidth);
      }
      this.items.forEach(function (_ref4) {
        var label = _ref4.label,
            string$$1 = _ref4.string,
            annotation = _ref4.annotation,
            action = _ref4.action,
            submenu = _ref4.submenu,
            isDivider = _ref4.isDivider;

        var itemMorph = _this3.addMorph(isDivider ? new MenuDivider({ position: pos }) : new MenuItem(Object.assign({
          label: label || string$$1,
          annotation: annotation,
          action: action,
          submenu: submenu,
          position: pos
        }, defaultStyle)));
        pos = itemMorph.bottomLeft;
        maxWidth = Math.max(itemMorph.width, maxWidth);
      });
      this.submorphs.forEach(function (ea) {
        if (ea.isLabel) {
          ea.fit();
          ea.autofit = false;
          ea.fixedWidth = true;
          ea.fixedHeight = true;
        }
        ea.width = maxWidth;
      });
      this.extent = lively_graphics.pt(maxWidth + pRight + pLeft, pos.y + pBottom);
    }
  }, {
    key: "openSubMenuDelayed",
    value: function Menu_openSubMenuDelayed_(evt, itemMorph, items) {
      var _this4 = this;

      this.state.openingSubMenuProcess && clearTimeout(this.state.openingSubMenuProcess);
      this.state.openingSubMenuProcess = setTimeout(function () {
        try {
          _this4.openSubMenu(evt, itemMorph, items);
        } catch (err) {
          var w = _this4.world();
          w ? w.logError(err) : console.error(err);
        }
      }, 200);
    }
  }, {
    key: "openSubMenu",
    value: function Menu_openSubMenu_(evt, itemMorph, items) {
      if (!itemMorph.selected) return;
      var existingSubMenu = this.submenu;
      if (existingSubMenu) {
        if (existingSubMenu.ownerItemMorph === itemMorph) return;
        if (this.morphsContainingPoint(evt.position).includes(existingSubMenu)) return;
        this.removeSubMenu();
      }
      var m = this.submenu = this.addMorph(new Menu$$1({
        items: items,
        ownerItemMorph: itemMorph,
        ownerMenu: this
      }));
      m.updateMorphs();
      m.offsetForOwnerMenu();
    }
  }, {
    key: "maybeRemoveSubmenu",
    value: function Menu_maybeRemoveSubmenu_() {
      var _this5 = this;

      lively_lang.fun.debounceNamed(this.id + "-maybeRemoveSubmenu", 300, function () {
        var w = _this5.world();
        if (!w) return;
        var submenu = _this5.submenu,
            selectedItemMorph = _this5.selectedItemMorph,
            handOverSubmenu = w && submenu && submenu.fullContainsWorldPoint(w.firstHand.position);

        if (submenu && submenu.ownerItemMorph !== selectedItemMorph && !submenu.ownerItemMorph.selected) {
          if (handOverSubmenu) {
            selectedItemMorph && (selectedItemMorph.selected = false);
            submenu.ownerItemMorph.selected = true;
          } else _this5.removeSubMenu();
        }
      })();
      return this.removeOnMouseOut;
    }
  }, {
    key: "removeSubMenu",
    value: function Menu_removeSubMenu_() {
      if (!this.submenu) return;
      var m = this.submenu;
      m.ownerMenu = null;
      this.submenu = null;
      m.remove();
    }
  }, {
    key: "moveBoundsForVisibility",
    value: function Menu_moveBoundsForVisibility_(menuBounds, visibleBounds) {
      var offsetX = 0,
          offsetY = 0;
      if (menuBounds.right() > visibleBounds.right()) offsetX = -1 * (menuBounds.right() - visibleBounds.right());
      var overlapLeft = menuBounds.left() + offsetX;
      if (overlapLeft < 0) offsetX += -overlapLeft;
      if (menuBounds.bottom() > visibleBounds.bottom()) {
        offsetY = -1 * (menuBounds.bottom() - visibleBounds.bottom());
        offsetX += 1;
      }
      var overlapTop = menuBounds.top() + offsetY;
      if (overlapTop < 0) offsetY += -overlapTop;
      return menuBounds.translatedBy(lively_graphics.pt(offsetX, offsetY));
    }
  }, {
    key: "moveSubMenuBoundsForVisibility",
    value: function Menu_moveSubMenuBoundsForVisibility_(subMenuBnds, mainMenuItemBnds, visibleBounds, direction) {
      if (!direction) {
        direction = mainMenuItemBnds.right() + subMenuBnds.width > visibleBounds.right() ? "left" : "right";
      }
      var extent = subMenuBnds.extent();
      if (direction === "left") {
        subMenuBnds = mainMenuItemBnds.topLeft().addXY(-extent.x, 0).extent(extent);
      } else {
        subMenuBnds = mainMenuItemBnds.topRight().extent(extent);
      }
      if (subMenuBnds.bottom() > visibleBounds.bottom()) {
        var deltaY = -1 * (subMenuBnds.bottom() - visibleBounds.bottom());
        subMenuBnds = subMenuBnds.translatedBy(lively_graphics.pt(0, deltaY));
      }
      if (subMenuBnds.top() < visibleBounds.top()) {
        var deltaY = visibleBounds.top() - subMenuBnds.top();
        subMenuBnds = subMenuBnds.translatedBy(lively_graphics.pt(0, deltaY));
      }
      return subMenuBnds;
    }
  }, {
    key: "offsetForOwnerMenu",
    value: function Menu_offsetForOwnerMenu_() {
      var owner = this.ownerMenu,
          visibleBounds = this.world().visibleBounds(),
          localVisibleBounds = owner.getGlobalTransform().inverse().transformRectToRect(visibleBounds),
          newBounds = this.clipForVisibility(this.moveSubMenuBoundsForVisibility(this.innerBounds(), owner.selectedItemMorph ? owner.selectedItemMorph.bounds() : owner.innerBounds(), localVisibleBounds), visibleBounds);
      this.setBounds(newBounds);
    }
  }, {
    key: "clipForVisibility",
    value: function Menu_clipForVisibility_() {
      var bounds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.bounds();
      var worldBounds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.world().visibleBounds();

      var globalBounds = this.owner.getTransform().transformRectToRect(bounds),
          overlapping = !worldBounds.containsRect(globalBounds.insetBy(5));
      var scrollbarWidth = 20;
      if (overlapping) {
        bounds = bounds.withExtent(lively_graphics.pt(scrollbarWidth + 5 + bounds.width, worldBounds.height));
      }
      return bounds;
    }
  }, {
    key: "offsetForWorld",
    value: function Menu_offsetForWorld_(pos) {
      var bounds = this.innerBounds().translatedBy(pos);
      if (this.owner.visibleBounds) {
        var worldBounds = this.owner.visibleBounds();
        bounds = this.clipForVisibility(this.moveBoundsForVisibility(bounds, worldBounds), worldBounds);
      }
      this.setBounds(bounds);
    }
  }, {
    key: "onHoverOut",
    value: function Menu_onHoverOut_() {
      if (this.removeOnMouseOut) this.remove();
    }
  }], [{
    key: "forItems",
    value: function Menu_forItems_(items) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { title: "" };

      return new this(Object.assign({}, opts, { items: items }));
    }
  }, {
    key: "openAt",
    value: function Menu_openAt_(pos, items) {
      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { title: "" };

      var menu = this.forItems(items, opts).openInWorldNear(pos);
      menu.offsetForWorld(pos);
      return menu;
    }
  }, {
    key: "openAtHand",
    value: function Menu_openAtHand_(items) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { title: "" };

      var hand = opts.hand,
          menu = this.forItems(items, lively_lang.obj.dissoc(opts, ["hand"])),
          pos = hand ? hand.position : lively_graphics.pt(0, 0);
      if (menu.titleMorph) pos = pos.addXY(0, -menu.titleMorph.height);
      menu.openInWorld(pos);
      menu.offsetForWorld(pos);
      return menu;
    }
  }], __lively_classholder__, undefined, {
    start: 2763,
    end: 14359
  });
}(Morph$1);

var Window$$1 = function (superclass) {
  var __lively_classholder__ = _classRecorder;
  var __lively_class__ = __lively_classholder__.hasOwnProperty("Window") && typeof __lively_classholder__.Window === "function" ? __lively_classholder__.Window : __lively_classholder__.Window = function Window$$1(__first_arg__) {
    if (__first_arg__ && __first_arg__[Symbol.for("lively-instance-restorer")]) {} else {
      this[Symbol.for("lively-instance-initialize")].apply(this, arguments);
    }
  };
  return lively.classes.runtime.initializeClass(__lively_class__, superclass, [{
    key: Symbol.for("lively-instance-initialize"),
    value: function Window_initialize_() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), Symbol.for("lively-instance-initialize"), this).call(this, props);
      this.resetPropertyCache();
      this.relayoutWindowControls();
      lively_bindings.connect(this, "extent", this, "relayoutWindowControls");
      lively_bindings.connect(this.titleLabel(), "value", this, "relayoutWindowControls");
    }
  }, {
    key: "__deserialize__",
    value: function Window___deserialize___(snapshot, ref) {
      lively.classes.runtime.initializeClass._get(Object.getPrototypeOf(__lively_class__.prototype), "__deserialize__", this).call(this, snapshot, ref);
      this.resetPropertyCache();
    }
  }, {
    key: "isWindow",
    get: function get() {
      return true;
    }
  }, {
    key: "targetMorphBounds",
    value: function Window_targetMorphBounds_() {
      return new lively_graphics.Rectangle(0, 25, this.width, this.height - 25);
    }
  }, {
    key: "resetPropertyCache",
    value: function Window_resetPropertyCache_() {
      this.propertyCache = {
        nonMinizedBounds: null,
        nonMaximizedBounds: null,
        minimizedBounds: null
      };
    }
  }, {
    key: "relayoutWindowControls",
    value: function Window_relayoutWindowControls_() {
      var innerB = this.innerBounds(),
          title = this.titleLabel(),
          labelBounds = innerB.withHeight(25),
          buttonOffset = lively_lang.arr.last(this.buttons()).bounds().right() + 3,
          minLabelBounds = labelBounds.withLeftCenter(lively_graphics.pt(buttonOffset, labelBounds.height / 2));
      this.resizer().bottomRight = innerB.bottomRight();
      if (this.targetMorph) this.targetMorph.setBounds(this.targetMorphBounds());
      title.textBounds().width < labelBounds.width - 2 * buttonOffset ? title.center = labelBounds.center() : title.leftCenter = minLabelBounds.leftCenter();
    }
  }, {
    key: "controls",
    value: function Window_controls_() {
      return this.buttons().concat(this.titleLabel()).concat(this.resizable ? this.resizer() : []);
    }
  }, {
    key: "buttons",
    value: function Window_buttons_() {
      var defaultStyle = {
        type: "ellipse",
        extent: lively_graphics.pt(14, 14)
      };
      var closeButton = this.getSubmorphNamed("close") || morph$1(Object.assign({}, defaultStyle, {
        name: "close",
        center: lively_graphics.pt(15, 13),
        borderColor: lively_graphics.Color.darkRed,
        fill: lively_graphics.Color.rgb(255, 96, 82),
        submorphs: [Label$$1.icon("times", {
          fill: null,
          visible: false,
          center: defaultStyle.extent.scaleBy(0.5),
          opacity: 0.5
        })]
      }));
      lively_bindings.connect(closeButton, "onMouseDown", this, "close");
      lively_bindings.connect(closeButton, "onHoverIn", closeButton.submorphs[0], "visible", { converter: function converter() {
          return true;
        } });
      lively_bindings.connect(closeButton, "onHoverOut", closeButton.submorphs[0], "visible", { converter: function converter() {
          return false;
        } });
      var minimizeButton = this.getSubmorphNamed("minimize") || morph$1(Object.assign({}, defaultStyle, {
        center: lively_graphics.pt(35, 13),
        name: "minimize",
        borderColor: lively_graphics.Color.brown,
        fill: lively_graphics.Color.rgb(255, 190, 6),
        submorphs: [Label$$1.icon("minus", {
          fill: null,
          visible: false,
          center: defaultStyle.extent.scaleBy(0.5),
          opacity: 0.5
        })]
      }));
      lively_bindings.connect(minimizeButton, "onMouseDown", this, "toggleMinimize");
      lively_bindings.connect(minimizeButton, "onHoverIn", minimizeButton.submorphs[0], "visible", { converter: function converter() {
          return true;
        } });
      lively_bindings.connect(minimizeButton, "onHoverOut", minimizeButton.submorphs[0], "visible", { converter: function converter() {
          return false;
        } });
      if (this.resizable) {
        var maximizeButton = this.getSubmorphNamed("maximize") || morph$1(Object.assign({}, defaultStyle, {
          name: "maximize",
          center: lively_graphics.pt(55, 13),
          borderColor: lively_graphics.Color.darkGreen,
          fill: lively_graphics.Color.green,
          submorphs: [Label$$1.icon("plus", {
            fill: null,
            visible: false,
            center: defaultStyle.extent.scaleBy(0.5),
            opacity: 0.5
          })]
        }));
        lively_bindings.connect(maximizeButton, "onMouseDown", this, "toggleMaximize");
        lively_bindings.connect(maximizeButton, "onHoverIn", maximizeButton.submorphs[0], "visible", { converter: function converter() {
            return true;
          } });
        lively_bindings.connect(maximizeButton, "onHoverOut", maximizeButton.submorphs[0], "visible", { converter: function converter() {
            return false;
          } });
      }
      return lively_lang.arr.compact([closeButton, minimizeButton, maximizeButton]);
    }
  }, {
    key: "titleLabel",
    value: function Window_titleLabel_() {
      return this.getSubmorphNamed("titleLabel") || morph$1({
        padding: lively_graphics.Rectangle.inset(0, 2, 0, 0),
        type: "label",
        name: "titleLabel",
        fill: null,
        fontColor: lively_graphics.Color.darkGray,
        reactsToPointer: false,
        value: ""
      });
    }
  }, {
    key: "resizer",
    value: function Window_resizer_() {
      var win = this,
          resizer = this.getSubmorphNamed("resizer");
      if (resizer) return resizer;
      resizer = morph$1({
        name: "resizer",
        nativeCursor: "nwse-resize",
        extent: lively_graphics.pt(20, 20),
        fill: lively_graphics.Color.transparent,
        bottomRight: this.extent
      });
      lively_bindings.connect(resizer, "onDrag", win, "resizeBy", { converter: function converter(evt) {
          return evt.state.dragDelta;
        } });
      lively_bindings.connect(win, "extent", resizer, "bottomRight");
      return resizer;
    }
  }, {
    key: "toggleMinimize",
    value: function Window_toggleMinimize_() {
      var cache = this.propertyCache,
          bounds = this.bounds(),
          duration = 200,
          easing = Expo.easeOut;
      if (this.minimized) {
        cache.minimizedBounds = bounds;
        this.animate({
          bounds: cache.nonMinizedBounds || bounds,
          duration: duration,
          easing: easing
        });
      } else {
        cache.nonMinizedBounds = bounds;
        var minimizedBounds = cache.minimizedBounds || bounds.withExtent(lively_graphics.pt(this.width, 25)),
            labelBounds = this.titleLabel().textBounds(),
            buttonOffset = lively_lang.arr.last(this.buttons()).bounds().right() + 3;
        if (labelBounds.width + 2 * buttonOffset < minimizedBounds.width) minimizedBounds = minimizedBounds.withWidth(labelBounds.width + buttonOffset + 3);
        cache.minimizedBounds = minimizedBounds;
        this.animate({
          bounds: cache.minimizedBounds,
          duration: duration,
          easing: easing
        });
      }
      this.minimized = !this.minimized;
      this.resizer().visible = !this.minimized;
    }
  }, {
    key: "toggleMaximize",
    value: function Window_toggleMaximize_() {
      var cache = this.propertyCache,
          easing = Expo.easeOut,
          duration = 200;
      if (this.maximized) {
        this.animate({
          bounds: cache.nonMaximizedBounds,
          duration: duration,
          easing: easing
        });
        this.resizer().bottomRight = this.extent;
        this.maximized = false;
      } else {
        cache.nonMaximizedBounds = this.bounds();
        this.animate({
          bounds: this.world().visibleBounds().insetBy(5),
          duration: duration,
          easing: easing
        });
        this.resizer().visible = true;
        this.maximized = true;
        this.minimized = false;
      }
    }
  }, {
    key: "close",
    value: function Window_close_() {
      var world = this.world();
      this.deactivate();
      this.remove();
      var next = world.activeWindow() || lively_lang.arr.last(world.getWindows());
      next && next.activate();
      lively_bindings.signal(this, "windowClosed", this);
      if (this.targetMorph && typeof this.targetMorph.onWindowClose === "function") this.targetMorph.onWindowClose();
    }
  }, {
    key: "onMouseDown",
    value: function Window_onMouseDown_(evt) {
      this.activate();
    }
  }, {
    key: "focus",
    value: function Window_focus_() {
      var w = this.world(),
          t = this.targetMorph;
      if (!w || !t) return;
      if (w.focusedMorph && (w.focusedMorph === t || t.isAncestorOf(w.focusedMorph))) return;
      t.focus();
    }
  }, {
    key: "isActive",
    value: function Window_isActive_() {
      var w = this.world();
      if (!w) return false;
      if (this.titleLabel().fontWeight != "bold") return false;
      return lively_lang.arr.last(w.getWindows()) === this;
    }
  }, {
    key: "activate",
    value: function Window_activate_() {
      var _this = this;

      if (this.isActive()) {
        this.focus();
        return this;
      }
      if (!this.world()) {
        this.openInWorldNearHand();
      } else this.bringToFront();
      var w = this.world() || this.env.world;
      lively_lang.arr.without(w.getWindows(), this).forEach(function (ea) {
        return ea.deactivate();
      });
      this.titleLabel().fontWeight = "bold";
      this.focus();
      lively_bindings.signal(this, "windowActivated", this);
      setTimeout(function () {
        _this.relayoutWindowControls();
      }, 0);
      return this;
    }
  }, {
    key: "deactivate",
    value: function Window_deactivate_() {
      this.titleLabel().fontWeight = "normal";
      this.relayoutWindowControls();
    }
  }], [{
    key: "properties",
    get: function get() {
      return {
        submorphs: {
          initialize: function initialize() {
            this.submorphs = this.controls();
          }
        },
        dropShadow: {
          initialize: function initialize() {
            this.dropShadow = new ShadowObject$$1(true);
          }
        },
        fill: { defaultValue: lively_graphics.Color.lightGray },
        borderRadius: { defaultValue: 7 },
        borderColor: { defaultValue: lively_graphics.Color.gray },
        borderWidth: { defaultValue: 1 },
        clipMode: { defaultValue: "hidden" },
        resizable: { defaultValue: true },
        title: {
          after: ["submorphs"],
          derived: true,
          get: function get() {
            return this.titleLabel().textString;
          },
          set: function set(title) {
            var textAndAttrs = typeof title === "string" ? [[title, {}]] : title,
                maxLength = 100,
                length = 0,
                truncated = [];
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = textAndAttrs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var ea = _step.value;

                var _ea = slicedToArray(ea, 2),
                    _string = _ea[0],
                    attr = _ea[1];

                _string = _string.replace(/\n/g, "");
                var delta = _string.length + length - maxLength;
                if (delta > 0) _string = _string.slice(0, -delta);
                truncated.push([_string, attr || {}]);
                if (length >= maxLength) break;
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }

            this.titleLabel().value = truncated;
          }
        },
        targetMorph: {
          after: ["submorphs"],
          derived: true,
          get: function get() {
            return lively_lang.arr.withoutAll(this.submorphs, this.controls())[0];
          },
          set: function set(morph$$1) {
            var _this2 = this;

            var ctrls = this.controls();
            lively_lang.arr.withoutAll(this.submorphs, ctrls).forEach(function (ea) {
              return ea.remove();
            });
            if (morph$$1) this.addMorph(morph$$1, ctrls[0]);
            this.whenRendered().then(function () {
              return _this2.relayoutWindowControls();
            });
          }
        }
      };
    }
  }], __lively_classholder__, undefined, {
    start: 254,
    end: 9120
  });
}(Morph$1);

var lazyInspect = function () {
  var _ref2 = asyncToGenerator(regeneratorRuntime.mark(function _callee(obj$$1) {
    var _ref3, realInspect;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return System.import("lively.morphic/ide/js/inspector.js");

          case 2:
            _ref3 = _context.sent;
            realInspect = _ref3.inspect;

            exports.inspect = realInspect;
            return _context.abrupt("return", realInspect(obj$$1));

          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  return function lazyInspect(_x3) {
    return _ref2.apply(this, arguments);
  };
}();

function morph$1() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { restore: false };

  var klass = Morph$1;
  if (props.type) {
    if (typeof props.type === "function") klass = props.type;else if (typeof props.type === "string") switch (props.type.toLowerCase()) {
      case "world":
        klass = World$$1;
        break;
      case "hand":
        klass = Hand$$1;
        break;
      case "image":
        klass = Image$$1;
        break;
      case "ellipse":
        klass = Ellipse$$1;
        break;
      case "triangle":
        klass = Triangle$$1;
        break;
      case "path":
        klass = Path$1;
        break;
      case "text":
        klass = Text$1;
        break;
      case "label":
        klass = Label$$1;
        break;
      case "list":
        klass = List$$1;
        break;
      case "button":
        klass = Button$$1;
        break;
      case "checkbox":
        klass = CheckBox;
        break;
      case "polygon":
        klass = Polygon$$1;
        break;
      case "html":
        klass = HTMLMorph$$1;
        break;
    }
  }
  return opts.restore ? new klass(defineProperty({}, Symbol.for("lively-instance-restorer"), true)).initFromJSON(props) : new klass(props);
}

exports.inspect = lazyInspect;

exports.Window = Window$$1;
exports.morph = morph$1;
exports.config = config;
exports.StyleRules = StyleRules;
exports.show = show$$1;
exports.ShadowObject = ShadowObject$$1;
exports.Button = Button$$1;
exports.Menu = Menu$$1;
exports.Icon = Icon$$1;
exports.newMorphId = newMorphId$$1;
exports.Morph = Morph$1;
exports.Ellipse = Ellipse$$1;
exports.Triangle = Triangle$$1;
exports.Image = Image$$1;
exports.Path = Path$1;
exports.Polygon = Polygon$$1;
exports.World = World$$1;
exports.Hand = Hand$$1;
exports.Text = Text$1;
exports.Label = Label$$1_Builder(Morph$1);
exports.HTMLMorph = HTMLMorph$$1;
exports.MorphicEnv = MorphicEnv;
exports.FillLayout = FillLayout;
exports.VerticalLayout = VerticalLayout;
exports.HorizontalLayout = HorizontalLayout;
exports.TilingLayout = TilingLayout;
exports.CellGroup = CellGroup;
exports.LayoutColumn = LayoutColumn;
exports.LayoutRow = LayoutRow;
exports.LayoutCell = LayoutCell;
exports.GridLayout = GridLayout$1;
exports.TooltipViewer = TooltipViewer$$1;
exports.Tooltip = Tooltip$$1;
exports.List = List$$1;
exports.FilterableList = FilterableList$$1;
exports.DropDownList = DropDownList$$1_Builder(Button$$1);

}((this.lively.morphic = this.lively.morphic || {}),lively.graphics,lively.lang,virtualDom,TweenMax,lively.bindings,bowser,lively.notifications,lively.serializer2,lively.resources,lively.morphic,svgIntersections));

  if (typeof module !== "undefined" && typeof require === "function") module.exports = GLOBAL.lively.modules;
})();